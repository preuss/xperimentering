From fb0dac7c7bc4897beb8cbb2ccbee78535392709a Mon Sep 17 00:00:00 2001
From: Jesper <jespr@semler.dk>
Date: Sun, 23 May 2021 00:29:06 +0200
Subject: [PATCH] Added todo's

---
 .../xpreuss/utils/timers/clock/providers/ITick.java  | 12 +++++++++++-
 .../xpreuss/utils/timers/clock/providers/Tick.java   |  5 +++++
 2 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java
index f0ac49d..4d9f0fa 100644
--- a/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java
@@ -93,8 +93,18 @@ public interface ITick {
 		return TimeSpan.fromElapsedInNanoseconds(getNanoseconds() - tickBefore.getNanoseconds());
 	}
 
+	/**
+	 * TODO: In the future two things:
+	 * TODO: 1. Change to use TimeUnit constants
+	 * TODO: 2. Or change to include Minute, hour and day this means change the second as one to nano to one.
+	 * TODO: Perhaps call it scale... ??? no maybe not.
+	 */
 	enum Resolution {
-		SECONDS(1), MILLISECONDS(1_000), MICROSECONDS(1_000_000), NANOSECONDS(1_000_000_000), OTHER(-1);
+		SECONDS(1),
+		MILLISECONDS(1_000),
+		MICROSECONDS(1_000_000),
+		NANOSECONDS(1_000_000_000),
+		OTHER(-1);
 
 		private final long size;
 
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
index f12bea9..7592308 100644
--- a/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
@@ -1,7 +1,12 @@
 package dk.xpreuss.utils.timers.clock.providers;
 
+/**
+ * This is a holder for tick values, that has a resolution.
+ *
+ */
 public class Tick implements ITick {
 	private final Resolution internalResolution;
+
 	private final long rawTicks;
 
 	public Tick(Resolution internalResolution, long rawTicks) {
-- 
2.26.2.windows.1

From 09c349eea66348aa0ff8cb77b9ae9eb050145b79 Mon Sep 17 00:00:00 2001
From: Jesper <jespr@semler.dk>
Date: Sun, 23 May 2021 00:10:33 +0200
Subject: [PATCH] Refactor and starting tests.

---
 src/main/java/dk/xpreuss/utils/timers/IStopWatch.java          | 2 +-
 src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java     | 3 ++-
 src/main/java/dk/xpreuss/utils/timers/clock/IClock.java        | 2 +-
 src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java   | 3 +--
 .../java/dk/xpreuss/utils/timers/clock/providers/Tick.java     | 1 -
 5 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java b/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
index 8cdad0c..55cfac7 100644
--- a/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
+++ b/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
@@ -48,11 +48,11 @@ public interface IStopWatch {
 	/**
 	 * Pauses an already startet stopwatch that has not been paused.
 	 * It will save the current elapsed time.
+	 *
 	 * @throws IllegalStateException if called when the stopwatch is not running or when stopwatch is already paused.
 	 */
 	void pause() throws IllegalStateException;
 	/**
-	 *
 	 * @throws IllegalStateException if called when the stopwatch
 	 */
 	void resume() throws IllegalStateException;
diff --git a/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java b/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
index 62d27b2..31bf47e 100644
--- a/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
+++ b/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
@@ -19,6 +19,7 @@ import java.util.concurrent.TimeUnit;
 
 
 import lombok.NonNull;
+
 public class MyStopWatchTest {
 	public static void main(@NonNull String[] args) throws InterruptedException {
 		Thread.sleep(1_000L);
@@ -26,7 +27,7 @@ public class MyStopWatchTest {
 
 		//StopWatch x = new StopWatch(new CpuTickProvider()) ;
 		//StopWatch x = new StopWatch(new MilliTickProvider()) ;
-		IStopWatch x = StopWatch.from(new NanoTickProvider()) ;
+		IStopWatch x = StopWatch.from(new NanoTickProvider());
 		x.start();
 		Thread.sleep(500L);
 		System.out.println("ELAPSED: 0,5xxx ==" + x.elapsed());
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java b/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java
index 8e4e922..20d735a 100644
--- a/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java
@@ -19,7 +19,7 @@ public interface IClock {
 	 * The default implementation currently calls {@link #instant}.
 	 *
 	 * @return the current millisecond instant from this clock, measured from
-	 *  the Java epoch of 1970-01-01T00:00Z (UTC), not null
+	 * the Java epoch of 1970-01-01T00:00Z (UTC), not null
 	 * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
 	 */
 	default long millis() {
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java b/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java
index 91f8cd7..f0875c9 100644
--- a/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java
@@ -10,7 +10,7 @@ import java.time.Instant;
 public class SystemClock implements IClock {
 	private static final long MILLI = 1_000;
 	private static final long MICRO = 1_000_000;
-	private static final long NANO =  1_000_000_000;
+	private static final long NANO = 1_000_000_000;
 
 	private final ITickProvider tickProvider;
 	private final long offset;
@@ -35,7 +35,6 @@ public class SystemClock implements IClock {
 		long compareMillis = compareNanos / MILLI;
 
 
-
 		// handle Instant like POSIX, see real conversion between Instant and j.u.Date
 		long utc = LeapSeconds.getInstance().enhance(instant.getEpochSecond());
 
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
index df0d2cf..f12bea9 100644
--- a/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
@@ -9,7 +9,6 @@ public class Tick implements ITick {
 		this.rawTicks = rawTicks;
 	}
 
-
 	@Override
 	public Resolution getRawTickResolution() {
 		return internalResolution;
-- 
2.26.2.windows.1

From 2d3ada73f0e0522dd81694274fc93e8c9a0f003f Mon Sep 17 00:00:00 2001
From: Jesper <jespr@semler.dk>
Date: Sat, 22 May 2021 23:52:47 +0200
Subject: [PATCH] Refactor and starting tests.

---
 build.gradle                                  |  17 +-
 .../dk/xpreuss/utils/timers/IStopWatch.java   |  59 +++++-
 .../xpreuss/utils/timers/MyStopWatchTest.java |  44 +----
 .../dk/xpreuss/utils/timers/StopWatch.java    | 187 +++++++++++++-----
 .../xpreuss/utils/timers/clock/TimeSpan.java  | 165 ++++++++++------
 .../xpreuss/utils/timers/StopWatchTest.java   |  98 +++++++++
 6 files changed, 415 insertions(+), 155 deletions(-)
 create mode 100644 src/test/java/dk/xpreuss/utils/timers/StopWatchTest.java

diff --git a/build.gradle b/build.gradle
index 7de6345..857728f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -53,8 +53,21 @@ dependencies {
 //	testCompileOnly 'org.projectlombok:lombok:1.18.20'
 //	testAnnotationProcessor 'org.projectlombok:lombok:1.18.20'
 
-	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
-	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
+	testImplementation 'org.junit.jupiter:junit-jupiter:5.7.2'
+	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.2'
+	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.2'
+//	testRuntimeOnly 'org.junit.platform:junit-platform-runner:1.7.2'
+//	testImplementation 'org.junit.platform:junit-platform-commons:1.7.2'
+
+	testImplementation 'org.testng:testng:7.4.0'
+
+	testImplementation 'org.mockito:mockito-core:3.10.0'
+	testImplementation 'org.mockito:mockito-junit-jupiter:3.10.0'
+	testImplementation 'org.mockito:mockito-testng:0.4.4'
+
+	testImplementation 'org.easymock:easymock:4.3'
+
+	testImplementation 'org.hamcrest:hamcrest:2.2'
 }
 
 test {
diff --git a/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java b/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
index 793e843..8cdad0c 100644
--- a/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
+++ b/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
@@ -3,31 +3,82 @@ package dk.xpreuss.utils.timers;
 import dk.xpreuss.utils.timers.clock.TimeSpan;
 import dk.xpreuss.utils.timers.clock.providers.ITickProvider;
 
+import java.sql.Time;
 import java.util.List;
 
 /**
  * SE https://github.com/maaza/Stopwatch/blob/master/edu/nyu/pqs/stopwatch/api/IStopwatch.java
  * for id√©
+ * <p>
+ * An interface defining a StopWatch used for timing, including laps and pause.
+ * The stopwatch objects are created from each implementation.
  */
 public interface IStopWatch {
 	//long getTicksInNanoseconds();
 	//long getElapsedTicksInNanoseconds();
 
+	/**
+	 * Returns the name or id of this stopwatch.
+	 *
+	 * @return the name or id of this stopwatch. Can never be null.
+	 */
 	String getName();
-	void start();
-	void stop();
+	/**
+	 * Starts the stopwatch.
+	 *
+	 * @throws IllegalStateException if called when the stopwatch is already running.
+	 */
+	void start() throws IllegalStateException;
+	/**
+	 * Stops the stopwatch (and records one final lap).
+	 *
+	 * @throws IllegalStateException if called when the stopwatch isn't running.
+	 */
+	void stop() throws IllegalStateException;
+
+	/**
+	 * Resets the stopwatch.  If the stopwatch is running, this method stops the watch and resets it.  This also clears all recorded laps.
+	 */
 	void reset();
+
+	/**
+	 * Convenience method for replacing {sw.Reset(); sw.Start();} with a single sw.Restart().
+	 */
 	void restart();
-	void pause();
-	void resume();
+	/**
+	 * Pauses an already startet stopwatch that has not been paused.
+	 * It will save the current elapsed time.
+	 * @throws IllegalStateException if called when the stopwatch is not running or when stopwatch is already paused.
+	 */
+	void pause() throws IllegalStateException;
+	/**
+	 *
+	 * @throws IllegalStateException if called when the stopwatch
+	 */
+	void resume() throws IllegalStateException;
+	/**
+	 * Stores the time elapsed since the last time lap() was called or since start() was called if this is the first lap.
+	 *
+	 * @return the lap elapsed that has just been done
+	 * @throws IllegalStateException if called when the stopwatch isn't running
+	 */
 	TimeSpan lap();
 	ITickProvider getTickProvider();
 	TimeSpan elapsed();
+	TimeSpan elapsedLastLap();
+	TimeSpan elapsedCurrentLap();
 	long elapsedNanoseconds();
 	long elapsedMilliseconds();
 	double elapsedSeconds();
 	boolean isRunning();
 	boolean isPaused();
 	boolean isStopped();
+	/**
+	 * Returns a list of lap times (in TimeSpans).  This method can be called at any time and will not throw an exception.
+	 *
+	 * @return a list of recorded lap times or an empty list if no times are recorded.
+	 */
 	List<TimeSpan> getTimeLaps();
+
+
 }
diff --git a/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java b/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
index 2a3062c..62d27b2 100644
--- a/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
+++ b/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
@@ -28,52 +28,26 @@ public class MyStopWatchTest {
 		//StopWatch x = new StopWatch(new MilliTickProvider()) ;
 		IStopWatch x = StopWatch.from(new NanoTickProvider()) ;
 		x.start();
-		x.lap();
-		Thread.sleep(1500L);
+		Thread.sleep(500L);
+		System.out.println("ELAPSED: 0,5xxx ==" + x.elapsed());
+		System.out.println("Lap last: " + x.elapsedLastLap());
+		System.out.println("Lap last: " + x.elapsedLastLap());
+		Thread.sleep(250L);
+		System.out.println("Lap ELAPSED: 0,250 ==" + x.lap());
+		System.out.println("Lap last: " + x.elapsedLastLap());
 		System.out.println("Lap ELAPSED: " + x.lap());
-		System.out.println("Lap ELAPSED: " + x.lap());
-		System.out.println("ELAPSED: " + x.elapsed());
 		System.out.println("ELAPSED: " + x.elapsed());
 		System.out.println("ELAPSED: " + x.elapsed());
 		System.out.println("Lap ELAPSED: " + x.lap());
-		Thread.sleep(2500L);
+		Thread.sleep(1200L);
 		x.pause();
-		Thread.sleep(5000L);
+		Thread.sleep(2500L);
 		//x.resume();
 		x.start();
 		System.out.println("Lap: " + x.lap());
 		Thread.sleep(5000L);
 		x.stop();
 		System.out.println(x.elapsed());
-
-		ITick tick1 = new MilliTickProvider().nextTick();
-		ITick tick2 = new MilliTickProvider().nextTick();
-		TimeSpan timeSpan = tick1.diff(tick2);
-
-		System.out.println(timeSpan);
-		timeSpan = x.elapsed();
-		long elapsedNanoseconds = x.elapsedNanoseconds();
-		long elapsedMilliseconds = x.elapsedMilliseconds();
-		double elapsedSeconds = x.elapsedSeconds();
-		System.out.println("Timespan: " + timeSpan);
-		System.out.println("elapsedNanoseconds = " + elapsedNanoseconds);
-		System.out.println("elapsedMilliseconds = " + elapsedMilliseconds);
-		System.out.println("elapsedSeconds = " + elapsedSeconds);
-
-		long start = System.nanoTime();
-		Thread.sleep(1200L);
-		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
-		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
-		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
-		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
-		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
-		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
-		Thread.sleep(2500L);
-		long stop = System.nanoTime();
-		long timeInNano = stop-start;
-		System.out.println("timeInNano = " + timeInNano);
-		System.out.println("TimeUnit.NANOSECONDS.toMillis(timeInNano) = " + TimeUnit.NANOSECONDS.toMillis(timeInNano));
-		System.out.println("TimeUnit.NANOSECONDS.toMillis(timeInNano) = " + TimeUnit.NANOSECONDS.toMillis(timeInNano) /1000.0);
 	}
 }
 
diff --git a/src/main/java/dk/xpreuss/utils/timers/StopWatch.java b/src/main/java/dk/xpreuss/utils/timers/StopWatch.java
index 2d7b804..82a6120 100644
--- a/src/main/java/dk/xpreuss/utils/timers/StopWatch.java
+++ b/src/main/java/dk/xpreuss/utils/timers/StopWatch.java
@@ -8,7 +8,11 @@ import dk.xpreuss.utils.timers.clock.providers.NanoTickProvider;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Objects;
-import java.util.Stack;
+
+import static dk.xpreuss.utils.timers.StopWatch.State.PAUSED;
+import static dk.xpreuss.utils.timers.StopWatch.State.READY;
+import static dk.xpreuss.utils.timers.StopWatch.State.RUNNING;
+import static dk.xpreuss.utils.timers.StopWatch.State.STOPPED;
 
 public class StopWatch implements IStopWatch {
 	public static final long NanosPerMillisecond = 1_000;
@@ -17,12 +21,14 @@ public class StopWatch implements IStopWatch {
 	private final String name;
 
 	private final ITickProvider tickProvider;
-	private boolean isRunning;
-	private boolean isPaused;
+	private State runningState;
+	//	private boolean isRunning;
+//	private boolean isPaused;
 	private ITick startTick;
 	private TimeSpan elapsedNano;
 	private LinkedList<TimeSpan> laps;
 
+
 	protected StopWatch(String name, ITickProvider tickProvider) {
 		this.name = Objects.requireNonNull(name);
 		this.tickProvider = tickProvider;
@@ -52,7 +58,7 @@ public class StopWatch implements IStopWatch {
 
 	private TimeSpan getElapsedTime() {
 		TimeSpan timeElapsedInNano = this.elapsedNano;
-		if (isRunning) {
+		if (RUNNING == this.runningState) {
 			// If the StopWatch is running, add elapsed time since the StopWatch is started last time.
 			ITick currentTick = getTicks();
 			TimeSpan elapsedInNanosecondsUntilNow = currentTick.diff(this.startTick);
@@ -67,36 +73,38 @@ public class StopWatch implements IStopWatch {
 	}
 
 	public final void start() {
-		if (isRunning && !isPaused) {
+		if (RUNNING == this.runningState) {
 			throw new IllegalStateException("The StopWatch has already been started.");
-		} if(isRunning && isPaused){
+		}
+		if (PAUSED == this.runningState) {
 			// Doing a resume
 			resume();
-		}else {
+		} else {
 			this.startTick = getTicks();
-			isRunning = true;
+			//isRunning = true;
+			this.runningState = RUNNING;
 		}
 	}
 
+	@Override
 	public final void stop() {
-		if (isRunning) {
-			ITick endTicksInNano = getTicks();
-			TimeSpan elapsedThisPeriod = endTicksInNano.diff(startTick);
-			this.elapsedNano = this.elapsedNano.add(elapsedThisPeriod);
-			isRunning = false;
-
-			if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
-				// If measuring small time periods and return of negative value reset elapsed.
-				this.elapsedNano = TimeSpan.Zero;
-			}
-		} else {
+		if (STOPPED == this.runningState) {
 			throw new IllegalStateException("StopWatch is already stopped.");
 		}
+		ITick endTicksInNano = getTicks();
+		TimeSpan elapsedThisPeriod = endTicksInNano.diff(startTick);
+		this.elapsedNano = this.elapsedNano.add(elapsedThisPeriod);
+		//isRunning = false;
+		this.runningState = STOPPED;
+
+		this.elapsedNano = resetIfNegative(this.elapsedNano);
 	}
 
+	@Override
 	public final void reset() {
-		isRunning = false;
-		isPaused = false;
+		this.runningState = READY;
+		//isRunning = false;
+		//isPaused = false;
 		startTick = getTicks(); // Don't care the start, this is not set yet.
 		elapsedNano = TimeSpan.Zero;
 		laps = new LinkedList<>();
@@ -105,9 +113,11 @@ public class StopWatch implements IStopWatch {
 	/**
 	 * Convenience method for replacing {sw.Reset(); sw.Start();} with a single sw.Restart()
 	 */
+	@Override
 	public final void restart() {
-		isRunning = true;
-		isPaused = false;
+		this.runningState = RUNNING;
+		//isRunning = true;
+		//isPaused = false;
 		startTick = getTicks(); // This is important, because we start again.
 		elapsedNano = TimeSpan.Zero;
 		laps = new LinkedList<>();
@@ -115,51 +125,49 @@ public class StopWatch implements IStopWatch {
 
 	@Override
 	public void pause() {
-		if (!isRunning) {
-			throw new IllegalStateException("StopWatch can not be paused if it is not startet.");
+		if (!this.runningState.isStarted()) {
+			throw new IllegalStateException("StopWatch can not be paused if it is not started.");
 		}
-		if (isPaused) {
+		if (this.runningState.isPaused()) {
 			throw new IllegalStateException("StopWatch is already paused.");
 		}
 
-		if (!isPaused && isRunning) {
-			ITick nowTicksInNano = getTicks();
-			TimeSpan elapsedThisPeriod = nowTicksInNano.diff(startTick);
-			this.elapsedNano = this.elapsedNano.add(elapsedThisPeriod);
-			isPaused = true;
-
-			if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
-				// If measuring small time periods and return of negative value reset elapsed.
-				this.elapsedNano = TimeSpan.Zero;
-			}
-		} else {
-			throw new IllegalStateException("StopWatch is already paused.");
-		}
+		ITick nowTicksInNano = getTicks();
+		TimeSpan elapsedThisPeriod = nowTicksInNano.diff(startTick);
+		this.elapsedNano = this.elapsedNano.add(elapsedThisPeriod);
+
+		//isPaused = true;
+		this.runningState = PAUSED;
+
+		this.elapsedNano = resetIfNegative(this.elapsedNano);
 	}
 
 	@Override
 	public void resume() {
-		if (isPaused && isRunning) {
-			ITick nowTicksInNano = getTicks();
-			this.startTick = nowTicksInNano;
-			isPaused = false;
-		} else {
-
+		if (!this.runningState.isStarted()) {
+			throw new IllegalStateException("StopWatch can be resumed if it is not started.");
+		}
+		if (!this.runningState.isPaused()) {
+			throw new IllegalStateException("StopWatch has not been paused.");
 		}
+
+		ITick nowTicksInNano = getTicks();
+		this.startTick = nowTicksInNano;
+
+		//isPaused = false;
+		this.runningState = RUNNING;
 	}
 
 	@Override
 	public TimeSpan lap() {
-		if (isRunning && !isPaused) {
+		//if (isRunning && !isPaused) {
+		if (this.runningState.isStarted() && !this.runningState.isPaused()) {
 			ITick nowTicksInNano = getTicks();
 			TimeSpan elapsedThisLap = nowTicksInNano.diff(this.startTick);
 			this.elapsedNano = this.elapsedNano.add(elapsedThisLap);
 			this.startTick = nowTicksInNano;
 
-			if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
-				// If measuring small time periods and return of negative value reset elapsed.
-				this.elapsedNano = TimeSpan.Zero;
-			}
+			this.elapsedNano = resetIfNegative(this.elapsedNano);
 			this.laps.add(elapsedThisLap);
 			return elapsedThisLap;
 		} else {
@@ -167,13 +175,27 @@ public class StopWatch implements IStopWatch {
 		}
 	}
 
+	/**
+	 * If measuring small time periods and return of negative value, the reset elapsed time.
+	 *
+	 * @param elapsedTime to be tested if negative
+	 * @return the elapsedTime or the reset to zero if elapsedTime was negative
+	 */
+	private TimeSpan resetIfNegative(TimeSpan elapsedTime) {
+		if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
+			return TimeSpan.Zero;
+		}
+		return elapsedTime;
+	}
+
+	@Override
 	public final boolean isRunning() {
-		return isRunning;
+		return this.runningState.isStarted();
 	}
 
 	@Override
 	public boolean isPaused() {
-		return isPaused;
+		return this.runningState.isPaused();
 	}
 
 	@Override
@@ -196,14 +218,28 @@ public class StopWatch implements IStopWatch {
 		return getElapsedTime();
 	}
 
-	public TimeSpan elapsedLap() {
-		if(laps.size() > 0) {
+	@Override
+	public TimeSpan elapsedLastLap() {
+		if (laps.size() > 0) {
 			return laps.getLast();
 		} else {
 			return getElapsedTime();
 		}
 	}
 
+	@Override
+	public TimeSpan elapsedCurrentLap() {
+		TimeSpan timeElapsedInNano = this.elapsedNano;
+		if (RUNNING == this.runningState) {
+			// If the StopWatch is running, add elapsed time since the StopWatch is started last time.
+			ITick currentTick = getTicks();
+			TimeSpan elapsedInNanosecondsUntilNow = currentTick.diff(this.startTick);
+			//timeElapsedInNano = timeElapsedInNano.add(elapsedInNanosecondsUntilNow);
+			timeElapsedInNano = elapsedInNanosecondsUntilNow;
+		}
+		return timeElapsedInNano;
+	}
+
 	@Override
 	public long elapsedNanoseconds() {
 		return (long) getElapsedTime().getTotalTimeNanoseconds();
@@ -218,4 +254,47 @@ public class StopWatch implements IStopWatch {
 	public double elapsedSeconds() {
 		return getElapsedTime().getTotalTimeSeconds();
 	}
+
+	/**
+	 * Enumeration type which indicates the status of stopwatch.
+	 */
+	protected enum State {
+		READY(false, false, false),
+		RUNNING(true, false, false),
+		PAUSED(true, false, true),
+		STOPPED(false, true, false);
+
+		private final boolean isStarted;
+		private final boolean isStopped;
+		private final boolean isPaused;
+
+		State(boolean isStarted, boolean isStopped, boolean isPaused) {
+			this.isStarted = isStarted;
+			this.isStopped = isStopped;
+			this.isPaused = isPaused;
+		}
+
+		public boolean isStarted() {
+			return isStarted;
+		}
+
+		public boolean isStopped() {
+			return isStopped;
+		}
+
+		public boolean isPaused() {
+			return isPaused;
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "StopWatch{" +
+				"name='" + name + '\'' +
+				", tickProvider=" + tickProvider.getClass().getSimpleName() +
+				", runningState=" + runningState.name() +
+				", elapsedNano=" + elapsedNano +
+				", lapsCount=" + laps.size() +
+				'}';
+	}
 }
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java b/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java
index c067637..ddaa581 100644
--- a/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java
@@ -1,16 +1,20 @@
 package dk.xpreuss.utils.timers.clock;
 
 import java.math.BigInteger;
+import java.util.Arrays;
 import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
 
 public class TimeSpan implements Comparable<TimeSpan> {
+	public static final TimeSpan Zero = new TimeSpan(0);
 	private static final int HoursPerDay = 24;
 	private static final int MinutesPerHour = 60;
 	private static final int SecondsPerMinute = 60;
 	private static final int MillisecondsPerSecond = 1_000;
 	private static final int MicrosecondsPerMillisecond = 1_000;
 	private static final int NanosecondsPerMicrosecond = 1_000;
-
 	private static final long ElapsedTimeInNanosecondsPerNanosecond = 1;
 	private static final long ElapsedTimeInNanosecondsPerMicrosecond = ElapsedTimeInNanosecondsPerNanosecond * 1_000;
 	private static final long ElapsedTimeInNanosecondsPerMillisecond = ElapsedTimeInNanosecondsPerMicrosecond * 1_000;
@@ -22,9 +26,6 @@ public class TimeSpan implements Comparable<TimeSpan> {
 	private static final int MillisPerMinute = MillisPerSecond * 60; //     60,000
 	private static final int MillisPerHour = MillisPerMinute * 60;   //  3,600,000
 	private static final int MillisPerDay = MillisPerHour * 24;      // 86,400,000
-
-	public static final TimeSpan Zero = new TimeSpan(0);
-
 	private BigInteger elapsedTimeInNanoseconds;
 	private long days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
 
@@ -36,6 +37,26 @@ public class TimeSpan implements Comparable<TimeSpan> {
 		this(elapsedTimeInNanoseconds.longValueExact());
 	}
 
+	public static TimeSpan Interval(double value, int scale) {
+		if (Double.isNaN(value)) {
+			throw new IllegalArgumentException("Cannot be NaN");
+		}
+		double tmp = value * scale;
+		double millis = tmp + (value >= 0 ? 0.5 : -0.5);
+		if ((millis > Integer.MAX_VALUE / Zero.ElapsedTimeInNanosecondsPerMillisecond) || (millis < Integer.MAX_VALUE / ElapsedTimeInNanosecondsPerMillisecond)) {
+			throw new ArithmeticException("double value out of byte range");
+		}
+		return new TimeSpan((long) millis * ElapsedTimeInNanosecondsPerMillisecond);
+	}
+
+	public static TimeSpan fromElapsedInNanoseconds(long elapsedInNanoseconds) {
+		return new TimeSpan(elapsedInNanoseconds);
+	}
+
+	public static Builder Builder() {
+		return new Builder();
+	}
+
 	private void initialize(long elapsedTimeInNanoseconds) {
 		this.elapsedTimeInNanoseconds = BigInteger.valueOf(elapsedTimeInNanoseconds);
 		this.days = calculateDays(elapsedTimeInNanoseconds);
@@ -119,15 +140,17 @@ public class TimeSpan implements Comparable<TimeSpan> {
 		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerSecond;
 	}
 
-	public double getTotalTimeMilliseconds() {
-		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerMillisecond;
+	public long getTotalTimeMilliseconds() {
+		return elapsedTimeInNanoseconds.longValueExact() / ElapsedTimeInNanosecondsPerMillisecond;
 	}
 
-	public double getTotalTimeMicroseconds() {
-		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerMicrosecond;
+	public long getTotalTimeMicroseconds() {
+		return elapsedTimeInNanoseconds.longValueExact() / ElapsedTimeInNanosecondsPerMicrosecond;
 	}
 
-	public double getTotalTimeNanoseconds() { return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerNanosecond;}
+	public long getTotalTimeNanoseconds() {
+		return elapsedTimeInNanoseconds.longValueExact() / ElapsedTimeInNanosecondsPerNanosecond;
+	}
 
 	public long getNanoAdjustment() {
 		return Math.addExact(nanoseconds,
@@ -158,18 +181,6 @@ public class TimeSpan implements Comparable<TimeSpan> {
 		return new TimeSpan(result);
 	}
 
-	public static TimeSpan Interval(double value, int scale) {
-		if (Double.isNaN(value)) {
-			throw new IllegalArgumentException("Cannot be NaN");
-		}
-		double tmp = value * scale;
-		double millis = tmp + (value >= 0 ? 0.5 : -0.5);
-		if ((millis > Integer.MAX_VALUE / Zero.ElapsedTimeInNanosecondsPerMillisecond) || (millis < Integer.MAX_VALUE / ElapsedTimeInNanosecondsPerMillisecond)) {
-			throw new ArithmeticException("double value out of byte range");
-		}
-		return new TimeSpan((long) millis * ElapsedTimeInNanosecondsPerMillisecond);
-	}
-
 	@Override
 	public String toString() {
 		return TimeSpanFormat.format(this, TimeSpanFormat.FormatPattern.MINIMUM);
@@ -179,11 +190,6 @@ public class TimeSpan implements Comparable<TimeSpan> {
 		return TimeSpanFormat.format(this, TimeSpanFormat.FormatPattern.FULL);
 	}
 
-	public static TimeSpan fromElapsedInNanoseconds(long elapsedInNanoseconds) {
-		return new TimeSpan(elapsedInNanoseconds);
-	}
-
-
 	/**
 	 * Compares this object with the specified object for order.  Returns a
 	 * negative integer, zero, or a positive integer as this object is less
@@ -241,74 +247,113 @@ public class TimeSpan implements Comparable<TimeSpan> {
 		return Objects.hash(elapsedTimeInNanoseconds, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
 	}
 
-	public static Builder Builder() {
-		return new Builder();
-	}
-
 	public static class Builder {
-		private BigInteger elapsedTimeInNanoseconds = BigInteger.ZERO;
-		private long days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
+		private BigInteger days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds = BigInteger.ZERO;
+
+		private static BigInteger multiply(long... values) {
+			return Arrays.stream(values).mapToObj(BigInteger::valueOf)
+					.reduce(BigInteger.ONE, BigInteger::multiply);
+		}
 
-		public Builder elapsedTimeInNanoseconds(long elapsedTimeInNanoseconds) {
-			this.elapsedTimeInNanoseconds = BigInteger.valueOf(elapsedTimeInNanoseconds);
+		private static BigInteger multiply(BigInteger mainValue, long... values) {
+			return Arrays.stream(values).mapToObj(BigInteger::valueOf)
+					.reduce(Optional.ofNullable(mainValue).orElse(BigInteger.ZERO), BigInteger::multiply);
+		}
+
+		private static BigInteger add(BigInteger... values) {
+			return Arrays.stream(values).reduce(BigInteger.ZERO, BigInteger::add);
+		}
+
+		public Builder days(BigInteger days) {
+			this.days = days;
 			return this;
 		}
 
 		public Builder days(long days) {
-			this.days = days;
+			this.days = BigInteger.valueOf(days);
 			return this;
 		}
 
-		public Builder hours(long hours) {
+		public Builder hours(BigInteger hours) {
 			this.hours = hours;
 			return this;
 		}
 
-		public Builder minutes(long minutes) {
+		public Builder hours(long hours) {
+			this.hours = BigInteger.valueOf(hours);
+			return this;
+		}
+
+		public Builder minutes(BigInteger minutes) {
 			this.minutes = minutes;
 			return this;
 		}
 
-		public Builder seconds(long seconds) {
+		public Builder minutes(long minutes) {
+			this.minutes = BigInteger.valueOf(minutes);
+			return this;
+		}
+
+		public Builder seconds(BigInteger seconds) {
 			this.seconds = seconds;
 			return this;
 		}
 
-		public Builder milliseconds(long milliseconds) {
+		public Builder seconds(long seconds) {
+			this.seconds = BigInteger.valueOf(seconds);
+			return this;
+		}
+
+		public Builder milliseconds(BigInteger milliseconds) {
 			this.milliseconds = milliseconds;
 			return this;
 		}
 
-		public Builder microseconds(long microseconds) {
+		public Builder milliseconds(long milliseconds) {
+			this.milliseconds = BigInteger.valueOf(milliseconds);
+			return this;
+		}
+
+		public Builder microseconds(BigInteger microseconds) {
 			this.microseconds = microseconds;
 			return this;
 		}
 
-		public Builder nanoseconds(long nanoseconds) {
+		public Builder microseconds(long microseconds) {
+			this.microseconds = BigInteger.valueOf(microseconds);
+			return this;
+		}
+
+		public Builder nanoseconds(BigInteger nanoseconds) {
 			this.nanoseconds = nanoseconds;
 			return this;
 		}
 
-		public TimeSpan build() {
-			long dayElapsedTimeInNanoseconds = days * TimeSpan.Zero.ElapsedTimeInNanosecondsPerDay;
-			long hourElapsedTimeInNanoseconds = hours * TimeSpan.Zero.ElapsedTimeInNanosecondsPerHour;
-			long minuteElapsedTimeInNanoseconds = minutes * TimeSpan.Zero.ElapsedTimeInNanosecondsPerMinute;
-			long secondElapsedTimeInNanoseconds = seconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerSecond;
-			long millisecondElapsedTimeInNanoseconds = milliseconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerMillisecond;
-			long microsecondElapsedTimeInNanoseconds = microseconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerMicrosecond;
-			long nanosecondElapsedTimeInNanoseconds = nanoseconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerNanosecond;
-
-			System.out.println("dayElapsedTimeInNanoseconds: " + dayElapsedTimeInNanoseconds);
-			System.out.println("hourElapsedTimeInNanoseconds: " + hourElapsedTimeInNanoseconds);
-			System.out.println("minuteElapsedTimeInNanoseconds: " + minuteElapsedTimeInNanoseconds);
-			System.out.println("secondElapsedTimeInNanoseconds: " + secondElapsedTimeInNanoseconds);
-			System.out.println("millisecondElapsedTimeInNanoseconds: " + millisecondElapsedTimeInNanoseconds);
-			System.out.println("microsecondElapsedTimeInNanoseconds: " + microsecondElapsedTimeInNanoseconds);
-			System.out.println("nanosecondElapsedTimeInNanoseconds: " + nanosecondElapsedTimeInNanoseconds);
-			System.out.println("elapsedTimeInNanoseconds: " + elapsedTimeInNanoseconds.longValue());
-
-			return new TimeSpan(elapsedTimeInNanoseconds.longValue() + dayElapsedTimeInNanoseconds + hourElapsedTimeInNanoseconds + minuteElapsedTimeInNanoseconds + secondElapsedTimeInNanoseconds + millisecondElapsedTimeInNanoseconds + microsecondElapsedTimeInNanoseconds + nanosecondElapsedTimeInNanoseconds);
+		public Builder nanoseconds(long nanoseconds) {
+			this.nanoseconds = BigInteger.valueOf(nanoseconds);
+			return this;
 		}
 
+		public TimeSpan build() {
+			BigInteger dayElapsedTimeInNanoseconds = multiply(days, TimeSpan.Zero.ElapsedTimeInNanosecondsPerDay);
+			BigInteger hourElapsedTimeInNanoseconds = multiply(hours, TimeSpan.Zero.ElapsedTimeInNanosecondsPerHour);
+			BigInteger minuteElapsedTimeInNanoseconds = multiply(minutes, TimeSpan.Zero.ElapsedTimeInNanosecondsPerMinute);
+			BigInteger secondElapsedTimeInNanoseconds = multiply(seconds, TimeSpan.Zero.ElapsedTimeInNanosecondsPerSecond);
+			BigInteger millisecondElapsedTimeInNanoseconds = multiply(milliseconds, TimeSpan.Zero.ElapsedTimeInNanosecondsPerMillisecond);
+			BigInteger microsecondElapsedTimeInNanoseconds = multiply(microseconds, TimeSpan.Zero.ElapsedTimeInNanosecondsPerMicrosecond);
+			BigInteger nanosecondElapsedTimeInNanoseconds = multiply(nanoseconds, TimeSpan.Zero.ElapsedTimeInNanosecondsPerNanosecond);
+
+			BigInteger totalElapsed = add(
+					dayElapsedTimeInNanoseconds,
+					hourElapsedTimeInNanoseconds,
+					minuteElapsedTimeInNanoseconds,
+					secondElapsedTimeInNanoseconds,
+					millisecondElapsedTimeInNanoseconds,
+					microsecondElapsedTimeInNanoseconds,
+					nanosecondElapsedTimeInNanoseconds
+			);
+			System.out.println(totalElapsed);
+			return new TimeSpan(totalElapsed);
+		}
 	}
 }
diff --git a/src/test/java/dk/xpreuss/utils/timers/StopWatchTest.java b/src/test/java/dk/xpreuss/utils/timers/StopWatchTest.java
new file mode 100644
index 0000000..959b37c
--- /dev/null
+++ b/src/test/java/dk/xpreuss/utils/timers/StopWatchTest.java
@@ -0,0 +1,98 @@
+package dk.xpreuss.utils.timers;
+
+import org.junit.jupiter.api.*;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public class StopWatchTest {
+	@BeforeAll
+	static void setup() {
+		System.out.println("@BeforeAll executed static");
+	}
+
+	@AfterAll
+	static void tear() {
+		System.out.println("@AfterAll executed");
+	}
+
+	/**
+	 * determine whether two numbers are "approximately equal" by seeing if they
+	 * are within a certain "tolerance percentage," with `tolerancePercentage` given
+	 * as a percentage (such as 10.0 meaning "10%").
+	 *
+	 * @param desiredValue
+	 * @param actualValue
+	 * @param tolerancePercentage 1 = 1%, 2.5 = 2.5%, etc.
+	 * @return if actualValue is inside tolerance +- %
+	 */
+	public static boolean approximatelyEqual(Number desiredValue, Number actualValue, Number tolerancePercentage) {
+		double diff = Math.abs(desiredValue.doubleValue() - actualValue.doubleValue());            //  1000 - 950  = 50
+		double tolerance = tolerancePercentage.doubleValue() / 100.0 * desiredValue.doubleValue(); //  20/100*1000 = 200
+		return diff <= tolerance; //  50<=200      = true
+	}
+
+	public static boolean isBetweenFromTo(Number actualValue, Number validFrom, Number validTo) {
+		return actualValue.doubleValue() >= validFrom.doubleValue() && actualValue.doubleValue() <= validTo.doubleValue();
+	}
+
+	@BeforeEach
+	void setupThis() {
+		System.out.println("@BeforeEach executred");
+	}
+
+	@Test
+	public void testLap() throws InterruptedException {
+		IStopWatch stopWatch = StopWatch.from("TestLap");
+		stopWatch.start();
+		final long SLEEP_FIRST = 100L;
+		final long APPROX_TIME = 50L;
+		Thread.sleep(SLEEP_FIRST);
+		long elapsedLastLap = stopWatch.elapsedLastLap().getTotalTimeMilliseconds();
+		long elapsedCurrentLap = stopWatch.elapsedCurrentLap().getTotalTimeMilliseconds();
+		long elapsed = stopWatch.elapsed().getTotalTimeMilliseconds();
+		long elapsedcurrentLapFinished = stopWatch.lap().getTotalTimeMilliseconds();
+		assertTrue(approximatelyEqual(elapsedLastLap, elapsedCurrentLap, 5), "Elapsed current lap and last lap should be the same.");
+		assertTrue(isBetweenFromTo(elapsedLastLap, SLEEP_FIRST, SLEEP_FIRST + APPROX_TIME));
+		assertTrue(isBetweenFromTo(elapsedCurrentLap, SLEEP_FIRST, SLEEP_FIRST + APPROX_TIME));
+		assertTrue(isBetweenFromTo(elapsed, SLEEP_FIRST, SLEEP_FIRST + APPROX_TIME));
+		assertTrue(isBetweenFromTo(elapsedcurrentLapFinished, SLEEP_FIRST, SLEEP_FIRST + APPROX_TIME));
+
+		final long SLEEP_SECOND = 200L;
+		long currentTotalSleep = SLEEP_FIRST + SLEEP_SECOND;
+		Thread.sleep(SLEEP_SECOND);
+		elapsedLastLap = stopWatch.elapsedLastLap().getTotalTimeMilliseconds();
+		elapsedCurrentLap = stopWatch.elapsedCurrentLap().getTotalTimeMilliseconds();
+		elapsed = stopWatch.elapsed().getTotalTimeMilliseconds();
+		elapsedcurrentLapFinished = stopWatch.lap().getTotalTimeMilliseconds();
+		assertTrue(isBetweenFromTo(elapsedLastLap, SLEEP_FIRST, SLEEP_FIRST + APPROX_TIME), "Should be " + SLEEP_FIRST + " but was " + elapsedLastLap);
+		assertTrue(isBetweenFromTo(elapsedCurrentLap, SLEEP_SECOND, SLEEP_SECOND + APPROX_TIME));
+		assertTrue(isBetweenFromTo(elapsed, currentTotalSleep, currentTotalSleep + APPROX_TIME));
+		assertTrue(isBetweenFromTo(elapsedcurrentLapFinished, SLEEP_SECOND, SLEEP_SECOND+ APPROX_TIME));
+
+	}
+
+	@Test
+	public void testIsRunning() {
+		assertTrue(true);
+	}
+
+	@Test
+	public void testIsPaused() {
+		assertTrue(true);
+	}
+
+	@Test
+	public void testIsStopped() {
+		assertTrue(true);
+	}
+
+	@Test
+	public void testGetTimeLaps() {
+		assertTrue(true);
+	}
+
+	@AfterEach
+	void tearThis() {
+		System.out.println("@AfterEach executed");
+	}
+}
\ No newline at end of file
-- 
2.26.2.windows.1

From 88e51066faed2c11adb6333edff15b7538ce97a5 Mon Sep 17 00:00:00 2001
From: Jesper <jespr@semler.dk>
Date: Thu, 20 May 2021 14:42:44 +0200
Subject: [PATCH] My initial commit

---
 .gitignore                                    |   20 +-
 UseUnicode.txt                                |   70 +
 build.gradle                                  |   70 +
 docs/AUTHORS                                  |    4 +
 docs/COPYING                                  |    1 +
 docs/COPYING.CLASSPATH                        |   26 +
 docs/README                                   |   51 +
 gradle.properties                             |    1 +
 gradle/wrapper/gradle-wrapper.jar             |  Bin 0 -> 59203 bytes
 gradle/wrapper/gradle-wrapper.properties      |    5 +
 gradlew                                       |  185 ++
 gradlew.bat                                   |   89 +
 settings.gradle                               |    2 +
 .../java/dk/xpreuss/utils/StandardOutput.java |   38 +
 src/main/java/dk/xpreuss/utils/Test.java      |   59 +
 .../locales/LocaleCalendarExtensions.java     |  108 +
 .../utils/locales/LocaleExtensions.java       |  112 +
 .../locales/LocaleICUCalendarExtensions.java  |  101 +
 .../utils/locales/LocaleNumberExtensions.java |   98 +
 .../dk/xpreuss/utils/locales/LocaleUtil.java  |   11 +
 .../xpreuss/utils/locales/NumberHelper.java   |  125 +
 .../xpreuss/utils/timers/Algs4Stopwatch.java  |   88 +
 .../utils/timers/Algs4StopwatchCPU.java       |   90 +
 .../dk/xpreuss/utils/timers/IStopWatch.java   |   33 +
 .../xpreuss/utils/timers/MyStopWatchTest.java |   79 +
 .../dk/xpreuss/utils/timers/StopWatch.java    |  221 ++
 .../xpreuss/utils/timers/TestStopWatch.java   |   26 +
 .../dk/xpreuss/utils/timers/clock/IClock.java |   38 +
 .../utils/timers/clock/SystemClock.java       |   78 +
 .../xpreuss/utils/timers/clock/TimeSpan.java  |  314 +++
 .../utils/timers/clock/TimeSpanFormat.java    |   59 +
 .../clock/providers/CpuTickProvider.java      |   34 +
 .../utils/timers/clock/providers/ITick.java   |  110 +
 .../timers/clock/providers/ITickProvider.java |   15 +
 .../clock/providers/MilliTickProvider.java    |   25 +
 .../clock/providers/NanoTickProvider.java     |   25 +
 .../utils/timers/clock/providers/Tick.java    |   22 +
 .../otherproviders/CpuTickProvider.java       |   24 +
 .../otherproviders/MilliTickProvider.java     |   15 +
 .../otherproviders/NanoTickProvider.java      |   15 +
 .../xperimentering/ByteOutputStream.java      |    4 +
 .../dk/xpreuss/xperimentering/ByteWriter.java |  383 +++
 .../xpreuss/xperimentering/IByteWriter.java   |   51 +
 .../java/dk/xpreuss/xperimentering/Main.java  |  125 +
 .../java/dk/xpreuss/xperimentering/Main2.java |   10 +
 .../xperimentering/Main3InputStream.java      |   12 +
 .../dk/xpreuss/xperimentering/SafeMath.java   |  101 +
 .../xperimentering/basex/Base64.java.txt      | 1185 +++++++++
 .../xperimentering/basex/Base64rfc4648.java   |  157 ++
 .../xpreuss/xperimentering/basex/IBase64.java |   10 +
 .../xperimentering/basex/IBaseNDecoder.java   |    5 +
 .../xperimentering/basex/IBaseNEncoder.java   |    5 +
 .../basex/coders/ByteBufferDecodeable.java    |    4 +
 .../basex/coders/ByteBufferEncodeable.java    |    4 +
 .../basex/coders/ByteDecodeable.java          |    4 +
 .../basex/coders/ByteEncodeable.java          |    4 +
 .../basex/coders/IByteCodec.java              |    4 +
 .../basex/coders/IByteDecoder.java            |    4 +
 .../basex/coders/IByteEncoder.java            |    4 +
 .../basex/coders/IByteStringCodec.java        |    4 +
 .../basex/coders/IByteStringDecoder.java      |    4 +
 .../basex/coders/IByteStringEncoder.java      |    4 +
 .../xperimentering/basex/coders/IDecoder.java |    5 +
 .../xperimentering/basex/coders/IEncoder.java |    5 +
 .../basex/coders/IStringByteCodec.java        |    4 +
 .../basex/coders/IStringByteDecoder.java      |    4 +
 .../basex/coders/IStringByteEncoder.java      |    4 +
 .../basex/coders/IStringCodec.java            |    4 +
 .../basex/coders/IStringDecoder.java          |    5 +
 .../basex/coders/IStringEncoder.java          |    5 +
 .../basex/mycoder/MyEncoder.java              |  152 ++
 .../basex/speedc/SpeedCDecoder.c              |   35 +
 .../basex/speedc/SpeedCDecoder.java           |   72 +
 .../basex/speedc/SpeedCEncoder.c              |   67 +
 .../basex/speedc/SpeedCEncoder.java           |   79 +
 .../xperimentering/basex/w3c/Base64.java      |  170 ++
 .../xperimentering/collections/Bag.java       |    4 +
 .../xperimentering/collections/Item.java      |   13 +
 .../xperimentering/collections/Queue.java     |    4 +
 .../xperimentering/collections/Stack.java     |   28 +
 .../edu/princeton/cs/algs4/AVLTreeST.java     |  835 +++++++
 .../edu/princeton/cs/algs4/Accumulator.java   |  145 ++
 .../edu/princeton/cs/algs4/AcyclicLP.java     |  191 ++
 .../edu/princeton/cs/algs4/AcyclicSP.java     |  190 ++
 .../algs4/AdjMatrixEdgeWeightedDigraph.java   |  216 ++
 .../edu/princeton/cs/algs4/AllowFilter.java   |   92 +
 .../edu/princeton/cs/algs4/Allowlist.java     |   93 +
 .../java/edu/princeton/cs/algs4/Alphabet.java |  280 +++
 .../edu/princeton/cs/algs4/AmericanFlag.java  |  313 +++
 .../edu/princeton/cs/algs4/AmericanFlagX.java |  202 ++
 .../edu/princeton/cs/algs4/Arbitrage.java     |  120 +
 .../princeton/cs/algs4/AssignmentProblem.java |  335 +++
 .../java/edu/princeton/cs/algs4/Average.java  |   83 +
 src/main/java/edu/princeton/cs/algs4/BST.java |  577 +++++
 .../java/edu/princeton/cs/algs4/BTree.java    |  314 +++
 src/main/java/edu/princeton/cs/algs4/Bag.java |  176 ++
 .../edu/princeton/cs/algs4/BellmanFordSP.java |  333 +++
 .../edu/princeton/cs/algs4/BinaryDump.java    |   98 +
 .../java/edu/princeton/cs/algs4/BinaryIn.java |  405 ++++
 .../princeton/cs/algs4/BinaryInsertion.java   |  148 ++
 .../edu/princeton/cs/algs4/BinaryOut.java     |  365 +++
 .../edu/princeton/cs/algs4/BinarySearch.java  |  131 +
 .../princeton/cs/algs4/BinarySearchST.java    |  459 ++++
 .../edu/princeton/cs/algs4/BinaryStdIn.java   |  323 +++
 .../edu/princeton/cs/algs4/BinaryStdOut.java  |  323 +++
 .../edu/princeton/cs/algs4/BinomialMinPQ.java |  328 +++
 .../edu/princeton/cs/algs4/Bipartite.java     |  236 ++
 .../princeton/cs/algs4/BipartiteMatching.java |  370 +++
 .../edu/princeton/cs/algs4/BipartiteX.java    |  251 ++
 .../edu/princeton/cs/algs4/BlockFilter.java   |   92 +
 .../edu/princeton/cs/algs4/BoruvkaMST.java    |  227 ++
 .../edu/princeton/cs/algs4/BoyerMoore.java    |  198 ++
 .../cs/algs4/BreadthFirstDirectedPaths.java   |  256 ++
 .../princeton/cs/algs4/BreadthFirstPaths.java |  319 +++
 src/main/java/edu/princeton/cs/algs4/CC.java  |  260 ++
 src/main/java/edu/princeton/cs/algs4/CPM.java |  123 +
 src/main/java/edu/princeton/cs/algs4/Cat.java |   87 +
 .../edu/princeton/cs/algs4/ClosestPair.java   |  232 ++
 .../princeton/cs/algs4/CollisionSystem.java   |  243 ++
 .../java/edu/princeton/cs/algs4/Complex.java  |  290 +++
 .../java/edu/princeton/cs/algs4/Count.java    |   99 +
 .../java/edu/princeton/cs/algs4/Counter.java  |  141 ++
 .../java/edu/princeton/cs/algs4/Cycle.java    |  206 ++
 .../java/edu/princeton/cs/algs4/Date.java     |  235 ++
 .../java/edu/princeton/cs/algs4/DeDup.java    |   87 +
 .../cs/algs4/DegreesOfSeparation.java         |  153 ++
 .../cs/algs4/DepthFirstDirectedPaths.java     |  173 ++
 .../princeton/cs/algs4/DepthFirstOrder.java   |  267 +++
 .../princeton/cs/algs4/DepthFirstPaths.java   |  170 ++
 .../princeton/cs/algs4/DepthFirstSearch.java  |  142 ++
 .../java/edu/princeton/cs/algs4/Digraph.java  |  308 +++
 .../princeton/cs/algs4/DigraphGenerator.java  |  573 +++++
 .../cs/algs4/DijkstraAllPairsSP.java          |  173 ++
 .../edu/princeton/cs/algs4/DijkstraSP.java    |  271 +++
 .../cs/algs4/DijkstraUndirectedSP.java        |  283 +++
 .../edu/princeton/cs/algs4/DirectedCycle.java |  178 ++
 .../princeton/cs/algs4/DirectedCycleX.java    |  194 ++
 .../edu/princeton/cs/algs4/DirectedDFS.java   |  188 ++
 .../edu/princeton/cs/algs4/DirectedEdge.java  |  115 +
 .../cs/algs4/DirectedEulerianCycle.java       |  276 +++
 .../cs/algs4/DirectedEulerianPath.java        |  278 +++
 .../edu/princeton/cs/algs4/DoublingRatio.java |   94 +
 .../edu/princeton/cs/algs4/DoublingTest.java  |   88 +
 .../java/edu/princeton/cs/algs4/Draw.java     | 1718 +++++++++++++
 .../edu/princeton/cs/algs4/DrawListener.java  |  104 +
 .../java/edu/princeton/cs/algs4/Edge.java     |  141 ++
 .../cs/algs4/EdgeWeightedDigraph.java         |  303 +++
 .../cs/algs4/EdgeWeightedDirectedCycle.java   |  219 ++
 .../princeton/cs/algs4/EdgeWeightedGraph.java |  309 +++
 .../edu/princeton/cs/algs4/EulerianCycle.java |  316 +++
 .../edu/princeton/cs/algs4/EulerianPath.java  |  309 +++
 src/main/java/edu/princeton/cs/algs4/FFT.java |  304 +++
 .../edu/princeton/cs/algs4/FarthestPair.java  |  193 ++
 .../edu/princeton/cs/algs4/FenwickTree.java   |  212 ++
 .../princeton/cs/algs4/FibonacciMinPQ.java    |  354 +++
 .../edu/princeton/cs/algs4/FileIndex.java     |  105 +
 .../java/edu/princeton/cs/algs4/FlowEdge.java |  228 ++
 .../edu/princeton/cs/algs4/FlowNetwork.java   |  217 ++
 .../edu/princeton/cs/algs4/FloydWarshall.java |  308 +++
 .../edu/princeton/cs/algs4/FordFulkerson.java |  294 +++
 .../princeton/cs/algs4/FrequencyCounter.java  |  110 +
 .../java/edu/princeton/cs/algs4/GREP.java     |   89 +
 .../java/edu/princeton/cs/algs4/GabowSCC.java |  222 ++
 .../cs/algs4/GaussJordanElimination.java      |  435 ++++
 .../cs/algs4/GaussianElimination.java         |  386 +++
 .../java/edu/princeton/cs/algs4/Genome.java   |  108 +
 .../edu/princeton/cs/algs4/GlobalMincut.java  |  314 +++
 .../edu/princeton/cs/algs4/GrahamScan.java    |  182 ++
 .../java/edu/princeton/cs/algs4/Graph.java    |  281 +++
 .../princeton/cs/algs4/GraphGenerator.java    |  494 ++++
 .../princeton/cs/algs4/GrayscalePicture.java  |  500 ++++
 .../java/edu/princeton/cs/algs4/Heap.java     |  139 ++
 .../java/edu/princeton/cs/algs4/HexDump.java  |  104 +
 .../edu/princeton/cs/algs4/HopcroftKarp.java  |  419 ++++
 .../java/edu/princeton/cs/algs4/Huffman.java  |  231 ++
 src/main/java/edu/princeton/cs/algs4/In.java  |  820 +++++++
 .../java/edu/princeton/cs/algs4/InTest.txt    |    2 +
 .../cs/algs4/IndexBinomialMinPQ.java          |  526 ++++
 .../cs/algs4/IndexFibonacciMinPQ.java         |  495 ++++
 .../edu/princeton/cs/algs4/IndexMaxPQ.java    |  416 ++++
 .../edu/princeton/cs/algs4/IndexMinPQ.java    |  397 +++
 .../cs/algs4/IndexMultiwayMinPQ.java          |  395 +++
 .../edu/princeton/cs/algs4/InplaceMSD.java    |  171 ++
 .../edu/princeton/cs/algs4/Insertion.java     |  235 ++
 .../edu/princeton/cs/algs4/InsertionX.java    |  155 ++
 .../edu/princeton/cs/algs4/Interval1D.java    |  279 +++
 .../edu/princeton/cs/algs4/Interval2D.java    |  168 ++
 .../edu/princeton/cs/algs4/Inversions.java    |  201 ++
 src/main/java/edu/princeton/cs/algs4/KMP.java |  192 ++
 .../java/edu/princeton/cs/algs4/KWIK.java     |  116 +
 .../java/edu/princeton/cs/algs4/Knuth.java    |  146 ++
 .../princeton/cs/algs4/KosarajuSharirSCC.java |  243 ++
 .../edu/princeton/cs/algs4/KruskalMST.java    |  229 ++
 src/main/java/edu/princeton/cs/algs4/LSD.java |  179 ++
 src/main/java/edu/princeton/cs/algs4/LZW.java |  136 ++
 .../edu/princeton/cs/algs4/LazyPrimMST.java   |  234 ++
 .../cs/algs4/LinearProbingHashST.java         |  297 +++
 .../princeton/cs/algs4/LinearProgramming.java |  425 ++++
 .../princeton/cs/algs4/LinearRegression.java  |  178 ++
 .../edu/princeton/cs/algs4/LinkedBag.java     |  176 ++
 .../edu/princeton/cs/algs4/LinkedQueue.java   |  229 ++
 .../edu/princeton/cs/algs4/LinkedStack.java   |  220 ++
 .../cs/algs4/LongestCommonSubstring.java      |  130 +
 .../cs/algs4/LongestRepeatedSubstring.java    |  113 +
 .../edu/princeton/cs/algs4/LookupCSV.java     |   99 +
 .../edu/princeton/cs/algs4/LookupIndex.java   |  116 +
 src/main/java/edu/princeton/cs/algs4/MSD.java |  249 ++
 .../java/edu/princeton/cs/algs4/MaxPQ.java    |  330 +++
 .../java/edu/princeton/cs/algs4/Merge.java    |  208 ++
 .../java/edu/princeton/cs/algs4/MergeBU.java  |  149 ++
 .../java/edu/princeton/cs/algs4/MergeX.java   |  263 ++
 .../java/edu/princeton/cs/algs4/MinPQ.java    |  321 +++
 .../java/edu/princeton/cs/algs4/Multiway.java |  105 +
 .../edu/princeton/cs/algs4/MultiwayMinPQ.java |  329 +++
 src/main/java/edu/princeton/cs/algs4/NFA.java |  178 ++
 .../princeton/cs/algs4/NonrecursiveDFS.java   |  166 ++
 .../cs/algs4/NonrecursiveDirectedDFS.java     |  147 ++
 src/main/java/edu/princeton/cs/algs4/Out.java |  343 +++
 .../java/edu/princeton/cs/algs4/Particle.java |  253 ++
 .../edu/princeton/cs/algs4/PatriciaSET.java   |  458 ++++
 .../edu/princeton/cs/algs4/PatriciaST.java    |  477 ++++
 .../java/edu/princeton/cs/algs4/Picture.java  |  516 ++++
 .../edu/princeton/cs/algs4/PictureDump.java   |   90 +
 .../edu/princeton/cs/algs4/PlayMusic.java     |  114 +
 .../java/edu/princeton/cs/algs4/Point2D.java  |  396 +++
 .../edu/princeton/cs/algs4/Polynomial.java    |  293 +++
 .../java/edu/princeton/cs/algs4/PrimMST.java  |  254 ++
 .../java/edu/princeton/cs/algs4/Queue.java    |  204 ++
 .../java/edu/princeton/cs/algs4/Quick.java    |  212 ++
 .../edu/princeton/cs/algs4/Quick3string.java  |  175 ++
 .../edu/princeton/cs/algs4/Quick3way.java     |  148 ++
 .../cs/algs4/QuickBentleyMcIlroy.java         |  202 ++
 .../edu/princeton/cs/algs4/QuickFindUF.java   |  200 ++
 .../edu/princeton/cs/algs4/QuickUnionUF.java  |  195 ++
 .../java/edu/princeton/cs/algs4/QuickX.java   |  175 ++
 .../edu/princeton/cs/algs4/RabinKarp.java     |  195 ++
 .../edu/princeton/cs/algs4/RandomSeq.java     |   94 +
 .../java/edu/princeton/cs/algs4/RectHV.java   |  248 ++
 .../edu/princeton/cs/algs4/RedBlackBST.java   |  758 ++++++
 .../princeton/cs/algs4/ResizingArrayBag.java  |  143 ++
 .../cs/algs4/ResizingArrayQueue.java          |  188 ++
 .../cs/algs4/ResizingArrayStack.java          |  197 ++
 .../edu/princeton/cs/algs4/RunLength.java     |  127 +
 src/main/java/edu/princeton/cs/algs4/SET.java |  369 +++
 src/main/java/edu/princeton/cs/algs4/ST.java  |  273 +++
 .../edu/princeton/cs/algs4/SegmentTree.java   |  358 +++
 .../edu/princeton/cs/algs4/Selection.java     |  181 ++
 .../cs/algs4/SeparateChainingHashST.java      |  238 ++
 .../cs/algs4/SequentialSearchST.java          |  238 ++
 .../java/edu/princeton/cs/algs4/Shell.java    |  152 ++
 .../edu/princeton/cs/algs4/SparseVector.java  |  245 ++
 .../java/edu/princeton/cs/algs4/Stack.java    |  215 ++
 .../princeton/cs/algs4/StaticSETofInts.java   |  105 +
 .../edu/princeton/cs/algs4/StdArrayIO.java    |  310 +++
 .../java/edu/princeton/cs/algs4/StdAudio.java |  480 ++++
 .../java/edu/princeton/cs/algs4/StdDraw.java  | 2120 +++++++++++++++++
 .../java/edu/princeton/cs/algs4/StdIn.java    |  696 ++++++
 .../edu/princeton/cs/algs4/StdInTest.java     |  340 +++
 .../java/edu/princeton/cs/algs4/StdOut.java   |  339 +++
 .../edu/princeton/cs/algs4/StdRandom.java     |  674 ++++++
 .../java/edu/princeton/cs/algs4/StdStats.java |  559 +++++
 .../edu/princeton/cs/algs4/Stopwatch.java     |  110 +
 .../edu/princeton/cs/algs4/StopwatchCPU.java  |  112 +
 .../edu/princeton/cs/algs4/SuffixArray.java   |  245 ++
 .../edu/princeton/cs/algs4/SuffixArrayX.java  |  295 +++
 .../edu/princeton/cs/algs4/SymbolDigraph.java |  213 ++
 .../edu/princeton/cs/algs4/SymbolGraph.java   |  245 ++
 src/main/java/edu/princeton/cs/algs4/TST.java |  322 +++
 .../edu/princeton/cs/algs4/TarjanSCC.java     |  216 ++
 .../edu/princeton/cs/algs4/TestIntroCS.java   |   64 +
 .../java/edu/princeton/cs/algs4/ThreeSum.java |  131 +
 .../edu/princeton/cs/algs4/ThreeSumFast.java  |  150 ++
 .../java/edu/princeton/cs/algs4/TopM.java     |   94 +
 .../edu/princeton/cs/algs4/Topological.java   |  185 ++
 .../edu/princeton/cs/algs4/TopologicalX.java  |  343 +++
 .../edu/princeton/cs/algs4/Transaction.java   |  244 ++
 .../princeton/cs/algs4/TransitiveClosure.java |  146 ++
 .../java/edu/princeton/cs/algs4/TrieSET.java  |  310 +++
 .../java/edu/princeton/cs/algs4/TrieST.java   |  333 +++
 .../cs/algs4/TwoPersonZeroSumGame.java        |  377 +++
 src/main/java/edu/princeton/cs/algs4/UF.java  |  227 ++
 .../edu/princeton/cs/algs4/UnicodeTest.java   |  107 +
 .../java/edu/princeton/cs/algs4/Vector.java   |  275 +++
 .../cs/algs4/WeightedQuickUnionUF.java        |  209 ++
 .../java/edu/princeton/cs/algs4/mandrill.jpg  |  Bin 0 -> 66925 bytes
 .../net/jhorstmann/base64/Base64Charset.java  |   28 +
 .../base64/Base64CharsetDecoder.java          |   57 +
 .../base64/Base64CharsetEncoder.java          |   38 +
 .../base64/Base64CharsetProvider.java         |   25 +
 .../jhorstmann/base64/Base64Exception.java    |   30 +
 .../jhorstmann/base64/Base64InputStream.java  |   92 +
 .../jhorstmann/base64/Base64NIODecoder.java   |  261 ++
 .../jhorstmann/base64/Base64OutputStream.java |   38 +
 .../base64/Base64StreamDecoder.java           |  261 ++
 .../base64/Base64StreamEncoder.java           |  191 ++
 .../base64/BufferedByteAppendable.java        |   61 +
 .../net/jhorstmann/base64/ByteAppendable.java |   44 +
 .../base64/FixedSizeStringBuilder.java        |   44 +
 .../base64/IncompleteStreamException.java     |   12 +
 .../base64/InvalidCharacterException.java     |   12 +
 .../codecs/base64/Base64Application.java      |  211 ++
 .../nowise/codecs/base64/Base64Decoder.java   |  281 +++
 .../nowise/codecs/base64/Base64Encoder.java   |  261 ++
 .../java.nio.charset.spi.CharsetProvider      |    1 +
 .../basex/coders/EncodingTest.java            |   10 +
 .../net/jhorstmann/base64/Base64Encoder.java  |   73 +
 .../base64/Base64InputStreamTest.java         |   92 +
 .../net/jhorstmann/base64/Base64Test.java     |  205 ++
 .../net/jhorstmann/base64/CharsetTest.java    |  130 +
 src/test/java/net/jhorstmann/base64/Main.java |   55 +
 .../codecs/base64/Base64DecoderTest.java      |  157 ++
 .../codecs/base64/Base64EncoderTest.java      |  159 ++
 312 files changed, 62325 insertions(+), 1 deletion(-)
 create mode 100644 UseUnicode.txt
 create mode 100644 build.gradle
 create mode 100644 docs/AUTHORS
 create mode 100644 docs/COPYING
 create mode 100644 docs/COPYING.CLASSPATH
 create mode 100644 docs/README
 create mode 100644 gradle.properties
 create mode 100644 gradle/wrapper/gradle-wrapper.jar
 create mode 100644 gradle/wrapper/gradle-wrapper.properties
 create mode 100644 gradlew
 create mode 100644 gradlew.bat
 create mode 100644 settings.gradle
 create mode 100644 src/main/java/dk/xpreuss/utils/StandardOutput.java
 create mode 100644 src/main/java/dk/xpreuss/utils/Test.java
 create mode 100644 src/main/java/dk/xpreuss/utils/locales/LocaleCalendarExtensions.java
 create mode 100644 src/main/java/dk/xpreuss/utils/locales/LocaleExtensions.java
 create mode 100644 src/main/java/dk/xpreuss/utils/locales/LocaleICUCalendarExtensions.java
 create mode 100644 src/main/java/dk/xpreuss/utils/locales/LocaleNumberExtensions.java
 create mode 100644 src/main/java/dk/xpreuss/utils/locales/LocaleUtil.java
 create mode 100644 src/main/java/dk/xpreuss/utils/locales/NumberHelper.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/Algs4Stopwatch.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/Algs4StopwatchCPU.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/StopWatch.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/TestStopWatch.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/IClock.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/TimeSpanFormat.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/providers/CpuTickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/providers/ITickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/providers/MilliTickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/providers/NanoTickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/otherproviders/CpuTickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/otherproviders/MilliTickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/utils/timers/otherproviders/NanoTickProvider.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/ByteOutputStream.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/ByteWriter.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/IByteWriter.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/Main.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/Main2.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/Main3InputStream.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/SafeMath.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/Base64.java.txt
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/Base64rfc4648.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/IBase64.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/IBaseNDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/IBaseNEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferDecodeable.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferEncodeable.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteDecodeable.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteEncodeable.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteCodec.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringCodec.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteCodec.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringCodec.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/mycoder/MyEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.c
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.c
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/basex/w3c/Base64.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/collections/Bag.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/collections/Item.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/collections/Queue.java
 create mode 100644 src/main/java/dk/xpreuss/xperimentering/collections/Stack.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AVLTreeST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Accumulator.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AcyclicLP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AcyclicSP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AdjMatrixEdgeWeightedDigraph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AllowFilter.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Allowlist.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Alphabet.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AmericanFlag.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AmericanFlagX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Arbitrage.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/AssignmentProblem.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Average.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BTree.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Bag.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BellmanFordSP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinaryDump.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinaryIn.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinaryInsertion.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinaryOut.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinarySearch.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinarySearchST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinaryStdIn.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinaryStdOut.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BinomialMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Bipartite.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BipartiteMatching.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BipartiteX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BlockFilter.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BoruvkaMST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BoyerMoore.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BreadthFirstDirectedPaths.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/BreadthFirstPaths.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/CC.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/CPM.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Cat.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ClosestPair.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/CollisionSystem.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Complex.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Count.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Counter.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Cycle.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Date.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DeDup.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DegreesOfSeparation.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DepthFirstDirectedPaths.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DepthFirstOrder.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DepthFirstPaths.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DepthFirstSearch.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Digraph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DigraphGenerator.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DijkstraAllPairsSP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DijkstraSP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DijkstraUndirectedSP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DirectedCycle.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DirectedCycleX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DirectedDFS.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DirectedEdge.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DirectedEulerianCycle.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DirectedEulerianPath.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DoublingRatio.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DoublingTest.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Draw.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/DrawListener.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Edge.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/EdgeWeightedDigraph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/EdgeWeightedDirectedCycle.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/EdgeWeightedGraph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/EulerianCycle.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/EulerianPath.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FFT.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FarthestPair.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FenwickTree.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FibonacciMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FileIndex.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FlowEdge.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FlowNetwork.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FloydWarshall.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FordFulkerson.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/FrequencyCounter.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GREP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GabowSCC.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GaussJordanElimination.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GaussianElimination.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Genome.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GlobalMincut.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GrahamScan.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Graph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GraphGenerator.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/GrayscalePicture.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Heap.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/HexDump.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/HopcroftKarp.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Huffman.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/In.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/InTest.txt
 create mode 100644 src/main/java/edu/princeton/cs/algs4/IndexBinomialMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/IndexFibonacciMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/IndexMaxPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/IndexMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/IndexMultiwayMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/InplaceMSD.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Insertion.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/InsertionX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Interval1D.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Interval2D.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Inversions.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/KMP.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/KWIK.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Knuth.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/KosarajuSharirSCC.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/KruskalMST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LSD.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LZW.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LazyPrimMST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LinearProbingHashST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LinearProgramming.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LinearRegression.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LinkedBag.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LinkedQueue.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LinkedStack.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LongestCommonSubstring.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LongestRepeatedSubstring.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LookupCSV.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/LookupIndex.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/MSD.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/MaxPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Merge.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/MergeBU.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/MergeX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/MinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Multiway.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/MultiwayMinPQ.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/NFA.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/NonrecursiveDFS.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/NonrecursiveDirectedDFS.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Out.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Particle.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/PatriciaSET.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/PatriciaST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Picture.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/PictureDump.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/PlayMusic.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Point2D.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Polynomial.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/PrimMST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Queue.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Quick.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Quick3string.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Quick3way.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/QuickBentleyMcIlroy.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/QuickFindUF.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/QuickUnionUF.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/QuickX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/RabinKarp.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/RandomSeq.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/RectHV.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/RedBlackBST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ResizingArrayBag.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ResizingArrayQueue.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ResizingArrayStack.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/RunLength.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SET.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SegmentTree.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Selection.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SeparateChainingHashST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SequentialSearchST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Shell.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SparseVector.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Stack.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StaticSETofInts.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdArrayIO.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdAudio.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdDraw.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdIn.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdInTest.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdOut.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdRandom.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StdStats.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Stopwatch.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/StopwatchCPU.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SuffixArray.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SuffixArrayX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SymbolDigraph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/SymbolGraph.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TarjanSCC.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TestIntroCS.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ThreeSum.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/ThreeSumFast.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TopM.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Topological.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TopologicalX.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Transaction.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TransitiveClosure.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TrieSET.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TrieST.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/TwoPersonZeroSumGame.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/UF.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/UnicodeTest.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/Vector.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/WeightedQuickUnionUF.java
 create mode 100644 src/main/java/edu/princeton/cs/algs4/mandrill.jpg
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64Charset.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64CharsetDecoder.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64CharsetEncoder.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64CharsetProvider.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64Exception.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64InputStream.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64NIODecoder.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64OutputStream.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64StreamDecoder.java
 create mode 100644 src/main/java/net/jhorstmann/base64/Base64StreamEncoder.java
 create mode 100644 src/main/java/net/jhorstmann/base64/BufferedByteAppendable.java
 create mode 100644 src/main/java/net/jhorstmann/base64/ByteAppendable.java
 create mode 100644 src/main/java/net/jhorstmann/base64/FixedSizeStringBuilder.java
 create mode 100644 src/main/java/net/jhorstmann/base64/IncompleteStreamException.java
 create mode 100644 src/main/java/net/jhorstmann/base64/InvalidCharacterException.java
 create mode 100644 src/main/java/se/nowise/codecs/base64/Base64Application.java
 create mode 100644 src/main/java/se/nowise/codecs/base64/Base64Decoder.java
 create mode 100644 src/main/java/se/nowise/codecs/base64/Base64Encoder.java
 create mode 100644 src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider
 create mode 100644 src/test/java/dk/xpreuss/xperimentering/basex/coders/EncodingTest.java
 create mode 100644 src/test/java/net/jhorstmann/base64/Base64Encoder.java
 create mode 100644 src/test/java/net/jhorstmann/base64/Base64InputStreamTest.java
 create mode 100644 src/test/java/net/jhorstmann/base64/Base64Test.java
 create mode 100644 src/test/java/net/jhorstmann/base64/CharsetTest.java
 create mode 100644 src/test/java/net/jhorstmann/base64/Main.java
 create mode 100644 src/test/java/se/nowise/codecs/base64/Base64DecoderTest.java
 create mode 100644 src/test/java/se/nowise/codecs/base64/Base64EncoderTest.java

diff --git a/.gitignore b/.gitignore
index a1fc39c..629b6a9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,10 @@
+### Intellij Idea Ignores
+.idea
+
+### Gradle Ignores
 .gradle
-/build/
+**/build/
+!src/**/build/
 
 # Ignore Gradle GUI config
 gradle-app.setting
@@ -12,3 +17,16 @@ gradle-app.setting
 
 # # Work around https://youtrack.jetbrains.com/issue/IDEA-116898
 # gradle/wrapper/gradle-wrapper.properties
+
+### Maven Ignores
+target/
+pom.xml.tag
+pom.xml.releaseBackup
+pom.xml.versionsBackup
+pom.xml.next
+release.properties
+dependency-reduced-pom.xml
+buildNumber.properties
+.mvn/timing.properties
+# https://github.com/takari/maven-wrapper#usage-without-binary-jar
+.mvn/wrapper/maven-wrapper.jar
\ No newline at end of file
diff --git a/UseUnicode.txt b/UseUnicode.txt
new file mode 100644
index 0000000..c15cb91
--- /dev/null
+++ b/UseUnicode.txt
@@ -0,0 +1,70 @@
+Milj√∏variabler:
+	DEFAULT_JVM_OPTIONS="-Dfile.encoding=UTF-8"
+	
+
+Defines Java encoding:
+	This defines what encoding java is using:
+		-Dfile.encoding=UTF-8
+	This defines property to specify the code page to use for output from the java or javaw command. 
+		-Dconsole.encoding=Cp1252
+		
+		-Dconsole.encoding=UTF-8
+	
+	This is a very used codepage:
+		UTF-8
+		CP1252
+		ISO-8859-1
+	
+Command Line Prompt DOS:
+	Unicode:
+		chcp 65001
+	
+	Windows Default:
+		chcp cp1252
+	
+	To make default change RegEx:
+		[HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\Autorun]
+			chcp 65001
+	
+	This is the fallback
+		[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage]
+			oemcp 65001
+		
+		The default is 
+			oemcp 850
+
+
+For Gradle:
+===============
+Don't know if this changes anything inside gradle.properties:
+---------------------------------------------------------------
+xorg.gradle.jvmargs=-Dconsole.encoding=UTF-8 -Dfile.encoding=UTF-8
+
+
+Remember gradle.properties
+----------------------------
+	systemProp.file.encoding=UTF-8
+
+
+Inside build.gradle before repositories
+-----------------------------------------
+/**
+ * 1st approach: Setting encoding during compilation in Java and Test classes
+ */
+compileJava.options.encoding = "UTF-8"
+compileTestJava.options.encoding = "UTF-8"
+javadoc.options.encoding = 'UTF-8'
+
+/**
+ * 2nd approach: Setting encoding during compilation in Java and Test classes
+ *
+tasks.withType(JavaCompile) {
+	options.encoding = "UTF-8"
+}
+tasks.withType(Test) {
+	systemProperty "file.encoding", "UTF-8"
+}
+tasks.withType(Javadoc) {
+	options.encoding = 'UTF-8'
+}
+ */
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000..7de6345
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,70 @@
+plugins {
+	id 'java'
+	id 'application'
+	id 'io.freefair.lombok' version '6.0.0-m2' // You don't need manual dependencies.
+}
+
+group 'dk.xpreuss.xperimentering'
+version '0.1.0-SNAPSHOT'
+
+application {
+	applicationDefaultJvmArgs = ["--add-opens", "--add-opens=java.base/jdk.internal.misc=ALL-UNNAMED"]
+}
+
+/**
+ * 1st approach: Setting encoding during compilation in Java and Test classes
+ */
+compileJava.options.encoding = "UTF-8"
+compileTestJava.options.encoding = "UTF-8"
+javadoc.options.encoding = 'UTF-8'
+
+/**
+ * 2nd approach: Setting encoding during compilation in Java and Test classes
+ *
+tasks.withType(JavaCompile) {
+	options.encoding = "UTF-8"
+}
+tasks.withType(Test) {
+	systemProperty "file.encoding", "UTF-8"
+}
+tasks.withType(Javadoc) {
+	options.encoding = 'UTF-8'
+}
+ */
+
+repositories {
+	mavenCentral()
+}
+
+
+mainClassName = "dk.xpreuss.xperimentering.Main"
+
+dependencies {
+	implementation 'io.reactivex.rxjava3:rxjava:3.0.13-RC4'
+	implementation 'com.ibm.icu:icu4j:69.1'
+	implementation 'net.time4j:time4j-base:5.8'
+	implementation 'net.time4j:time4j-tzdata:5.0-2021a'
+	implementation 'net.time4j:time4j-sqlxml:5.8'
+	implementation 'net.time4j:time4j-ui:5.8'
+
+//	compileOnly 'org.projectlombok:lombok:1.18.20'
+//	annotationProcessor 'org.projectlombok:lombok:1.18.20'
+//
+//	testCompileOnly 'org.projectlombok:lombok:1.18.20'
+//	testAnnotationProcessor 'org.projectlombok:lombok:1.18.20'
+
+	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
+	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
+}
+
+test {
+	useJUnitPlatform()
+}
+
+println "GRADLE_OPTS: " + System.getenv("GRADLE_OPTS")
+println "File encoding: " + System.getProperty("file.encoding")
+println "file.encoding sys property = " + System.properties["file.encoding"]
+println "GRADLE_OPTS env variable = " + System.getenv("GRADLE_OPTS")
+println "JAVA_TOOL_OPTIONS env variable = " + System.getenv("JAVA_TOOL_OPTIONS")
+println "UTF-8 test: ‚Üì"
+
diff --git a/docs/AUTHORS b/docs/AUTHORS
new file mode 100644
index 0000000..38371bd
--- /dev/null
+++ b/docs/AUTHORS
@@ -0,0 +1,4 @@
+Anders L√∂vgren <lespaul@algonet.se>         // obsolete
+Anders L√∂vgren <anders.lovgren@bmc.uu.se>   // obsolete
+
+Anders L√∂vgren <andlov@nowise.se>
diff --git a/docs/COPYING b/docs/COPYING
new file mode 100644
index 0000000..ea5b606
--- /dev/null
+++ b/docs/COPYING
@@ -0,0 +1 @@
+../LICENSE
\ No newline at end of file
diff --git a/docs/COPYING.CLASSPATH b/docs/COPYING.CLASSPATH
new file mode 100644
index 0000000..f941d8a
--- /dev/null
+++ b/docs/COPYING.CLASSPATH
@@ -0,0 +1,26 @@
+The Base64Code library is distributed under the terms of the GNU General Public 
+License with the following clarification and special exception. 
+
+See http://www.gnu.org/software/classpath/license.html for further details.
+
+GNU Classpath Exception:
+-----------------------------------------------------
+
+Linking this library statically or dynamically with other modules is making
+a combined work based on this library. Thus, the terms and conditions of the
+GNU General Public License cover the whole combination.  
+
+ As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent modules,
+and to copy and distribute the resulting executable under terms of your
+choice, provided that you also meet, for each linked independent module, the
+terms and conditions of the license of that module. An independent module is
+a module which is not derived from or based on this library. If you modify
+this library, you may extend this exception to your version of the library,
+but you are not obligated to do so. If you do not wish to do so, delete this
+exception statement from your version.  
+
+-----------------------------------------------------
+
+// Anders L√∂vgren, 2009-03-30
diff --git a/docs/README b/docs/README
new file mode 100644
index 0000000..7b9f488
--- /dev/null
+++ b/docs/README
@@ -0,0 +1,51 @@
+
+   Base64Code - Base64 Encoder/Decoder Java Library
+
+
+** INTRODUCTION:
+
+   This Java (tm) library implements Base64 encoding and decoding. It was
+   written because I couldn't find anything like it in the JDK except for an
+   internal class in com.sun.*, and using classes from this package is
+   totally unsupported by Sun.
+
+** DIFFERENCES:
+
+   Whats differs this library from most others are:
+   
+     1. It supports encoding and decoding of input streams in chunk mode.
+     2. The size of the internal allocated input buffer can be restricted.
+     
+   When encoding or decoding an string or byte array only the result buffer
+   gets allocated, the source is used as input buffer.
+   
+** SPECIFICATION:
+
+   This implementation is based on http://en.wikipedia.org/wiki/Base64 and 
+   RFC 2045 (section 6.8). However, support for the line break mode in 76 
+   character blocks mentioned in the RFC are not supported, mostly because 
+   I don't have any use of it.
+   
+   The library has been verified to produce the same result as other commonly 
+   used implementations, among them:
+   
+     *) The base64_encode() and base64_decode() functions in PHP.
+     *) The base64 command from GNU coreutils.
+
+** LICENSE:
+
+   The Base64Code Java Library is licensed under GPL with the classpath 
+   exception. This means that you are free to use this library even in 
+   commercial applications (closed source), see the files COPYING and
+   COPYING.CLASSPATH for details.
+   
+   The license gives you permission to (freely) link to and use this library
+   in unmodified form. If you use (copy) source code from this library to
+   your application, then the you have to release your work as open source 
+   as well.
+      
+** COPYRIGHT:
+
+   This library is Copyright (C) 2009 by Anders L√∂vgren.
+   
+// Anders L√∂vgren, 2009-05-27
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 0000000..4f94d5c
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1 @@
+systemProp.file.encoding=UTF-8
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000000000000000000000000000000000..e708b1c023ec8b20f512888fe07c5bd3ff77bb8f
GIT binary patch
literal 59203
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
E2O(~oYXATM

literal 0
HcmV?d00001

diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..29e4134
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-7.0.2-all.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
new file mode 100644
index 0000000..4f906e0
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,185 @@
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=`expr $i + 1`
+    done
+    case $i in
+        0) set -- ;;
+        1) set -- "$args0" ;;
+        2) set -- "$args0" "$args1" ;;
+        3) set -- "$args0" "$args1" "$args2" ;;
+        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=`save "$@"`
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000..107acd3
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,89 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000..18243d2
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+rootProject.name = 'xperimentering'
+
diff --git a/src/main/java/dk/xpreuss/utils/StandardOutput.java b/src/main/java/dk/xpreuss/utils/StandardOutput.java
new file mode 100644
index 0000000..ec5d0b6
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/StandardOutput.java
@@ -0,0 +1,38 @@
+package dk.xpreuss.utils;
+
+import java.util.Locale;
+import java.util.MissingResourceException;
+
+public class StandardOutput {
+	private static final Locale DANISH_LOCALE = Locale.forLanguageTag("da-Latn-DK");
+	private static final String DEFAULT_CHARSET_NAME = "UTF-8";
+	private static final Locale DEFAULT_LOCALE = Locale.ITALY;
+
+	public static void main(String[] args) {
+		printLocale(DANISH_LOCALE);
+	}
+
+	public static void printLocale(Locale locale) {
+		System.out.println("--- Printing Locale ---");
+		System.out.println("ToString === " + locale);
+		System.out.println("Country: " + locale.getCountry());
+		System.out.println("Language: " + locale.getLanguage());
+		System.out.println("Variant: " + locale.getVariant());
+		System.out.println("Script: " + locale.getScript());
+		try {
+			System.out.println("ISO3 Country: " + locale.getISO3Country());
+		} catch (MissingResourceException e) {
+			System.out.println("ISO3 Country: === No ISO3 COUNTRY ===");
+		}
+		System.out.println("ISO3 Language: " + locale.getISO3Language());
+		System.out.println("Display Country: " + locale.getDisplayCountry());
+		System.out.println("Display Language: " + locale.getDisplayLanguage());
+		System.out.println("Display Variant: " + locale.getDisplayVariant());
+		System.out.println("Display Name: " + locale.getDisplayName());
+		System.out.println("Display Script: " + locale.getDisplayScript());
+		System.out.println("Has Extension ? " + (locale.hasExtensions() ? "YES" : "NO"));
+
+
+		System.out.println("--- Ending Printing Locale ---");
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/Test.java b/src/main/java/dk/xpreuss/utils/Test.java
new file mode 100644
index 0000000..d876eb3
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/Test.java
@@ -0,0 +1,59 @@
+package dk.xpreuss.utils;
+
+import com.ibm.icu.util.ULocale;
+import dk.xpreuss.utils.locales.NumberHelper;
+import dk.xpreuss.utils.locales.LocaleCalendarExtensions;
+import dk.xpreuss.utils.locales.LocaleNumberExtensions;
+
+import java.util.Date;
+import java.util.Locale;
+
+public class Test {
+	public static void main(String[] args) {
+
+		Locale locale = Locale.forLanguageTag(LocaleNumberExtensions.DK.getValue());
+		System.out.println(locale);
+
+		String x = NumberHelper.convertDate(LocaleCalendarExtensions.DK.toString(), new Date(), "HH:mm");
+		System.out.println("X: " + x);
+
+		String num = NumberHelper.convertNumber(LocaleCalendarExtensions.DK.name(), 44455.44);
+		System.out.println("Num: " + num);
+
+		System.out.println("Locale bulgarien bg: " + Locale.forLanguageTag("bg"));
+		Locale[] availableLocales = Locale.getAvailableLocales();
+		for (int i = 0; i < availableLocales.length; i++) {
+			Locale availableLocale = availableLocales[i];
+			//System.out.println(availableLocale);
+		}
+		StandardOutput.printLocale(Locale.forLanguageTag("bg-Cyrl-BG"));
+		System.out.println(ULocale.forLanguageTag("bg-Cyrl-BG"));
+		ULocale uLocale = ULocale.forLanguageTag("bg-Cyrl-BG");
+		ULocale uLocale1 = ULocale.acceptLanguage("bg,da", null);
+		System.out.println("Ulocale 1: " + uLocale1);
+		uLocale1 = ULocale.forLocale(Locale.forLanguageTag("bg-Cyrl-BG"));
+		System.out.println("Ulocale 1: " + uLocale1);
+
+		System.out.println(": " + ULocale.forLanguageTag("ar_SA@calendar=islamic"));
+		uLocale1 = new ULocale("ar_SA@calendar=islamic");
+		System.out.println(" : " + uLocale1);
+		System.out.println(new ULocale(LocaleNumberExtensions.DK.getValue()));
+		System.out.println(new Locale(LocaleNumberExtensions.DK.getValue()));
+		System.out.println(new Locale("da-DK-u-ca-islamic"));
+		System.out.println(new ULocale("da-DK-u-ca-islamic"));
+		Locale[] locales = Locale.getAvailableLocales();
+		for (int i = 0; i < locales.length; i++) {
+			Locale locale1 = locales[i];
+			if (locale1.getScript() != null && !locale1.getScript().equals("")) {
+				StandardOutput.printLocale(locale1);
+			}
+		}
+
+		StandardOutput.printLocale(Locale.forLanguageTag(LocaleCalendarExtensions.DK.getValue()));
+		StandardOutput.printLocale(Locale.forLanguageTag(LocaleNumberExtensions.DK.getValue()));
+		StandardOutput.printLocale(Locale.forLanguageTag("da-DK-u-nu-latn-ca-latn"));
+		System.out.println(ULocale.forLanguageTag(LocaleCalendarExtensions.DK.getValue()));
+		System.out.println(ULocale.forLanguageTag(LocaleNumberExtensions.DK.getValue()));
+		System.out.println(ULocale.forLanguageTag("da-DK-u-nu-latn-ca-latn"));
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/locales/LocaleCalendarExtensions.java b/src/main/java/dk/xpreuss/utils/locales/LocaleCalendarExtensions.java
new file mode 100644
index 0000000..f6f0780
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/locales/LocaleCalendarExtensions.java
@@ -0,0 +1,108 @@
+package dk.xpreuss.utils.locales;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+
+public enum LocaleCalendarExtensions {
+	SA("ar-SA-u-ca-arab"),
+	AM("hy-AM-u-ca-arevmda"),
+	CN("zh-TW-u-ca-hant"),
+	CZ("cs-CZ-u-ca-latn"),
+	DK("da-DK-u-ca-latn"),
+	NL("nl-NL-u-ca-latn"),
+	IE("ie-IE-u-ca-latn"),
+	FR("fr-FR-u-ca-latn"),
+	DE("de-DE-u-ca-latn"),
+	GR("el-GR-u-ca-grek"),
+	IL("iw-IL-u-ca-hebr"),
+	IN("hi-IN-u-ca-hindu"),
+	IT("it-IT-u-ca-latn"),
+	JP("ja-JP-u-ca-jpan"),
+	NO("nb-NO-u-ca-latn"),
+	IR(""), //"fa-IR-u-ca-fars"),
+	PL("pl-PL-u-ca-latn"),
+	PT("pt-PT-u-ca-latn"),
+	RU("ru-RU-u-ca-cyrl"),
+	ES("es-ES-u-ca-latn"),
+	SE("sv-SE-u-ca-latn"),
+	TH("th-TH-u-ca-thai"),
+	TR("tr-TR-u-ca-latn"),
+	PK(""),//"ur-PK-u-ca-arab"),
+	VN("vi-VN-u-ca-latn");
+
+	String value;
+
+	LocaleCalendarExtensions(String val) {
+		this.value = val;
+	}
+
+	public String getValue() {
+		return value;
+	}
+
+	static LocaleCalendarExtensions byValue(String val) {
+		return Arrays.stream(values()).filter(v -> v.value.equals(val)).findFirst().orElse(null);
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getArabicSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(SA);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getJapanSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(JP);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getChinaSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getFarsiSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+
+		retVal.add(IR);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getUrduSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(PK);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getAsianSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(JP);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getHebrewSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(IL);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getHinduSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(IN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getThaiSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(TH);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleCalendarExtensions> getGreekSupport() {
+		final EnumSet<LocaleCalendarExtensions> retVal = EnumSet.noneOf(LocaleCalendarExtensions.class);
+		retVal.add(GR);
+		return retVal;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/utils/locales/LocaleExtensions.java b/src/main/java/dk/xpreuss/utils/locales/LocaleExtensions.java
new file mode 100644
index 0000000..ba03767
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/locales/LocaleExtensions.java
@@ -0,0 +1,112 @@
+package dk.xpreuss.utils.locales;
+
+import com.ibm.icu.util.ULocale;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.Locale;
+
+public enum LocaleExtensions {
+	SA("ar-SA-u-ca-arab-nu-arab"),
+	AM("hy-AM-u-ca-arevmda-nu-arevmda"),
+	CN("zh-TW-u-ca-nu-arab"), //"zh-TW-u-nu-hant"
+	CZ("cs-CZ-u-ca-latn-nu-latn"),
+	DK("da-DK-u-ca-latn-nu-latn"),
+	NL("nl-NL-u-ca-latn-nu-latn"),
+	IE("ie-IE-u-ca-latn-nu-latn"),
+	FR("fr-FR-u-ca-latn-nu-latn"),
+	DE("de-DE-u-ca-latn-nu-latn"),
+	GR("el-GR-u-ca-latn-nu-grek"),
+	IL("iw-IL-u-ca-latn-nu-hebr"),
+	IN("hi-IN-u-ca-latn-nu-hindu"),
+	IT("it-IT-u-ca-latn-nu-latn"),
+	JP("ja-JP-u-ca-jpan-nu-arab"),
+	NO("nb-NO-u-ca-latn-nu-latn"),
+	IR("fa-IR-u-nu-arab"),
+	PL("pl-PL-u-ca-latn-nu-latn"),
+	PT("pt-PT-u-ca-latn-nu-latn"),
+	RU("ru-RU-u-ca-cyrl-nu-cyrl"),
+	ES("es-ES-u-ca-latn-nu-latn"),
+	SE("sv-SE-u-ca-latn-nu-latn"),
+	TH("th-TH-u-ca-thai-nu-thai"),
+	TR("tr-TR-u-ca-latn-nu-latn"),
+	PK("ur-PK-u-nu-arab"),
+	VN("vi-VN-u-ca-latn-nu-latn");
+
+	private final String value;
+	private final Locale locale;
+	private final ULocale uLocale;
+
+	LocaleExtensions(String ietfBcp47LanguageTag) {
+		this.value = ietfBcp47LanguageTag;
+		this.locale = Locale.forLanguageTag(ietfBcp47LanguageTag);
+		this.uLocale = ULocale.forLanguageTag(ietfBcp47LanguageTag);
+	}
+
+	public String getValue() {
+		return value;
+	}
+
+	public Locale getLocale() {
+		return locale;
+	}
+
+	public ULocale getULocale() {
+		return uLocale;
+	}
+
+	static LocaleExtensions byValue(String val) {
+		return Arrays.stream(values()).filter(v -> v.value.equals(val)).findFirst().orElse(null);
+	}
+
+	static LocaleExtensions byLang(String lang) {
+		return Arrays.stream(values()).filter(it -> it.value.substring(0, 2).equals(lang)).findAny().orElse(null);
+	}
+
+	public static EnumSet<LocaleExtensions> getArabicSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(SA);
+		//TODO
+		retVal.add(JP);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleExtensions> getFarsiSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(PK);
+		retVal.add(IR);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleExtensions> getAsianSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(JP);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleExtensions> getHebrewSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(IL);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleExtensions> getHinduSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(IN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleExtensions> getThaiSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(TH);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleExtensions> getGreekSupport() {
+		final EnumSet<LocaleExtensions> retVal = EnumSet.noneOf(LocaleExtensions.class);
+		retVal.add(GR);
+		return retVal;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/utils/locales/LocaleICUCalendarExtensions.java b/src/main/java/dk/xpreuss/utils/locales/LocaleICUCalendarExtensions.java
new file mode 100644
index 0000000..458fa53
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/locales/LocaleICUCalendarExtensions.java
@@ -0,0 +1,101 @@
+package dk.xpreuss.utils.locales;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+
+public enum LocaleICUCalendarExtensions {
+	SA("ar_SA@calendar=islamic"),
+	AM("hy_AM@calendar=armenian"),
+	CN("zh_Hans@calendar=chinese"),
+	CZ("cs_CZ@calendar=latin"),
+	DK("da_DK@calendar=latin"),
+	NL("nl_NL@calendar=latin"),
+	IE("ie_IE@calendar=latin"),
+	FR("fr_FR@calendar=latin"),
+	DE("de_DE@calendar=latin"),
+	GR("el_GR@calendar=greek"),
+	IL("iw_IL@calendar=hebrew"),
+	IN("hi_IN@calendar=hindu"),
+	IT("it_IT@calendar=Latin"),
+	JP("ja_JP_TRADITIONAL@calendar=japanese"),
+	NO("nb_NO@calendar=latin"),
+	IR("fa_IR@calendar=persian"),
+	PL("pl_PL@calendar=latin"),
+	PT("pt_PT@calendar=latin"),
+	RU("ru_RU@calendar=cyrillic"),
+	ES("es_ES@calendar=latin"),
+	SE("sv_SE@calendar=latin"),
+	TH("th_TH_TRADITIONAL@calendar=buddhist"),
+	TR("tr_TR@calendar=latin"),
+	PK("ur_PK@calendar=pakistan"),
+	VN("vi_VN@calendar=latin");
+
+	String value;
+
+	LocaleICUCalendarExtensions(String val) {
+		this.value = val;
+	}
+
+	public String getValue() {
+		return value;
+	}
+
+	static LocaleICUCalendarExtensions byValue(String val) {
+		return Arrays.stream(values()).filter(v -> v.value.equals(val)).findFirst().orElse(null);
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getArabicSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(SA);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getJapanSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(JP);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getChinaSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getFarsiSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+
+		retVal.add(IR);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getUrduSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(PK);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getHebrewSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(IL);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getHinduSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(IN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getThaiSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(TH);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleICUCalendarExtensions> getGreekSupport() {
+		final EnumSet<LocaleICUCalendarExtensions> retVal = EnumSet.noneOf(LocaleICUCalendarExtensions.class);
+		retVal.add(GR);
+		return retVal;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/utils/locales/LocaleNumberExtensions.java b/src/main/java/dk/xpreuss/utils/locales/LocaleNumberExtensions.java
new file mode 100644
index 0000000..fcd09f9
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/locales/LocaleNumberExtensions.java
@@ -0,0 +1,98 @@
+package dk.xpreuss.utils.locales;
+
+import java.util.Arrays;
+import java.util.EnumSet;
+import java.util.Locale;
+
+public enum LocaleNumberExtensions {
+	SA("ar-SA-u-nu-arab"),
+	AM("hy-AM-u-nu-arevmda"),
+	CN("zh-TW-u-nu-arab"), //"zh-TW-u-nu-hant"
+	CZ("cs-CZ-u-nu-latn"),
+	DK("da-DK-u-nu-latn"),
+	NL("nl-NL-u-nu-latn"),
+	IE("ie-IE-u-nu-latn"),
+	FR("fr-FR-u-nu-latn"),
+	DE("de-DE-u-nu-latn"),
+	GR("el-GR-u-nu-grek"),
+	IL("iw-IL-u-nu-hebr"),
+	IN("hi-IN-u-nu-hindu"),
+	IT("it-IT-u-nu-latn"),
+	JP("ja-JP-u-nu-arab"),
+	NO("nb-NO-u-nu-latn"),
+	IR("fa-IR-u-nu-arab"),
+	PL("pl-PL-u-nu-latn"),
+	PT("pt-PT-u-nu-latn"),
+	RU("ru-RU-u-nu-cyrl"),
+	ES("es-ES-u-nu-latn"),
+	SE("sv-SE-u-nu-latn"),
+	TH("th-TH-u-nu-thai"),
+	TR("tr-TR-u-nu-latn"),
+	PK("ur-PK-u-nu-arab"),
+	VN("vi-VN-u-nu-latn");
+
+	String value;
+
+	LocaleNumberExtensions(String val) {
+		this.value = val;
+	}
+
+	public String getValue() {
+		return value;
+	}
+
+	static LocaleNumberExtensions byValue(String val) {
+		return Arrays.stream(values()).filter(v -> v.value.equals(val)).findFirst().orElse(null);
+	}
+
+	static LocaleNumberExtensions byLang(String lang) {
+		return Arrays.stream(values()).filter(it -> it.value.substring(0, 2).equals(lang)).findAny().orElse(null);
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getArabicSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(SA);
+		//TODO
+		retVal.add(JP);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getFarsiSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(PK);
+		retVal.add(IR);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getAsianSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(JP);
+		retVal.add(CN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getHebrewSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(IL);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getHinduSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(IN);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getThaiSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(TH);
+		return retVal;
+	}
+
+	public static EnumSet<LocaleNumberExtensions> getGreekSupport() {
+		final EnumSet<LocaleNumberExtensions> retVal = EnumSet.noneOf(LocaleNumberExtensions.class);
+		retVal.add(GR);
+		return retVal;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/utils/locales/LocaleUtil.java b/src/main/java/dk/xpreuss/utils/locales/LocaleUtil.java
new file mode 100644
index 0000000..112c5b2
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/locales/LocaleUtil.java
@@ -0,0 +1,11 @@
+package dk.xpreuss.utils.locales;
+
+import com.ibm.icu.util.ULocale;
+
+import java.util.Locale;
+
+public class LocaleUtil {
+	public static final Locale DK_LOCALE = LocaleExtensions.DK.getLocale();
+	public static final ULocale DK_ULOCALE = LocaleExtensions.DK.getULocale();
+
+}
diff --git a/src/main/java/dk/xpreuss/utils/locales/NumberHelper.java b/src/main/java/dk/xpreuss/utils/locales/NumberHelper.java
new file mode 100644
index 0000000..9482278
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/locales/NumberHelper.java
@@ -0,0 +1,125 @@
+package dk.xpreuss.utils.locales;
+
+import com.ibm.icu.text.DateFormat;
+import com.ibm.icu.text.DecimalFormatSymbols;
+import com.ibm.icu.text.NumberFormat;
+
+import java.util.Arrays;
+import java.util.Locale;
+
+/**
+ * See https://stackoverflow.com/questions/43456068/java-locale-builder-setextensionlocale-unicode-locale-extension
+ */
+public class NumberHelper {
+	/**
+	 * @param country where lang code provider is ar en cn fr ur it is as per LocaleCalendarExtensions Enum main declarations
+	 * @param date    given date
+	 * @param format  definition in which case I have clause to deal with HH:mm and so on just read through below code
+	 * @return
+	 */
+	public static String convertDate(String country, java.util.Date date, String format) {
+		StringBuilder output = new StringBuilder();
+		if (country != null && date != null) {
+
+			var found = Arrays.stream(LocaleICUCalendarExtensions.values()).anyMatch(it -> it.name().equals(country));
+			if (found) {
+				var found1 = LocaleNumberExtensions.valueOf(country);
+				com.ibm.icu.util.ULocale locale = new com.ibm.icu.util.ULocale(found1.value);
+				com.ibm.icu.util.Calendar calendar = com.ibm.icu.util.Calendar.getInstance(locale);
+				calendar.setTime(date);
+				com.ibm.icu.text.DateFormat df;
+				if (format.equals("HH:mm")) {
+					df = com.ibm.icu.text.DateFormat.getPatternInstance(com.ibm.icu.text.DateFormat.HOUR_MINUTE, locale);
+				} else {
+					if (format.equals("dd MMM yyyy HH:mm:ss")) {
+						df = com.ibm.icu.text.DateFormat.getDateInstance(DateFormat.FULL, locale);
+					} else if (format.equals("dd MMM")) {
+						df = com.ibm.icu.text.DateFormat.getPatternInstance(com.ibm.icu.text.DateFormat.ABBR_MONTH_DAY, locale);
+					} else {
+						df = com.ibm.icu.text.DateFormat.getDateInstance(DateFormat.LONG, locale);
+					}
+				}
+				output.append(df.format(calendar));
+			}
+		}
+		return output.toString();
+	}
+
+	/**
+	 * Converts number to given locale
+	 *
+	 * @param country
+	 * @param number
+	 * @return
+	 */
+	public static String convertNumber(String country, Number number) {
+		String output = null;
+		if (country != null) {
+			var found = Arrays.stream(LocaleNumberExtensions.values()).filter(it -> it.name().equals(country)).findFirst();
+			var locale = found.map(it -> new Locale.Builder().setLanguageTag(it.value).build());
+
+			boolean arabic = LocaleCalendarExtensions.getArabicSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean china = LocaleCalendarExtensions.getChinaSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean japan = LocaleCalendarExtensions.getJapanSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean farsi = LocaleCalendarExtensions.getFarsiSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean urdu = LocaleCalendarExtensions.getUrduSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean hebrew = LocaleCalendarExtensions.getHebrewSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean greek = LocaleCalendarExtensions.getGreekSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean hindu = LocaleCalendarExtensions.getHinduSupport().stream().anyMatch(x -> x.name().equals(country));
+			boolean thai = LocaleCalendarExtensions.getThaiSupport().stream().anyMatch(x -> x.name().equals(country));
+
+			if (arabic || hindu | thai || farsi || urdu) {
+				if (found.isPresent()) {
+					//Locale locale = new Locale.Builder().setLanguageTag(found.get().value).build();
+					DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(locale.get());
+					NumberFormat numberFormat = NumberFormat.getNumberInstance(locale.get());
+					Number numbers;
+					if (number.toString().indexOf('.') > -1) {
+						numbers = number.doubleValue();
+					} else {
+						numbers = number.longValue();
+					}
+					output = numberFormat != null ? numberFormat.format(numbers) : "";
+				}
+			} else if (japan | china || hebrew || greek) {
+				// to extend look up types here
+				//http://www.atetric.com/atetric/javadoc/com.ibm.icu/icu4j/49.1/src-html/com/ibm/icu/util/ULocale.html
+				//http://icu-project.org/~yoshito/jacoco_57.1/com.ibm.icu.util/ULocale.java.html
+				com.ibm.icu.util.ULocale uLocale = null;
+
+				if (japan) {
+					uLocale = new com.ibm.icu.util.ULocale("ja_JP_JP");//ja_JP_JP  //
+				}
+				if (china) {
+					uLocale = new com.ibm.icu.util.ULocale("zh_Hans");//zh_CN_TRADITIONAL@collation=pinyin;
+				}
+				if (hebrew) {
+					uLocale = new com.ibm.icu.util.ULocale("he_IL");
+
+				}
+				if (greek) {
+					uLocale = new com.ibm.icu.util.ULocale("el_GR");
+				}
+				com.ibm.icu.text.NumberFormat nf = com.ibm.icu.text.NumberFormat.getInstance(uLocale);
+				Number numbers;
+				if (number.toString().indexOf('.') > -1) {
+					numbers = number.doubleValue();
+				} else {
+					numbers = number.longValue();
+				}
+				output = nf.format(numbers);
+			} else if (found.isPresent()) {
+				DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(locale.get());
+				NumberFormat numberFormat = NumberFormat.getNumberInstance(locale.get());
+				Number numbers;
+				if (number.toString().indexOf('.') > -1) {
+					numbers = number.doubleValue();
+				} else {
+					numbers = number.longValue();
+				}
+				output = numberFormat != null ? numberFormat.format(numbers) : "";
+			}
+		}
+		return output != null ? output : number.toString();
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/Algs4Stopwatch.java b/src/main/java/dk/xpreuss/utils/timers/Algs4Stopwatch.java
new file mode 100644
index 0000000..ce136e8
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/Algs4Stopwatch.java
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *  Compilation:  javac Stopwatch.java
+ *  Execution:    java Stopwatch n
+ *  Dependencies: none
+ *
+ *  A utility class to measure the running time (wall clock) of a program.
+ *
+ *  % java8 Stopwatch 100000000
+ *  6.666667e+11  0.5820 seconds
+ *  6.666667e+11  8.4530 seconds
+ *
+ ******************************************************************************/
+
+package dk.xpreuss.utils.timers;
+
+import edu.princeton.cs.algs4.StdOut;
+
+/**
+ * The {@code Stopwatch} data type is for measuring
+ * the time that elapses between the start and end of a
+ * programming task (wall-clock time).
+ * <p>
+ * See {@link Algs4StopwatchCPU} for a version that measures CPU time.
+ * For additional documentation,
+ * see <a href="https://algs4.cs.princeton.edu/14analysis">Section 1.4</a> of
+ * <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ * @author Robert Sedgewick
+ * @author Kevin Wayne
+ */
+
+
+public class Algs4Stopwatch {
+
+	private final long start;
+
+	/**
+	 * Initializes a new stopwatch.
+	 */
+	public Algs4Stopwatch() {
+		start = System.currentTimeMillis();
+	}
+
+
+	/**
+	 * Returns the elapsed CPU time (in seconds) since the stopwatch was created.
+	 *
+	 * @return elapsed CPU time (in seconds) since the stopwatch was created
+	 */
+	public double elapsedTime() {
+		long now = System.currentTimeMillis();
+		return (now - start) / 1000.0;
+	}
+
+
+	/**
+	 * Unit tests the {@code Stopwatch} data type.
+	 * Takes a command-line argument {@code n} and computes the
+	 * sum of the square roots of the first {@code n} positive integers,
+	 * first using {@code Math.sqrt()}, then using {@code Math.pow()}.
+	 * It prints to standard output the sum and the amount of time to
+	 * compute the sum. Note that the discrete sum can be approximated by
+	 * an integral - the sum should be approximately 2/3 * (n^(3/2) - 1).
+	 *
+	 * @param args the command-line arguments
+	 */
+	public static void main(String[] args) {
+		int n = Integer.parseInt(args[0]);
+
+		// sum of square roots of integers from 1 to n using Math.sqrt(x).
+		Algs4Stopwatch timer1 = new Algs4Stopwatch();
+		double sum1 = 0.0;
+		for (int i = 1; i <= n; i++) {
+			sum1 += Math.sqrt(i);
+		}
+		double time1 = timer1.elapsedTime();
+		StdOut.printf("%e (%.2f seconds)\n", sum1, time1);
+
+		// sum of square roots of integers from 1 to n using Math.pow(x, 0.5).
+		Algs4Stopwatch timer2 = new Algs4Stopwatch();
+		double sum2 = 0.0;
+		for (int i = 1; i <= n; i++) {
+			sum2 += Math.pow(i, 0.5);
+		}
+		double time2 = timer2.elapsedTime();
+		StdOut.printf("%e (%.2f seconds)\n", sum2, time2);
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/Algs4StopwatchCPU.java b/src/main/java/dk/xpreuss/utils/timers/Algs4StopwatchCPU.java
new file mode 100644
index 0000000..28ca7ca
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/Algs4StopwatchCPU.java
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *  Compilation:  javac StopwatchCPU.java
+ *  Execution:    java StopwtachCPU n
+ *  Dependencies: none
+ *
+ *  A version of Stopwatch.java that measures CPU time on a single
+ *  core or processor (instead of wall clock time).
+ *
+ *  % java8 StopwatchCPU 100000000
+ *  6.666667e+11 (1.05 seconds)
+ *  6.666667e+11 (7.50 seconds)
+ *
+ ******************************************************************************/
+
+package dk.xpreuss.utils.timers;
+
+import edu.princeton.cs.algs4.StdOut;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+
+/**
+ * The {@code StopwatchCPU} data type is for measuring
+ * the CPU time used during a programming task.
+ * <p>
+ * See {@link Algs4Stopwatch} for a version that measures wall-clock time
+ * (the real time that elapses).
+ *
+ * @author Josh Hug
+ * @author Robert Sedgewick
+ * @author Kevin Wayne
+ */
+
+public class Algs4StopwatchCPU {
+	private static final double NANOSECONDS_PER_SECOND = 1_000_000_000;
+
+	private final ThreadMXBean threadTimer;
+	private final long start;
+
+	/**
+	 * Initializes a new stopwatch.
+	 */
+	public Algs4StopwatchCPU() {
+		threadTimer = ManagementFactory.getThreadMXBean();
+		start = threadTimer.getCurrentThreadCpuTime();
+	}
+
+	/**
+	 * Returns the elapsed CPU time (in seconds) since the stopwatch was created.
+	 *
+	 * @return elapsed CPU time (in seconds) since the stopwatch was created
+	 */
+	public double elapsedTime() {
+		long now = threadTimer.getCurrentThreadCpuTime();
+		return (now - start) / NANOSECONDS_PER_SECOND;
+	}
+
+	/**
+	 * Unit tests the {@code StopwatchCPU} data type.
+	 * Takes a command-line argument {@code n} and computes the
+	 * sum of the square roots of the first {@code n} positive integers,
+	 * first using {@code Math.sqrt()}, then using {@code Math.pow()}.
+	 * It prints to standard output the sum and the amount of time to
+	 * compute the sum. Note that the discrete sum can be approximated by
+	 * an integral - the sum should be approximately 2/3 * (n^(3/2) - 1).
+	 *
+	 * @param args the command-line arguments
+	 */
+	public static void main(String[] args) {
+		int n = Integer.parseInt(args[0]);
+
+		// sum of square roots of integers from 1 to n using Math.sqrt(x).
+		Algs4StopwatchCPU timer1 = new Algs4StopwatchCPU();
+		double sum1 = 0.0;
+		for (int i = 1; i <= n; i++) {
+			sum1 += Math.sqrt(i);
+		}
+		double time1 = timer1.elapsedTime();
+		StdOut.printf("%e (%.2f seconds)\n", sum1, time1);
+
+		// sum of square roots of integers from 1 to n using Math.pow(x, 0.5).
+		Algs4StopwatchCPU timer2 = new Algs4StopwatchCPU();
+		double sum2 = 0.0;
+		for (int i = 1; i <= n; i++) {
+			sum2 += Math.pow(i, 0.5);
+		}
+		double time2 = timer2.elapsedTime();
+		StdOut.printf("%e (%.2f seconds)\n", sum2, time2);
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java b/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
new file mode 100644
index 0000000..793e843
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/IStopWatch.java
@@ -0,0 +1,33 @@
+package dk.xpreuss.utils.timers;
+
+import dk.xpreuss.utils.timers.clock.TimeSpan;
+import dk.xpreuss.utils.timers.clock.providers.ITickProvider;
+
+import java.util.List;
+
+/**
+ * SE https://github.com/maaza/Stopwatch/blob/master/edu/nyu/pqs/stopwatch/api/IStopwatch.java
+ * for id√©
+ */
+public interface IStopWatch {
+	//long getTicksInNanoseconds();
+	//long getElapsedTicksInNanoseconds();
+
+	String getName();
+	void start();
+	void stop();
+	void reset();
+	void restart();
+	void pause();
+	void resume();
+	TimeSpan lap();
+	ITickProvider getTickProvider();
+	TimeSpan elapsed();
+	long elapsedNanoseconds();
+	long elapsedMilliseconds();
+	double elapsedSeconds();
+	boolean isRunning();
+	boolean isPaused();
+	boolean isStopped();
+	List<TimeSpan> getTimeLaps();
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java b/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
new file mode 100644
index 0000000..2a3062c
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/MyStopWatchTest.java
@@ -0,0 +1,79 @@
+package dk.xpreuss.utils.timers;
+
+import dk.xpreuss.utils.timers.clock.TimeSpan;
+import dk.xpreuss.utils.timers.clock.providers.*;
+import net.time4j.CalendarUnit;
+import net.time4j.Duration;
+import net.time4j.Moment;
+import net.time4j.SystemClock;
+import net.time4j.base.ResourceLoader;
+import net.time4j.clock.AbstractClock;
+import net.time4j.clock.AdjustableClock;
+import net.time4j.scale.TickProvider;
+import net.time4j.scale.TimeScale;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+import java.time.Clock;
+import java.util.concurrent.TimeUnit;
+
+
+import lombok.NonNull;
+public class MyStopWatchTest {
+	public static void main(@NonNull String[] args) throws InterruptedException {
+		Thread.sleep(1_000L);
+
+
+		//StopWatch x = new StopWatch(new CpuTickProvider()) ;
+		//StopWatch x = new StopWatch(new MilliTickProvider()) ;
+		IStopWatch x = StopWatch.from(new NanoTickProvider()) ;
+		x.start();
+		x.lap();
+		Thread.sleep(1500L);
+		System.out.println("Lap ELAPSED: " + x.lap());
+		System.out.println("Lap ELAPSED: " + x.lap());
+		System.out.println("ELAPSED: " + x.elapsed());
+		System.out.println("ELAPSED: " + x.elapsed());
+		System.out.println("ELAPSED: " + x.elapsed());
+		System.out.println("Lap ELAPSED: " + x.lap());
+		Thread.sleep(2500L);
+		x.pause();
+		Thread.sleep(5000L);
+		//x.resume();
+		x.start();
+		System.out.println("Lap: " + x.lap());
+		Thread.sleep(5000L);
+		x.stop();
+		System.out.println(x.elapsed());
+
+		ITick tick1 = new MilliTickProvider().nextTick();
+		ITick tick2 = new MilliTickProvider().nextTick();
+		TimeSpan timeSpan = tick1.diff(tick2);
+
+		System.out.println(timeSpan);
+		timeSpan = x.elapsed();
+		long elapsedNanoseconds = x.elapsedNanoseconds();
+		long elapsedMilliseconds = x.elapsedMilliseconds();
+		double elapsedSeconds = x.elapsedSeconds();
+		System.out.println("Timespan: " + timeSpan);
+		System.out.println("elapsedNanoseconds = " + elapsedNanoseconds);
+		System.out.println("elapsedMilliseconds = " + elapsedMilliseconds);
+		System.out.println("elapsedSeconds = " + elapsedSeconds);
+
+		long start = System.nanoTime();
+		Thread.sleep(1200L);
+		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
+		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
+		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
+		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
+		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
+		System.out.println("ELAPSED: " +TimeUnit.NANOSECONDS.toMillis((System.nanoTime()-start)));
+		Thread.sleep(2500L);
+		long stop = System.nanoTime();
+		long timeInNano = stop-start;
+		System.out.println("timeInNano = " + timeInNano);
+		System.out.println("TimeUnit.NANOSECONDS.toMillis(timeInNano) = " + TimeUnit.NANOSECONDS.toMillis(timeInNano));
+		System.out.println("TimeUnit.NANOSECONDS.toMillis(timeInNano) = " + TimeUnit.NANOSECONDS.toMillis(timeInNano) /1000.0);
+	}
+}
+
diff --git a/src/main/java/dk/xpreuss/utils/timers/StopWatch.java b/src/main/java/dk/xpreuss/utils/timers/StopWatch.java
new file mode 100644
index 0000000..2d7b804
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/StopWatch.java
@@ -0,0 +1,221 @@
+package dk.xpreuss.utils.timers;
+
+import dk.xpreuss.utils.timers.clock.TimeSpan;
+import dk.xpreuss.utils.timers.clock.providers.ITick;
+import dk.xpreuss.utils.timers.clock.providers.ITickProvider;
+import dk.xpreuss.utils.timers.clock.providers.NanoTickProvider;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Stack;
+
+public class StopWatch implements IStopWatch {
+	public static final long NanosPerMillisecond = 1_000;
+	public static final long NanosPerSecond = NanosPerMillisecond * 1_000;
+
+	private final String name;
+
+	private final ITickProvider tickProvider;
+	private boolean isRunning;
+	private boolean isPaused;
+	private ITick startTick;
+	private TimeSpan elapsedNano;
+	private LinkedList<TimeSpan> laps;
+
+	protected StopWatch(String name, ITickProvider tickProvider) {
+		this.name = Objects.requireNonNull(name);
+		this.tickProvider = tickProvider;
+		reset();
+	}
+
+	public static IStopWatch from(String name, ITickProvider tickProvider) {
+		return new StopWatch(name, tickProvider);
+	}
+
+	public static IStopWatch from(ITickProvider tickProvider) {
+		return new StopWatch("", tickProvider);
+	}
+
+	public static IStopWatch from(String name) {
+		return new StopWatch(name, new NanoTickProvider());
+	}
+
+	/**
+	 * <p>Generates a count of nanoseconds. </p>
+	 *
+	 * @return count of nanosecond ticks since an arbitrary but fixed start time which is typically the boot time
+	 */
+	private ITick getTicks() {
+		return tickProvider.nextTick();
+	}
+
+	private TimeSpan getElapsedTime() {
+		TimeSpan timeElapsedInNano = this.elapsedNano;
+		if (isRunning) {
+			// If the StopWatch is running, add elapsed time since the StopWatch is started last time.
+			ITick currentTick = getTicks();
+			TimeSpan elapsedInNanosecondsUntilNow = currentTick.diff(this.startTick);
+			timeElapsedInNano = timeElapsedInNano.add(elapsedInNanosecondsUntilNow);
+		}
+		return timeElapsedInNano;
+	}
+
+	@Override
+	public String getName() {
+		return name;
+	}
+
+	public final void start() {
+		if (isRunning && !isPaused) {
+			throw new IllegalStateException("The StopWatch has already been started.");
+		} if(isRunning && isPaused){
+			// Doing a resume
+			resume();
+		}else {
+			this.startTick = getTicks();
+			isRunning = true;
+		}
+	}
+
+	public final void stop() {
+		if (isRunning) {
+			ITick endTicksInNano = getTicks();
+			TimeSpan elapsedThisPeriod = endTicksInNano.diff(startTick);
+			this.elapsedNano = this.elapsedNano.add(elapsedThisPeriod);
+			isRunning = false;
+
+			if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
+				// If measuring small time periods and return of negative value reset elapsed.
+				this.elapsedNano = TimeSpan.Zero;
+			}
+		} else {
+			throw new IllegalStateException("StopWatch is already stopped.");
+		}
+	}
+
+	public final void reset() {
+		isRunning = false;
+		isPaused = false;
+		startTick = getTicks(); // Don't care the start, this is not set yet.
+		elapsedNano = TimeSpan.Zero;
+		laps = new LinkedList<>();
+	}
+
+	/**
+	 * Convenience method for replacing {sw.Reset(); sw.Start();} with a single sw.Restart()
+	 */
+	public final void restart() {
+		isRunning = true;
+		isPaused = false;
+		startTick = getTicks(); // This is important, because we start again.
+		elapsedNano = TimeSpan.Zero;
+		laps = new LinkedList<>();
+	}
+
+	@Override
+	public void pause() {
+		if (!isRunning) {
+			throw new IllegalStateException("StopWatch can not be paused if it is not startet.");
+		}
+		if (isPaused) {
+			throw new IllegalStateException("StopWatch is already paused.");
+		}
+
+		if (!isPaused && isRunning) {
+			ITick nowTicksInNano = getTicks();
+			TimeSpan elapsedThisPeriod = nowTicksInNano.diff(startTick);
+			this.elapsedNano = this.elapsedNano.add(elapsedThisPeriod);
+			isPaused = true;
+
+			if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
+				// If measuring small time periods and return of negative value reset elapsed.
+				this.elapsedNano = TimeSpan.Zero;
+			}
+		} else {
+			throw new IllegalStateException("StopWatch is already paused.");
+		}
+	}
+
+	@Override
+	public void resume() {
+		if (isPaused && isRunning) {
+			ITick nowTicksInNano = getTicks();
+			this.startTick = nowTicksInNano;
+			isPaused = false;
+		} else {
+
+		}
+	}
+
+	@Override
+	public TimeSpan lap() {
+		if (isRunning && !isPaused) {
+			ITick nowTicksInNano = getTicks();
+			TimeSpan elapsedThisLap = nowTicksInNano.diff(this.startTick);
+			this.elapsedNano = this.elapsedNano.add(elapsedThisLap);
+			this.startTick = nowTicksInNano;
+
+			if (this.elapsedNano.compareTo(TimeSpan.Zero) < 0) {
+				// If measuring small time periods and return of negative value reset elapsed.
+				this.elapsedNano = TimeSpan.Zero;
+			}
+			this.laps.add(elapsedThisLap);
+			return elapsedThisLap;
+		} else {
+			throw new IllegalStateException("StopWatch is not running or is paused.");
+		}
+	}
+
+	public final boolean isRunning() {
+		return isRunning;
+	}
+
+	@Override
+	public boolean isPaused() {
+		return isPaused;
+	}
+
+	@Override
+	public boolean isStopped() {
+		return !(isRunning() || isPaused());
+	}
+
+	@Override
+	public List<TimeSpan> getTimeLaps() {
+		return laps.stream().toList();
+	}
+
+	@Override
+	public ITickProvider getTickProvider() {
+		return tickProvider;
+	}
+
+	@Override
+	public TimeSpan elapsed() {
+		return getElapsedTime();
+	}
+
+	public TimeSpan elapsedLap() {
+		if(laps.size() > 0) {
+			return laps.getLast();
+		} else {
+			return getElapsedTime();
+		}
+	}
+
+	@Override
+	public long elapsedNanoseconds() {
+		return (long) getElapsedTime().getTotalTimeNanoseconds();
+	}
+
+	@Override
+	public long elapsedMilliseconds() {
+		return (long) getElapsedTime().getTotalTimeMilliseconds();
+	}
+
+	@Override
+	public double elapsedSeconds() {
+		return getElapsedTime().getTotalTimeSeconds();
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/TestStopWatch.java b/src/main/java/dk/xpreuss/utils/timers/TestStopWatch.java
new file mode 100644
index 0000000..fca149a
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/TestStopWatch.java
@@ -0,0 +1,26 @@
+package dk.xpreuss.utils.timers;
+
+import dk.xpreuss.utils.timers.clock.providers.MilliTickProvider;
+import dk.xpreuss.utils.timers.clock.providers.NanoTickProvider;
+
+import java.time.LocalDateTime;
+import java.util.Date;
+
+public class TestStopWatch {
+	public static void main(String[] args) throws InterruptedException {
+		IStopWatch stopWatch = StopWatch.from(new MilliTickProvider());
+		//stopWatch = new StopWatch(new NanoTickProvider());
+		stopWatch.start();
+		//Thread.sleep(seconds(5));
+		stopWatch.stop();
+		System.out.println(stopWatch.elapsed());
+		System.out.println(new Date(-1));
+		System.out.println(new Date(0));
+		//System.out.println(new Date(Long.MIN_VALUE));
+		System.out.println(LocalDateTime.of(-1, 1, 1, 1, 1));
+	}
+
+	public static long seconds(long seconds) {
+		return seconds * 1_000;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java b/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java
new file mode 100644
index 0000000..8e4e922
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/IClock.java
@@ -0,0 +1,38 @@
+package dk.xpreuss.utils.timers.clock;
+
+import java.time.DateTimeException;
+import java.time.Instant;
+
+public interface IClock {
+	//-------------------------------------------------------------------------
+	/**
+	 * Gets the current millisecond instant of the clock.
+	 * <p>
+	 * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).
+	 * This is equivalent to the definition of {@link System#currentTimeMillis()}.
+	 * <p>
+	 * Most applications should avoid this method and use {@link Instant} to represent
+	 * an instant on the time-line rather than a raw millisecond value.
+	 * This method is provided to allow the use of the clock in high performance use cases
+	 * where the creation of an object would be unacceptable.
+	 * <p>
+	 * The default implementation currently calls {@link #instant}.
+	 *
+	 * @return the current millisecond instant from this clock, measured from
+	 *  the Java epoch of 1970-01-01T00:00Z (UTC), not null
+	 * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
+	 */
+	default long millis() {
+		return instant().toEpochMilli();
+	}
+
+	/**
+	 * Gets the current instant of the clock.
+	 * <p>
+	 * This returns an instant representing the current instant as defined by the clock.
+	 *
+	 * @return the current instant from this clock, not null
+	 * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
+	 */
+	abstract Instant instant();
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java b/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java
new file mode 100644
index 0000000..91f8cd7
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/SystemClock.java
@@ -0,0 +1,78 @@
+package dk.xpreuss.utils.timers.clock;
+
+import dk.xpreuss.utils.timers.clock.providers.ITickProvider;
+import dk.xpreuss.utils.timers.clock.providers.MilliTickProvider;
+import net.time4j.scale.LeapSeconds;
+
+import java.time.Clock;
+import java.time.Instant;
+
+public class SystemClock implements IClock {
+	private static final long MILLI = 1_000;
+	private static final long MICRO = 1_000_000;
+	private static final long NANO =  1_000_000_000;
+
+	private final ITickProvider tickProvider;
+	private final long offset;
+
+	private SystemClock() {
+		this(new MilliTickProvider(), calculateOffsetCalibration(new MilliTickProvider()));
+	}
+
+	private SystemClock(ITickProvider tickProvider, long offset) {
+		this.tickProvider = tickProvider;
+		this.offset = offset;
+	}
+
+	private static long calculateOffsetCalibration(ITickProvider tickProvider) {
+		// see https://bugs.openjdk.java.net/browse/JDK-8068730 (affects Java 9 or later)
+		Instant instant = Clock.systemUTC().instant();
+
+		long compareNanos = tickProvider.nextTickOfNanoseconds();
+
+		long currentMillis = System.currentTimeMillis();
+
+		long compareMillis = compareNanos / MILLI;
+
+
+
+		// handle Instant like POSIX, see real conversion between Instant and j.u.Date
+		long utc = LeapSeconds.getInstance().enhance(instant.getEpochSecond());
+
+		// offset = [instant] - [counter]
+		long instantNanos = Math.multiplyExact(utc, NANO) + instant.getNano();
+		return Math.subtractExact(instantNanos, compareNanos);
+	}
+
+	private long utcNanos() {
+		return Math.addExact(tickProvider.nextTickOfNanoseconds(), this.offset);
+	}
+
+	@Override
+	public Instant instant() {
+		System.out.println("offset: " + offset);
+		System.out.println("getNanos: " + tickProvider.nextTickOfNanoseconds());
+		return Instant.ofEpochSecond(tickProvider.nextTickOfNanoseconds());
+	}
+
+	public static void main(String[] args) {
+		System.out.println(new SystemClock().instant());
+		System.out.println(new SystemClock().instant().getNano());
+		System.out.println(new SystemClock().instant().getEpochSecond());
+		System.out.println(new SystemClock().instant());
+		Clock.systemUTC().instant();
+		System.out.println(System.currentTimeMillis());
+		System.out.println(System.nanoTime());
+
+
+		System.out.println("TimeSpan.Zero => " + TimeSpan.Zero);
+		System.out.println("TimeSpan.44 => " + TimeSpan.Builder().minutes(59).build());
+		System.out.println("xx TimeSpan.Zero => " + TimeSpan.Zero.toStringFull());
+		System.out.println("xxTimeSpan.44 => " + TimeSpan.Builder().days(77).milliseconds(123).microseconds(0).nanoseconds(678).build().toStringFull());
+
+		TimeSpan a = TimeSpan.Builder().minutes(-5).build();
+		TimeSpan b = TimeSpan.Builder().minutes(10).build();
+		TimeSpan result = a.add(b).add(TimeSpan.fromElapsedInNanoseconds(100000000000L));
+		System.out.println(result);
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java b/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java
new file mode 100644
index 0000000..c067637
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpan.java
@@ -0,0 +1,314 @@
+package dk.xpreuss.utils.timers.clock;
+
+import java.math.BigInteger;
+import java.util.Objects;
+
+public class TimeSpan implements Comparable<TimeSpan> {
+	private static final int HoursPerDay = 24;
+	private static final int MinutesPerHour = 60;
+	private static final int SecondsPerMinute = 60;
+	private static final int MillisecondsPerSecond = 1_000;
+	private static final int MicrosecondsPerMillisecond = 1_000;
+	private static final int NanosecondsPerMicrosecond = 1_000;
+
+	private static final long ElapsedTimeInNanosecondsPerNanosecond = 1;
+	private static final long ElapsedTimeInNanosecondsPerMicrosecond = ElapsedTimeInNanosecondsPerNanosecond * 1_000;
+	private static final long ElapsedTimeInNanosecondsPerMillisecond = ElapsedTimeInNanosecondsPerMicrosecond * 1_000;
+	private static final long ElapsedTimeInNanosecondsPerSecond = ElapsedTimeInNanosecondsPerMillisecond * 1_000;
+	private static final long ElapsedTimeInNanosecondsPerMinute = ElapsedTimeInNanosecondsPerSecond * 60;
+	private static final long ElapsedTimeInNanosecondsPerHour = ElapsedTimeInNanosecondsPerMinute * 60;
+	private static final long ElapsedTimeInNanosecondsPerDay = ElapsedTimeInNanosecondsPerHour * 24;
+	private static final int MillisPerSecond = 1000;
+	private static final int MillisPerMinute = MillisPerSecond * 60; //     60,000
+	private static final int MillisPerHour = MillisPerMinute * 60;   //  3,600,000
+	private static final int MillisPerDay = MillisPerHour * 24;      // 86,400,000
+
+	public static final TimeSpan Zero = new TimeSpan(0);
+
+	private BigInteger elapsedTimeInNanoseconds;
+	private long days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
+
+	private TimeSpan(long elapsedInNanoseconds) {
+		initialize(elapsedInNanoseconds);
+	}
+
+	private TimeSpan(BigInteger elapsedTimeInNanoseconds) {
+		this(elapsedTimeInNanoseconds.longValueExact());
+	}
+
+	private void initialize(long elapsedTimeInNanoseconds) {
+		this.elapsedTimeInNanoseconds = BigInteger.valueOf(elapsedTimeInNanoseconds);
+		this.days = calculateDays(elapsedTimeInNanoseconds);
+		this.hours = calculateHours(elapsedTimeInNanoseconds);
+		this.minutes = calculateMinutes(elapsedTimeInNanoseconds);
+		this.seconds = calculateSeconds(elapsedTimeInNanoseconds);
+		this.milliseconds = calculateMilliseconds(elapsedTimeInNanoseconds);
+		this.microseconds = calculateMicroseconds(elapsedTimeInNanoseconds);
+		this.nanoseconds = calculateNanoseconds(elapsedTimeInNanoseconds);
+	}
+
+	private long calculateDays(long elapsedTimeInNanoseconds) {
+		return elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerDay;
+	}
+
+	private long calculateHours(long elapsedTimeInNanoseconds) {
+		return (elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerHour) % HoursPerDay;
+	}
+
+	private long calculateMinutes(long elapsedTimeInNanoseconds) {
+		return (elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerMinute) % MinutesPerHour;
+	}
+
+	private long calculateSeconds(long elapsedTimeInNanoseconds) {
+		return (elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerSecond) % SecondsPerMinute;
+	}
+
+	private long calculateMilliseconds(long elapsedTimeInNanoseconds) {
+		return (elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerMillisecond) % MillisecondsPerSecond;
+	}
+
+	private long calculateMicroseconds(long elapsedTimeInNanoseconds) {
+		return (elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerMicrosecond) % MicrosecondsPerMillisecond;
+	}
+
+	private long calculateNanoseconds(long elapsedTimeInNanoseconds) {
+		return (elapsedTimeInNanoseconds / ElapsedTimeInNanosecondsPerNanosecond) % NanosecondsPerMicrosecond;
+	}
+
+	public long getDays() {
+		return days;
+	}
+
+	public long getHours() {
+		return hours;
+	}
+
+	public long getMinutes() {
+		return minutes;
+	}
+
+	public long getSeconds() {
+		return seconds;
+	}
+
+	public long getMilliseconds() {
+		return milliseconds;
+	}
+
+	public long getMicroseconds() {
+		return microseconds;
+	}
+
+	public long getNanoseconds() {
+		return nanoseconds;
+	}
+
+	public double getTotalTimeDays() {
+		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerDay;
+	}
+
+	public double getTotalTimeHours() {
+		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerHour;
+	}
+
+	public double getTotalTimeMinutes() {
+		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerMinute;
+	}
+
+	public double getTotalTimeSeconds() {
+		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerSecond;
+	}
+
+	public double getTotalTimeMilliseconds() {
+		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerMillisecond;
+	}
+
+	public double getTotalTimeMicroseconds() {
+		return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerMicrosecond;
+	}
+
+	public double getTotalTimeNanoseconds() { return elapsedTimeInNanoseconds.doubleValue() / ElapsedTimeInNanosecondsPerNanosecond;}
+
+	public long getNanoAdjustment() {
+		return Math.addExact(nanoseconds,
+				Math.addExact(
+						Math.multiplyExact(microseconds, NanosecondsPerMicrosecond),
+						Math.multiplyExact(milliseconds, MicrosecondsPerMillisecond * NanosecondsPerMicrosecond)
+				)
+		);
+	}
+
+	public TimeSpan add(TimeSpan other) {
+		BigInteger result = elapsedTimeInNanoseconds.add(other.elapsedTimeInNanoseconds);
+		return new TimeSpan(result);
+	}
+
+	public TimeSpan subtract(TimeSpan other) {
+		BigInteger result = elapsedTimeInNanoseconds.subtract(other.elapsedTimeInNanoseconds);
+		return new TimeSpan(result);
+	}
+
+	public TimeSpan negate() {
+		BigInteger result = elapsedTimeInNanoseconds.negate();
+		return new TimeSpan(result);
+	}
+
+	public TimeSpan duration() {
+		BigInteger result = elapsedTimeInNanoseconds.abs();
+		return new TimeSpan(result);
+	}
+
+	public static TimeSpan Interval(double value, int scale) {
+		if (Double.isNaN(value)) {
+			throw new IllegalArgumentException("Cannot be NaN");
+		}
+		double tmp = value * scale;
+		double millis = tmp + (value >= 0 ? 0.5 : -0.5);
+		if ((millis > Integer.MAX_VALUE / Zero.ElapsedTimeInNanosecondsPerMillisecond) || (millis < Integer.MAX_VALUE / ElapsedTimeInNanosecondsPerMillisecond)) {
+			throw new ArithmeticException("double value out of byte range");
+		}
+		return new TimeSpan((long) millis * ElapsedTimeInNanosecondsPerMillisecond);
+	}
+
+	@Override
+	public String toString() {
+		return TimeSpanFormat.format(this, TimeSpanFormat.FormatPattern.MINIMUM);
+	}
+
+	public String toStringFull() {
+		return TimeSpanFormat.format(this, TimeSpanFormat.FormatPattern.FULL);
+	}
+
+	public static TimeSpan fromElapsedInNanoseconds(long elapsedInNanoseconds) {
+		return new TimeSpan(elapsedInNanoseconds);
+	}
+
+
+	/**
+	 * Compares this object with the specified object for order.  Returns a
+	 * negative integer, zero, or a positive integer as this object is less
+	 * than, equal to, or greater than the specified object.
+	 *
+	 * <p>The implementor must ensure
+	 * {@code sgn(x.compareTo(y)) == -sgn(y.compareTo(x))}
+	 * for all {@code x} and {@code y}.  (This
+	 * implies that {@code x.compareTo(y)} must throw an exception iff
+	 * {@code y.compareTo(x)} throws an exception.)
+	 *
+	 * <p>The implementor must also ensure that the relation is transitive:
+	 * {@code (x.compareTo(y) > 0 && y.compareTo(z) > 0)} implies
+	 * {@code x.compareTo(z) > 0}.
+	 *
+	 * <p>Finally, the implementor must ensure that {@code x.compareTo(y)==0}
+	 * implies that {@code sgn(x.compareTo(z)) == sgn(y.compareTo(z))}, for
+	 * all {@code z}.
+	 *
+	 * <p>It is strongly recommended, but <i>not</i> strictly required that
+	 * {@code (x.compareTo(y)==0) == (x.equals(y))}.  Generally speaking, any
+	 * class that implements the {@code Comparable} interface and violates
+	 * this condition should clearly indicate this fact.  The recommended
+	 * language is "Note: this class has a natural ordering that is
+	 * inconsistent with equals."
+	 *
+	 * <p>In the foregoing description, the notation
+	 * {@code sgn(}<i>expression</i>{@code )} designates the mathematical
+	 * <i>signum</i> function, which is defined to return one of {@code -1},
+	 * {@code 0}, or {@code 1} according to whether the value of
+	 * <i>expression</i> is negative, zero, or positive, respectively.
+	 *
+	 * @param o the object to be compared.
+	 * @return a negative integer, zero, or a positive integer as this object
+	 * is less than, equal to, or greater than the specified object.
+	 * @throws NullPointerException if the specified object is null
+	 * @throws ClassCastException   if the specified object's type prevents it
+	 *                              from being compared to this object.
+	 */
+	@Override
+	public int compareTo(TimeSpan o) {
+		return this.elapsedTimeInNanoseconds.compareTo(o.elapsedTimeInNanoseconds);
+	}
+
+	@Override
+	public boolean equals(Object o) {
+		if (this == o) return true;
+		if (o == null || getClass() != o.getClass()) return false;
+		TimeSpan timeSpan = (TimeSpan) o;
+		return days == timeSpan.days && hours == timeSpan.hours && minutes == timeSpan.minutes && seconds == timeSpan.seconds && milliseconds == timeSpan.milliseconds && microseconds == timeSpan.microseconds && nanoseconds == timeSpan.nanoseconds && elapsedTimeInNanoseconds.equals(timeSpan.elapsedTimeInNanoseconds);
+	}
+
+	@Override
+	public int hashCode() {
+		return Objects.hash(elapsedTimeInNanoseconds, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);
+	}
+
+	public static Builder Builder() {
+		return new Builder();
+	}
+
+	public static class Builder {
+		private BigInteger elapsedTimeInNanoseconds = BigInteger.ZERO;
+		private long days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;
+
+		public Builder elapsedTimeInNanoseconds(long elapsedTimeInNanoseconds) {
+			this.elapsedTimeInNanoseconds = BigInteger.valueOf(elapsedTimeInNanoseconds);
+			return this;
+		}
+
+		public Builder days(long days) {
+			this.days = days;
+			return this;
+		}
+
+		public Builder hours(long hours) {
+			this.hours = hours;
+			return this;
+		}
+
+		public Builder minutes(long minutes) {
+			this.minutes = minutes;
+			return this;
+		}
+
+		public Builder seconds(long seconds) {
+			this.seconds = seconds;
+			return this;
+		}
+
+		public Builder milliseconds(long milliseconds) {
+			this.milliseconds = milliseconds;
+			return this;
+		}
+
+		public Builder microseconds(long microseconds) {
+			this.microseconds = microseconds;
+			return this;
+		}
+
+		public Builder nanoseconds(long nanoseconds) {
+			this.nanoseconds = nanoseconds;
+			return this;
+		}
+
+		public TimeSpan build() {
+			long dayElapsedTimeInNanoseconds = days * TimeSpan.Zero.ElapsedTimeInNanosecondsPerDay;
+			long hourElapsedTimeInNanoseconds = hours * TimeSpan.Zero.ElapsedTimeInNanosecondsPerHour;
+			long minuteElapsedTimeInNanoseconds = minutes * TimeSpan.Zero.ElapsedTimeInNanosecondsPerMinute;
+			long secondElapsedTimeInNanoseconds = seconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerSecond;
+			long millisecondElapsedTimeInNanoseconds = milliseconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerMillisecond;
+			long microsecondElapsedTimeInNanoseconds = microseconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerMicrosecond;
+			long nanosecondElapsedTimeInNanoseconds = nanoseconds * TimeSpan.Zero.ElapsedTimeInNanosecondsPerNanosecond;
+
+			System.out.println("dayElapsedTimeInNanoseconds: " + dayElapsedTimeInNanoseconds);
+			System.out.println("hourElapsedTimeInNanoseconds: " + hourElapsedTimeInNanoseconds);
+			System.out.println("minuteElapsedTimeInNanoseconds: " + minuteElapsedTimeInNanoseconds);
+			System.out.println("secondElapsedTimeInNanoseconds: " + secondElapsedTimeInNanoseconds);
+			System.out.println("millisecondElapsedTimeInNanoseconds: " + millisecondElapsedTimeInNanoseconds);
+			System.out.println("microsecondElapsedTimeInNanoseconds: " + microsecondElapsedTimeInNanoseconds);
+			System.out.println("nanosecondElapsedTimeInNanoseconds: " + nanosecondElapsedTimeInNanoseconds);
+			System.out.println("elapsedTimeInNanoseconds: " + elapsedTimeInNanoseconds.longValue());
+
+			return new TimeSpan(elapsedTimeInNanoseconds.longValue() + dayElapsedTimeInNanoseconds + hourElapsedTimeInNanoseconds + minuteElapsedTimeInNanoseconds + secondElapsedTimeInNanoseconds + millisecondElapsedTimeInNanoseconds + microsecondElapsedTimeInNanoseconds + nanosecondElapsedTimeInNanoseconds);
+		}
+
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpanFormat.java b/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpanFormat.java
new file mode 100644
index 0000000..beac8e7
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/TimeSpanFormat.java
@@ -0,0 +1,59 @@
+package dk.xpreuss.utils.timers.clock;
+
+public class TimeSpanFormat {
+	public enum FormatPattern {
+		NONE, MINIMUM, FULL;
+	}
+
+	//
+	//  Format
+	//
+	//  Actions: Main method called from TimeSpan.ToString
+	//
+	static String format(TimeSpan value, FormatPattern formatPattern) {
+		StringBuilder sb = new StringBuilder();
+		long days = Math.abs(value.getDays());
+		long hours = Math.abs(value.getHours());
+		long minutes = Math.abs(value.getMinutes());
+		long seconds = Math.abs(value.getSeconds());
+		long secondFractions = Math.abs(value.getNanoAdjustment());
+
+		// Pattern Full == [-]dd,HH:mm:ss.fffffffff
+		// Pattern Minimum = [-][d,]HH:mm:ss[.fffffffff]
+		final String positiveOrNegative = value.getTotalTimeSeconds() < 0 ? "-" : "";
+		final String dayHourSep = ",";
+		final String hourMinuteSep = ":";
+		final String minuteSecondSep = ":";
+		final String secondFractionSep = ",";
+
+		sb.append(positiveOrNegative);
+		if (formatPattern == FormatPattern.FULL || days != 0) {
+			sb.append(days);
+			sb.append(dayHourSep);
+		}
+		sb.append(String.format("%02d", hours));
+		sb.append(hourMinuteSep);
+		sb.append(String.format("%02d", minutes));
+		sb.append(minuteSecondSep);
+		sb.append(String.format("%02d", seconds));
+		if (formatPattern == FormatPattern.MINIMUM) {
+			int effectiveDigits = 9;
+			while (effectiveDigits > 0) {
+				if (secondFractions % 10 == 0) {
+					secondFractions = secondFractions / 10;
+					effectiveDigits--;
+				} else {
+					break;
+				}
+			}
+			if (effectiveDigits > 0) {
+				sb.append(secondFractionSep);
+				sb.append(String.format("%0" + (effectiveDigits) + "d", secondFractions));
+			}
+		} else if (formatPattern == FormatPattern.FULL || secondFractions != 0) {
+			sb.append(secondFractionSep);
+			sb.append(String.format("%09d", secondFractions));
+		}
+		return sb.toString();
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/CpuTickProvider.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/CpuTickProvider.java
new file mode 100644
index 0000000..581f451
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/CpuTickProvider.java
@@ -0,0 +1,34 @@
+package dk.xpreuss.utils.timers.clock.providers;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+
+public class CpuTickProvider implements ITickProvider {
+	private static final long NANO_TO_MILLI = 1_000_000;
+
+	private final ThreadMXBean threadTimer;
+
+	public CpuTickProvider() {
+		this.threadTimer = ManagementFactory.getThreadMXBean();
+	}
+
+	@Override
+	public ITick.Resolution getMaxResolution() {
+		return ITick.Resolution.NANOSECONDS;
+	}
+
+	@Override
+	public long nextTickOfNanoseconds() {
+		return threadTimer.getCurrentThreadCpuTime();
+	}
+
+	@Override
+	public long nextTickOfMilliseconds() {
+		return threadTimer.getCurrentThreadCpuTime() / NANO_TO_MILLI;
+	}
+
+	@Override
+	public ITick nextTick() {
+		return new Tick(getMaxResolution(), threadTimer.getCurrentThreadCpuTime());
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java
new file mode 100644
index 0000000..f0ac49d
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITick.java
@@ -0,0 +1,110 @@
+package dk.xpreuss.utils.timers.clock.providers;
+
+import dk.xpreuss.utils.timers.clock.TimeSpan;
+
+import static dk.xpreuss.utils.timers.clock.providers.ITick.Resolution.*;
+
+public interface ITick {
+	/**
+	 * The internal tick resolution
+	 *
+	 * @return the internal tick resolution
+	 */
+	Resolution getRawTickResolution();
+
+	/**
+	 * Returns the internal tick using the internal tick resolution;
+	 *
+	 * @return number of ticks in internal tick resolution
+	 */
+	long getRawTicks();
+
+	/**
+	 * Converts the raw internal resolution to this resolution.
+	 *
+	 * @param resolution the ticks to be converted to this resolution
+	 * @return returns the converted ticks
+	 */
+	default long getTicksBy(Resolution resolution) {
+		return getRawTicks() * (resolution.size / getRawTickResolution().size);
+	}
+
+	/**
+	 * Converts the ticks to a custom resolution
+	 *
+	 * @param customResolution the new resolution size
+	 * @return the ticks in the custom resolution
+	 */
+	default long getTicksBy(long customResolution) {
+		return getTicksBy(NANOSECONDS) * (customResolution / NANOSECONDS.size);
+	}
+
+	/**
+	 * @return ticks by default resolution
+	 */
+	default long getDefaultTicks() {
+		return getTicksBy(getDefaultResolution());
+	}
+
+	/**
+	 * @return the default resolution
+	 */
+	default Resolution getDefaultResolution() {
+		return NANOSECONDS;
+	}
+
+	/**
+	 * Returns ticks at resolution seconds
+	 *
+	 * @return ticks with resolution seconds
+	 */
+	default long getSeconds() {
+		return getTicksBy(SECONDS);
+	}
+
+	/**
+	 * Returns ticks at resolution milliseconds
+	 *
+	 * @return ticks with resolution milliseconds
+	 */
+	default long getMilliseconds() {
+		return getTicksBy(MILLISECONDS);
+	}
+
+	/**
+	 * Returns ticks at resolution microseconds
+	 *
+	 * @return ticks with resolution microseconds
+	 */
+	default long getMicroseconds() {
+		return getTicksBy(MICROSECONDS);
+	}
+
+	/**
+	 * Returns ticks at resolution nanoseconds
+	 *
+	 * @return ticks with resolution nanoseconds
+	 */
+	default long getNanoseconds() {
+		return getTicksBy(NANOSECONDS);
+	}
+
+	default TimeSpan diff(ITick tickBefore) {
+		return TimeSpan.fromElapsedInNanoseconds(getNanoseconds() - tickBefore.getNanoseconds());
+	}
+
+	enum Resolution {
+		SECONDS(1), MILLISECONDS(1_000), MICROSECONDS(1_000_000), NANOSECONDS(1_000_000_000), OTHER(-1);
+
+		private final long size;
+
+		Resolution(long size) {
+			this.size = size;
+		}
+
+		public long getSize() {
+			return size;
+		}
+	}
+}
+
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITickProvider.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITickProvider.java
new file mode 100644
index 0000000..96e4b62
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/ITickProvider.java
@@ -0,0 +1,15 @@
+package dk.xpreuss.utils.timers.clock.providers;
+
+public interface ITickProvider {
+	ITick.Resolution getMaxResolution();
+
+	/**
+	 * <p>Generates a count of nanoseconds. </p>
+	 *
+	 * @return count of nanosecond ticks since an arbitrary but fixed start time which is typically the boot time
+	 */
+	long nextTickOfNanoseconds();
+	long nextTickOfMilliseconds();
+	ITick nextTick();
+}
+
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/MilliTickProvider.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/MilliTickProvider.java
new file mode 100644
index 0000000..aa5f777
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/MilliTickProvider.java
@@ -0,0 +1,25 @@
+package dk.xpreuss.utils.timers.clock.providers;
+
+public class MilliTickProvider implements ITickProvider {
+	private static final int MILLISECONDS_TO_NANOSECONDS = 1_000_000;
+
+	@Override
+	public ITick.Resolution getMaxResolution() {
+		return ITick.Resolution.MILLISECONDS;
+	}
+
+	@Override
+	public long nextTickOfNanoseconds() {
+		return System.currentTimeMillis() * MILLISECONDS_TO_NANOSECONDS;
+	}
+
+	@Override
+	public long nextTickOfMilliseconds() {
+		return System.currentTimeMillis();
+	}
+
+	@Override
+	public ITick nextTick() {
+		return new Tick(getMaxResolution(), System.currentTimeMillis());
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/NanoTickProvider.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/NanoTickProvider.java
new file mode 100644
index 0000000..7ddd781
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/NanoTickProvider.java
@@ -0,0 +1,25 @@
+package dk.xpreuss.utils.timers.clock.providers;
+
+public class NanoTickProvider implements ITickProvider {
+	private static final long NANO_TO_MILLI = 1_000_000;
+
+	@Override
+	public ITick.Resolution getMaxResolution() {
+		return ITick.Resolution.NANOSECONDS;
+	}
+
+	@Override
+	public long nextTickOfNanoseconds() {
+		return System.nanoTime();
+	}
+
+	@Override
+	public long nextTickOfMilliseconds() {
+		return System.nanoTime() / NANO_TO_MILLI;
+	}
+
+	@Override
+	public ITick nextTick() {
+		return new Tick(getMaxResolution(), System.nanoTime());
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java b/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
new file mode 100644
index 0000000..df0d2cf
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/clock/providers/Tick.java
@@ -0,0 +1,22 @@
+package dk.xpreuss.utils.timers.clock.providers;
+
+public class Tick implements ITick {
+	private final Resolution internalResolution;
+	private final long rawTicks;
+
+	public Tick(Resolution internalResolution, long rawTicks) {
+		this.internalResolution = internalResolution;
+		this.rawTicks = rawTicks;
+	}
+
+
+	@Override
+	public Resolution getRawTickResolution() {
+		return internalResolution;
+	}
+
+	@Override
+	public long getRawTicks() {
+		return rawTicks;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/otherproviders/CpuTickProvider.java b/src/main/java/dk/xpreuss/utils/timers/otherproviders/CpuTickProvider.java
new file mode 100644
index 0000000..1333f37
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/otherproviders/CpuTickProvider.java
@@ -0,0 +1,24 @@
+package dk.xpreuss.utils.timers.otherproviders;
+
+import net.time4j.scale.TickProvider;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadMXBean;
+
+public class CpuTickProvider implements TickProvider {
+	private final ThreadMXBean threadTimer;
+
+	public CpuTickProvider() {
+		this.threadTimer = ManagementFactory.getThreadMXBean();
+	}
+
+	@Override
+	public String getPlatform() {
+		return System.getProperty("java.vm.name");
+	}
+
+	@Override
+	public long getNanos() {
+		return threadTimer.getCurrentThreadCpuTime();
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/otherproviders/MilliTickProvider.java b/src/main/java/dk/xpreuss/utils/timers/otherproviders/MilliTickProvider.java
new file mode 100644
index 0000000..c4ea692
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/otherproviders/MilliTickProvider.java
@@ -0,0 +1,15 @@
+package dk.xpreuss.utils.timers.otherproviders;
+
+import net.time4j.scale.TickProvider;
+
+public class MilliTickProvider implements TickProvider {
+	@Override
+	public String getPlatform() {
+		return System.getProperty("java.vm.name");
+	}
+
+	@Override
+	public long getNanos() {
+		return System.currentTimeMillis();
+	}
+}
diff --git a/src/main/java/dk/xpreuss/utils/timers/otherproviders/NanoTickProvider.java b/src/main/java/dk/xpreuss/utils/timers/otherproviders/NanoTickProvider.java
new file mode 100644
index 0000000..0e02ea7
--- /dev/null
+++ b/src/main/java/dk/xpreuss/utils/timers/otherproviders/NanoTickProvider.java
@@ -0,0 +1,15 @@
+package dk.xpreuss.utils.timers.otherproviders;
+
+import net.time4j.scale.TickProvider;
+
+public class NanoTickProvider implements TickProvider {
+	@Override
+	public String getPlatform() {
+		return System.getProperty("java.vm.name");
+	}
+
+	@Override
+	public long getNanos() {
+		return System.nanoTime();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/xperimentering/ByteOutputStream.java b/src/main/java/dk/xpreuss/xperimentering/ByteOutputStream.java
new file mode 100644
index 0000000..8588e4b
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/ByteOutputStream.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering;
+
+public class ByteOutputStream {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/ByteWriter.java b/src/main/java/dk/xpreuss/xperimentering/ByteWriter.java
new file mode 100644
index 0000000..1c03eca
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/ByteWriter.java
@@ -0,0 +1,383 @@
+package dk.xpreuss.xperimentering;
+
+import java.io.*;
+import java.util.Objects;
+
+/**
+ * Abstract class for writing to byte streams.  The only methods that a
+ * subclass must implement are write(byte[], int, int), flush(), and close().
+ * Most subclasses, however, will override some of the methods defined here in
+ * order to provide higher efficiency, additional functionality, or both.
+ *
+ */
+public abstract class ByteWriter implements Closeable, Flushable {
+
+	/**
+	 * Temporary buffer used to hold writes of strings and single characters
+	 */
+	private char[] writeBuffer;
+
+	/**
+	 * Size of writeBuffer, must be >= 1
+	 */
+	private static final int WRITE_BUFFER_SIZE = 1024;
+
+	/**
+	 * Returns a new {@code ByteWriter} which discards all characters.  The
+	 * returned stream is initially open.  The stream is closed by calling
+	 * the {@code close()} method.  Subsequent calls to {@code close()} have
+	 * no effect.
+	 *
+	 * <p> While the stream is open, the {@code append(char)}, {@code
+	 * append(CharSequence)}, {@code append(CharSequence, int, int)},
+	 * {@code flush()}, {@code write(int)}, {@code write(char[])}, and
+	 * {@code write(char[], int, int)} methods do nothing. After the stream
+	 * has been closed, these methods all throw {@code IOException}.
+	 *
+	 * <p> The {@link #lock object} used to synchronize operations on the
+	 * returned {@code ByteWriter} is not specified.
+	 *
+	 * @return a {@code ByteWriter} which discards all characters
+	 *
+	 * @since 11
+	 */
+	public static ByteWriter nullWriter() {
+		return new ByteWriter() {
+			private volatile boolean closed;
+
+			private void ensureOpen() throws IOException {
+				if (closed) {
+					throw new IOException("Stream closed");
+				}
+			}
+
+			@Override
+			public ByteWriter append(char c) throws IOException {
+				ensureOpen();
+				return this;
+			}
+
+			@Override
+			public ByteWriter append(CharSequence csq) throws IOException {
+				ensureOpen();
+				return this;
+			}
+
+			@Override
+			public ByteWriter append(CharSequence csq, int start, int end) throws IOException {
+				ensureOpen();
+				if (csq != null) {
+					Objects.checkFromToIndex(start, end, csq.length());
+				}
+				return this;
+			}
+
+			@Override
+			public void write(int c) throws IOException {
+				ensureOpen();
+			}
+
+			@Override
+			public void write(char[] cbuf, int off, int len) throws IOException {
+				Objects.checkFromIndexSize(off, len, cbuf.length);
+				ensureOpen();
+			}
+
+			@Override
+			public void write(String str) throws IOException {
+				Objects.requireNonNull(str);
+				ensureOpen();
+			}
+
+			@Override
+			public void write(String str, int off, int len) throws IOException {
+				Objects.checkFromIndexSize(off, len, str.length());
+				ensureOpen();
+			}
+
+			@Override
+			public void flush() throws IOException {
+				ensureOpen();
+			}
+
+			@Override
+			public void close() throws IOException {
+				closed = true;
+			}
+		};
+	}
+
+	/**
+	 * The object used to synchronize operations on this stream.  For
+	 * efficiency, a character-stream object may use an object other than
+	 * itself to protect critical sections.  A subclass should therefore use
+	 * the object in this field rather than {@code this} or a synchronized
+	 * method.
+	 */
+	protected Object lock;
+
+	/**
+	 * Creates a new character-stream bytewriter whose critical sections will
+	 * synchronize on the bytewriter itself.
+	 */
+	protected ByteWriter() {
+		this.lock = this;
+	}
+
+	/**
+	 * Creates a new character-stream bytewriter whose critical sections will
+	 * synchronize on the given object.
+	 *
+	 * @param  lock
+	 *         Object to synchronize on
+	 */
+	protected ByteWriter(Object lock) {
+		if (lock == null) {
+			throw new NullPointerException();
+		}
+		this.lock = lock;
+	}
+
+	/**
+	 * Writes a single character.  The character to be written is contained in
+	 * the 16 low-order bits of the given integer value; the 16 high-order bits
+	 * are ignored.
+	 *
+	 * <p> Subclasses that intend to support efficient single-character output
+	 * should override this method.
+	 *
+	 * @param  c
+	 *         int specifying a character to be written
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public void write(int c) throws IOException {
+		synchronized (lock) {
+			if (writeBuffer == null){
+				writeBuffer = new char[WRITE_BUFFER_SIZE];
+			}
+			writeBuffer[0] = (char) c;
+			write(writeBuffer, 0, 1);
+		}
+	}
+
+	/**
+	 * Writes an array of characters.
+	 *
+	 * @param  cbuf
+	 *         Array of characters to be written
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public void write(char cbuf[]) throws IOException {
+		write(cbuf, 0, cbuf.length);
+	}
+
+	/**
+	 * Writes a portion of an array of characters.
+	 *
+	 * @param  cbuf
+	 *         Array of characters
+	 *
+	 * @param  off
+	 *         Offset from which to start writing characters
+	 *
+	 * @param  len
+	 *         Number of characters to write
+	 *
+	 * @throws  IndexOutOfBoundsException
+	 *          Implementations should throw this exception
+	 *          if {@code off} is negative, or {@code len} is negative,
+	 *          or {@code off + len} is negative or greater than the length
+	 *          of the given array
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public abstract void write(char cbuf[], int off, int len) throws IOException;
+
+	/**
+	 * Writes a string.
+	 *
+	 * @param  str
+	 *         String to be written
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public void write(String str) throws IOException {
+		write(str, 0, str.length());
+	}
+
+	/**
+	 * Writes a portion of a string.
+	 *
+	 * @implSpec
+	 * The implementation in this class throws an
+	 * {@code IndexOutOfBoundsException} for the indicated conditions;
+	 * overriding methods may choose to do otherwise.
+	 *
+	 * @param  str
+	 *         A String
+	 *
+	 * @param  off
+	 *         Offset from which to start writing characters
+	 *
+	 * @param  len
+	 *         Number of characters to write
+	 *
+	 * @throws  IndexOutOfBoundsException
+	 *          Implementations should throw this exception
+	 *          if {@code off} is negative, or {@code len} is negative,
+	 *          or {@code off + len} is negative or greater than the length
+	 *          of the given string
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public void write(String str, int off, int len) throws IOException {
+		synchronized (lock) {
+			char cbuf[];
+			if (len <= WRITE_BUFFER_SIZE) {
+				if (writeBuffer == null) {
+					writeBuffer = new char[WRITE_BUFFER_SIZE];
+				}
+				cbuf = writeBuffer;
+			} else {    // Don't permanently allocate very large buffers.
+				cbuf = new char[len];
+			}
+			str.getChars(off, (off + len), cbuf, 0);
+			write(cbuf, 0, len);
+		}
+	}
+
+	/**
+	 * Appends the specified character sequence to this bytewriter.
+	 *
+	 * <p> An invocation of this method of the form {@code out.append(csq)}
+	 * behaves in exactly the same way as the invocation
+	 *
+	 * <pre>
+	 *     out.write(csq.toString()) </pre>
+	 *
+	 * <p> Depending on the specification of {@code toString} for the
+	 * character sequence {@code csq}, the entire sequence may not be
+	 * appended. For instance, invoking the {@code toString} method of a
+	 * character buffer will return a subsequence whose content depends upon
+	 * the buffer's position and limit.
+	 *
+	 * @param  csq
+	 *         The character sequence to append.  If {@code csq} is
+	 *         {@code null}, then the four characters {@code "null"} are
+	 *         appended to this bytewriter.
+	 *
+	 * @return  This bytewriter
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 *
+	 * @since  1.5
+	 */
+	public ByteWriter append(CharSequence csq) throws IOException {
+		write(String.valueOf(csq));
+		return this;
+	}
+
+	/**
+	 * Appends a subsequence of the specified character sequence to this bytewriter.
+	 * {@code Appendable}.
+	 *
+	 * <p> An invocation of this method of the form
+	 * {@code out.append(csq, start, end)} when {@code csq}
+	 * is not {@code null} behaves in exactly the
+	 * same way as the invocation
+	 *
+	 * <pre>{@code
+	 *     out.write(csq.subSequence(start, end).toString())
+	 * }</pre>
+	 *
+	 * @param  csq
+	 *         The character sequence from which a subsequence will be
+	 *         appended.  If {@code csq} is {@code null}, then characters
+	 *         will be appended as if {@code csq} contained the four
+	 *         characters {@code "null"}.
+	 *
+	 * @param  start
+	 *         The index of the first character in the subsequence
+	 *
+	 * @param  end
+	 *         The index of the character following the last character in the
+	 *         subsequence
+	 *
+	 * @return  This bytewriter
+	 *
+	 * @throws  IndexOutOfBoundsException
+	 *          If {@code start} or {@code end} are negative, {@code start}
+	 *          is greater than {@code end}, or {@code end} is greater than
+	 *          {@code csq.length()}
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 *
+	 * @since  1.5
+	 */
+	public ByteWriter append(CharSequence csq, int start, int end) throws IOException {
+		if (csq == null) csq = "null";
+		return append(csq.subSequence(start, end));
+	}
+
+	/**
+	 * Appends the specified character to this bytewriter.
+	 *
+	 * <p> An invocation of this method of the form {@code out.append(c)}
+	 * behaves in exactly the same way as the invocation
+	 *
+	 * <pre>
+	 *     out.write(c) </pre>
+	 *
+	 * @param  c
+	 *         The 16-bit character to append
+	 *
+	 * @return  This bytewriter
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 *
+	 * @since 1.5
+	 */
+	public ByteWriter append(char c) throws IOException {
+		write(c);
+		return this;
+	}
+
+	/**
+	 * Flushes the stream.  If the stream has saved any characters from the
+	 * various write() methods in a buffer, write them immediately to their
+	 * intended destination.  Then, if that destination is another character or
+	 * byte stream, flush it.  Thus one flush() invocation will flush all the
+	 * buffers in a chain of ByteWriters and OutputStreams.
+	 *
+	 * <p> If the intended destination of this stream is an abstraction provided
+	 * by the underlying operating system, for example a file, then flushing the
+	 * stream guarantees only that bytes previously written to the stream are
+	 * passed to the operating system for writing; it does not guarantee that
+	 * they are actually written to a physical device such as a disk drive.
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public abstract void flush() throws IOException;
+
+	/**
+	 * Closes the stream, flushing it first. Once the stream has been closed,
+	 * further write() or flush() invocations will cause an IOException to be
+	 * thrown. Closing a previously closed stream has no effect.
+	 *
+	 * @throws  IOException
+	 *          If an I/O error occurs
+	 */
+	public abstract void close() throws IOException;
+
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/IByteWriter.java b/src/main/java/dk/xpreuss/xperimentering/IByteWriter.java
new file mode 100644
index 0000000..557e5a9
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/IByteWriter.java
@@ -0,0 +1,51 @@
+package dk.xpreuss.xperimentering;
+
+import java.io.IOException;
+import java.util.Collection;
+
+public interface IByteWriter {
+	IByteWriter append(byte b) throws IOException;
+
+	/**
+	 * Appends a portion of an array of characters.
+	 *
+	 * @param bytes Array of characters
+	 * @throws IOException               If an I/O error occurs
+	 */
+	IByteWriter append(byte[] bytes) throws IOException;
+
+	/**
+	 * Appends a portion of an array of characters.
+	 *
+	 * @param bytes Array of characters
+	 * @param start Index of the first byte in the array
+	 * @param end   Index of the last byte in the array
+	 * @throws IndexOutOfBoundsException If {@code start} or {@code end} are negative, {@code start}
+	 *                                   is greater than {@code end}, or {@code end} is greater than
+	 *                                   {@code bytes.size}
+	 * @throws IOException               If an I/O error occurs
+	 */
+	IByteWriter append(byte[] bytes, int start, int end) throws IOException;
+
+	/**
+	 * Appends the specified byte sequence to this writer.
+	 *
+	 * @param bytes The bytes to append.  If {@code bytes} is
+	 *              {@code null}, then it will throw NullPointerException.
+	 * @return This writer
+	 * @throws IOException          If an I/O error occurs
+	 * @throws NullPointerException If bytes any bytes in collection is null.
+	 * @since 1.0
+	 */
+	IByteWriter append(Collection<Byte> bytes) throws IOException;
+
+	/**
+	 * Appends 4 bytes from this int. The bytes to be appended is contained in
+	 * the 32 bits of the given integer value.
+	 *
+	 * @param bytes int specifying 4 bytes to be appended
+	 * @throws IOException If an I/O error occurs
+	 * @since 1.0
+	 */
+	IByteWriter append(int bytes) throws IOException;
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/Main.java b/src/main/java/dk/xpreuss/xperimentering/Main.java
new file mode 100644
index 0000000..56cce50
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/Main.java
@@ -0,0 +1,125 @@
+package dk.xpreuss.xperimentering;
+
+import dk.xpreuss.xperimentering.basex.Base64rfc4648;
+import dk.xpreuss.xperimentering.basex.IBase64;
+
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.text.BreakIterator;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Base64;
+
+public class Main {
+	public static String encode(String source) {
+		final int baseSize = 64;
+		final String charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+		final byte[] encodeData = new byte[baseSize];
+		for (int i = 0; i < 64; i++) {
+			encodeData[i] = (byte) charSet.charAt(i);
+		}
+		if (encodeData.length != baseSize) {
+			throw new IllegalStateException("The BaseSize should be " + baseSize + ", but is " + encodeData.length);
+		}
+
+		final int srcSize = source.getBytes().length;
+
+		final int dstLength = (srcSize + 2) / 3 * 4 + srcSize / 72;
+//		final int dstLength = Base64rfc4648.paddedBase64(srcSize);
+
+		System.out.println("Source size: " + srcSize);
+		System.out.println("DstLength: " + dstLength);
+		System.out.println("Other  (Ceiling(4n/3)): " + Math.ceil((4.0 * srcSize) / 3));
+		System.out.println("Other2 (floor((3 * (length - padding)) / 4): " + Math.floor(3 * (dstLength) / 4.0));
+
+		int length = srcSize;
+		byte[] dst = new byte[dstLength];
+		byte[] src = source.getBytes();
+		int start = 0;
+
+		int x = 0;
+		int dstIndex = 0;
+		int state = 0;  // which char in pattern
+		int old = 0;  // previous byte
+		int len = 0;  // length decoded so far
+		int max = length + start;
+		for (int srcIndex = start; srcIndex < max; srcIndex++) {
+			x = src[srcIndex];
+			switch (++state) {
+				case 1:
+					dst[dstIndex++] = encodeData[(x >> 2) & 0x3f];
+					break;
+				case 2:
+					dst[dstIndex++] = encodeData[((old << 4) & 0x30)
+							| ((x >> 4) & 0xf)];
+					break;
+				case 3:
+					dst[dstIndex++] = encodeData[((old << 2) & 0x3C)
+							| ((x >> 6) & 0x3)];
+					dst[dstIndex++] = encodeData[x & 0x3F];
+					state = 0;
+					break;
+			}
+			old = x;
+			if (++len >= 72) {
+				dst[dstIndex++] = (byte) '\n';
+				len = 0;
+			}
+		}
+		/*
+		 * now clean up the end bytes
+		 */
+
+		switch (state) {
+			case 1:
+				dst[dstIndex++] = encodeData[(old << 4) & 0x30];
+				dst[dstIndex++] = (byte) '=';
+				dst[dstIndex++] = (byte) '=';
+				break;
+			case 2:
+				dst[dstIndex++] = encodeData[(old << 2) & 0x3c];
+				dst[dstIndex++] = (byte) '=';
+				break;
+		}
+		return new String(dst);
+
+		//return  "YWJjZGVmZw==";
+	}
+
+	public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
+		final int baseSize = 64;
+		String source = "abcdefghijklmnopqrstuvwxy";
+source="wxy";
+		byte[] sourceBytes = source.getBytes();
+
+		String encodedString = encode(source);
+		final String expectedEncodedString = "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eQ==";
+		System.out.println("Source:   " + source);
+		System.out.println("Target:   " + encodedString);
+		System.out.println("Expected: " + expectedEncodedString);
+		System.out.println("Does it work ? " + (expectedEncodedString.equals(encodedString)));
+
+		System.out.println("Hello World");
+		for (int i = 0; i < 20; i++) {
+			System.out.println("n= " + i + ",  Pad : " + Base64rfc4648.calculateOutLenght(i, false, false) + ", UnPad: " + Base64rfc4648.calculateOutLenght(i, true, false));
+		}
+
+		final String charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+		byte [] encoded = encodeBlock(sourceBytes, 2);
+		for (int i = 0; i < encoded.length; i++) {
+			encoded[i] = (byte)charSet.charAt(encoded[i]);
+		}
+		System.out.println(new String(encoded));
+	}
+
+	private static byte[] encodeBlock(byte [] src, int len) {
+		byte [] out = new byte[4];
+		out[0] =(byte) (src[0]>>2);
+		out[1]= (byte) (((src[0] & 0x03)<<4) | (src[1] >> 4));
+		out[2]=(byte) (len > 0 ? (((src[1]  & 0x0F)<<2) | (src[2]  >> 6)) : '=');
+		out[3]=(byte) (len > 1 ? (src[2]  & 0x3F) : '=');
+		return out;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/Main2.java b/src/main/java/dk/xpreuss/xperimentering/Main2.java
new file mode 100644
index 0000000..24acb68
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/Main2.java
@@ -0,0 +1,10 @@
+package dk.xpreuss.xperimentering;
+
+import io.reactivex.rxjava3.core.*;
+
+public class Main2 {
+	public static void main(String[] args) {
+
+		Flowable.just("Hello world").subscribe(System.out::println);
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/Main3InputStream.java b/src/main/java/dk/xpreuss/xperimentering/Main3InputStream.java
new file mode 100644
index 0000000..bc71381
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/Main3InputStream.java
@@ -0,0 +1,12 @@
+package dk.xpreuss.xperimentering;
+
+import net.jhorstmann.base64.Base64OutputStream;
+
+import java.io.*;
+
+public class Main3InputStream {
+	public static void main(String[] args) throws FileNotFoundException {
+		OutputStream os = new Base64OutputStream(new OutputStreamWriter(new BufferedOutputStream(new PrintStream(new File("")))));
+		Writer w;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/SafeMath.java b/src/main/java/dk/xpreuss/xperimentering/SafeMath.java
new file mode 100644
index 0000000..c3d07c8
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/SafeMath.java
@@ -0,0 +1,101 @@
+package dk.xpreuss.xperimentering;
+
+public class SafeMath {
+	public static final int safeAdd(int left, int right) {
+		if (right > 0 ? left > Integer.MAX_VALUE - right
+				: left < Integer.MIN_VALUE - right) {
+			throw new ArithmeticException("Integer overflow");
+		}
+		return left + right;
+	}
+
+	public static final long safeAdd(long left, long right) {
+		if (right > 0 ? left > Long.MAX_VALUE - right
+				: left < Long.MIN_VALUE - right) {
+			throw new ArithmeticException("Long Integer overflow");
+		}
+		return left + right;
+	}
+
+	public static final int safeSubtract(int left, int right) {
+		if (right > 0 ? left < Integer.MIN_VALUE + right
+				: left > Integer.MAX_VALUE + right) {
+			throw new ArithmeticException("Integer overflow");
+		}
+		return left - right;
+	}
+
+	public static final long safeSubtract(long left, long right) {
+		if (right > 0 ? left < Long.MIN_VALUE + right
+				: left > Long.MAX_VALUE + right) {
+			throw new ArithmeticException("Long Integer overflow");
+		}
+		return left - right;
+	}
+
+	public static final int safeMultiply(int left, int right) {
+		if (right > 0 ? left > Integer.MAX_VALUE / right
+				|| left < Integer.MIN_VALUE / right
+				: (right < -1 ? left > Integer.MIN_VALUE / right
+				|| left < Integer.MAX_VALUE / right
+				: right == -1
+				&& left == Integer.MIN_VALUE)) {
+			throw new ArithmeticException("Integer overflow");
+		}
+		return left * right;
+	}
+
+	public static final long safeMultiply(long left, long right) {
+		if (right > 0 ? left > Long.MAX_VALUE / right
+				|| left < Long.MIN_VALUE / right
+				: (right < -1 ? left > Long.MIN_VALUE / right
+				|| left < Long.MAX_VALUE / right
+				: right == -1
+				&& left == Long.MIN_VALUE)) {
+			throw new ArithmeticException("Long Integer overflow");
+		}
+		return left * right;
+	}
+
+	public static final int safeDivide(int left, int right) {
+		if ((left == Integer.MIN_VALUE) && (right == -1)) {
+			throw new ArithmeticException("Integer overflow");
+		}
+		return left / right;
+	}
+
+	public static final long safeDivide(long left, long right) {
+		if ((left == Long.MIN_VALUE) && (right == -1)) {
+			throw new ArithmeticException("Long Integer overflow");
+		}
+		return left / right;
+	}
+
+	public static final int safeNegate(int a) {
+		if (a == Integer.MIN_VALUE) {
+			throw new ArithmeticException("Integer overflow");
+		}
+		return -a;
+	}
+
+	public static final long safeNegate(long a) {
+		if (a == Long.MIN_VALUE) {
+			throw new ArithmeticException("Long Integer overflow");
+		}
+		return -a;
+	}
+
+	public static final int safeAbs(int a) {
+		if (a == Integer.MIN_VALUE) {
+			throw new ArithmeticException("Integer overflow");
+		}
+		return Math.abs(a);
+	}
+
+	public static final long safeAbs(long a) {
+		if (a == Long.MIN_VALUE) {
+			throw new ArithmeticException("Long Integer overflow");
+		}
+		return Math.abs(a);
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/Base64.java.txt b/src/main/java/dk/xpreuss/xperimentering/basex/Base64.java.txt
new file mode 100644
index 0000000..4686ee3
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/Base64.java.txt
@@ -0,0 +1,1185 @@
+package dk.xpreuss.xperimentering.basex;
+
+
+import java.io.FilterOutputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+
+import sun.nio.cs.ISO_8859_1;
+
+import jdk.internal.vm.annotation.IntrinsicCandidate;
+
+/**
+ * This class consists exclusively of static methods for obtaining
+ * encoders and decoders for the Base64 encoding scheme. The
+ * implementation of this class supports the following types of Base64
+ * as specified in
+ * <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a> and
+ * <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.
+ *
+ * <ul>
+ * <li><a id="basic"><b>Basic</b></a>
+ * <p> Uses "The Base64 Alphabet" as specified in Table 1 of
+ *     RFC 4648 and RFC 2045 for encoding and decoding operation.
+ *     The encoder does not add any line feed (line separator)
+ *     character. The decoder rejects data that contains characters
+ *     outside the base64 alphabet.</p></li>
+ *
+ * <li><a id="url"><b>URL and Filename safe</b></a>
+ * <p> Uses the "URL and Filename safe Base64 Alphabet" as specified
+ *     in Table 2 of RFC 4648 for encoding and decoding. The
+ *     encoder does not add any line feed (line separator) character.
+ *     The decoder rejects data that contains characters outside the
+ *     base64 alphabet.</p></li>
+ *
+ * <li><a id="mime"><b>MIME</b></a>
+ * <p> Uses "The Base64 Alphabet" as specified in Table 1 of
+ *     RFC 2045 for encoding and decoding operation. The encoded output
+ *     must be represented in lines of no more than 76 characters each
+ *     and uses a carriage return {@code '\r'} followed immediately by
+ *     a linefeed {@code '\n'} as the line separator. No line separator
+ *     is added to the end of the encoded output. All line separators
+ *     or other characters not found in the base64 alphabet table are
+ *     ignored in decoding operation.</p></li>
+ * </ul>
+ *
+ * <p> Unless otherwise noted, passing a {@code null} argument to a
+ * method of this class will cause a {@link java.lang.NullPointerException
+ * NullPointerException} to be thrown.
+ *
+ * @author  Xueming Shen
+ * @since   1.8
+ */
+
+public class Base64 {
+
+	private Base64() {}
+
+	/**
+	 * Returns a {@link Encoder} that encodes using the
+	 * <a href="#basic">Basic</a> type base64 encoding scheme.
+	 *
+	 * @return  A Base64 encoder.
+	 */
+	public static Encoder getEncoder() {
+		return Encoder.RFC4648;
+	}
+
+	/**
+	 * Returns a {@link Encoder} that encodes using the
+	 * <a href="#url">URL and Filename safe</a> type base64
+	 * encoding scheme.
+	 *
+	 * @return  A Base64 encoder.
+	 */
+	public static Encoder getUrlEncoder() {
+		return Encoder.RFC4648_URLSAFE;
+	}
+
+	/**
+	 * Returns a {@link Encoder} that encodes using the
+	 * <a href="#mime">MIME</a> type base64 encoding scheme.
+	 *
+	 * @return  A Base64 encoder.
+	 */
+	public static Encoder getMimeEncoder() {
+		return Encoder.RFC2045;
+	}
+
+	/**
+	 * Returns a {@link Encoder} that encodes using the
+	 * <a href="#mime">MIME</a> type base64 encoding scheme
+	 * with specified line length and line separators.
+	 *
+	 * @param   lineLength
+	 *          the length of each output line (rounded down to nearest multiple
+	 *          of 4). If the rounded down line length is not a positive value,
+	 *          the output will not be separated in lines
+	 * @param   lineSeparator
+	 *          the line separator for each output line
+	 *
+	 * @return  A Base64 encoder.
+	 *
+	 * @throws  IllegalArgumentException if {@code lineSeparator} includes any
+	 *          character of "The Base64 Alphabet" as specified in Table 1 of
+	 *          RFC 2045.
+	 */
+	public static Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) {
+		Objects.requireNonNull(lineSeparator);
+		int[] base64 = Decoder.fromBase64;
+		for (byte b : lineSeparator) {
+			if (base64[b & 0xff] != -1)
+				throw new IllegalArgumentException(
+						"Illegal base64 line separator character 0x" + Integer.toString(b, 16));
+		}
+		// round down to nearest multiple of 4
+		lineLength &= ~0b11;
+		if (lineLength <= 0) {
+			return Encoder.RFC4648;
+		}
+		return new Encoder(false, lineSeparator, lineLength, true);
+	}
+
+	/**
+	 * Returns a {@link Decoder} that decodes using the
+	 * <a href="#basic">Basic</a> type base64 encoding scheme.
+	 *
+	 * @return  A Base64 decoder.
+	 */
+	public static Decoder getDecoder() {
+		return Decoder.RFC4648;
+	}
+
+	/**
+	 * Returns a {@link Decoder} that decodes using the
+	 * <a href="#url">URL and Filename safe</a> type base64
+	 * encoding scheme.
+	 *
+	 * @return  A Base64 decoder.
+	 */
+	public static Decoder getUrlDecoder() {
+		return Decoder.RFC4648_URLSAFE;
+	}
+
+	/**
+	 * Returns a {@link Decoder} that decodes using the
+	 * <a href="#mime">MIME</a> type base64 decoding scheme.
+	 *
+	 * @return  A Base64 decoder.
+	 */
+	public static Decoder getMimeDecoder() {
+		return Decoder.RFC2045;
+	}
+
+	/**
+	 * This class implements an encoder for encoding byte data using
+	 * the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
+	 *
+	 * <p> Instances of {@link Encoder} class are safe for use by
+	 * multiple concurrent threads.
+	 *
+	 * <p> Unless otherwise noted, passing a {@code null} argument to
+	 * a method of this class will cause a
+	 * {@link java.lang.NullPointerException NullPointerException} to
+	 * be thrown.
+	 * <p> If the encoded byte output of the needed size can not
+	 *     be allocated, the encode methods of this class will
+	 *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
+	 *     to be thrown.
+	 *
+	 * @see     Decoder
+	 * @since   1.8
+	 */
+	public static class Encoder {
+
+		private final byte[] newline;
+		private final int linemax;
+		private final boolean isURL;
+		private final boolean doPadding;
+
+		private Encoder(boolean isURL, byte[] newline, int linemax, boolean doPadding) {
+			this.isURL = isURL;
+			this.newline = newline;
+			this.linemax = linemax;
+			this.doPadding = doPadding;
+		}
+
+		/**
+		 * This array is a lookup table that translates 6-bit positive integer
+		 * index values into their "Base64 Alphabet" equivalents as specified
+		 * in "Table 1: The Base64 Alphabet" of RFC 2045 (and RFC 4648).
+		 */
+		private static final char[] toBase64 = {
+				'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+				'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+				'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+				'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+				'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
+		};
+
+		/**
+		 * It's the lookup table for "URL and Filename safe Base64" as specified
+		 * in Table 2 of the RFC 4648, with the '+' and '/' changed to '-' and
+		 * '_'. This table is used when BASE64_URL is specified.
+		 */
+		private static final char[] toBase64URL = {
+				'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+				'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+				'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+				'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+				'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
+		};
+
+		private static final int MIMELINEMAX = 76;
+		private static final byte[] CRLF = new byte[] {'\r', '\n'};
+
+		static final Encoder RFC4648 = new Encoder(false, null, -1, true);
+		static final Encoder RFC4648_URLSAFE = new Encoder(true, null, -1, true);
+		static final Encoder RFC2045 = new Encoder(false, CRLF, MIMELINEMAX, true);
+
+		/**
+		 * Calculates the length of the encoded output bytes.
+		 *
+		 * @param srclen length of the bytes to encode
+		 * @param throwOOME if true, throws OutOfMemoryError if the length of
+		 *                  the encoded bytes overflows; else returns the
+		 *                  length
+		 * @return length of the encoded bytes, or -1 if the length overflows
+		 *
+		 */
+		private final int encodedOutLength(int srclen, boolean throwOOME) {
+			int len = 0;
+			try {
+				if (doPadding) {
+					len = Math.multiplyExact(4, (Math.addExact(srclen, 2) / 3));
+				} else {
+					int n = srclen % 3;
+					len = Math.addExact(Math.multiplyExact(4, (srclen / 3)), (n == 0 ? 0 : n + 1));
+				}
+				if (linemax > 0) {                             // line separators
+					len = Math.addExact(len, (len - 1) / linemax * newline.length);
+				}
+			} catch (ArithmeticException ex) {
+				if (throwOOME) {
+					throw new OutOfMemoryError("Encoded size is too large");
+				} else {
+					// let the caller know that encoded bytes length
+					// is too large
+					len = -1;
+				}
+			}
+			return len;
+		}
+
+		/**
+		 * Encodes all bytes from the specified byte array into a newly-allocated
+		 * byte array using the {@link Base64} encoding scheme. The returned byte
+		 * array is of the length of the resulting bytes.
+		 *
+		 * @param   src
+		 *          the byte array to encode
+		 * @return  A newly-allocated byte array containing the resulting
+		 *          encoded bytes.
+		 */
+		public byte[] encode(byte[] src) {
+			int len = encodedOutLength(src.length, true);          // dst array size
+			byte[] dst = new byte[len];
+			int ret = encode0(src, 0, src.length, dst);
+			if (ret != dst.length)
+				return Arrays.copyOf(dst, ret);
+			return dst;
+		}
+
+		/**
+		 * Encodes all bytes from the specified byte array using the
+		 * {@link Base64} encoding scheme, writing the resulting bytes to the
+		 * given output byte array, starting at offset 0.
+		 *
+		 * <p> It is the responsibility of the invoker of this method to make
+		 * sure the output byte array {@code dst} has enough space for encoding
+		 * all bytes from the input byte array. No bytes will be written to the
+		 * output byte array if the output byte array is not big enough.
+		 *
+		 * @param   src
+		 *          the byte array to encode
+		 * @param   dst
+		 *          the output byte array
+		 * @return  The number of bytes written to the output byte array
+		 *
+		 * @throws  IllegalArgumentException if {@code dst} does not have enough
+		 *          space for encoding all input bytes.
+		 */
+		public int encode(byte[] src, byte[] dst) {
+			int len = encodedOutLength(src.length, false);         // dst array size
+			if (dst.length < len || len == -1)
+				throw new IllegalArgumentException(
+						"Output byte array is too small for encoding all input bytes");
+			return encode0(src, 0, src.length, dst);
+		}
+
+		/**
+		 * Encodes the specified byte array into a String using the {@link Base64}
+		 * encoding scheme.
+		 *
+		 * <p> This method first encodes all input bytes into a base64 encoded
+		 * byte array and then constructs a new String by using the encoded byte
+		 * array and the {@link java.nio.charset.StandardCharsets#ISO_8859_1
+		 * ISO-8859-1} charset.
+		 *
+		 * <p> In other words, an invocation of this method has exactly the same
+		 * effect as invoking
+		 * {@code new String(encode(src), StandardCharsets.ISO_8859_1)}.
+		 *
+		 * @param   src
+		 *          the byte array to encode
+		 * @return  A String containing the resulting Base64 encoded characters
+		 */
+		@SuppressWarnings("deprecation")
+		public String encodeToString(byte[] src) {
+			byte[] encoded = encode(src);
+			return new String(encoded, 0, 0, encoded.length);
+		}
+
+		/**
+		 * Encodes all remaining bytes from the specified byte buffer into
+		 * a newly-allocated ByteBuffer using the {@link Base64} encoding
+		 * scheme.
+		 *
+		 * Upon return, the source buffer's position will be updated to
+		 * its limit; its limit will not have been changed. The returned
+		 * output buffer's position will be zero and its limit will be the
+		 * number of resulting encoded bytes.
+		 *
+		 * @param   buffer
+		 *          the source ByteBuffer to encode
+		 * @return  A newly-allocated byte buffer containing the encoded bytes.
+		 */
+		public ByteBuffer encode(ByteBuffer buffer) {
+			int len = encodedOutLength(buffer.remaining(), true);
+			byte[] dst = new byte[len];
+			int ret = 0;
+			if (buffer.hasArray()) {
+				ret = encode0(buffer.array(),
+						buffer.arrayOffset() + buffer.position(),
+						buffer.arrayOffset() + buffer.limit(),
+						dst);
+				buffer.position(buffer.limit());
+			} else {
+				byte[] src = new byte[buffer.remaining()];
+				buffer.get(src);
+				ret = encode0(src, 0, src.length, dst);
+			}
+			if (ret != dst.length)
+				dst = Arrays.copyOf(dst, ret);
+			return ByteBuffer.wrap(dst);
+		}
+
+		/**
+		 * Wraps an output stream for encoding byte data using the {@link Base64}
+		 * encoding scheme.
+		 *
+		 * <p> It is recommended to promptly close the returned output stream after
+		 * use, during which it will flush all possible leftover bytes to the underlying
+		 * output stream. Closing the returned output stream will close the underlying
+		 * output stream.
+		 *
+		 * @param   os
+		 *          the output stream.
+		 * @return  the output stream for encoding the byte data into the
+		 *          specified Base64 encoded format
+		 */
+		public OutputStream wrap(OutputStream os) {
+			Objects.requireNonNull(os);
+			return new EncOutputStream(os, isURL ? toBase64URL : toBase64,
+					newline, linemax, doPadding);
+		}
+
+		/**
+		 * Returns an encoder instance that encodes equivalently to this one,
+		 * but without adding any padding character at the end of the encoded
+		 * byte data.
+		 *
+		 * <p> The encoding scheme of this encoder instance is unaffected by
+		 * this invocation. The returned encoder instance should be used for
+		 * non-padding encoding operation.
+		 *
+		 * @return an equivalent encoder that encodes without adding any
+		 *         padding character at the end
+		 */
+		public Encoder withoutPadding() {
+			if (!doPadding)
+				return this;
+			return new Encoder(isURL, newline, linemax, false);
+		}
+
+		@IntrinsicCandidate
+		private void encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {
+			char[] base64 = isURL ? toBase64URL : toBase64;
+			for (int sp0 = sp, dp0 = dp ; sp0 < sl; ) {
+				int bits = (src[sp0++] & 0xff) << 16 |
+						(src[sp0++] & 0xff) <<  8 |
+						(src[sp0++] & 0xff);
+				dst[dp0++] = (byte)base64[(bits >>> 18) & 0x3f];
+				dst[dp0++] = (byte)base64[(bits >>> 12) & 0x3f];
+				dst[dp0++] = (byte)base64[(bits >>> 6)  & 0x3f];
+				dst[dp0++] = (byte)base64[bits & 0x3f];
+			}
+		}
+
+		private int encode0(byte[] src, int off, int end, byte[] dst) {
+			char[] base64 = isURL ? toBase64URL : toBase64;
+			int sp = off;
+			int slen = (end - off) / 3 * 3;
+			int sl = off + slen;
+			if (linemax > 0 && slen  > linemax / 4 * 3)
+				slen = linemax / 4 * 3;
+			int dp = 0;
+			while (sp < sl) {
+				int sl0 = Math.min(sp + slen, sl);
+				encodeBlock(src, sp, sl0, dst, dp, isURL);
+				int dlen = (sl0 - sp) / 3 * 4;
+				dp += dlen;
+				sp = sl0;
+				if (dlen == linemax && sp < end) {
+					for (byte b : newline){
+						dst[dp++] = b;
+					}
+				}
+			}
+			if (sp < end) {               // 1 or 2 leftover bytes
+				int b0 = src[sp++] & 0xff;
+				dst[dp++] = (byte)base64[b0 >> 2];
+				if (sp == end) {
+					dst[dp++] = (byte)base64[(b0 << 4) & 0x3f];
+					if (doPadding) {
+						dst[dp++] = '=';
+						dst[dp++] = '=';
+					}
+				} else {
+					int b1 = src[sp++] & 0xff;
+					dst[dp++] = (byte)base64[(b0 << 4) & 0x3f | (b1 >> 4)];
+					dst[dp++] = (byte)base64[(b1 << 2) & 0x3f];
+					if (doPadding) {
+						dst[dp++] = '=';
+					}
+				}
+			}
+			return dp;
+		}
+	}
+
+	/**
+	 * This class implements a decoder for decoding byte data using the
+	 * Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
+	 *
+	 * <p> The Base64 padding character {@code '='} is accepted and
+	 * interpreted as the end of the encoded byte data, but is not
+	 * required. So if the final unit of the encoded byte data only has
+	 * two or three Base64 characters (without the corresponding padding
+	 * character(s) padded), they are decoded as if followed by padding
+	 * character(s). If there is a padding character present in the
+	 * final unit, the correct number of padding character(s) must be
+	 * present, otherwise {@code IllegalArgumentException} (
+	 * {@code IOException} when reading from a Base64 stream) is thrown
+	 * during decoding.
+	 *
+	 * <p> Instances of {@link Decoder} class are safe for use by
+	 * multiple concurrent threads.
+	 *
+	 * <p> Unless otherwise noted, passing a {@code null} argument to
+	 * a method of this class will cause a
+	 * {@link java.lang.NullPointerException NullPointerException} to
+	 * be thrown.
+	 * <p> If the decoded byte output of the needed size can not
+	 *     be allocated, the decode methods of this class will
+	 *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
+	 *     to be thrown.
+	 *
+	 * @see     Encoder
+	 * @since   1.8
+	 */
+	public static class Decoder {
+
+		private final boolean isURL;
+		private final boolean isMIME;
+
+		private Decoder(boolean isURL, boolean isMIME) {
+			this.isURL = isURL;
+			this.isMIME = isMIME;
+		}
+
+		/**
+		 * Lookup table for decoding unicode characters drawn from the
+		 * "Base64 Alphabet" (as specified in Table 1 of RFC 2045) into
+		 * their 6-bit positive integer equivalents.  Characters that
+		 * are not in the Base64 alphabet but fall within the bounds of
+		 * the array are encoded to -1.
+		 *
+		 */
+		private static final int[] fromBase64 = new int[256];
+		static {
+			Arrays.fill(fromBase64, -1);
+			for (int i = 0; i < Encoder.toBase64.length; i++)
+				fromBase64[Encoder.toBase64[i]] = i;
+			fromBase64['='] = -2;
+		}
+
+		/**
+		 * Lookup table for decoding "URL and Filename safe Base64 Alphabet"
+		 * as specified in Table2 of the RFC 4648.
+		 */
+		private static final int[] fromBase64URL = new int[256];
+
+		static {
+			Arrays.fill(fromBase64URL, -1);
+			for (int i = 0; i < Encoder.toBase64URL.length; i++)
+				fromBase64URL[Encoder.toBase64URL[i]] = i;
+			fromBase64URL['='] = -2;
+		}
+
+		static final Decoder RFC4648         = new Decoder(false, false);
+		static final Decoder RFC4648_URLSAFE = new Decoder(true, false);
+		static final Decoder RFC2045         = new Decoder(false, true);
+
+		/**
+		 * Decodes all bytes from the input byte array using the {@link Base64}
+		 * encoding scheme, writing the results into a newly-allocated output
+		 * byte array. The returned byte array is of the length of the resulting
+		 * bytes.
+		 *
+		 * @param   src
+		 *          the byte array to decode
+		 *
+		 * @return  A newly-allocated byte array containing the decoded bytes.
+		 *
+		 * @throws  IllegalArgumentException
+		 *          if {@code src} is not in valid Base64 scheme
+		 */
+		public byte[] decode(byte[] src) {
+			byte[] dst = new byte[decodedOutLength(src, 0, src.length)];
+			int ret = decode0(src, 0, src.length, dst);
+			if (ret != dst.length) {
+				dst = Arrays.copyOf(dst, ret);
+			}
+			return dst;
+		}
+
+		/**
+		 * Decodes a Base64 encoded String into a newly-allocated byte array
+		 * using the {@link Base64} encoding scheme.
+		 *
+		 * <p> An invocation of this method has exactly the same effect as invoking
+		 * {@code decode(src.getBytes(StandardCharsets.ISO_8859_1))}
+		 *
+		 * @param   src
+		 *          the string to decode
+		 *
+		 * @return  A newly-allocated byte array containing the decoded bytes.
+		 *
+		 * @throws  IllegalArgumentException
+		 *          if {@code src} is not in valid Base64 scheme
+		 */
+		public byte[] decode(String src) {
+			return decode(src.getBytes(ISO_8859_1.INSTANCE));
+		}
+
+		/**
+		 * Decodes all bytes from the input byte array using the {@link Base64}
+		 * encoding scheme, writing the results into the given output byte array,
+		 * starting at offset 0.
+		 *
+		 * <p> It is the responsibility of the invoker of this method to make
+		 * sure the output byte array {@code dst} has enough space for decoding
+		 * all bytes from the input byte array. No bytes will be written to
+		 * the output byte array if the output byte array is not big enough.
+		 *
+		 * <p> If the input byte array is not in valid Base64 encoding scheme
+		 * then some bytes may have been written to the output byte array before
+		 * IllegalargumentException is thrown.
+		 *
+		 * @param   src
+		 *          the byte array to decode
+		 * @param   dst
+		 *          the output byte array
+		 *
+		 * @return  The number of bytes written to the output byte array
+		 *
+		 * @throws  IllegalArgumentException
+		 *          if {@code src} is not in valid Base64 scheme, or {@code dst}
+		 *          does not have enough space for decoding all input bytes.
+		 */
+		public int decode(byte[] src, byte[] dst) {
+			int len = decodedOutLength(src, 0, src.length);
+			if (dst.length < len || len == -1)
+				throw new IllegalArgumentException(
+						"Output byte array is too small for decoding all input bytes");
+			return decode0(src, 0, src.length, dst);
+		}
+
+		/**
+		 * Decodes all bytes from the input byte buffer using the {@link Base64}
+		 * encoding scheme, writing the results into a newly-allocated ByteBuffer.
+		 *
+		 * <p> Upon return, the source buffer's position will be updated to
+		 * its limit; its limit will not have been changed. The returned
+		 * output buffer's position will be zero and its limit will be the
+		 * number of resulting decoded bytes
+		 *
+		 * <p> {@code IllegalArgumentException} is thrown if the input buffer
+		 * is not in valid Base64 encoding scheme. The position of the input
+		 * buffer will not be advanced in this case.
+		 *
+		 * @param   buffer
+		 *          the ByteBuffer to decode
+		 *
+		 * @return  A newly-allocated byte buffer containing the decoded bytes
+		 *
+		 * @throws  IllegalArgumentException
+		 *          if {@code buffer} is not in valid Base64 scheme
+		 */
+		public ByteBuffer decode(ByteBuffer buffer) {
+			int pos0 = buffer.position();
+			try {
+				byte[] src;
+				int sp, sl;
+				if (buffer.hasArray()) {
+					src = buffer.array();
+					sp = buffer.arrayOffset() + buffer.position();
+					sl = buffer.arrayOffset() + buffer.limit();
+					buffer.position(buffer.limit());
+				} else {
+					src = new byte[buffer.remaining()];
+					buffer.get(src);
+					sp = 0;
+					sl = src.length;
+				}
+				byte[] dst = new byte[decodedOutLength(src, sp, sl)];
+				return ByteBuffer.wrap(dst, 0, decode0(src, sp, sl, dst));
+			} catch (IllegalArgumentException iae) {
+				buffer.position(pos0);
+				throw iae;
+			}
+		}
+
+		/**
+		 * Returns an input stream for decoding {@link Base64} encoded byte stream.
+		 *
+		 * <p> The {@code read}  methods of the returned {@code InputStream} will
+		 * throw {@code IOException} when reading bytes that cannot be decoded.
+		 *
+		 * <p> Closing the returned input stream will close the underlying
+		 * input stream.
+		 *
+		 * @param   is
+		 *          the input stream
+		 *
+		 * @return  the input stream for decoding the specified Base64 encoded
+		 *          byte stream
+		 */
+		public InputStream wrap(InputStream is) {
+			Objects.requireNonNull(is);
+			return new DecInputStream(is, isURL ? fromBase64URL : fromBase64, isMIME);
+		}
+
+		/**
+		 * Calculates the length of the decoded output bytes.
+		 *
+		 * @param src the byte array to decode
+		 * @param sp the source  position
+		 * @param sl the source limit
+		 *
+		 * @return length of the decoded bytes
+		 *
+		 */
+		private int decodedOutLength(byte[] src, int sp, int sl) {
+			int[] base64 = isURL ? fromBase64URL : fromBase64;
+			int paddings = 0;
+			int len = sl - sp;
+			if (len == 0)
+				return 0;
+			if (len < 2) {
+				if (isMIME && base64[0] == -1)
+					return 0;
+				throw new IllegalArgumentException(
+						"Input byte[] should at least have 2 bytes for base64 bytes");
+			}
+			if (isMIME) {
+				// scan all bytes to fill out all non-alphabet. a performance
+				// trade-off of pre-scan or Arrays.copyOf
+				int n = 0;
+				while (sp < sl) {
+					int b = src[sp++] & 0xff;
+					if (b == '=') {
+						len -= (sl - sp + 1);
+						break;
+					}
+					if ((b = base64[b]) == -1)
+						n++;
+				}
+				len -= n;
+			} else {
+				if (src[sl - 1] == '=') {
+					paddings++;
+					if (src[sl - 2] == '=')
+						paddings++;
+				}
+			}
+			if (paddings == 0 && (len & 0x3) !=  0)
+				paddings = 4 - (len & 0x3);
+
+			// If len is near to Integer.MAX_VALUE, (len + 3)
+			// can possibly overflow, perform this operation as
+			// long and cast it back to integer when the value comes under
+			// integer limit. The final value will always be in integer
+			// limits
+			return 3 * (int) ((len + 3L) / 4) - paddings;
+		}
+
+		/**
+		 * Decodes base64 characters, and returns the number of data bytes
+		 * written into the destination array.
+		 *
+		 * It is the fast path for full 4-byte to 3-byte decoding w/o errors.
+		 *
+		 * decodeBlock() can be overridden by an arch-specific intrinsic.
+		 * decodeBlock can choose to decode all, none, or a variable-sized
+		 * prefix of the src bytes.  This allows the intrinsic to decode in
+		 * chunks of the src that are of a favorable size for the specific
+		 * processor it's running on.
+		 *
+		 * If the intrinsic function does not process all of the bytes in
+		 * src, it must process a multiple of four of them, making the
+		 * returned destination length a multiple of three.
+		 *
+		 * If any illegal base64 bytes are encountered in src by the
+		 * intrinsic, the intrinsic must return the actual number of valid
+		 * data bytes already written to dst.  Note that the '=' pad
+		 * character is treated as an illegal Base64 character by
+		 * decodeBlock, so it will not process a block of 4 bytes
+		 * containing pad characters.
+		 *
+		 * Given the parameters, no length check is possible on dst, so dst
+		 * is assumed to be large enough to store the decoded bytes.
+		 *
+		 * @param  src
+		 *         the source byte array of Base64 encoded bytes
+		 * @param  sp
+		 *         the offset into src array to begin reading
+		 * @param  sl
+		 *         the offset (exclusive) past the last byte to be converted.
+		 * @param  dst
+		 *         the destination byte array of decoded data bytes
+		 * @param  dp
+		 *         the offset into dst array to begin writing
+		 * @param  isURL
+		 *         boolean, when true decode RFC4648 URL-safe base64 characters
+		 * @return the number of destination data bytes produced
+		 */
+		@IntrinsicCandidate
+		private int decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {
+			int[] base64 = isURL ? fromBase64URL : fromBase64;
+			int sl0 = sp + ((sl - sp) & ~0b11);
+			int new_dp = dp;
+			while (sp < sl0) {
+				int b1 = base64[src[sp++] & 0xff];
+				int b2 = base64[src[sp++] & 0xff];
+				int b3 = base64[src[sp++] & 0xff];
+				int b4 = base64[src[sp++] & 0xff];
+				if ((b1 | b2 | b3 | b4) < 0) {    // non base64 byte
+					return new_dp - dp;
+				}
+				int bits0 = b1 << 18 | b2 << 12 | b3 << 6 | b4;
+				dst[new_dp++] = (byte)(bits0 >> 16);
+				dst[new_dp++] = (byte)(bits0 >>  8);
+				dst[new_dp++] = (byte)(bits0);
+			}
+			return new_dp - dp;
+		}
+
+		private int decode0(byte[] src, int sp, int sl, byte[] dst) {
+			int[] base64 = isURL ? fromBase64URL : fromBase64;
+			int dp = 0;
+			int bits = 0;
+			int shiftto = 18;       // pos of first byte of 4-byte atom
+
+			while (sp < sl) {
+				if (shiftto == 18 && sp < sl - 4) {       // fast path
+					int dl = decodeBlock(src, sp, sl, dst, dp, isURL);
+					/*
+					 * Calculate how many characters were processed by how many
+					 * bytes of data were returned.
+					 */
+					int chars_decoded = (dl / 3) * 4;
+
+					sp += chars_decoded;
+					dp += dl;
+				}
+				if (sp >= sl) {
+					// we're done
+					break;
+				}
+				int b = src[sp++] & 0xff;
+				if ((b = base64[b]) < 0) {
+					if (b == -2) {         // padding byte '='
+						// =     shiftto==18 unnecessary padding
+						// x=    shiftto==12 a dangling single x
+						// x     to be handled together with non-padding case
+						// xx=   shiftto==6&&sp==sl missing last =
+						// xx=y  shiftto==6 last is not =
+						if (shiftto == 6 && (sp == sl || src[sp++] != '=') ||
+								shiftto == 18) {
+							throw new IllegalArgumentException(
+									"Input byte array has wrong 4-byte ending unit");
+						}
+						break;
+					}
+					if (isMIME)    // skip if for rfc2045
+						continue;
+					else
+						throw new IllegalArgumentException(
+								"Illegal base64 character " +
+										Integer.toString(src[sp - 1], 16));
+				}
+				bits |= (b << shiftto);
+				shiftto -= 6;
+				if (shiftto < 0) {
+					dst[dp++] = (byte)(bits >> 16);
+					dst[dp++] = (byte)(bits >>  8);
+					dst[dp++] = (byte)(bits);
+					shiftto = 18;
+					bits = 0;
+				}
+			}
+			// reached end of byte array or hit padding '=' characters.
+			if (shiftto == 6) {
+				dst[dp++] = (byte)(bits >> 16);
+			} else if (shiftto == 0) {
+				dst[dp++] = (byte)(bits >> 16);
+				dst[dp++] = (byte)(bits >>  8);
+			} else if (shiftto == 12) {
+				// dangling single "x", incorrectly encoded.
+				throw new IllegalArgumentException(
+						"Last unit does not have enough valid bits");
+			}
+			// anything left is invalid, if is not MIME.
+			// if MIME, ignore all non-base64 character
+			while (sp < sl) {
+				if (isMIME && base64[src[sp++] & 0xff] < 0)
+					continue;
+				throw new IllegalArgumentException(
+						"Input byte array has incorrect ending byte at " + sp);
+			}
+			return dp;
+		}
+	}
+
+	/*
+	 * An output stream for encoding bytes into the Base64.
+	 */
+	private static class EncOutputStream extends FilterOutputStream {
+
+		private int leftover = 0;
+		private int b0, b1, b2;
+		private boolean closed = false;
+
+		private final char[] base64;    // byte->base64 mapping
+		private final byte[] newline;   // line separator, if needed
+		private final int linemax;
+		private final boolean doPadding;// whether or not to pad
+		private int linepos = 0;
+		private byte[] buf;
+
+		EncOutputStream(OutputStream os, char[] base64,
+		                byte[] newline, int linemax, boolean doPadding) {
+			super(os);
+			this.base64 = base64;
+			this.newline = newline;
+			this.linemax = linemax;
+			this.doPadding = doPadding;
+			this.buf = new byte[linemax <= 0 ? 8124 : linemax];
+		}
+
+		@Override
+		public void write(int b) throws IOException {
+			byte[] buf = new byte[1];
+			buf[0] = (byte)(b & 0xff);
+			write(buf, 0, 1);
+		}
+
+		private void checkNewline() throws IOException {
+			if (linepos == linemax) {
+				out.write(newline);
+				linepos = 0;
+			}
+		}
+
+		private void writeb4(char b1, char b2, char b3, char b4) throws IOException {
+			buf[0] = (byte)b1;
+			buf[1] = (byte)b2;
+			buf[2] = (byte)b3;
+			buf[3] = (byte)b4;
+			out.write(buf, 0, 4);
+		}
+
+		@Override
+		public void write(byte[] b, int off, int len) throws IOException {
+			if (closed)
+				throw new IOException("Stream is closed");
+			if (off < 0 || len < 0 || len > b.length - off)
+				throw new ArrayIndexOutOfBoundsException();
+			if (len == 0)
+				return;
+			if (leftover != 0) {
+				if (leftover == 1) {
+					b1 = b[off++] & 0xff;
+					len--;
+					if (len == 0) {
+						leftover++;
+						return;
+					}
+				}
+				b2 = b[off++] & 0xff;
+				len--;
+				checkNewline();
+				writeb4(base64[b0 >> 2],
+						base64[(b0 << 4) & 0x3f | (b1 >> 4)],
+						base64[(b1 << 2) & 0x3f | (b2 >> 6)],
+						base64[b2 & 0x3f]);
+				linepos += 4;
+			}
+			int nBits24 = len / 3;
+			leftover = len - (nBits24 * 3);
+
+			while (nBits24 > 0) {
+				checkNewline();
+				int dl = linemax <= 0 ? buf.length : buf.length - linepos;
+				int sl = off + Math.min(nBits24, dl / 4) * 3;
+				int dp = 0;
+				for (int sp = off; sp < sl; ) {
+					int bits = (b[sp++] & 0xff) << 16 |
+							(b[sp++] & 0xff) <<  8 |
+							(b[sp++] & 0xff);
+					buf[dp++] = (byte)base64[(bits >>> 18) & 0x3f];
+					buf[dp++] = (byte)base64[(bits >>> 12) & 0x3f];
+					buf[dp++] = (byte)base64[(bits >>> 6)  & 0x3f];
+					buf[dp++] = (byte)base64[bits & 0x3f];
+				}
+				out.write(buf, 0, dp);
+				off = sl;
+				linepos += dp;
+				nBits24 -= dp / 4;
+			}
+			if (leftover == 1) {
+				b0 = b[off++] & 0xff;
+			} else if (leftover == 2) {
+				b0 = b[off++] & 0xff;
+				b1 = b[off++] & 0xff;
+			}
+		}
+
+		@Override
+		public void close() throws IOException {
+			if (!closed) {
+				closed = true;
+				if (leftover == 1) {
+					checkNewline();
+					out.write(base64[b0 >> 2]);
+					out.write(base64[(b0 << 4) & 0x3f]);
+					if (doPadding) {
+						out.write('=');
+						out.write('=');
+					}
+				} else if (leftover == 2) {
+					checkNewline();
+					out.write(base64[b0 >> 2]);
+					out.write(base64[(b0 << 4) & 0x3f | (b1 >> 4)]);
+					out.write(base64[(b1 << 2) & 0x3f]);
+					if (doPadding) {
+						out.write('=');
+					}
+				}
+				leftover = 0;
+				out.close();
+			}
+		}
+	}
+
+	/*
+	 * An input stream for decoding Base64 bytes
+	 */
+	private static class DecInputStream extends InputStream {
+
+		private final InputStream is;
+		private final boolean isMIME;
+		private final int[] base64;     // base64 -> byte mapping
+		private int bits = 0;           // 24-bit buffer for decoding
+
+		/* writing bit pos inside bits; one of 24 (left, msb), 18, 12, 6, 0 */
+		private int wpos = 0;
+
+		/* reading bit pos inside bits: one of 24 (left, msb), 16, 8, 0 */
+		private int rpos = 0;
+
+		private boolean eof = false;
+		private boolean closed = false;
+
+		DecInputStream(InputStream is, int[] base64, boolean isMIME) {
+			this.is = is;
+			this.base64 = base64;
+			this.isMIME = isMIME;
+		}
+
+		private byte[] sbBuf = new byte[1];
+
+		@Override
+		public int read() throws IOException {
+			return read(sbBuf, 0, 1) == -1 ? -1 : sbBuf[0] & 0xff;
+		}
+
+		private int leftovers(byte[] b, int off, int pos, int limit) {
+			eof = true;
+
+			/*
+			 * We use a loop here, as this method is executed only a few times.
+			 * Unrolling the loop would probably not contribute much here.
+			 */
+			while (rpos - 8 >= wpos && pos != limit) {
+				rpos -= 8;
+				b[pos++] = (byte) (bits >> rpos);
+			}
+			return pos - off != 0 || rpos - 8 >= wpos ? pos - off : -1;
+		}
+
+		private int eof(byte[] b, int off, int pos, int limit) throws IOException {
+			/*
+			 * pos != limit
+			 *
+			 * wpos == 18: x     dangling single x, invalid unit
+			 * accept ending xx or xxx without padding characters
+			 */
+			if (wpos == 18) {
+				throw new IOException("Base64 stream has one un-decoded dangling byte.");
+			}
+			rpos = 24;
+			return leftovers(b, off, pos, limit);
+		}
+
+		private int padding(byte[] b, int off, int pos, int limit) throws IOException {
+			/*
+			 * pos != limit
+			 *
+			 * wpos == 24: =    (unnecessary padding)
+			 * wpos == 18: x=   (dangling single x, invalid unit)
+			 * wpos == 12 and missing last '=': xx=  (invalid padding)
+			 * wpos == 12 and last is not '=': xx=x (invalid padding)
+			 */
+			if (wpos >= 18 || wpos == 12 && is.read() != '=') {
+				throw new IOException("Illegal base64 ending sequence:" + wpos);
+			}
+			rpos = 24;
+			return leftovers(b, off, pos, limit);
+		}
+
+		@Override
+		public int read(byte[] b, int off, int len) throws IOException {
+			if (closed) {
+				throw new IOException("Stream is closed");
+			}
+			Objects.checkFromIndexSize(off, len, b.length);
+			if (len == 0) {
+				return 0;
+			}
+
+			/*
+			 * Rather than keeping 2 running vars (e.g., off and len),
+			 * we only keep one (pos), while definitely fixing the boundaries
+			 * of the range [off, limit).
+			 * More specifically, each use of pos as an index in b meets
+			 *      pos - off >= 0 & limit - pos > 0
+			 *
+			 * Note that limit can overflow to Integer.MIN_VALUE. However,
+			 * as long as comparisons with pos are as coded, there's no harm.
+			 */
+			int pos = off;
+			final int limit = off + len;
+			if (eof) {
+				return leftovers(b, off, pos, limit);
+			}
+
+			/*
+			 * Leftovers from previous invocation; here, wpos = 0.
+			 * There can be at most 2 leftover bytes (rpos <= 16).
+			 * Further, b has at least one free place.
+			 *
+			 * The logic could be coded as a loop, (as in method leftovers())
+			 * but the explicit "unrolling" makes it possible to generate
+			 * better byte extraction code.
+			 */
+			if (rpos == 16) {
+				b[pos++] = (byte) (bits >> 8);
+				rpos = 8;
+				if (pos == limit) {
+					return len;
+				}
+			}
+			if (rpos == 8) {
+				b[pos++] = (byte) bits;
+				rpos = 0;
+				if (pos == limit) {
+					return len;
+				}
+			}
+
+			bits = 0;
+			wpos = 24;
+			for (;;) {
+				/* pos != limit & rpos == 0 */
+				final int i = is.read();
+				if (i < 0) {
+					return eof(b, off, pos, limit);
+				}
+				final int v = base64[i];
+				if (v < 0) {
+					/*
+					 * i not in alphabet, thus
+					 *      v == -2: i is '=', the padding
+					 *      v == -1: i is something else, typically CR or LF
+					 */
+					if (v == -1) {
+						if (isMIME) {
+							continue;
+						}
+						throw new IOException("Illegal base64 character 0x" +
+								Integer.toHexString(i));
+					}
+					return padding(b, off, pos, limit);
+				}
+				wpos -= 6;
+				bits |= v << wpos;
+				if (wpos != 0) {
+					continue;
+				}
+				if (limit - pos >= 3) {
+					/* frequently taken fast path, no need to track rpos */
+					b[pos++] = (byte) (bits >> 16);
+					b[pos++] = (byte) (bits >> 8);
+					b[pos++] = (byte) bits;
+					bits = 0;
+					wpos = 24;
+					if (pos == limit) {
+						return len;
+					}
+					continue;
+				}
+
+				/* b has either 1 or 2 free places */
+				b[pos++] = (byte) (bits >> 16);
+				if (pos == limit) {
+					rpos = 16;
+					return len;
+				}
+				b[pos++] = (byte) (bits >> 8);
+				/* pos == limit, no need for an if */
+				rpos = 8;
+				return len;
+			}
+		}
+
+		@Override
+		public int available() throws IOException {
+			if (closed)
+				throw new IOException("Stream is closed");
+			return is.available();   // TBD:
+		}
+
+		@Override
+		public void close() throws IOException {
+			if (!closed) {
+				closed = true;
+				is.close();
+			}
+		}
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/Base64rfc4648.java b/src/main/java/dk/xpreuss/xperimentering/basex/Base64rfc4648.java
new file mode 100644
index 0000000..301410d
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/Base64rfc4648.java
@@ -0,0 +1,157 @@
+package dk.xpreuss.xperimentering.basex;
+
+import dk.xpreuss.xperimentering.SafeMath;
+import dk.xpreuss.xperimentering.basex.coders.*;
+
+/**
+ * See https://stackoverflow.com/questions/13378815/base64-length-calculation
+ * <p>
+ * Different types of base64 length calculations:
+ * Padding: Math.floor(n+2) / 3 * 4
+ * UnPadding: Math.floor(n*4+2) / 3
+ */
+public class Base64rfc4648 {
+	/**
+	 * This is the ceil division of ceil(x / y)
+	 * See https://stackoverflow.com/a/45401395/4711156
+	 *
+	 * @param x value
+	 * @param y value
+	 * @return the divided x by y ceil
+	 */
+	private static int ceilDiv(int x, int y) {
+		// Remember it's like Maths.floor(x+y-1) / y
+		return (x + y - 1) / y;
+	}
+
+	private static long ceilDiv(long x, long y) {
+		// Remember it's like Maths.floor(x+y-1) / y
+		return (x + y - 1) / y;
+	}
+
+	private static int ceilDivSafe(int x, int y) {
+		// Remember it's like Maths.floor(x+y-1) / y
+		return SafeMath.safeDivide(Math.subtractExact(Math.addExact(x, y), 1), y);
+	}
+
+	private static long ceilDivSafe(long x, long y) {
+		// Remember it's like Maths.floor(x+y-1) / y
+		return SafeMath.safeDivide(Math.subtractExact(Math.addExact(x, y), 1), y);
+	}
+
+	private static int paddedBase64(int n) {
+		int blocks = ceilDiv(n, 3);
+		return blocks * 4;
+	}
+
+	private static long paddedBase64(long n) {
+		long blocks = ceilDiv(n, 3);
+		return blocks * 4;
+	}
+
+	private static int paddedBase64Safe(int n) {
+		int blocks = ceilDivSafe(n, 3);
+		return Math.multiplyExact(blocks, 4);
+	}
+
+	private static long paddedBase64Safe(long n) {
+		long blocks = ceilDivSafe(n, 3);
+		return Math.multiplyExact(blocks, 4);
+	}
+
+	public static int unpaddedBase64(int n) {
+		int bits = 8 * n;
+		return ceilDiv(bits, 6);
+	}
+
+	public static long unpaddedBase64(long n) {
+		long bits = 8 * n;
+		return ceilDiv(bits, 6);
+	}
+
+	private static int unpaddedBase64Safe(int n) {
+		int bits = Math.multiplyExact(8, n);
+		return ceilDivSafe(bits, 6);
+	}
+
+	private static long unpaddedBase64Safe(long n) {
+		long bits = Math.multiplyExact(8, n);
+		return ceilDivSafe(bits, 6);
+	}
+
+	/**
+	 * Calculates the length of the encoded output bytes.
+	 *
+	 * @param srcLength        length of the bytes to encode
+	 * @param padded           if true, tells if it should be padded
+	 * @param safeAndThrowOOME if true, tells if it should test for overflow,
+	 *                         and throws OutOfMemoryError if the length of
+	 *                         the encoded bytes overflows; else returns the
+	 *                         length
+	 * @return length of the encoded bytes, or -1 if the length overflows
+	 */
+	public static int calculateOutLenght(int srcLength, boolean padded, boolean safeAndThrowOOME) {
+		// Always test for overflow
+		final boolean safe = safeAndThrowOOME;
+		try {
+			if (padded) {
+				if (safe) {
+					return paddedBase64Safe(srcLength);
+				} else {
+					return paddedBase64(srcLength);
+				}
+			} else {
+				if (safe) {
+					return unpaddedBase64Safe(srcLength);
+				} else {
+					return unpaddedBase64(srcLength);
+				}
+			}
+		} catch (ArithmeticException e) {
+			if (safeAndThrowOOME) {
+				throw new OutOfMemoryError("Encoded size is too large");
+			} else {
+				// let the caller know that encoded bytes length is too large
+				return -1;
+			}
+		}
+	}
+
+	/**
+	 * Calculates the length of the encoded output bytes.
+	 *
+	 * @param srcLength        length of the bytes to encode
+	 * @param padded           if true, tells if it should be padded
+	 * @param safeAndThrowOOME if true, tells if it should test for overflow,
+	 *                         and throws OutOfMemoryError if the length of
+	 *                         the encoded bytes overflows; else returns the
+	 *                         length
+	 * @return length of the encoded bytes, or -1 if the length overflows
+	 */
+	public static long calculateOutLenght(long srcLength, boolean padded, boolean safeAndThrowOOME) {
+		// Always test for overflow
+		final boolean safe = safeAndThrowOOME;
+		try {
+			if (padded) {
+				if (safe) {
+					return paddedBase64Safe(srcLength);
+				} else {
+					return paddedBase64(srcLength);
+				}
+			} else {
+				if (safe) {
+					return unpaddedBase64Safe(srcLength);
+				} else {
+					return unpaddedBase64(srcLength);
+				}
+			}
+		} catch (ArithmeticException e) {
+			if (safeAndThrowOOME) {
+				throw new OutOfMemoryError("Encoded size is too large");
+			} else {
+				// let the caller know that encoded bytes length is too large
+				return -1;
+			}
+		}
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/IBase64.java b/src/main/java/dk/xpreuss/xperimentering/basex/IBase64.java
new file mode 100644
index 0000000..5bb8f49
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/IBase64.java
@@ -0,0 +1,10 @@
+package dk.xpreuss.xperimentering.basex;
+
+public interface IBase64 {
+	interface Decoder {
+
+	}
+	interface Encoder {
+
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/IBaseNDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/IBaseNDecoder.java
new file mode 100644
index 0000000..725d78c
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/IBaseNDecoder.java
@@ -0,0 +1,5 @@
+package dk.xpreuss.xperimentering.basex;
+
+public interface IBaseNDecoder {
+	byte[] decode(byte[] src);
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/IBaseNEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/IBaseNEncoder.java
new file mode 100644
index 0000000..8652c25
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/IBaseNEncoder.java
@@ -0,0 +1,5 @@
+package dk.xpreuss.xperimentering.basex;
+
+public interface IBaseNEncoder {
+	byte[] encode(byte[] src);
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferDecodeable.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferDecodeable.java
new file mode 100644
index 0000000..52da3ff
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferDecodeable.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface ByteBufferDecodeable {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferEncodeable.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferEncodeable.java
new file mode 100644
index 0000000..2f26ca7
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteBufferEncodeable.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface ByteBufferEncodeable {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteDecodeable.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteDecodeable.java
new file mode 100644
index 0000000..b538748
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteDecodeable.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface ByteDecodeable {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteEncodeable.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteEncodeable.java
new file mode 100644
index 0000000..02c6b8c
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/ByteEncodeable.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface ByteEncodeable {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteCodec.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteCodec.java
new file mode 100644
index 0000000..65e0022
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteCodec.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IByteCodec extends IByteDecoder, IByteEncoder{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteDecoder.java
new file mode 100644
index 0000000..c894c27
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteDecoder.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IByteDecoder extends IDecoder<byte[], byte[]>{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteEncoder.java
new file mode 100644
index 0000000..063d6a8
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteEncoder.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IByteEncoder extends IEncoder<byte[], byte[]> {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringCodec.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringCodec.java
new file mode 100644
index 0000000..e701f62
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringCodec.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IByteStringCodec extends IByteStringEncoder, IByteStringDecoder {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringDecoder.java
new file mode 100644
index 0000000..a6db36a
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringDecoder.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IByteStringDecoder extends IDecoder<Byte[], String>{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringEncoder.java
new file mode 100644
index 0000000..b6d30da
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IByteStringEncoder.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IByteStringEncoder extends IEncoder<Byte[], String>{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IDecoder.java
new file mode 100644
index 0000000..2f232e6
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IDecoder.java
@@ -0,0 +1,5 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IDecoder<TSource,UDestination> {
+	UDestination decode(TSource src);
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IEncoder.java
new file mode 100644
index 0000000..669989e
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IEncoder.java
@@ -0,0 +1,5 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IEncoder<TSource,UDestination> {
+	UDestination encode(TSource src);
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteCodec.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteCodec.java
new file mode 100644
index 0000000..fcb40fa
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteCodec.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IStringByteCodec extends IStringByteEncoder, IStringByteDecoder{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteDecoder.java
new file mode 100644
index 0000000..868a115
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteDecoder.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IStringByteDecoder {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteEncoder.java
new file mode 100644
index 0000000..6d5d2c7
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringByteEncoder.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IStringByteEncoder extends IEncoder<String, byte[]>{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringCodec.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringCodec.java
new file mode 100644
index 0000000..71cea45
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringCodec.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IStringCodec extends IStringEncoder, IStringDecoder{
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringDecoder.java
new file mode 100644
index 0000000..97d9d8c
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringDecoder.java
@@ -0,0 +1,5 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IStringDecoder extends IDecoder<String, String> {
+	String decode(String src);
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringEncoder.java
new file mode 100644
index 0000000..360fba3
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/coders/IStringEncoder.java
@@ -0,0 +1,5 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+public interface IStringEncoder extends IEncoder<String, String> {
+	String encode(String src);
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/mycoder/MyEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/mycoder/MyEncoder.java
new file mode 100644
index 0000000..b78ce7f
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/mycoder/MyEncoder.java
@@ -0,0 +1,152 @@
+package dk.xpreuss.xperimentering.basex.mycoder;
+
+import java.io.ByteArrayInputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.function.IntFunction;
+import java.util.stream.IntStream;
+
+public class MyEncoder {
+	/**
+	 * This array is a lookup table that translates 6-bit positive integer
+	 * index values into their "Base64 Alphabet" equivalents as specified
+	 * in "Table 1: The Base64 Alphabet" of RFC 2045 (and RFC 4648).
+	 */
+	private static final char[] toBase64 = {
+			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+			'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+			'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+			'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
+	};
+
+
+	/**
+	 * It's the lookup table for "URL and Filename safe Base64" as specified
+	 * in Table 2 of the RFC 4648, with the '+' and '/' changed to '-' and
+	 * '_'. This table is used when BASE64_URL is specified.
+	 */
+	private static final char[] toBase64URL = {
+			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+			'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
+			'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
+			'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
+			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'
+	};
+
+	public static void main(String[] args) throws InterruptedException {
+		final String srcStr = "asdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrf";
+		final byte[] src = srcStr.getBytes(StandardCharsets.UTF_8);
+		int[] intArray = {1,2,3,4,5};
+//		Arrays.stream(intArray).;
+
+		boolean throwOOME = false;
+		boolean isURL = false;
+		boolean doPadding = true;
+		int linemax = -1;
+		byte[] newline = null;
+
+		final int max = 1;
+		long start, end;
+		start = System.nanoTime();
+		for (int i = 0; i < max; i++) {
+			//Thread.sleep(2000);
+			final byte[] encodedData = encode(src, throwOOME, isURL, doPadding, linemax, newline);
+		}
+		end = System.nanoTime();
+		System.out.println("Time: " + ((double) (end - start)) / 1_000_000_000 + " sekunder");
+	}
+
+	public static byte[] encode(final byte[] src, final boolean throwOOME, final boolean isURL, final boolean doPadding, final int linemax, final byte[] newline) {
+		final char[] base64TranslationTable = isURL ? toBase64URL : toBase64;
+		final int len = encodedOutLength(src.length, true, doPadding, linemax, newline);          // dst array size
+		final byte[] dst = new byte[len];
+		System.out.println("src.length: " + src.length);
+		System.out.println("src.length/4: " + src.length / 4);
+		System.out.println("src.length%4: " + src.length % 4);
+		final int ret = encode0(src, 0, src.length, dst, base64TranslationTable, doPadding, linemax, newline);
+		if (ret != dst.length) {
+			return Arrays.copyOf(dst, ret);
+		}
+		return dst;
+	}
+
+	private static int encodedOutLength(int srclen, boolean throwOOME, boolean doPadding, int linemax, byte[] newline) {
+		int len = 0;
+		try {
+			if (doPadding) {
+				len = Math.multiplyExact(4, (Math.addExact(srclen, 2) / 3));
+			} else {
+				int n = srclen % 3;
+				len = Math.addExact(Math.multiplyExact(4, (srclen / 3)), (n == 0 ? 0 : n + 1));
+			}
+			if (linemax > 0) {                             // line separators
+				len = Math.addExact(len, (len - 1) / linemax * newline.length);
+			}
+		} catch (ArithmeticException ex) {
+			if (throwOOME) {
+				throw new OutOfMemoryError("Encoded size is too large");
+			} else {
+				// let the caller know that encoded bytes length
+				// is too large
+				len = -1;
+			}
+		}
+		return len;
+	}
+
+	private static void encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, final char[] base64TranslationTable) {
+		char[] base64 = base64TranslationTable;
+		for (int sp0 = sp, dp0 = dp; sp0 < sl; ) {
+			int bits = (src[sp0++] & 0xff) << 16 |
+					(src[sp0++] & 0xff) << 8 |
+					(src[sp0++] & 0xff);
+			dst[dp0++] = (byte) base64[(bits >>> 18) & 0x3f];
+			dst[dp0++] = (byte) base64[(bits >>> 12) & 0x3f];
+			dst[dp0++] = (byte) base64[(bits >>> 6) & 0x3f];
+			dst[dp0++] = (byte) base64[bits & 0x3f];
+		}
+	}
+
+	private static int encode0(byte[] src, int off, int end, byte[] dst, final char[] base64TranslationTable, boolean doPadding, int linemax, byte[] newline) {
+		char[] base64 = base64TranslationTable;
+		int sp = off;
+		int slen = (end - off) / 3 * 3;
+		int sl = off + slen;
+		if (linemax > 0 && slen > linemax / 4 * 3)
+			slen = linemax / 4 * 3;
+		int dp = 0;
+		while (sp < sl) {
+			int sl0 = Math.min(sp + slen, sl);
+			encodeBlock(src, sp, sl0, dst, dp, base64);
+			int dlen = (sl0 - sp) / 3 * 4;
+			dp += dlen;
+			sp = sl0;
+			if (dlen == linemax && sp < end) {
+				for (byte b : newline) {
+					dst[dp++] = b;
+				}
+			}
+		}
+		if (sp < end) {               // 1 or 2 leftover bytes
+			int b0 = src[sp++] & 0xff;
+			dst[dp++] = (byte) base64[b0 >> 2];
+			if (sp == end) {
+				dst[dp++] = (byte) base64[(b0 << 4) & 0x3f];
+				if (doPadding) {
+					dst[dp++] = '=';
+					dst[dp++] = '=';
+				}
+			} else {
+				int b1 = src[sp++] & 0xff;
+				dst[dp++] = (byte) base64[(b0 << 4) & 0x3f | (b1 >> 4)];
+				dst[dp++] = (byte) base64[(b1 << 2) & 0x3f];
+				if (doPadding) {
+					dst[dp++] = '=';
+				}
+			}
+		}
+		return dp;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.c b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.c
new file mode 100644
index 0000000..314e072
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.c
@@ -0,0 +1,35 @@
+static const int B64index[256] = { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62, 63, 62, 62, 63, 52, 53, 54, 55,
+56, 57, 58, 59, 60, 61,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,
+7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,  0,
+0,  0,  0, 63,  0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 };
+
+std::string b64decode(const void* data, const size_t len)
+{
+    unsigned char* p = (unsigned char*)data;
+    int pad = len > 0 && (len % 4 || p[len - 1] == '=');
+    const size_t L = ((len + 3) / 4 - pad) * 4;
+    std::string str(L / 4 * 3 + pad, '\0');
+
+    for (size_t i = 0, j = 0; i < L; i += 4)
+    {
+        int n = B64index[p[i]] << 18 | B64index[p[i + 1]] << 12 | B64index[p[i + 2]] << 6 | B64index[p[i + 3]];
+        str[j++] = n >> 16;
+        str[j++] = n >> 8 & 0xFF;
+        str[j++] = n & 0xFF;
+    }
+    if (pad)
+    {
+        int n = B64index[p[L]] << 18 | B64index[p[L + 1]] << 12;
+        str[str.size() - 1] = n >> 16;
+
+        if (len > L + 2 && p[L + 2] != '=')
+        {
+            n |= B64index[p[L + 2]] << 6;
+            str.push_back(n >> 8 & 0xFF);
+        }
+    }
+    return str;
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.java
new file mode 100644
index 0000000..3d59a6c
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCDecoder.java
@@ -0,0 +1,72 @@
+package dk.xpreuss.xperimentering.basex.speedc;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.stream.IntStream;
+
+public class SpeedCDecoder {
+	private static final byte[] BASE64_INDEX = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63, 52, 53, 54, 55,
+			56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6,
+			7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,
+			0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+			41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};
+
+	public static void main(String[] args) {
+//		final String encodedText = "aGVsbG8="; // hello
+//		final String encodedText = "aGVsbG/m+OW9pySA"; // hello√¶√∏√•¬Ω¬ß$‚Ç¨
+		final String encodedText = "aGVsbG/DpsO4w6XCvcKnJOKCrA=="; // hello√¶√∏√•¬Ω¬ß$‚Ç¨
+
+		String output = decode(encodedText.getBytes());
+		for (String s : Charset.availableCharsets().keySet()) {
+			System.out.println("Key: " + s);
+		}
+		System.out.println("=>" + output + "<= MY decoding");
+		System.out.println("->" + new String(Base64.getDecoder().decode(encodedText.getBytes())) + "<- JAVA's own");
+
+	}
+
+	/**
+	 * Base64 Decoder
+	 * Base64 encoding/decoding (RFC1341)
+	 * Copyright (c) 2021, Jesper Preuss jesperpreuss@yahoo.dk
+	 *
+	 * @param src encoded Data to be decoded in bytes
+	 * @return the decoded data to bytes, you have to convert to string yourself.
+	 */
+	public static String decode(final byte[] src) {
+		final int srcLength = src.length;
+		final boolean pad = srcLength > 0 && ((srcLength % 4) > 0 || src[srcLength - 1] == '=');
+		final int outLength = ((srcLength + 3) / 4 - (pad ? 1 : 0)) * 4;
+		final int strLength = outLength / 4 * 3 + (pad ? 1 : 0);
+		final int[] out = new int[strLength + 1];
+
+		for (int i = 0, j = 0; i < outLength; i += 4) {
+			int n = BASE64_INDEX[src[i]] << 18 | BASE64_INDEX[src[i + 1]] << 12 | BASE64_INDEX[src[i + 2]] << 6 | BASE64_INDEX[src[i + 3]];
+			out[j++] = n >> 16;
+			out[j++] = n >> 8 & 0b1111_1111;
+			out[j++] = n & 0b1111_1111;
+		}
+		if (pad) {
+			int n = BASE64_INDEX[src[outLength]] << 18 | BASE64_INDEX[src[outLength + 1]] << 12;
+			out[strLength - 1] = n >> 16;
+
+			if (srcLength > (outLength + 2) && src[outLength + 2] != '=') {
+				n |= BASE64_INDEX[src[outLength + 2]] << 6;
+				out[strLength] = n >> 8 & 0b1111_1111;
+			}
+
+		}
+
+		byte [] newOut = new byte[out.length-1];
+		for(int i =0;i<newOut.length;i++) {
+			newOut[i] = (byte) out[i];
+		}
+
+		return new String(newOut);
+	}
+
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.c b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.c
new file mode 100644
index 0000000..8ed4599
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.c
@@ -0,0 +1,67 @@
+/*
+* Base64 encoding/decoding (RFC1341)
+* Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi>
+*
+* This software may be distributed under the terms of the BSD license.
+* See README for more details.
+*/
+
+// 2016-12-12 - Gaspard Petit : Slightly modified to return a std::string
+// instead of a buffer allocated with malloc.
+
+#include <string>
+
+static const unsigned char base64_table[65] =
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+/**
+* base64_encode - Base64 encode
+* @src: Data to be encoded
+* @len: Length of the data to be encoded
+* @out_len: Pointer to output length variable, or %NULL if not used
+* Returns: Allocated buffer of out_len bytes of encoded data,
+* or empty string on failure
+*/
+std::string base64_encode(const unsigned char *src, size_t len)
+{
+    unsigned char *out, *pos;
+    const unsigned char *end, *in;
+
+    size_t olen;
+
+    olen = 4*((len + 2) / 3); /* 3-byte blocks to 4-byte */
+
+    if (olen < len)
+        return std::string(); /* integer overflow */
+
+    std::string outStr;
+    outStr.resize(olen);
+    out = (unsigned char*)&outStr[0];
+
+    end = src + len;
+    in = src;
+    pos = out;
+    while (end - in >= 3) {
+        *pos++ = base64_table[in[0] >> 2];
+        *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
+        *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
+        *pos++ = base64_table[in[2] & 0x3f];
+        in += 3;
+    }
+
+    if (end - in) {
+        *pos++ = base64_table[in[0] >> 2];
+        if (end - in == 1) {
+            *pos++ = base64_table[(in[0] & 0x03) << 4];
+            *pos++ = '=';
+        }
+        else {
+            *pos++ = base64_table[((in[0] & 0x03) << 4) |
+                (in[1] >> 4)];
+            *pos++ = base64_table[(in[1] & 0x0f) << 2];
+        }
+        *pos++ = '=';
+    }
+
+    return outStr;
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.java b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.java
new file mode 100644
index 0000000..8288faf
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/speedc/SpeedCEncoder.java
@@ -0,0 +1,79 @@
+package dk.xpreuss.xperimentering.basex.speedc;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Base64;
+
+public class SpeedCEncoder {
+	private static final byte[] BASE64_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".getBytes();
+
+	public static void main(String[] args) throws InterruptedException {
+		final String originalText = "hello√¶√∏√•¬Ω¬ß$‚Ç¨";
+//		final String originalText = "√¶helloworld";
+
+//		byte[] output = encode(originalText.getBytes());
+		byte[] output = encode(originalText.getBytes(StandardCharsets.UTF_8));
+		System.out.println("=>" + new String(output) + "<= MY Calculation");
+		System.out.println("->" + new String(Base64.getEncoder().encode(originalText.getBytes(StandardCharsets.UTF_8))) + "<- JAVA's own");
+
+		final String textA = "asdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrfasdf√¶lkjasdf√¶lkjasdflkjasdflkjas√¶ldkfjas√¶ldkfja√¶sldkfhj√¶alsndrv√¶oislernv√¶lsijrf";
+		final int max = 1_000_00;
+		long start, end;
+		start = System.nanoTime();
+		for(int i=0;i<max;i++) {
+			final byte [] encodedData = Base64.getEncoder().encode(textA.getBytes(StandardCharsets.UTF_8));
+		}
+		end = System.nanoTime();
+		System.out.println("Time: " + ((double)(end-start))/1_000_000_000 + " sekunder");
+
+		start = System.nanoTime();
+		for(int i=0;i<max;i++) {
+			final byte [] encodedData = encode(textA.getBytes(StandardCharsets.UTF_8));
+		}
+		end = System.nanoTime();
+		System.out.println("Time: " + ((double)(end-start))/1_000_000_000 + " sekunder");
+	}
+
+	/**
+	 * Base64 Encoder
+	 * Base64 encoding/decoding (RFC1341)
+	 * Copyright (c) 2021, Jesper Preuss jesperpreuss@yahoo.dk
+	 *
+	 * @param src Data to be encoded in bytes
+	 * @return the encoded data to bytes, you have to convert to string yourself.
+	 */
+	public static byte[] encode(final byte[] src) {
+		int outLength = 4 * ((src.length + 2) / 3); /* 3-byte blocks to 4-byte */
+		byte[] out = new byte[outLength];
+
+		if (outLength < src.length) {
+			return new byte[0]; // Integer overflow
+		}
+
+
+		final int srcLength = src.length;
+		int srcPos = 0;
+		int outPos = 0;
+
+		while ((srcLength - srcPos) >= 3) {
+			out[outPos++] = BASE64_TABLE[(src[srcPos] & 0xFF) >> 2];
+			out[outPos++] = BASE64_TABLE[((((src[srcPos] & 0xFF) & 0b0000_0011) << 4) | ((src[srcPos + 1] & 0xFF) >> 4))];
+			out[outPos++] = BASE64_TABLE[(((src[srcPos + 1] & 0xFF) & 0b0000_1111) << 2) | ((src[srcPos + 2] & 0xFF) >> 6)];
+			out[outPos++] = BASE64_TABLE[(src[srcPos + 2] & 0xFF) & 0b0011_1111];
+			srcPos += 3;
+		}
+
+		if ((srcLength - srcPos) > 0) {
+			out[outPos++] = BASE64_TABLE[(src[srcPos] & 0xFF) >> 2];
+			if ((srcLength - srcPos) == 1) {
+				out[outPos++] = BASE64_TABLE[((src[srcPos] & 0xFF) & 0b0000_0011) << 4];
+				out[outPos++] = '=';
+			} else {
+				out[outPos++] = BASE64_TABLE[(((src[srcPos] & 0xFF) & 0b0000_0011) << 4) | ((src[srcPos + 1] & 0xFF) >> 4)];
+				out[outPos++] = BASE64_TABLE[((src[srcPos + 1] & 0xFF) & 0b0000_1111) << 2];
+			}
+			out[outPos++] = '=';
+		}
+
+		return out;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/basex/w3c/Base64.java b/src/main/java/dk/xpreuss/xperimentering/basex/w3c/Base64.java
new file mode 100644
index 0000000..eb77140
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/basex/w3c/Base64.java
@@ -0,0 +1,170 @@
+package dk.xpreuss.xperimentering.basex.w3c;
+
+/**
+ * Utility to base64 encode and decode a string.
+ *
+ * @author Stephen Uhler
+ * @version 1.9, 02/07/24
+ */
+
+public class Base64 {
+	static byte[] encodeData;
+	static String charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+	static {
+		encodeData = new byte[64];
+		for (int i = 0; i < 64; i++) {
+			byte c = (byte) charSet.charAt(i);
+			encodeData[i] = c;
+		}
+	}
+
+	private Base64() {
+	}
+
+	/**
+	 * base-64 encode a string
+	 *
+	 * @param s The ascii string to encode
+	 * @returns The base64 encoded result
+	 */
+
+	public static String
+	encode(String s) {
+		return encode(s.getBytes());
+	}
+
+	/**
+	 * base-64 encode a byte array
+	 *
+	 * @param src The byte array to encode
+	 * @returns The base64 encoded result
+	 */
+
+	public static String
+	encode(byte[] src) {
+		return encode(src, 0, src.length);
+	}
+
+	/**
+	 * base-64 encode a byte array
+	 *
+	 * @param src   The byte array to encode
+	 * @param start The starting index
+	 * @param length   The number of bytes
+	 * @returns The base64 encoded result
+	 */
+
+	public static String
+	encode(byte[] src, int start, int length) {
+		byte[] dst = new byte[(length + 2) / 3 * 4 + length / 72];
+		int x = 0;
+		int dstIndex = 0;
+		int state = 0;  // which char in pattern
+		int old = 0;  // previous byte
+		int len = 0;  // length decoded so far
+		int max = length + start;
+		for (int srcIndex = start; srcIndex < max; srcIndex++) {
+			x = src[srcIndex];
+			switch (++state) {
+				case 1:
+					dst[dstIndex++] = encodeData[(x >> 2) & 0x3f];
+					break;
+				case 2:
+					dst[dstIndex++] = encodeData[((old << 4) & 0x30)
+							| ((x >> 4) & 0xf)];
+					break;
+				case 3:
+					dst[dstIndex++] = encodeData[((old << 2) & 0x3C)
+							| ((x >> 6) & 0x3)];
+					dst[dstIndex++] = encodeData[x & 0x3F];
+					state = 0;
+					break;
+			}
+			old = x;
+			if (++len >= 72) {
+				dst[dstIndex++] = (byte) '\n';
+				len = 0;
+			}
+		}
+
+		/*
+		 * now clean up the end bytes
+		 */
+
+		switch (state) {
+			case 1:
+				dst[dstIndex++] = encodeData[(old << 4) & 0x30];
+				dst[dstIndex++] = (byte) '=';
+				dst[dstIndex++] = (byte) '=';
+				break;
+			case 2:
+				dst[dstIndex++] = encodeData[(old << 2) & 0x3c];
+				dst[dstIndex++] = (byte) '=';
+				break;
+		}
+		return new String(dst);
+	}
+
+	/**
+	 * A Base64 decoder.  This implementation is slow, and
+	 * doesn't handle wrapped lines.
+	 * The output is undefined if there are errors in the input.
+	 *
+	 * @param s a Base64 encoded string
+	 * @returns The byte array eith the decoded result
+	 */
+
+	public static byte[]
+	decode(String s) {
+		int end = 0;  // end state
+		if (s.endsWith("=")) {
+			end++;
+		}
+		if (s.endsWith("==")) {
+			end++;
+		}
+		int len = (s.length() + 3) / 4 * 3 - end;
+		byte[] result = new byte[len];
+		int dst = 0;
+		try {
+			for (int src = 0; src < s.length(); src++) {
+				int code = charSet.indexOf(s.charAt(src));
+				if (code == -1) {
+					break;
+				}
+				switch (src % 4) {
+					case 0:
+						result[dst] = (byte) (code << 2);
+						break;
+					case 1:
+						result[dst++] |= (byte) ((code >> 4) & 0x3);
+						result[dst] = (byte) (code << 4);
+						break;
+					case 2:
+						result[dst++] |= (byte) ((code >> 2) & 0xf);
+						result[dst] = (byte) (code << 6);
+						break;
+					case 3:
+						result[dst++] |= (byte) (code & 0x3f);
+						break;
+				}
+			}
+		} catch (ArrayIndexOutOfBoundsException e) {
+		}
+		return result;
+	}
+
+	/**
+	 * Test the decoder and encoder.
+	 * Call as <code>Base64 [string]</code>.
+	 */
+
+	public static void
+	main(String[] args) {
+		System.out.println("encode: " + args[0] + " -> ("
+				+ encode(args[0]) + ")");
+		System.out.println("decode: " + args[0] + " -> ("
+				+ new String(decode(args[0])) + ")");
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/dk/xpreuss/xperimentering/collections/Bag.java b/src/main/java/dk/xpreuss/xperimentering/collections/Bag.java
new file mode 100644
index 0000000..fe74337
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/collections/Bag.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.collections;
+
+public class Bag {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/collections/Item.java b/src/main/java/dk/xpreuss/xperimentering/collections/Item.java
new file mode 100644
index 0000000..2fa145f
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/collections/Item.java
@@ -0,0 +1,13 @@
+package dk.xpreuss.xperimentering.collections;
+
+public class Item<T> {
+	private T value;
+
+	public T getValue() {
+		return value;
+	}
+
+	public void setValue(T value) {
+		this.value = value;
+	}
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/collections/Queue.java b/src/main/java/dk/xpreuss/xperimentering/collections/Queue.java
new file mode 100644
index 0000000..0e68e6c
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/collections/Queue.java
@@ -0,0 +1,4 @@
+package dk.xpreuss.xperimentering.collections;
+
+public class Queue {
+}
diff --git a/src/main/java/dk/xpreuss/xperimentering/collections/Stack.java b/src/main/java/dk/xpreuss/xperimentering/collections/Stack.java
new file mode 100644
index 0000000..94d41f4
--- /dev/null
+++ b/src/main/java/dk/xpreuss/xperimentering/collections/Stack.java
@@ -0,0 +1,28 @@
+package dk.xpreuss.xperimentering.collections;
+
+/**
+ *
+ * @param <T>
+ */
+public interface Stack<T> {
+	/**
+	 * create and empty stack
+	 * @param item the item to add on top
+	 */
+	void push(T item);
+	/**
+	 * Removes the top on stack and returns it
+	 * @return item
+	 */
+	T pop();
+	/**
+	 * Tells if this stack is empty
+	 * @return boolean is this stack is empty
+	 */
+	boolean isEmpty();
+	/**
+	 * Tells the size of stack, and returns 0 if empty.
+	 * @return int size of stack
+	 */
+	int size();
+}
diff --git a/src/main/java/edu/princeton/cs/algs4/AVLTreeST.java b/src/main/java/edu/princeton/cs/algs4/AVLTreeST.java
new file mode 100644
index 0000000..d8520da
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AVLTreeST.java
@@ -0,0 +1,835 @@
+/******************************************************************************
+ *  Compilation:  javac AVLTreeST.java
+ *  Execution:    java AVLTreeST < input.txt
+ *  Dependencies: StdIn.java StdOut.java  
+ *  Data files:   https://algs4.cs.princeton.edu/33balanced/tinyST.txt  
+ *    
+ *  A symbol table implemented using an AVL tree.
+ *
+ *  % more tinyST.txt
+ *  S E A R C H E X A M P L E
+ *  
+ *  % java AVLTreeST < tinyST.txt
+ *  A 8
+ *  C 4
+ *  E 12
+ *  H 5
+ *  L 11
+ *  M 9
+ *  P 10
+ *  R 3
+ *  S 0
+ *  X 7
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code AVLTreeST} class represents an ordered symbol table of
+ *  generic key-value pairs. It supports the usual <em>put</em>, <em>get</em>,
+ *  <em>contains</em>, <em>delete</em>, <em>size</em>, and <em>is-empty</em>
+ *  methods. It also provides ordered methods for finding the <em>minimum</em>,
+ *  <em>maximum</em>, <em>floor</em>, and <em>ceiling</em>. It also provides a
+ *  <em>keys</em> method for iterating over all of the keys. A symbol table
+ *  implements the <em>associative array</em> abstraction: when associating a
+ *  value with a key that is already in the symbol table, the convention is to
+ *  replace the old value with the new value. Unlike {@link java.util.Map}, this
+ *  class uses the convention that values cannot be {@code null}
+ *  ‚Äîsetting the value associated with a key to {@code null} is
+ *  equivalent to deleting the key from the symbol table.
+ *  <p>
+ *  This symbol table implementation uses internally an
+ *  <a href="https://en.wikipedia.org/wiki/AVL_tree"> AVL tree </a> (Georgy
+ *  Adelson-Velsky and Evgenii Landis' tree) which is a self-balancing BST.
+ *  In an AVL tree, the heights of the two child subtrees of any
+ *  node differ by at most one; if at any time they differ by more than one,
+ *  rebalancing is done to restore this property.
+ *  <p>
+ *  This implementation requires that the key type implements the
+ *  {@code Comparable} interface and calls the {@code compareTo()} and
+ *  method to compare two keys. It does not call either {@code equals()} or
+ *  {@code hashCode()}. The <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>minimum</em>, <em>maximum</em>, <em>ceiling</em>, and
+ *  <em>floor</em> operations each take logarithmic time in the worst case. The
+ *  <em>size</em>, and <em>is-empty</em> operations take constant time.
+ *  Construction also takes constant time.
+ * 
+ *  For other implementations of the same API, see {@link ST}, {@link BinarySearchST},
+ *  {@link SequentialSearchST}, {@link BST}, {@link RedBlackBST},
+ *  {@link SeparateChainingHashST}, and {@link LinearProbingHashST}.
+ * 
+ *  @author Marcelo Silva
+ */
+
+public class AVLTreeST<Key extends Comparable<Key>, Value> {
+
+    /**
+     * The root node.
+     */
+    private Node root;
+
+    /**
+     * This class represents an inner node of the AVL tree.
+     */
+    private class Node {
+        private final Key key;   // the key
+        private Value val;       // the associated value
+        private int height;      // height of the subtree
+        private int size;        // number of nodes in subtree
+        private Node left;       // left subtree
+        private Node right;      // right subtree
+
+        public Node(Key key, Value val, int height, int size) {
+            this.key = key;
+            this.val = val;
+            this.size = size;
+            this.height = height;
+        }
+    }
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public AVLTreeST() {
+    }
+
+    /**
+     * Checks if the symbol table is empty.
+     * 
+     * @return {@code true} if the symbol table is empty.
+     */
+    public boolean isEmpty() {
+        return root == null;
+    }
+
+    /**
+     * Returns the number key-value pairs in the symbol table.
+     * 
+     * @return the number key-value pairs in the symbol table
+     */
+    public int size() {
+        return size(root);
+    }
+
+    /**
+     * Returns the number of nodes in the subtree.
+     * 
+     * @param x the subtree
+     * 
+     * @return the number of nodes in the subtree
+     */
+    private int size(Node x) {
+        if (x == null) return 0;
+        return x.size;
+    }
+
+    /**
+     * Returns the height of the internal AVL tree. It is assumed that the
+     * height of an empty tree is -1 and the height of a tree with just one node
+     * is 0.
+     * 
+     * @return the height of the internal AVL tree
+     */
+    public int height() {
+        return height(root);
+    }
+
+    /**
+     * Returns the height of the subtree.
+     * 
+     * @param x the subtree
+     * 
+     * @return the height of the subtree.
+     */
+    private int height(Node x) {
+        if (x == null) return -1;
+        return x.height;
+    }
+
+    /**
+     * Returns the value associated with the given key.
+     * 
+     * @param key the key
+     * @return the value associated with the given key if the key is in the
+     *         symbol table and {@code null} if the key is not in the
+     *         symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null");
+        Node x = get(root, key);
+        if (x == null) return null;
+        return x.val;
+    }
+
+    /**
+     * Returns value associated with the given key in the subtree or
+     * {@code null} if no such key.
+     * 
+     * @param x the subtree
+     * @param key the key
+     * @return value associated with the given key in the subtree or
+     *         {@code null} if no such key
+     */
+    private Node get(Node x, Key key) {
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp < 0) return get(x.left, key);
+        else if (cmp > 0) return get(x.right, key);
+        else return x;
+    }
+
+    /**
+     * Checks if the symbol table contains the given key.
+     * 
+     * @param key the key
+     * @return {@code true} if the symbol table contains {@code key}
+     *         and {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        return get(key) != null;
+    }
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting
+     * the old value with the new value if the symbol table already contains the
+     * specified key. Deletes the specified key (and its associated value) from
+     * this symbol table if the specified value is {@code null}.
+     * 
+     * @param key the key
+     * @param val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
+        if (val == null) {
+            delete(key);
+            return;
+        }
+        root = put(root, key, val);
+        assert check();
+    }
+
+    /**
+     * Inserts the key-value pair in the subtree. It overrides the old value
+     * with the new value if the symbol table already contains the specified key
+     * and deletes the specified key (and its associated value) from this symbol
+     * table if the specified value is {@code null}.
+     * 
+     * @param x the subtree
+     * @param key the key
+     * @param val the value
+     * @return the subtree
+     */
+    private Node put(Node x, Key key, Value val) {
+        if (x == null) return new Node(key, val, 0, 1);
+        int cmp = key.compareTo(x.key);
+        if (cmp < 0) {
+            x.left = put(x.left, key, val);
+        }
+        else if (cmp > 0) {
+            x.right = put(x.right, key, val);
+        }
+        else {
+            x.val = val;
+            return x;
+        }
+        x.size = 1 + size(x.left) + size(x.right);
+        x.height = 1 + Math.max(height(x.left), height(x.right));
+        return balance(x);
+    }
+
+    /**
+     * Restores the AVL tree property of the subtree.
+     * 
+     * @param x the subtree
+     * @return the subtree with restored AVL property
+     */
+    private Node balance(Node x) {
+        if (balanceFactor(x) < -1) {
+            if (balanceFactor(x.right) > 0) {
+                x.right = rotateRight(x.right);
+            }
+            x = rotateLeft(x);
+        }
+        else if (balanceFactor(x) > 1) {
+            if (balanceFactor(x.left) < 0) {
+                x.left = rotateLeft(x.left);
+            }
+            x = rotateRight(x);
+        }
+        return x;
+    }
+
+    /**
+     * Returns the balance factor of the subtree. The balance factor is defined
+     * as the difference in height of the left subtree and right subtree, in
+     * this order. Therefore, a subtree with a balance factor of -1, 0 or 1 has
+     * the AVL property since the heights of the two child subtrees differ by at
+     * most one.
+     * 
+     * @param x the subtree
+     * @return the balance factor of the subtree
+     */
+    private int balanceFactor(Node x) {
+        return height(x.left) - height(x.right);
+    }
+
+    /**
+     * Rotates the given subtree to the right.
+     * 
+     * @param x the subtree
+     * @return the right rotated subtree
+     */
+    private Node rotateRight(Node x) {
+        Node y = x.left;
+        x.left = y.right;
+        y.right = x;
+        y.size = x.size;
+        x.size = 1 + size(x.left) + size(x.right);
+        x.height = 1 + Math.max(height(x.left), height(x.right));
+        y.height = 1 + Math.max(height(y.left), height(y.right));
+        return y;
+    }
+
+    /**
+     * Rotates the given subtree to the left.
+     * 
+     * @param x the subtree
+     * @return the left rotated subtree
+     */
+    private Node rotateLeft(Node x) {
+        Node y = x.right;
+        x.right = y.left;
+        y.left = x;
+        y.size = x.size;
+        x.size = 1 + size(x.left) + size(x.right);
+        x.height = 1 + Math.max(height(x.left), height(x.right));
+        y.height = 1 + Math.max(height(y.left), height(y.right));
+        return y;
+    }
+
+    /**
+     * Removes the specified key and its associated value from the symbol table
+     * (if the key is in the symbol table).
+     * 
+     * @param key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
+        if (!contains(key)) return;
+        root = delete(root, key);
+        assert check();
+    }
+
+    /**
+     * Removes the specified key and its associated value from the given
+     * subtree.
+     * 
+     * @param x the subtree
+     * @param key the key
+     * @return the updated subtree
+     */
+    private Node delete(Node x, Key key) {
+        int cmp = key.compareTo(x.key);
+        if (cmp < 0) {
+            x.left = delete(x.left, key);
+        }
+        else if (cmp > 0) {
+            x.right = delete(x.right, key);
+        }
+        else {
+            if (x.left == null) {
+                return x.right;
+            }
+            else if (x.right == null) {
+                return x.left;
+            }
+            else {
+                Node y = x;
+                x = min(y.right);
+                x.right = deleteMin(y.right);
+                x.left = y.left;
+            }
+        }
+        x.size = 1 + size(x.left) + size(x.right);
+        x.height = 1 + Math.max(height(x.left), height(x.right));
+        return balance(x);
+    }
+
+    /**
+     * Removes the smallest key and associated value from the symbol table.
+     * 
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMin() {
+        if (isEmpty()) throw new NoSuchElementException("called deleteMin() with empty symbol table");
+        root = deleteMin(root);
+        assert check();
+    }
+
+    /**
+     * Removes the smallest key and associated value from the given subtree.
+     * 
+     * @param x the subtree
+     * @return the updated subtree
+     */
+    private Node deleteMin(Node x) {
+        if (x.left == null) return x.right;
+        x.left = deleteMin(x.left);
+        x.size = 1 + size(x.left) + size(x.right);
+        x.height = 1 + Math.max(height(x.left), height(x.right));
+        return balance(x);
+    }
+
+    /**
+     * Removes the largest key and associated value from the symbol table.
+     * 
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMax() {
+        if (isEmpty()) throw new NoSuchElementException("called deleteMax() with empty symbol table");
+        root = deleteMax(root);
+        assert check();
+    }
+
+    /**
+     * Removes the largest key and associated value from the given subtree.
+     * 
+     * @param x the subtree
+     * @return the updated subtree
+     */
+    private Node deleteMax(Node x) {
+        if (x.right == null) return x.left;
+        x.right = deleteMax(x.right);
+        x.size = 1 + size(x.left) + size(x.right);
+        x.height = 1 + Math.max(height(x.left), height(x.right));
+        return balance(x);
+    }
+
+    /**
+     * Returns the smallest key in the symbol table.
+     * 
+     * @return the smallest key in the symbol table
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("called min() with empty symbol table");
+        return min(root).key;
+    }
+
+    /**
+     * Returns the node with the smallest key in the subtree.
+     * 
+     * @param x the subtree
+     * @return the node with the smallest key in the subtree
+     */
+    private Node min(Node x) {
+        if (x.left == null) return x;
+        return min(x.left);
+    }
+
+    /**
+     * Returns the largest key in the symbol table.
+     * 
+     * @return the largest key in the symbol table
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("called max() with empty symbol table");
+        return max(root).key;
+    }
+
+    /**
+     * Returns the node with the largest key in the subtree.
+     * 
+     * @param x the subtree
+     * @return the node with the largest key in the subtree
+     */
+    private Node max(Node x) {
+        if (x.right == null) return x;
+        return max(x.right);
+    }
+
+    /**
+     * Returns the largest key in the symbol table less than or equal to
+     * {@code key}.
+     * 
+     * @param key the key
+     * @return the largest key in the symbol table less than or equal to
+     *         {@code key}
+     * @throws NoSuchElementException if the symbol table is empty
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key floor(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
+        if (isEmpty()) throw new NoSuchElementException("called floor() with empty symbol table");
+        Node x = floor(root, key);
+        if (x == null) return null;
+        else return x.key;
+    }
+
+    /**
+     * Returns the node in the subtree with the largest key less than or equal
+     * to the given key.
+     * 
+     * @param x the subtree
+     * @param key the key
+     * @return the node in the subtree with the largest key less than or equal
+     *         to the given key
+     */
+    private Node floor(Node x, Key key) {
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp == 0) return x;
+        if (cmp < 0) return floor(x.left, key);
+        Node y = floor(x.right, key);
+        if (y != null) return y;
+        else return x;
+    }
+
+    /**
+     * Returns the smallest key in the symbol table greater than or equal to
+     * {@code key}.
+     * 
+     * @param key the key
+     * @return the smallest key in the symbol table greater than or equal to
+     *         {@code key}
+     * @throws NoSuchElementException if the symbol table is empty
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key ceiling(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
+        if (isEmpty()) throw new NoSuchElementException("called ceiling() with empty symbol table");
+        Node x = ceiling(root, key);
+        if (x == null) return null;
+        else return x.key;
+    }
+
+    /**
+     * Returns the node in the subtree with the smallest key greater than or
+     * equal to the given key.
+     * 
+     * @param x the subtree
+     * @param key the key
+     * @return the node in the subtree with the smallest key greater than or
+     *         equal to the given key
+     */
+    private Node ceiling(Node x, Key key) {
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp == 0) return x;
+        if (cmp > 0) return ceiling(x.right, key);
+        Node y = ceiling(x.left, key);
+        if (y != null) return y;
+        else return x;
+    }
+
+    /**
+     * Returns the kth smallest key in the symbol table.
+     * 
+     * @param k the order statistic
+     * @return the kth smallest key in the symbol table
+     * @throws IllegalArgumentException unless {@code k} is between 0 and
+     *             {@code size() -1 }
+     */
+    public Key select(int k) {
+        if (k < 0 || k >= size()) throw new IllegalArgumentException("k is not in range 0-" + (size() - 1));
+        Node x = select(root, k);
+        return x.key;
+    }
+
+    /**
+     * Returns the node with key the kth smallest key in the subtree.
+     * 
+     * @param x the subtree
+     * @param k the kth smallest key in the subtree
+     * @return the node with key the kth smallest key in the subtree
+     */
+    private Node select(Node x, int k) {
+        if (x == null) return null;
+        int t = size(x.left);
+        if (t > k) return select(x.left, k);
+        else if (t < k) return select(x.right, k - t - 1);
+        else return x;
+    }
+
+    /**
+     * Returns the number of keys in the symbol table strictly less than
+     * {@code key}.
+     * 
+     * @param key the key
+     * @return the number of keys in the symbol table strictly less than
+     *         {@code key}
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public int rank(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to rank() is null");
+        return rank(key, root);
+    }
+
+    /**
+     * Returns the number of keys in the subtree less than key.
+     * 
+     * @param key the key
+     * @param x the subtree
+     * @return the number of keys in the subtree less than key
+     */
+    private int rank(Key key, Node x) {
+        if (x == null) return 0;
+        int cmp = key.compareTo(x.key);
+        if (cmp < 0) return rank(key, x.left);
+        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right);
+        else return size(x.left);
+    }
+
+    /**
+     * Returns all keys in the symbol table.
+     * 
+     * @return all keys in the symbol table
+     */
+    public Iterable<Key> keys() {
+        return keysInOrder();
+    }
+
+    /**
+     * Returns all keys in the symbol table following an in-order traversal.
+     * 
+     * @return all keys in the symbol table following an in-order traversal
+     */
+    public Iterable<Key> keysInOrder() {
+        Queue<Key> queue = new Queue<Key>();
+        keysInOrder(root, queue);
+        return queue;
+    }
+
+    /**
+     * Adds the keys in the subtree to queue following an in-order traversal.
+     * 
+     * @param x the subtree
+     * @param queue the queue
+     */
+    private void keysInOrder(Node x, Queue<Key> queue) {
+        if (x == null) return;
+        keysInOrder(x.left, queue);
+        queue.enqueue(x.key);
+        keysInOrder(x.right, queue);
+    }
+
+    /**
+     * Returns all keys in the symbol table following a level-order traversal.
+     * 
+     * @return all keys in the symbol table following a level-order traversal.
+     */
+    public Iterable<Key> keysLevelOrder() {
+        Queue<Key> queue = new Queue<Key>();
+        if (!isEmpty()) {
+            Queue<Node> queue2 = new Queue<Node>();
+            queue2.enqueue(root);
+            while (!queue2.isEmpty()) {
+                Node x = queue2.dequeue();
+                queue.enqueue(x.key);
+                if (x.left != null) {
+                    queue2.enqueue(x.left);
+                }
+                if (x.right != null) {
+                    queue2.enqueue(x.right);
+                }
+            }
+        }
+        return queue;
+    }
+
+    /**
+     * Returns all keys in the symbol table in the given range.
+     * 
+     * @param lo the lowest key
+     * @param hi the highest key
+     * @return all keys in the symbol table between {@code lo} (inclusive)
+     *         and {@code hi} (exclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *             is {@code null}
+     */
+    public Iterable<Key> keys(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null");
+        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null");
+        Queue<Key> queue = new Queue<Key>();
+        keys(root, queue, lo, hi);
+        return queue;
+    }
+
+    /**
+     * Adds the keys between {@code lo} and {@code hi} in the subtree
+     * to the {@code queue}.
+     * 
+     * @param x the subtree
+     * @param queue the queue
+     * @param lo the lowest key
+     * @param hi the highest key
+     */
+    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {
+        if (x == null) return;
+        int cmplo = lo.compareTo(x.key);
+        int cmphi = hi.compareTo(x.key);
+        if (cmplo < 0) keys(x.left, queue, lo, hi);
+        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key);
+        if (cmphi > 0) keys(x.right, queue, lo, hi);
+    }
+
+    /**
+     * Returns the number of keys in the symbol table in the given range.
+     * 
+     * @param lo minimum endpoint
+     * @param hi maximum endpoint
+     * @return the number of keys in the symbol table between {@code lo}
+     *         (inclusive) and {@code hi} (exclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *             is {@code null}
+     */
+    public int size(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to size() is null");
+        if (hi == null) throw new IllegalArgumentException("second argument to size() is null");
+        if (lo.compareTo(hi) > 0) return 0;
+        if (contains(hi)) return rank(hi) - rank(lo) + 1;
+        else return rank(hi) - rank(lo);
+    }
+
+    /**
+     * Checks if the AVL tree invariants are fine.
+     * 
+     * @return {@code true} if the AVL tree invariants are fine
+     */
+    private boolean check() {
+        if (!isBST()) StdOut.println("Symmetric order not consistent");
+        if (!isAVL()) StdOut.println("AVL property not consistent");
+        if (!isSizeConsistent()) StdOut.println("Subtree counts not consistent");
+        if (!isRankConsistent()) StdOut.println("Ranks not consistent");
+        return isBST() && isAVL() && isSizeConsistent() && isRankConsistent();
+    }
+
+    /**
+     * Checks if AVL property is consistent.
+     * 
+     * @return {@code true} if AVL property is consistent.
+     */
+    private boolean isAVL() {
+        return isAVL(root);
+    }
+
+    /**
+     * Checks if AVL property is consistent in the subtree.
+     * 
+     * @param x the subtree
+     * @return {@code true} if AVL property is consistent in the subtree
+     */
+    private boolean isAVL(Node x) {
+        if (x == null) return true;
+        int bf = balanceFactor(x);
+        if (bf > 1 || bf < -1) return false;
+        return isAVL(x.left) && isAVL(x.right);
+    }
+
+    /**
+     * Checks if the symmetric order is consistent.
+     * 
+     * @return {@code true} if the symmetric order is consistent
+     */
+    private boolean isBST() {
+        return isBST(root, null, null);
+    }
+
+    /**
+     * Checks if the tree rooted at x is a BST with all keys strictly between
+     * min and max (if min or max is null, treat as empty constraint) Credit:
+     * Bob Dondero's elegant solution
+     * 
+     * @param x the subtree
+     * @param min the minimum key in subtree
+     * @param max the maximum key in subtree
+     * @return {@code true} if if the symmetric order is consistent
+     */
+    private boolean isBST(Node x, Key min, Key max) {
+        if (x == null) return true;
+        if (min != null && x.key.compareTo(min) <= 0) return false;
+        if (max != null && x.key.compareTo(max) >= 0) return false;
+        return isBST(x.left, min, x.key) && isBST(x.right, x.key, max);
+    }
+
+    /**
+     * Checks if size is consistent.
+     * 
+     * @return {@code true} if size is consistent
+     */
+    private boolean isSizeConsistent() {
+        return isSizeConsistent(root);
+    }
+
+    /**
+     * Checks if the size of the subtree is consistent.
+     * 
+     * @return {@code true} if the size of the subtree is consistent
+     */
+    private boolean isSizeConsistent(Node x) {
+        if (x == null) return true;
+        if (x.size != size(x.left) + size(x.right) + 1) return false;
+        return isSizeConsistent(x.left) && isSizeConsistent(x.right);
+    }
+
+    /**
+     * Checks if rank is consistent.
+     * 
+     * @return {@code true} if rank is consistent
+     */
+    private boolean isRankConsistent() {
+        for (int i = 0; i < size(); i++)
+            if (i != rank(select(i))) return false;
+        for (Key key : keys())
+            if (key.compareTo(select(rank(key))) != 0) return false;
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code AVLTreeST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        AVLTreeST<String, Integer> st = new AVLTreeST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+        for (String s : st.keys())
+            StdOut.println(s + " " + st.get(s));
+        StdOut.println();
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Accumulator.java b/src/main/java/edu/princeton/cs/algs4/Accumulator.java
new file mode 100644
index 0000000..4c2a8d7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Accumulator.java
@@ -0,0 +1,145 @@
+/******************************************************************************
+ *  Compilation:  javac Accumulator.java
+ *  Execution:    java Accumulator < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *
+ *  Mutable data type that calculates the mean, sample standard
+ *  deviation, and sample variance of a stream of real numbers
+ *  use a stable, one-pass algorithm.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code Accumulator} class is a data type for computing the running
+ *  mean, sample standard deviation, and sample variance of a stream of real
+ *  numbers. It provides an example of a mutable data type and a streaming
+ *  algorithm.
+ *  <p>
+ *  This implementation uses a one-pass algorithm that is less susceptible
+ *  to floating-point roundoff error than the more straightforward
+ *  implementation based on saving the sum of the squares of the numbers.
+ *  This technique is due to
+ *  <a href = "https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm">B. P. Welford</a>.
+ *  Each operation takes constant time in the worst case.
+ *  The amount of memory is constant - the data values are not stored.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Accumulator {
+    private int n = 0;          // number of data values
+    private double sum = 0.0;   // sample variance * (n-1)
+    private double mu = 0.0;    // sample mean
+
+    /**
+     * Initializes an accumulator.
+     */
+    public Accumulator() {
+    }
+
+    /**
+     * Adds the specified data value to the accumulator.
+     * @param  x the data value
+     */
+    public void addDataValue(double x) {
+        n++;
+        double delta = x - mu;
+        mu  += delta / n;
+        sum += (double) (n - 1) / n * delta * delta;
+    }
+
+    /**
+     * Returns the mean of the data values.
+     * @return the mean of the data values
+     */
+    public double mean() {
+        return mu;
+    }
+
+    /**
+     * Returns the sample variance of the data values.
+     * @return the sample variance of the data values
+     */
+    public double var() {
+        if (n <= 1) return Double.NaN;
+        return sum / (n - 1);
+    }
+
+    /**
+     * Returns the sample standard deviation of the data values.
+     * @return the sample standard deviation of the data values
+     */
+    public double stddev() {
+        return Math.sqrt(this.var());
+    }
+
+    /**
+     * Returns the number of data values.
+     * @return the number of data values
+     */
+    public int count() {
+        return n;
+    }
+
+    /**
+     * Returns a string representation of this accumulator.
+     * @return a string representation of this accumulator
+     */
+    public String toString() {
+        return "n = " + n + ", mean = " + mean() + ", stddev = " + stddev();
+    }
+
+    /**
+     * Unit tests the {@code Accumulator} data type.
+     * Reads in a stream of real number from standard input;
+     * adds them to the accumulator; and prints the mean,
+     * sample standard deviation, and sample variance to standard
+     * output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Accumulator stats = new Accumulator();
+        while (!StdIn.isEmpty()) {
+            double x = StdIn.readDouble();
+            stats.addDataValue(x);
+        }
+
+        StdOut.printf("n      = %d\n",   stats.count());
+        StdOut.printf("mean   = %.5f\n", stats.mean());
+        StdOut.printf("stddev = %.5f\n", stats.stddev());
+        StdOut.printf("var    = %.5f\n", stats.var());
+        StdOut.println(stats);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AcyclicLP.java b/src/main/java/edu/princeton/cs/algs4/AcyclicLP.java
new file mode 100644
index 0000000..b9e70f2
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AcyclicLP.java
@@ -0,0 +1,191 @@
+/******************************************************************************
+ *  Compilation:  javac AcyclicLP.java
+ *  Execution:    java AcyclicP V E
+ *  Dependencies: EdgeWeightedDigraph.java DirectedEdge.java Topological.java
+ *  Data files:   https://algs4.cs.princeton.edu/44sp/tinyEWDAG.txt
+ *  
+ *  Computes longeset paths in an edge-weighted acyclic digraph.
+ *
+ *  Remark: should probably check that graph is a DAG before running
+ *
+ *  % java AcyclicLP tinyEWDAG.txt 5
+ *  5 to 0 (2.44)  5->1  0.32   1->3  0.29   3->6  0.52   6->4  0.93   4->0  0.38   
+ *  5 to 1 (0.32)  5->1  0.32   
+ *  5 to 2 (2.77)  5->1  0.32   1->3  0.29   3->6  0.52   6->4  0.93   4->7  0.37   7->2  0.34   
+ *  5 to 3 (0.61)  5->1  0.32   1->3  0.29   
+ *  5 to 4 (2.06)  5->1  0.32   1->3  0.29   3->6  0.52   6->4  0.93   
+ *  5 to 5 (0.00)  
+ *  5 to 6 (1.13)  5->1  0.32   1->3  0.29   3->6  0.52   
+ *  5 to 7 (2.43)  5->1  0.32   1->3  0.29   3->6  0.52   6->4  0.93   4->7  0.37   
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code AcyclicLP} class represents a data type for solving the
+ *  single-source longest paths problem in edge-weighted directed
+ *  acyclic graphs (DAGs). The edge weights can be positive, negative, or zero.
+ *  <p>
+ *  This implementation uses a topological-sort based algorithm.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the
+ *  edge-weighted digraph).
+ *  <p>
+ *  This correctly computes longest paths if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>. Since all intermediate
+ *  results are sums of edge weights, they are bounded by <em>V C</em>,
+ *  where <em>V</em> is the number of vertices and <em>C</em> is the maximum
+ *  absolute value of any edge weight.
+ *  <p>
+ *  For additional documentation,   
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of   
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class AcyclicLP {
+    private double[] distTo;          // distTo[v] = distance  of longest s->v path
+    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on longest s->v path
+
+    /**
+     * Computes a longest paths tree from {@code s} to every other vertex in
+     * the directed acyclic graph {@code G}.
+     * @param G the acyclic digraph
+     * @param s the source vertex
+     * @throws IllegalArgumentException if the digraph is not acyclic
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public AcyclicLP(EdgeWeightedDigraph G, int s) {
+        distTo = new double[G.V()];
+        edgeTo = new DirectedEdge[G.V()];
+
+        validateVertex(s);
+
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = Double.NEGATIVE_INFINITY;
+        distTo[s] = 0.0;
+
+        // relax vertices in topological order
+        Topological topological = new Topological(G);
+        if (!topological.hasOrder())
+            throw new IllegalArgumentException("Digraph is not acyclic.");
+        for (int v : topological.order()) {
+            for (DirectedEdge e : G.adj(v))
+                relax(e);
+        }
+    }
+
+    // relax edge e, but update if you find a *longer* path
+    private void relax(DirectedEdge e) {
+        int v = e.from(), w = e.to();
+        if (distTo[w] < distTo[v] + e.weight()) {
+            distTo[w] = distTo[v] + e.weight();
+            edgeTo[w] = e;
+        }       
+    }
+
+    /**
+     * Returns the length of a longest path from the source vertex {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return the length of a longest path from the source vertex {@code s} to vertex {@code v};
+     *         {@code Double.NEGATIVE_INFINITY} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public double distTo(int v) {
+        validateVertex(v);
+        return distTo[v];
+    }
+
+    /**
+     * Is there a path from the source vertex {@code s} to vertex {@code v}?
+     * @param  v the destination vertex
+     * @return {@code true} if there is a path from the source vertex
+     *         {@code s} to vertex {@code v}, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return distTo[v] > Double.NEGATIVE_INFINITY;
+    }
+
+    /**
+     * Returns a longest path from the source vertex {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return a longest path from the source vertex {@code s} to vertex {@code v}
+     *         as an iterable of edges, and {@code null} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
+        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
+            path.push(e);
+        }
+        return path;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = distTo.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code AcyclicLP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        int s = Integer.parseInt(args[1]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
+
+        AcyclicLP lp = new AcyclicLP(G, s);
+
+        for (int v = 0; v < G.V(); v++) {
+            if (lp.hasPathTo(v)) {
+                StdOut.printf("%d to %d (%.2f)  ", s, v, lp.distTo(v));
+                for (DirectedEdge e : lp.pathTo(v)) {
+                    StdOut.print(e + "   ");
+                }
+                StdOut.println();
+            }
+            else {
+                StdOut.printf("%d to %d         no path\n", s, v);
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AcyclicSP.java b/src/main/java/edu/princeton/cs/algs4/AcyclicSP.java
new file mode 100644
index 0000000..99f7803
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AcyclicSP.java
@@ -0,0 +1,190 @@
+/******************************************************************************
+ *  Compilation:  javac AcyclicSP.java
+ *  Execution:    java AcyclicSP V E
+ *  Dependencies: EdgeWeightedDigraph.java DirectedEdge.java Topological.java
+ *  Data files:   https://algs4.cs.princeton.edu/44sp/tinyEWDAG.txt
+ *
+ *  Computes shortest paths in an edge-weighted acyclic digraph.
+ *
+ *  % java AcyclicSP tinyEWDAG.txt 5
+ *  5 to 0 (0.73)  5->4  0.35   4->0  0.38   
+ *  5 to 1 (0.32)  5->1  0.32   
+ *  5 to 2 (0.62)  5->7  0.28   7->2  0.34   
+ *  5 to 3 (0.61)  5->1  0.32   1->3  0.29   
+ *  5 to 4 (0.35)  5->4  0.35   
+ *  5 to 5 (0.00)  
+ *  5 to 6 (1.13)  5->1  0.32   1->3  0.29   3->6  0.52   
+ *  5 to 7 (0.28)  5->7  0.28   
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code AcyclicSP} class represents a data type for solving the
+ *  single-source shortest paths problem in edge-weighted directed acyclic
+ *  graphs (DAGs). The edge weights can be positive, negative, or zero.
+ *  <p>
+ *  This implementation uses a topological-sort based algorithm.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the
+ *  edge-weighted digraph).
+ *  <p>
+ *  This correctly computes shortest paths if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>. Since all intermediate
+ *  results are sums of edge weights, they are bounded by <em>V C</em>,
+ *  where <em>V</em> is the number of vertices and <em>C</em> is the maximum
+ *  absolute value of any edge weight.
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of    
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class AcyclicSP {
+    private double[] distTo;         // distTo[v] = distance  of shortest s->v path
+    private DirectedEdge[] edgeTo;   // edgeTo[v] = last edge on shortest s->v path
+
+
+    /**
+     * Computes a shortest paths tree from {@code s} to every other vertex in
+     * the directed acyclic graph {@code G}.
+     * @param G the acyclic digraph
+     * @param s the source vertex
+     * @throws IllegalArgumentException if the digraph is not acyclic
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public AcyclicSP(EdgeWeightedDigraph G, int s) {
+        distTo = new double[G.V()];
+        edgeTo = new DirectedEdge[G.V()];
+
+        validateVertex(s);
+
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = Double.POSITIVE_INFINITY;
+        distTo[s] = 0.0;
+
+        // visit vertices in topological order
+        Topological topological = new Topological(G);
+        if (!topological.hasOrder())
+            throw new IllegalArgumentException("Digraph is not acyclic.");
+        for (int v : topological.order()) {
+            for (DirectedEdge e : G.adj(v))
+                relax(e);
+        }
+    }
+
+    // relax edge e
+    private void relax(DirectedEdge e) {
+        int v = e.from(), w = e.to();
+        if (distTo[w] > distTo[v] + e.weight()) {
+            distTo[w] = distTo[v] + e.weight();
+            edgeTo[w] = e;
+        }       
+    }
+
+    /**
+     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
+     *         {@code Double.POSITIVE_INFINITY} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public double distTo(int v) {
+        validateVertex(v);
+        return distTo[v];
+    }
+
+    /**
+     * Is there a path from the source vertex {@code s} to vertex {@code v}?
+     * @param  v the destination vertex
+     * @return {@code true} if there is a path from the source vertex
+     *         {@code s} to vertex {@code v}, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return distTo[v] < Double.POSITIVE_INFINITY;
+    }
+
+    /**
+     * Returns a shortest path from the source vertex {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return a shortest path from the source vertex {@code s} to vertex {@code v}
+     *         as an iterable of edges, and {@code null} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
+        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
+            path.push(e);
+        }
+        return path;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = distTo.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code AcyclicSP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        int s = Integer.parseInt(args[1]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
+
+        // find shortest path from s to each other vertex in DAG
+        AcyclicSP sp = new AcyclicSP(G, s);
+        for (int v = 0; v < G.V(); v++) {
+            if (sp.hasPathTo(v)) {
+                StdOut.printf("%d to %d (%.2f)  ", s, v, sp.distTo(v));
+                for (DirectedEdge e : sp.pathTo(v)) {
+                    StdOut.print(e + "   ");
+                }
+                StdOut.println();
+            }
+            else {
+                StdOut.printf("%d to %d         no path\n", s, v);
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AdjMatrixEdgeWeightedDigraph.java b/src/main/java/edu/princeton/cs/algs4/AdjMatrixEdgeWeightedDigraph.java
new file mode 100644
index 0000000..e83eb18
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AdjMatrixEdgeWeightedDigraph.java
@@ -0,0 +1,216 @@
+/******************************************************************************
+ *  Compilation:  javac AdjMatrixEdgeWeightedDigraph.java
+ *  Execution:    java AdjMatrixEdgeWeightedDigraph V E
+ *  Dependencies: StdOut.java
+ *
+ *  An edge-weighted digraph, implemented using an adjacency matrix.
+ *  Parallel edges are disallowed; self-loops are allowed.
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code AdjMatrixEdgeWeightedDigraph} class represents a edge-weighted
+ *  digraph of vertices named 0 through <em>V</em> - 1, where each
+ *  directed edge is of type {@link DirectedEdge} and has a real-valued weight.
+ *  It supports the following two primary operations: add a directed edge
+ *  to the digraph and iterate over all of edges incident from a given vertex.
+ *  It also provides
+ *  methods for returning the number of vertices <em>V</em> and the number
+ *  of edges <em>E</em>. Parallel edges are disallowed; self-loops are permitted.
+ *  <p>
+ *  This implementation uses an adjacency-matrix representation.
+ *  All operations take constant time (in the worst case) except
+ *  iterating over the edges incident from a given vertex, which takes
+ *  time proportional to <em>V</em>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class AdjMatrixEdgeWeightedDigraph {
+    private static final String NEWLINE = System.getProperty("line.separator");
+
+    private final int V;
+    private int E;
+    private DirectedEdge[][] adj;
+    
+    /**
+     * Initializes an empty edge-weighted digraph with {@code V} vertices and 0 edges.
+     * @param V the number of vertices
+     * @throws IllegalArgumentException if {@code V < 0}
+     */
+    public AdjMatrixEdgeWeightedDigraph(int V) {
+        if (V < 0) throw new IllegalArgumentException("number of vertices must be non-negative");
+        this.V = V;
+        this.E = 0;
+        this.adj = new DirectedEdge[V][V];
+    }
+
+    /**
+     * Initializes a random edge-weighted digraph with {@code V} vertices and <em>E</em> edges.
+     * @param V the number of vertices
+     * @param E the number of edges
+     * @throws IllegalArgumentException if {@code V < 0}
+     * @throws IllegalArgumentException if {@code E < 0}
+     */
+    public AdjMatrixEdgeWeightedDigraph(int V, int E) {
+        this(V);
+        if (E < 0) throw new IllegalArgumentException("number of edges must be non-negative");
+        if (E > V*V) throw new IllegalArgumentException("too many edges");
+
+        // can be inefficient
+        while (this.E != E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;
+            addEdge(new DirectedEdge(v, w, weight));
+        }
+    }
+
+    /**
+     * Returns the number of vertices in the edge-weighted digraph.
+     * @return the number of vertices in the edge-weighted digraph
+     */
+    public int V() {
+        return V;
+    }
+
+    /**
+     * Returns the number of edges in the edge-weighted digraph.
+     * @return the number of edges in the edge-weighted digraph
+     */
+    public int E() {
+        return E;
+    }
+
+    /**
+     * Adds the directed edge {@code e} to the edge-weighted digraph (if there
+     * is not already an edge with the same endpoints).
+     * @param e the edge
+     */
+    public void addEdge(DirectedEdge e) {
+        int v = e.from();
+        int w = e.to();
+        validateVertex(v);
+        validateVertex(w);
+        if (adj[v][w] == null) {
+            E++;
+            adj[v][w] = e;
+        }
+    }
+
+    /**
+     * Returns the directed edges incident from vertex {@code v}.
+     * @param v the vertex
+     * @return the directed edges incident from vertex {@code v} as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> adj(int v) {
+        validateVertex(v);
+        return new AdjIterator(v);
+    }
+
+    // support iteration over graph vertices
+    private class AdjIterator implements Iterator<DirectedEdge>, Iterable<DirectedEdge> {
+        private int v;
+        private int w = 0;
+
+        public AdjIterator(int v) {
+            this.v = v;
+        }
+
+        public Iterator<DirectedEdge> iterator() {
+            return this;
+        }
+
+        public boolean hasNext() {
+            while (w < V) {
+                if (adj[v][w] != null) return true;
+                w++;
+            }
+            return false;
+        }
+
+        public DirectedEdge next() {
+            if (!hasNext()) {
+                throw new NoSuchElementException();
+            }
+            return adj[v][w++];
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    /**
+     * Returns a string representation of the edge-weighted digraph. This method takes
+     * time proportional to <em>V</em><sup>2</sup>.
+     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
+     *   followed by the <em>V</em> adjacency lists of edges
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(V + " " + E + NEWLINE);
+        for (int v = 0; v < V; v++) {
+            s.append(v + ": ");
+            for (DirectedEdge e : adj(v)) {
+                s.append(e + "  ");
+            }
+            s.append(NEWLINE);
+        }
+        return s.toString();
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+
+    /**
+     * Unit tests the {@code AdjMatrixEdgeWeightedDigraph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        AdjMatrixEdgeWeightedDigraph G = new AdjMatrixEdgeWeightedDigraph(V, E);
+        StdOut.println(G);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AllowFilter.java b/src/main/java/edu/princeton/cs/algs4/AllowFilter.java
new file mode 100644
index 0000000..a227091
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AllowFilter.java
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *  Compilation:  javac AllowFilter.java
+ *  Execution:    java AllowFilter allowlist.txt < input.txt
+ *  Dependencies: SET In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/tinyTale.txt
+ *                https://algs4.cs.princeton.edu/35applications/allowlist.txt
+ * 
+ *  Read in a allowlist of words from a file. Then read in a list of
+ *  words from standard input and print out all those words that
+ *  are in the first file.
+ * 
+ *  % more tinyTale.txt 
+ *  it was the best of times it was the worst of times 
+ *  it was the age of wisdom it was the age of foolishness 
+ *  it was the epoch of belief it was the epoch of incredulity 
+ *  it was the season of light it was the season of darkness 
+ *  it was the spring of hope it was the winter of despair
+ *
+ *  % more list.txt 
+ *  was it the of 
+ * 
+ *  % java AllowFilter list.txt < tinyTale.txt 
+ *  it was the of it was the of
+ *  it was the of it was the of
+ *  it was the of it was the of
+ *  it was the of it was the of
+ *  it was the of it was the of
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code AllowFilter} class provides a client for reading in an <em>allowlist</em>
+ *  of words from a file; then, reading in a sequence of words from standard input,
+ *  printing out each word that appears in the file.
+ *  It is useful as a test client for various symbol table implementations.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class AllowFilter {  
+
+    // Do not instantiate.
+    private AllowFilter() { }
+
+    public static void main(String[] args) {
+        SET<String> set = new SET<String>();
+
+        // read in strings and add to set
+        In in = new In(args[0]);
+        while (!in.isEmpty()) {
+            String word = in.readString();
+            set.add(word);
+        }
+
+        // read in string from standard input, printing out all exceptions
+        while (!StdIn.isEmpty()) {
+            String word = StdIn.readString();
+            if (set.contains(word))
+                StdOut.println(word);
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Allowlist.java b/src/main/java/edu/princeton/cs/algs4/Allowlist.java
new file mode 100644
index 0000000..02ee24f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Allowlist.java
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *  Compilation:  javac Allowlist.java
+ *  Execution:    java Allowlist allowlist.txt < data.txt
+ *  Dependencies: StaticSetOfInts.java In.java StdOut.java
+ *
+ *  Data files:   https://algs4.cs.princeton.edu/11model/tinyAllowlist.txt
+ *                https://algs4.cs.princeton.edu/11model/tinyText.txt
+ *                https://algs4.cs.princeton.edu/11model/largeAllowlist.txt
+ *                https://algs4.cs.princeton.edu/11model/largeText.txt
+ *
+ *  Allowlist filter.
+ *
+ *
+ *  % java Allowlist tinyAllowlist.txt < tinyText.txt
+ *  50
+ *  99
+ *  13
+ *
+ *  % java Allowlist largeAllowlist.txt < largeText.txt | more
+ *  499569
+ *  984875
+ *  295754
+ *  207807
+ *  140925
+ *  161828
+ *  [367,966 total values]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Allowlist} class provides a client for reading in
+ *  a set of integers from a file; reading in a sequence of integers
+ *  from standard input; and printing to standard output those 
+ *  integers not in the allowlist.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Allowlist {
+
+    // Do not instantiate.
+    private Allowlist() { }
+
+    /**
+     * Reads in a sequence of integers from the allowlist file, specified as
+     * a command-line argument. Reads in integers from standard input and
+     * prints to standard output those integers that are not in the file.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        int[] white = in.readAllInts();
+        StaticSETofInts set = new StaticSETofInts(white);
+
+        // Read key, print if not in allowlist.
+        while (!StdIn.isEmpty()) {
+            int key = StdIn.readInt();
+            if (!set.contains(key))
+                StdOut.println(key);
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Alphabet.java b/src/main/java/edu/princeton/cs/algs4/Alphabet.java
new file mode 100644
index 0000000..2342dda
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Alphabet.java
@@ -0,0 +1,280 @@
+/******************************************************************************
+ *  Compilation:  javac Alphabet.java
+ *  Execution:    java Alphabet
+ *  Dependencies: StdOut.java
+ *  
+ *  A data type for alphabets, for use with string-processing code
+ *  that must convert between an alphabet of size R and the integers
+ *  0 through R-1.
+ *
+ *  Warning: supports only the basic multilingual plane (BMP), i.e,
+ *           Unicode characters between U+0000 and U+FFFF.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+public class Alphabet {
+
+    /**
+     *  The binary alphabet { 0, 1 }.
+     */
+    public static final Alphabet BINARY = new Alphabet("01");
+
+    /**
+     *  The octal alphabet { 0, 1, 2, 3, 4, 5, 6, 7 }.
+     */
+    public static final Alphabet OCTAL = new Alphabet("01234567");
+
+    /**
+     *  The decimal alphabet { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }.
+     */
+    public static final Alphabet DECIMAL = new Alphabet("0123456789");
+
+    /**
+     *  The hexadecimal alphabet { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F }.
+     */
+    public static final Alphabet HEXADECIMAL = new Alphabet("0123456789ABCDEF");
+
+    /**
+     *  The DNA alphabet { A, C, T, G }.
+     */
+    public static final Alphabet DNA = new Alphabet("ACGT");
+
+    /**
+     *  The lowercase alphabet { a, b, c, ..., z }.
+     */
+    public static final Alphabet LOWERCASE = new Alphabet("abcdefghijklmnopqrstuvwxyz");
+
+    /**
+     *  The uppercase alphabet { A, B, C, ..., Z }.
+     */
+
+    public static final Alphabet UPPERCASE = new Alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+
+    /**
+     *  The protein alphabet { A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y }.
+     */
+    public static final Alphabet PROTEIN = new Alphabet("ACDEFGHIKLMNPQRSTVWY");
+
+    /**
+     *  The base-64 alphabet (64 characters).
+     */
+    public static final Alphabet BASE64 = new Alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
+
+    /**
+     *  The ASCII alphabet (0-127).
+     */
+    public static final Alphabet ASCII = new Alphabet(128);
+
+    /**
+     *  The extended ASCII alphabet (0-255).
+     */
+    public static final Alphabet EXTENDED_ASCII = new Alphabet(256);
+
+    /**
+     *  The Unicode 16 alphabet (0-65,535).
+     */
+    public static final Alphabet UNICODE16      = new Alphabet(65536);
+
+
+    private char[] alphabet;     // the characters in the alphabet
+    private int[] inverse;       // indices
+    private final int R;         // the radix of the alphabet
+
+    /**
+     * Initializes a new alphabet from the given set of characters.
+     *
+     * @param alpha the set of characters
+     */
+    public Alphabet(String alpha) {
+
+        // check that alphabet contains no duplicate chars
+        boolean[] unicode = new boolean[Character.MAX_VALUE];
+        for (int i = 0; i < alpha.length(); i++) {
+            char c = alpha.charAt(i);
+            if (unicode[c])
+                throw new IllegalArgumentException("Illegal alphabet: repeated character = '" + c + "'");
+            unicode[c] = true;
+        }
+
+        alphabet = alpha.toCharArray();
+        R = alpha.length();
+        inverse = new int[Character.MAX_VALUE];
+        for (int i = 0; i < inverse.length; i++)
+            inverse[i] = -1;
+
+        // can't use char since R can be as big as 65,536
+        for (int c = 0; c < R; c++)
+            inverse[alphabet[c]] = c;
+    }
+
+    /**
+     * Initializes a new alphabet using characters 0 through R-1.
+     *
+     * @param radix the number of characters in the alphabet (the radix R)
+     */
+    private Alphabet(int radix) {
+        this.R = radix;
+        alphabet = new char[R];
+        inverse = new int[R];
+
+        // can't use char since R can be as big as 65,536
+        for (int i = 0; i < R; i++)
+            alphabet[i] = (char) i;
+        for (int i = 0; i < R; i++)
+            inverse[i] = i;
+    }
+
+    /**
+     * Initializes a new alphabet using characters 0 through 255.
+     */
+    public Alphabet() {
+        this(256);
+    }
+
+    /**
+     * Returns true if the argument is a character in this alphabet.
+     *
+     * @param  c the character
+     * @return {@code true} if {@code c} is a character in this alphabet;
+     *         {@code false} otherwise
+     */
+    public boolean contains(char c) {
+        return inverse[c] != -1;
+    }
+
+    /**
+     * Returns the number of characters in this alphabet (the radix).
+     * 
+     * @return the number of characters in this alphabet
+     * @deprecated Replaced by {@link #radix()}.
+     */
+    @Deprecated
+    public int R() {
+        return R;
+    }
+
+    /**
+     * Returns the number of characters in this alphabet (the radix).
+     * 
+     * @return the number of characters in this alphabet
+     */
+    public int radix() {
+        return R;
+    }
+
+    /**
+     * Returns the binary logarithm of the number of characters in this alphabet.
+     * 
+     * @return the binary logarithm (rounded up) of the number of characters in this alphabet
+     */
+    public int lgR() {
+        int lgR = 0;
+        for (int t = R-1; t >= 1; t /= 2)
+            lgR++;
+        return lgR;
+    }
+
+    /**
+     * Returns the index corresponding to the argument character.
+     * 
+     * @param  c the character
+     * @return the index corresponding to the character {@code c}
+     * @throws IllegalArgumentException unless {@code c} is a character in this alphabet
+     */
+    public int toIndex(char c) {
+        if (c >= inverse.length || inverse[c] == -1) {
+            throw new IllegalArgumentException("Character " + c + " not in alphabet");
+        }
+        return inverse[c];
+    }
+
+    /**
+     * Returns the indices corresponding to the argument characters.
+     * 
+     * @param  s the characters
+     * @return the indices corresponding to the characters {@code s}
+     * @throws IllegalArgumentException unless every character in {@code s}
+     *         is a character in this alphabet
+     */
+    public int[] toIndices(String s) {
+        char[] source = s.toCharArray();
+        int[] target  = new int[s.length()];
+        for (int i = 0; i < source.length; i++)
+            target[i] = toIndex(source[i]);
+        return target;
+    }
+
+    /**
+     * Returns the character corresponding to the argument index.
+     * 
+     * @param  index the index
+     * @return the character corresponding to the index {@code index}
+     * @throws IllegalArgumentException unless {@code 0 <= index < R}
+     */
+    public char toChar(int index) {
+        if (index < 0 || index >= R) {
+            throw new IllegalArgumentException("index must be between 0 and " + R + ": " + index);
+        }
+        return alphabet[index];
+    }
+
+    /**
+     * Returns the characters corresponding to the argument indices.
+     * 
+     * @param  indices the indices
+     * @return the characters corresponding to the indices {@code indices}
+     * @throws IllegalArgumentException unless {@code 0 < indices[i] < R}
+     *         for every {@code i}
+     */
+    public String toChars(int[] indices) {
+        StringBuilder s = new StringBuilder(indices.length);
+        for (int i = 0; i < indices.length; i++)
+            s.append(toChar(indices[i]));
+        return s.toString();
+    }
+
+    /**
+     * Unit tests the {@code Alphabet} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int[]  encoded1 = Alphabet.BASE64.toIndices("NowIsTheTimeForAllGoodMen");
+        String decoded1 = Alphabet.BASE64.toChars(encoded1);
+        StdOut.println(decoded1);
+ 
+        int[]  encoded2 = Alphabet.DNA.toIndices("AACGAACGGTTTACCCCG");
+        String decoded2 = Alphabet.DNA.toChars(encoded2);
+        StdOut.println(decoded2);
+
+        int[]  encoded3 = Alphabet.DECIMAL.toIndices("01234567890123456789");
+        String decoded3 = Alphabet.DECIMAL.toChars(encoded3);
+        StdOut.println(decoded3);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AmericanFlag.java b/src/main/java/edu/princeton/cs/algs4/AmericanFlag.java
new file mode 100644
index 0000000..c769fef
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AmericanFlag.java
@@ -0,0 +1,313 @@
+/******************************************************************************
+ *  Compilation:  javac AmericanFlag.java
+ *  Execution:    java AmericanFlag < input.txt
+ *                java AmericanFlag int < input-non-negative-ints.txt  
+ *  Dependencies: StdIn.java StdOut.java Stack.java
+ *  Data files:   https://algs4.cs.princeton.edu/51radix/words3.txt
+ *                https://algs4.cs.princeton.edu/51radix/shells.txt
+ *
+ *  Sort an array of strings or integers in-place using American flag sort.
+ *
+ *  % java AmericanFlag < shells.txt 
+ *  are
+ *  by
+ *  sea
+ *  seashells
+ *  seashells
+ *  sells
+ *  sells
+ *  she
+ *  she
+ *  shells
+ *  shore
+ *  surely
+ *  the
+ *  the
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code AmericanFlag} class provides static methods for sorting an
+ *  array of extended ASCII strings or integers in-place using 
+ *  American flag sort. This is a non-recursive implementation.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/51radix">Section 5.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne
+ *  and <a href = "http://static.usenix.org/publications/compsystems/1993/win_mcilroy.pdf">
+ *  Engineering Radix Sort</a> by McIlroy and Bostic.
+ *  For a version that uses only one auxilary array, see {@link AmericanFlagX}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *  @author Ivan Pesin
+ */
+
+public class AmericanFlag {
+    private static final int BITS_PER_BYTE =   8;
+    private static final int BITS_PER_INT  =  32;   // each Java int is 32 bits 
+    private static final int R             = 256;   // extend ASCII alphabet size
+    private static final int CUTOFF        =  15;   // cutoff to insertion sort
+
+    // do not instantiate
+    private AmericanFlag() { } 
+
+    // return dth character of s, -1 if d = length of string
+    private static int charAt(String s, int d) {
+        assert d >= 0 && d <= s.length();
+        if (d == s.length()) return -1;
+        return s.charAt(d);
+    }
+
+    /**
+     * Rearranges the array of extended ASCII strings in ascending order.
+     * This is an unstable sorting algorithm.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(String[] a) {
+        sort(a, 0, a.length - 1);
+    }
+
+    // sort from a[lo] to a[hi], starting at the dth character
+    public static void sort(String[] a, int lo, int hi) {
+        // one-time allocation of data structures
+        Stack<Integer> st = new Stack<Integer>();
+        int[] first = new int[R+2];
+        int[] next  = new int[R+2];
+        int d = 0; // character index to sort by
+
+        st.push(lo);
+        st.push(hi);
+        st.push(d);
+        
+        while (!st.isEmpty()) {
+            d = st.pop();
+            hi = st.pop();
+            lo = st.pop();
+        
+            if (hi <= lo + CUTOFF) {
+                insertion(a, lo, hi, d);
+                continue;
+            }
+
+            // compute frequency counts
+            for (int i = lo; i <= hi; i++) {
+                int c = charAt(a[i], d) + 1; // account for -1 representing end-of-string
+                first[c+1]++;
+            }
+
+            // first[c] = location of first string whose dth character = c
+            first[0] = lo;
+            for (int c = 0; c <= R; c++) {
+                first[c+1] += first[c];
+            
+                if (c > 0 && first[c+1]-1 > first[c]) { 
+                    // add subproblem for character c (excludes sentinel c == 0)
+                    st.push(first[c]);
+                    st.push(first[c+1] - 1);
+                    st.push(d+1); 
+                }
+            }
+
+            // next[c] = location to place next string whose dth character = c
+            for (int c = 0; c < R+2; c++)
+                next[c] = first[c];
+
+            // permute data in place
+            for (int k = lo; k <= hi; k++) {
+                int c = charAt(a[k], d) + 1;
+                while (first[c] > k) {
+                    exch(a, k, next[c]++);
+                    c = charAt(a[k], d) + 1;
+                }
+                next[c]++;
+            }
+          
+            // clear first[] and next[] arrays
+            for (int c = 0; c < R+2; c++) {
+                first[c] = 0;
+                next[c] = 0;
+            }
+        }
+    }
+    
+    // insertion sort a[lo..hi], starting at dth character
+    private static void insertion(String[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(String[] a, int i, int j) {
+        String temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+    // is v less than w, starting at character d
+    private static boolean less(String v, String w, int d) {
+        // assert v.substring(0, d).equals(w.substring(0, d));
+        for (int i = d; i <  Math.min(v.length(), w.length()); i++) {
+            if (v.charAt(i) < w.charAt(i)) return true;
+            if (v.charAt(i) > w.charAt(i)) return false;
+        }
+        return v.length() < w.length();
+    }
+
+   /**
+     * Rearranges the array of 32-bit integers in ascending order.
+     * Currently assumes that the integers are nonnegative.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(int[] a) {
+        sort(a, 0, a.length-1);
+    }
+
+    // MSD sort from a[lo] to a[hi]
+    private static void sort(int[] a, int lo, int hi) {
+        // one-time allocation of data structures
+        Stack<Integer> st = new Stack<Integer>();
+        int[] first = new int[R+1];
+        int[] next  = new int[R+1];
+        int mask = R - 1;   // 0xFF;
+        int d = 0;          // byte to sort by
+
+        st.push(lo);
+        st.push(hi);
+        st.push(d);
+        
+        while (!st.isEmpty()) {
+            d = st.pop();
+            hi = st.pop();
+            lo = st.pop();
+        
+            if (hi <= lo + CUTOFF) {
+                insertion(a, lo, hi, d);
+                continue;
+            }
+          
+            // compute frequency counts (need R = 256)
+            int shift = BITS_PER_INT - BITS_PER_BYTE*d - BITS_PER_BYTE;
+            for (int i = lo; i <= hi; i++) {
+                int c = (a[i] >> shift) & mask;
+                first[c+1]++;
+            }
+
+            // first[c] = location of first int whose dth byte = c
+            first[0] = lo;
+            for (int c = 0; c < R; c++) {
+                first[c+1] += first[c];
+            
+                if (d < 3 && first[c+1]-1 > first[c]) { 
+                    // add subproblem for byte c
+                    st.push(first[c]);
+                    st.push(first[c+1] - 1);
+                    st.push(d+1); 
+                }
+            }
+
+            // next[c] = location to place next string whose dth byte = c
+            for (int c = 0; c < R+1; c++)
+                next[c] = first[c];
+
+            // permute data in place
+            for (int k = lo; k <= hi; k++) {
+                int c = (a[k] >> shift) & mask;
+                while (first[c] > k) {
+                    exch(a, k, next[c]++);
+                    c = (a[k] >> shift) & mask;
+                }
+                next[c]++;
+            }
+          
+            // clear first[] and next[] arrays
+            for (int c = 0; c < R+1; c++) {
+                first[c] = 0;
+                next[c] = 0;
+            }
+        }
+    }
+
+    // insertion sort a[lo..hi], starting at dth byte
+    private static void insertion(int[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(int[] a, int i, int j) {
+        int temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+    
+    // is v less than w, starting at byte d
+    private static boolean less(int v, int w, int d) {
+        int mask = R - 1;   // 0xFF;
+        for (int i = d; i < 4; i++) {
+            int shift = BITS_PER_INT - BITS_PER_BYTE*i - BITS_PER_BYTE;
+            int a = (v >> shift) & mask;
+            int b = (w >> shift) & mask;
+            if (a < b) return true;
+            if (a > b) return false;
+        }
+        return false;
+    }
+    
+    /**
+     * Reads in a sequence of extended ASCII strings or non-negative ints from standard input;
+     * American flag sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments: "int" to read input as non-negative integers
+     */
+    public static void main(String[] args) {
+        if (args.length > 0 && args[0].equals("int")) {
+            int[] a = StdIn.readAllInts();
+            sort(a);
+
+            // print results
+            for (int i = 0; i < a.length; i++)
+                StdOut.println(a[i]);
+        }
+
+        else {
+            String[] a = StdIn.readAllStrings();
+            sort(a);
+            // print results
+            for (int i = 0; i < a.length; i++)
+                StdOut.println(a[i]);
+        }
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AmericanFlagX.java b/src/main/java/edu/princeton/cs/algs4/AmericanFlagX.java
new file mode 100644
index 0000000..3c1f6dc
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AmericanFlagX.java
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *  Compilation:  javac AmericanFlagX.java
+ *  Execution:    java AmericanFlagX < input.txt
+ *  Dependencies: StdIn.java StdOut.java Stack.java
+ *  Data files:   https://algs4.cs.princeton.edu/51radix/words3.txt
+ *                https://algs4.cs.princeton.edu/51radix/shells.txt
+ *
+ *  Sort an array of strings or integers in-place using American Flag sort.
+ *
+ *  % java AmericanFlagX < shells.txt 
+ *  are
+ *  by
+ *  sea
+ *  seashells
+ *  seashells
+ *  sells
+ *  sells
+ *  she
+ *  she
+ *  shells
+ *  shore
+ *  surely
+ *  the
+ *  the
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code AmericanFlagX} class provides static methods for sorting an
+ *  array of extended ASCII strings or integers in-place using 
+ *  American Flag sort. This implementation is non-recursive and uses only 
+ *  one auxiliary array.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/51radix">Section 5.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne
+ *  and <a href = "http://static.usenix.org/publications/compsystems/1993/win_mcilroy.pdf">
+ *  Engineering Radix Sort</a> by McIlroy and Bostic.
+ *  For a version that uses two auxilary arrays, see {@link AmericanFlag}.
+ *
+ *  @author Ivan Pesin
+ */
+
+public class AmericanFlagX {
+    private static final int R      = 256;   // extend ASCII alphabet size
+    private static final int CUTOFF =  15;   // cutoff to insertion sort
+
+    // do not instantiate
+    private AmericanFlagX() { } 
+
+    // return dth character of s, -1 if d = length of string
+    private static int charAt(String s, int d) {
+        assert d >= 0 && d <= s.length();
+        if (d == s.length()) return -1;
+        return s.charAt(d);
+    }
+
+    /**
+     * Rearranges the array of extended ASCII strings in ascending order.
+     * This is an unstable in-place sorting algorithm.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(String[] a) {
+        sort(a, 0, a.length - 1);
+    }
+
+    // sort from a[lo] to a[hi], starting at the dth character
+    public static void sort(String[] a, int lo, int hi) {
+        // one-time allocation of data structures
+        Stack<Integer> st = new Stack<Integer>();
+        int[] count = new int[R+1];
+        int d = 0; // character index to sort by
+
+        st.push(lo);
+        st.push(hi);
+        st.push(d);
+        
+        while (!st.isEmpty()) {
+            d = st.pop();
+            hi = st.pop();
+            lo = st.pop();
+
+            if (hi <= lo + CUTOFF) {
+                insertion(a, lo, hi, d);
+                continue;
+            }
+
+            // compute frequency counts
+            for (int i = lo; i <= hi; i++) {
+                int c = charAt(a[i], d) + 1; // account for -1 representing end-of-string
+                count[c]++;
+            }
+
+            // accumulate counts relative to a[0], so that 
+            // count[c] is the number of keys <= c
+            count[0] += lo;
+            for (int c = 0; c < R; c++) {
+                count[c+1] += count[c];
+            
+                if (c > 0 && count[c+1]-1 > count[c]) { 
+                    // add subproblem for character c (excludes sentinel c == 0)
+                    st.push(count[c]);
+                    st.push(count[c+1]-1);
+                    st.push(d+1); 
+                }
+            }
+
+            // permute data in place
+            // for details and proof see Knuth Theorem 5.1.2B and ch 5.2 excercise 13.
+            for (int r = hi; r >= lo; r--) {
+
+                // locate element that must be shifted right of r
+                int c = charAt(a[r], d) + 1;
+                while (r >= lo && count[c]-1 <= r) {
+                    if (count[c]-1 == r) count[c]--;
+                    r--;
+                    if (r >= lo) c = charAt(a[r], d) + 1;
+                }
+
+                // if r < lo the subarray is sorted.
+                if (r < lo) break;
+            
+                // permute a[r] until correct element is in place
+                while (--count[c] != r) {
+                    exch(a, r, count[c]);
+                    c = charAt(a[r], d) + 1;
+                }
+            }
+          
+            // clear count[] array
+            for (int c = 0; c < R+1; c++)
+                count[c] = 0;
+        }
+    }
+    
+    // insertion sort a[lo..hi], starting at dth character
+    private static void insertion(String[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(String[] a, int i, int j) {
+        String temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+    // is v less than w, starting at character d
+    private static boolean less(String v, String w, int d) {
+        // assert v.substring(0, d).equals(w.substring(0, d));
+        for (int i = d; i <  Math.min(v.length(), w.length()); i++) {
+            if (v.charAt(i) < w.charAt(i)) return true;
+            if (v.charAt(i) > w.charAt(i)) return false;
+        }
+        return v.length() < w.length();
+    }
+        
+    /**
+     * Reads in a sequence of extended ASCII strings or non-negative ints from standard input;
+     * American flag sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {      
+        String[] a = StdIn.readAllStrings();
+        sort(a);
+        // print results
+        for (int i = 0; i < a.length; i++)
+            StdOut.println(a[i]);
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Arbitrage.java b/src/main/java/edu/princeton/cs/algs4/Arbitrage.java
new file mode 100644
index 0000000..87474d8
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Arbitrage.java
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *  Compilation:  javac Arbitrage.java
+ *  Execution:    java Arbitrage < input.txt
+ *  Dependencies: EdgeWeightedDigraph.java DirectedEdge.java
+ *                BellmanFordSP.java
+ *  Data file:    https://algs4.cs.princeton.edu/44sp/rates.txt
+ *
+ *  Arbitrage detection.
+ *
+ *  % more rates.txt
+ *  5
+ *  USD 1      0.741  0.657  1.061  1.005
+ *  EUR 1.349  1      0.888  1.433  1.366
+ *  GBP 1.521  1.126  1      1.614  1.538
+ *  CHF 0.942  0.698  0.619  1      0.953
+ *  CAD 0.995  0.732  0.650  1.049  1
+ *
+ *  % java Arbitrage < rates.txt
+ *  1000.00000 USD =  741.00000 EUR
+ *   741.00000 EUR = 1012.20600 CAD
+ *  1012.20600 CAD = 1007.14497 USD
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Arbitrage} class provides a client that finds an arbitrage
+ *  opportunity in a currency exchange table by constructing a
+ *  complete-digraph representation of the exchange table and then finding
+ *  a negative cycle in the digraph.
+ *  <p>
+ *  This implementation uses the Bellman-Ford algorithm to find a
+ *  negative cycle in the complete digraph.
+ *  The running time is proportional to <em>V</em><sup>3</sup> in the
+ *  worst case, where <em>V</em> is the number of currencies.
+ *  <p>
+ *  This code is guaranteed to find an arbitrage opportunity in a 
+ *  currency exchange table (or report that no such arbitrage 
+ *  opportunity exists) under the assumption that all arithmetic
+ *  performed is without floating-point rounding error or arithmetic
+ *  overflow. Since the code computes the logarithms of the edge weights,
+ *  floating-point rounding error will be present and it may fail on
+ *  some pathological inputs.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Arbitrage {
+
+    // this class cannot be instantiated
+    private Arbitrage() { }
+
+    /**
+     *  Reads the currency exchange table from standard input and
+     *  prints an arbitrage opportunity to standard output (if one exists).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // V currencies
+        int V = StdIn.readInt();
+        String[] name = new String[V];
+
+        // create complete network
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);
+        for (int v = 0; v < V; v++) {
+            name[v] = StdIn.readString();
+            for (int w = 0; w < V; w++) {
+                double rate = StdIn.readDouble();
+                DirectedEdge e = new DirectedEdge(v, w, -Math.log(rate));
+                G.addEdge(e);
+            }
+        }
+
+        // find negative cycle
+        BellmanFordSP spt = new BellmanFordSP(G, 0);
+        if (spt.hasNegativeCycle()) {
+            double stake = 1000.0;
+            for (DirectedEdge e : spt.negativeCycle()) {
+                StdOut.printf("%10.5f %s ", stake, name[e.from()]);
+                stake *= Math.exp(-e.weight());
+                StdOut.printf("= %10.5f %s\n", stake, name[e.to()]);
+            }
+        }
+        else {
+            StdOut.println("No arbitrage opportunity");
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/AssignmentProblem.java b/src/main/java/edu/princeton/cs/algs4/AssignmentProblem.java
new file mode 100644
index 0000000..d870464
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/AssignmentProblem.java
@@ -0,0 +1,335 @@
+/******************************************************************************
+ *  Compilation:  javac AssignmentProblem.java
+ *  Execution:    java AssignmentProblem n
+ *  Dependencies: DijkstraSP.java DirectedEdge.java
+ *
+ *  Solve an n-by-n assignment problem in n^3 log n time using the
+ *  successive shortest path algorithm.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code AssignmentProblem} class represents a data type for computing
+ *  an optimal solution to an <em>n</em>-by-<em>n</em> <em>assignment problem</em>.
+ *  The assignment problem is to find a minimum weight matching in an
+ *  edge-weighted complete bipartite graph.
+ *  <p>
+ *  The data type supplies methods for determining the optimal solution
+ *  and the corresponding dual solution.
+ *  <p>
+ *  This implementation uses the <em>successive shortest paths algorithm</em>.
+ *  The order of growth of the running time in the worst case is
+ *  O(<em>n</em>^3 log <em>n</em>) to solve an <em>n</em>-by-<em>n</em>
+ *  instance.
+ *  <p> 
+ *  This computes correct results if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/65reductions">Section 6.5</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class AssignmentProblem {
+    private static final double FLOATING_POINT_EPSILON = 1E-14;
+    private static final int UNMATCHED = -1;
+
+    private int n;              // number of rows and columns
+    private double[][] weight;  // the n-by-n cost matrix
+    private double minWeight;   // minimum value of any weight
+    private double[] px;        // px[i] = dual variable for row i
+    private double[] py;        // py[j] = dual variable for col j
+    private int[] xy;           // xy[i] = j means i-j is a match
+    private int[] yx;           // yx[j] = i means i-j is a match
+
+    /**
+     * Determines an optimal solution to the assignment problem.
+     *
+     * @param  weight the <em>n</em>-by-<em>n</em> matrix of weights
+     * @throws IllegalArgumentException unless all weights are nonnegative
+     * @throws IllegalArgumentException if {@code weight} is {@code null}
+     */ 
+    public AssignmentProblem(double[][] weight) {
+        if (weight == null) throw new IllegalArgumentException("constructor argument is null");
+
+        n = weight.length;
+        this.weight = new double[n][n];
+        for (int i = 0; i < n; i++) {
+            for (int j = 0; j < n; j++) {
+                if (Double.isNaN(weight[i][j]))
+                    throw new IllegalArgumentException("weight " + i + "-" + j  + " is NaN");
+                if (weight[i][j] < minWeight) minWeight = weight[i][j];
+                this.weight[i][j] = weight[i][j];
+            }
+        }
+
+        // dual variables
+        px = new double[n];
+        py = new double[n];
+
+        // initial matching is empty
+        xy = new int[n];
+        yx = new int[n];
+        for (int i = 0; i < n; i++)
+             xy[i] = UNMATCHED;
+        for (int j = 0; j < n; j++)
+             yx[j] = UNMATCHED;
+
+        // add n edges to matching
+        for (int k = 0; k < n; k++) {
+            assert isDualFeasible();
+            assert isComplementarySlack();
+            augment();
+        }
+        assert certifySolution();
+    }
+
+    // find shortest augmenting path and upate
+    private void augment() {
+
+        // build residual graph
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(2*n+2);
+        int s = 2*n, t = 2*n+1;
+        for (int i = 0; i < n; i++) {
+            if (xy[i] == UNMATCHED)
+                G.addEdge(new DirectedEdge(s, i, 0.0));
+        }
+        for (int j = 0; j < n; j++) {
+            if (yx[j] == UNMATCHED)
+                G.addEdge(new DirectedEdge(n+j, t, py[j]));
+        }
+        for (int i = 0; i < n; i++) {
+            for (int j = 0; j < n; j++) {
+                if (xy[i] == j) G.addEdge(new DirectedEdge(n+j, i, 0.0));
+                else            G.addEdge(new DirectedEdge(i, n+j, reducedCost(i, j)));
+            }
+        }
+
+        // compute shortest path from s to every other vertex
+        DijkstraSP spt = new DijkstraSP(G, s);
+
+        // augment along alternating path
+        for (DirectedEdge e : spt.pathTo(t)) {
+            int i = e.from(), j = e.to() - n;
+            if (i < n) {
+                xy[i] = j;
+                yx[j] = i;
+            }
+        }
+
+        // update dual variables
+        for (int i = 0; i < n; i++)
+            px[i] += spt.distTo(i);
+        for (int j = 0; j < n; j++)
+            py[j] += spt.distTo(n+j);
+    }
+
+    // reduced cost of i-j
+    // (subtracting off minWeight reweights all weights to be non-negative)
+    private double reducedCost(int i, int j) {
+        double reducedCost = (weight[i][j] - minWeight) + px[i] - py[j];
+
+        // to avoid issues with floating-point precision
+        double magnitude = Math.abs(weight[i][j]) + Math.abs(px[i]) + Math.abs(py[j]);
+        if (Math.abs(reducedCost) <= FLOATING_POINT_EPSILON * magnitude) return 0.0;
+
+        assert reducedCost >= 0.0;
+        return reducedCost;
+    }
+
+    /**
+     * Returns the dual optimal value for the specified row.
+     *
+     * @param  i the row index
+     * @return the dual optimal value for row {@code i}
+     * @throws IllegalArgumentException unless {@code 0 <= i < n}
+     *
+     */
+    // dual variable for row i
+    public double dualRow(int i) {
+        validate(i);
+        return px[i];
+    }
+
+    /**
+     * Returns the dual optimal value for the specified column.
+     *
+     * @param  j the column index
+     * @return the dual optimal value for column {@code j}
+     * @throws IllegalArgumentException unless {@code 0 <= j < n}
+     *
+     */
+    public double dualCol(int j) {
+        validate(j);
+        return py[j];
+    }
+
+    /**
+     * Returns the column associated with the specified row in the optimal solution.
+     *
+     * @param  i the row index
+     * @return the column matched to row {@code i} in the optimal solution
+     * @throws IllegalArgumentException unless {@code 0 <= i < n}
+     *
+     */
+    public int sol(int i) {
+        validate(i);
+        return xy[i];
+    }
+
+    /**
+     * Returns the total weight of the optimal solution
+     *
+     * @return the total weight of the optimal solution
+     *
+     */
+    public double weight() {
+        double total = 0.0;
+        for (int i = 0; i < n; i++) {
+            if (xy[i] != UNMATCHED)
+                total += weight[i][xy[i]];
+        }
+        return total;
+    }
+
+    private void validate(int i) {
+        if (i < 0 || i >= n) throw new IllegalArgumentException("index is not between 0 and " + (n-1) + ": " + i);
+    }
+
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // check that dual variables are feasible
+    private boolean isDualFeasible() {
+        // check that all edges have >= 0 reduced cost
+        for (int i = 0; i < n; i++) {
+            for (int j = 0; j < n; j++) {
+                if (reducedCost(i, j) < 0) {
+                    StdOut.println("Dual variables are not feasible");
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    // check that primal and dual variables are complementary slack
+    private boolean isComplementarySlack() {
+
+        // check that all matched edges have 0-reduced cost
+        for (int i = 0; i < n; i++) {
+            if ((xy[i] != UNMATCHED) && (reducedCost(i, xy[i]) != 0)) {
+                StdOut.println("Primal and dual variables are not complementary slack");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // check that primal variables are a perfect matching
+    private boolean isPerfectMatching() {
+
+        // check that xy[] is a perfect matching
+        boolean[] perm = new boolean[n];
+        for (int i = 0; i < n; i++) {
+            if (perm[xy[i]]) {
+                StdOut.println("Not a perfect matching");
+                return false;
+            }
+            perm[xy[i]] = true;
+        }
+
+        // check that xy[] and yx[] are inverses
+        for (int j = 0; j < n; j++) {
+            if (xy[yx[j]] != j) {
+                StdOut.println("xy[] and yx[] are not inverses");
+                return false;
+            }
+        }
+        for (int i = 0; i < n; i++) {
+            if (yx[xy[i]] != i) {
+                StdOut.println("xy[] and yx[] are not inverses");
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    // check optimality conditions
+    private boolean certifySolution() {
+        return isPerfectMatching() && isDualFeasible() && isComplementarySlack();
+    }
+
+    /**
+     * Unit tests the {@code AssignmentProblem} data type.
+     * Takes a command-line argument n; creates a random n-by-n matrix;
+     * solves the n-by-n assignment problem; and prints the optimal
+     * solution.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // create random n-by-n matrix
+        int n = Integer.parseInt(args[0]);
+        double[][] weight = new double[n][n];
+        for (int i = 0; i < n; i++) {
+            for (int j = 0; j < n; j++) {
+                weight[i][j] = StdRandom.uniform(900) + 100;  // 3 digits
+            }
+        }
+
+        // solve assignment problem
+        AssignmentProblem assignment = new AssignmentProblem(weight);
+        StdOut.printf("weight = %.0f\n", assignment.weight());
+        StdOut.println();
+
+        // print n-by-n matrix and optimal solution
+        if (n >= 20) return;
+        for (int i = 0; i < n; i++) {
+            for (int j = 0; j < n; j++) {
+                if (j == assignment.sol(i))
+                    StdOut.printf("*%.0f ", weight[i][j]);
+                else
+                    StdOut.printf(" %.0f ", weight[i][j]);
+            }
+            StdOut.println();
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Average.java b/src/main/java/edu/princeton/cs/algs4/Average.java
new file mode 100644
index 0000000..ff0854c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Average.java
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *  Compilation:  javac Average.java
+ *  Execution:    java Average < data.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  
+ *  Reads in a sequence of real numbers, and computes their average.
+ *
+ *  % java Average
+ *  10.0 5.0 6.0
+ *  3.0 7.0 32.0
+ *  [Ctrl-d]
+ *  Average is 10.5
+ *
+ *  Note [Ctrl-d] signifies the end of file on Unix.
+ *  On windows use [Ctrl-z].
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Average} class provides a client for reading in a sequence
+ *  of real numbers and printing out their average.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/11model">Section 1.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Average { 
+
+    // this class should not be instantiated
+    private Average() { }
+
+    /**
+     * Reads in a sequence of real numbers from standard input and prints
+     * out their average to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        int count = 0;       // number input values
+        double sum = 0.0;    // sum of input values
+
+        // read data and compute statistics
+        while (!StdIn.isEmpty()) {
+            double value = StdIn.readDouble();
+            sum += value;
+            count++;
+        }
+
+        // compute the average
+        double average = sum / count;
+
+        // print results
+        StdOut.println("Average is " + average);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BST.java b/src/main/java/edu/princeton/cs/algs4/BST.java
new file mode 100644
index 0000000..69c09d1
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BST.java
@@ -0,0 +1,577 @@
+/******************************************************************************
+ *  Compilation:  javac BST.java
+ *  Execution:    java BST
+ *  Dependencies: StdIn.java StdOut.java Queue.java
+ *  Data files:   https://algs4.cs.princeton.edu/32bst/tinyST.txt  
+ *
+ *  A symbol table implemented with a binary search tree.
+ * 
+ *  % more tinyST.txt
+ *  S E A R C H E X A M P L E
+ *  
+ *  % java BST < tinyST.txt
+ *  A 8
+ *  C 4
+ *  E 12
+ *  H 5
+ *  L 11
+ *  M 9
+ *  P 10
+ *  R 3
+ *  S 0
+ *  X 7
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code BST} class represents an ordered symbol table of generic
+ *  key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides ordered methods for finding the <em>minimum</em>,
+ *  <em>maximum</em>, <em>floor</em>, <em>select</em>, <em>ceiling</em>.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  It requires that
+ *  the key type implements the {@code Comparable} interface and calls the
+ *  {@code compareTo()} and method to compare two keys. It does not call either
+ *  {@code equals()} or {@code hashCode()}.
+ *  <p>
+ *  This implementation uses an (unbalanced) <em>binary search tree</em>.
+ *  The <em>put</em>, <em>contains</em>, <em>remove</em>, <em>minimum</em>,
+ *  <em>maximum</em>, <em>ceiling</em>, <em>floor</em>, <em>select</em>, and
+ *  <em>rank</em>  operations each take &Theta;(<em>n</em>) time in the worst
+ *  case, where <em>n</em> is the number of key-value pairs.
+ *  The <em>size</em> and <em>is-empty</em> operations take &Theta;(1) time.
+ *  The keys method takes &Theta;(<em>n</em>) time in the worst case.
+ *  Construction takes &Theta;(1) time.
+ *  <p>
+ *  For alternative implementations of the symbol table API, see {@link ST},
+ *  {@link BinarySearchST}, {@link SequentialSearchST}, {@link RedBlackBST},
+ *  {@link SeparateChainingHashST}, and {@link LinearProbingHashST},
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/32bst">Section 3.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BST<Key extends Comparable<Key>, Value> {
+    private Node root;             // root of BST
+
+    private class Node {
+        private Key key;           // sorted by key
+        private Value val;         // associated data
+        private Node left, right;  // left and right subtrees
+        private int size;          // number of nodes in subtree
+
+        public Node(Key key, Value val, int size) {
+            this.key = key;
+            this.val = val;
+            this.size = size;
+        }
+    }
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public BST() {
+    }
+
+    /**
+     * Returns true if this symbol table is empty.
+     * @return {@code true} if this symbol table is empty; {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return size(root);
+    }
+
+    // return number of key-value pairs in BST rooted at x
+    private int size(Node x) {
+        if (x == null) return 0;
+        else return x.size;
+    }
+
+    /**
+     * Does this symbol table contain the given key?
+     *
+     * @param  key the key
+     * @return {@code true} if this symbol table contains {@code key} and
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        return get(key) != null;
+    }
+
+    /**
+     * Returns the value associated with the given key.
+     *
+     * @param  key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *         and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        return get(root, key);
+    }
+
+    private Value get(Node x, Key key) {
+        if (key == null) throw new IllegalArgumentException("calls get() with a null key");
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if      (cmp < 0) return get(x.left, key);
+        else if (cmp > 0) return get(x.right, key);
+        else              return x.val;
+    }
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("calls put() with a null key");
+        if (val == null) {
+            delete(key);
+            return;
+        }
+        root = put(root, key, val);
+        assert check();
+    }
+
+    private Node put(Node x, Key key, Value val) {
+        if (x == null) return new Node(key, val, 1);
+        int cmp = key.compareTo(x.key);
+        if      (cmp < 0) x.left  = put(x.left,  key, val);
+        else if (cmp > 0) x.right = put(x.right, key, val);
+        else              x.val   = val;
+        x.size = 1 + size(x.left) + size(x.right);
+        return x;
+    }
+
+
+    /**
+     * Removes the smallest key and associated value from the symbol table.
+     *
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMin() {
+        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
+        root = deleteMin(root);
+        assert check();
+    }
+
+    private Node deleteMin(Node x) {
+        if (x.left == null) return x.right;
+        x.left = deleteMin(x.left);
+        x.size = size(x.left) + size(x.right) + 1;
+        return x;
+    }
+
+    /**
+     * Removes the largest key and associated value from the symbol table.
+     *
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMax() {
+        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow");
+        root = deleteMax(root);
+        assert check();
+    }
+
+    private Node deleteMax(Node x) {
+        if (x.right == null) return x.left;
+        x.right = deleteMax(x.right);
+        x.size = size(x.left) + size(x.right) + 1;
+        return x;
+    }
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).    
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
+        root = delete(root, key);
+        assert check();
+    }
+
+    private Node delete(Node x, Key key) {
+        if (x == null) return null;
+
+        int cmp = key.compareTo(x.key);
+        if      (cmp < 0) x.left  = delete(x.left,  key);
+        else if (cmp > 0) x.right = delete(x.right, key);
+        else { 
+            if (x.right == null) return x.left;
+            if (x.left  == null) return x.right;
+            Node t = x;
+            x = min(t.right);
+            x.right = deleteMin(t.right);
+            x.left = t.left;
+        } 
+        x.size = size(x.left) + size(x.right) + 1;
+        return x;
+    } 
+
+
+    /**
+     * Returns the smallest key in the symbol table.
+     *
+     * @return the smallest key in the symbol table
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("calls min() with empty symbol table");
+        return min(root).key;
+    } 
+
+    private Node min(Node x) { 
+        if (x.left == null) return x; 
+        else                return min(x.left); 
+    } 
+
+    /**
+     * Returns the largest key in the symbol table.
+     *
+     * @return the largest key in the symbol table
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("calls max() with empty symbol table");
+        return max(root).key;
+    } 
+
+    private Node max(Node x) {
+        if (x.right == null) return x; 
+        else                 return max(x.right); 
+    } 
+
+    /**
+     * Returns the largest key in the symbol table less than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the largest key in the symbol table less than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key floor(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
+        if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
+        Node x = floor(root, key);
+        if (x == null) throw new NoSuchElementException("argument to floor() is too small");
+        else return x.key;
+    } 
+
+    private Node floor(Node x, Key key) {
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp == 0) return x;
+        if (cmp <  0) return floor(x.left, key);
+        Node t = floor(x.right, key); 
+        if (t != null) return t;
+        else return x; 
+    } 
+
+    public Key floor2(Key key) {
+        Key x = floor2(root, key, null);
+        if (x == null) throw new NoSuchElementException("argument to floor() is too small");
+        else return x;
+
+    }
+
+    private Key floor2(Node x, Key key, Key best) {
+        if (x == null) return best;
+        int cmp = key.compareTo(x.key);
+        if      (cmp  < 0) return floor2(x.left, key, best);
+        else if (cmp  > 0) return floor2(x.right, key, x.key);
+        else               return x.key;
+    } 
+
+    /**
+     * Returns the smallest key in the symbol table greater than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the smallest key in the symbol table greater than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key ceiling(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
+        if (isEmpty()) throw new NoSuchElementException("calls ceiling() with empty symbol table");
+        Node x = ceiling(root, key);
+        if (x == null) throw new NoSuchElementException("argument to floor() is too large");
+        else return x.key;
+    }
+
+    private Node ceiling(Node x, Key key) {
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp == 0) return x;
+        if (cmp < 0) { 
+            Node t = ceiling(x.left, key); 
+            if (t != null) return t;
+            else return x; 
+        } 
+        return ceiling(x.right, key); 
+    } 
+
+    /**
+     * Return the key in the symbol table of a given {@code rank}.
+     * This key has the property that there are {@code rank} keys in
+     * the symbol table that are smaller. In other words, this key is the
+     * ({@code rank}+1)st smallest key in the symbol table.
+     *
+     * @param  rank the order statistic
+     * @return the key in the symbol table of given {@code rank}
+     * @throws IllegalArgumentException unless {@code rank} is between 0 and
+     *        <em>n</em>‚Äì1
+     */
+    public Key select(int rank) {
+        if (rank < 0 || rank >= size()) {
+            throw new IllegalArgumentException("argument to select() is invalid: " + rank);
+        }
+        return select(root, rank);
+    }
+
+    // Return key in BST rooted at x of given rank.
+    // Precondition: rank is in legal range.
+    private Key select(Node x, int rank) {
+        if (x == null) return null;
+        int leftSize = size(x.left);
+        if      (leftSize > rank) return select(x.left,  rank);
+        else if (leftSize < rank) return select(x.right, rank - leftSize - 1); 
+        else                      return x.key;
+    }
+
+    /**
+     * Return the number of keys in the symbol table strictly less than {@code key}.
+     *
+     * @param  key the key
+     * @return the number of keys in the symbol table strictly less than {@code key}
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public int rank(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to rank() is null");
+        return rank(key, root);
+    } 
+
+    // Number of keys in the subtree less than key.
+    private int rank(Key key, Node x) {
+        if (x == null) return 0; 
+        int cmp = key.compareTo(x.key); 
+        if      (cmp < 0) return rank(key, x.left); 
+        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right); 
+        else              return size(x.left); 
+    } 
+
+    /**
+     * Returns all keys in the symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     *
+     * @return all keys in the symbol table
+     */
+    public Iterable<Key> keys() {
+        if (isEmpty()) return new Queue<Key>();
+        return keys(min(), max());
+    }
+
+    /**
+     * Returns all keys in the symbol table in the given range,
+     * as an {@code Iterable}.
+     *
+     * @param  lo minimum endpoint
+     * @param  hi maximum endpoint
+     * @return all keys in the symbol table between {@code lo} 
+     *         (inclusive) and {@code hi} (inclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *         is {@code null}
+     */
+    public Iterable<Key> keys(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null");
+        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null");
+
+        Queue<Key> queue = new Queue<Key>();
+        keys(root, queue, lo, hi);
+        return queue;
+    } 
+
+    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) { 
+        if (x == null) return; 
+        int cmplo = lo.compareTo(x.key); 
+        int cmphi = hi.compareTo(x.key); 
+        if (cmplo < 0) keys(x.left, queue, lo, hi); 
+        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key); 
+        if (cmphi > 0) keys(x.right, queue, lo, hi); 
+    } 
+
+    /**
+     * Returns the number of keys in the symbol table in the given range.
+     *
+     * @param  lo minimum endpoint
+     * @param  hi maximum endpoint
+     * @return the number of keys in the symbol table between {@code lo} 
+     *         (inclusive) and {@code hi} (inclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *         is {@code null}
+     */
+    public int size(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to size() is null");
+        if (hi == null) throw new IllegalArgumentException("second argument to size() is null");
+
+        if (lo.compareTo(hi) > 0) return 0;
+        if (contains(hi)) return rank(hi) - rank(lo) + 1;
+        else              return rank(hi) - rank(lo);
+    }
+
+    /**
+     * Returns the height of the BST (for debugging).
+     *
+     * @return the height of the BST (a 1-node tree has height 0)
+     */
+    public int height() {
+        return height(root);
+    }
+    private int height(Node x) {
+        if (x == null) return -1;
+        return 1 + Math.max(height(x.left), height(x.right));
+    }
+
+    /**
+     * Returns the keys in the BST in level order (for debugging).
+     *
+     * @return the keys in the BST in level order traversal
+     */
+    public Iterable<Key> levelOrder() {
+        Queue<Key> keys = new Queue<Key>();
+        Queue<Node> queue = new Queue<Node>();
+        queue.enqueue(root);
+        while (!queue.isEmpty()) {
+            Node x = queue.dequeue();
+            if (x == null) continue;
+            keys.enqueue(x.key);
+            queue.enqueue(x.left);
+            queue.enqueue(x.right);
+        }
+        return keys;
+    }
+
+  /*************************************************************************
+    *  Check integrity of BST data structure.
+    ***************************************************************************/
+    private boolean check() {
+        if (!isBST())            StdOut.println("Not in symmetric order");
+        if (!isSizeConsistent()) StdOut.println("Subtree counts not consistent");
+        if (!isRankConsistent()) StdOut.println("Ranks not consistent");
+        return isBST() && isSizeConsistent() && isRankConsistent();
+    }
+
+    // does this binary tree satisfy symmetric order?
+    // Note: this test also ensures that data structure is a binary tree since order is strict
+    private boolean isBST() {
+        return isBST(root, null, null);
+    }
+
+    // is the tree rooted at x a BST with all keys strictly between min and max
+    // (if min or max is null, treat as empty constraint)
+    // Credit: Bob Dondero's elegant solution
+    private boolean isBST(Node x, Key min, Key max) {
+        if (x == null) return true;
+        if (min != null && x.key.compareTo(min) <= 0) return false;
+        if (max != null && x.key.compareTo(max) >= 0) return false;
+        return isBST(x.left, min, x.key) && isBST(x.right, x.key, max);
+    } 
+
+    // are the size fields correct?
+    private boolean isSizeConsistent() { return isSizeConsistent(root); }
+    private boolean isSizeConsistent(Node x) {
+        if (x == null) return true;
+        if (x.size != size(x.left) + size(x.right) + 1) return false;
+        return isSizeConsistent(x.left) && isSizeConsistent(x.right);
+    } 
+
+    // check that ranks are consistent
+    private boolean isRankConsistent() {
+        for (int i = 0; i < size(); i++)
+            if (i != rank(select(i))) return false;
+        for (Key key : keys())
+            if (key.compareTo(select(rank(key))) != 0) return false;
+        return true;
+    }
+
+
+    /**
+     * Unit tests the {@code BST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        BST<String, Integer> st = new BST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+
+        for (String s : st.levelOrder())
+            StdOut.println(s + " " + st.get(s));
+
+        StdOut.println();
+
+        for (String s : st.keys())
+            StdOut.println(s + " " + st.get(s));
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BTree.java b/src/main/java/edu/princeton/cs/algs4/BTree.java
new file mode 100644
index 0000000..e80da03
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BTree.java
@@ -0,0 +1,314 @@
+/******************************************************************************
+ *  Compilation:  javac BTree.java
+ *  Execution:    java BTree
+ *  Dependencies: StdOut.java
+ *
+ *  B-tree.
+ *
+ *  Limitations
+ *  -----------
+ *   -  Assumes M is even and M >= 4
+ *   -  should b be an array of children or list (it would help with
+ *      casting to make it a list)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BTree} class represents an ordered symbol table of generic
+ *  key-value pairs.
+ *  It supports the <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>size</em>, and <em>is-empty</em> methods.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  This implementation uses a B-tree. It requires that
+ *  the key type implements the {@code Comparable} interface and calls the
+ *  {@code compareTo()} and method to compare two keys. It does not call either
+ *  {@code equals()} or {@code hashCode()}.
+ *  The <em>get</em>, <em>put</em>, and <em>contains</em> operations
+ *  each make log<sub><em>m</em></sub>(<em>n</em>) probes in the worst case,
+ *  where <em>n</em> is the number of key-value pairs
+ *  and <em>m</em> is the branching factor.
+ *  The <em>size</em>, and <em>is-empty</em> operations take constant time.
+ *  Construction takes constant time.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/62btree">Section 6.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class BTree<Key extends Comparable<Key>, Value>  {
+    // max children per B-tree node = M-1
+    // (must be even and greater than 2)
+    private static final int M = 4;
+
+    private Node root;       // root of the B-tree
+    private int height;      // height of the B-tree
+    private int n;           // number of key-value pairs in the B-tree
+
+    // helper B-tree node data type
+    private static final class Node {
+        private int m;                             // number of children
+        private Entry[] children = new Entry[M];   // the array of children
+
+        // create a node with k children
+        private Node(int k) {
+            m = k;
+        }
+    }
+
+    // internal nodes: only use key and next
+    // external nodes: only use key and value
+    private static class Entry {
+        private Comparable key;
+        private Object val;
+        private Node next;     // helper field to iterate over array entries
+        public Entry(Comparable key, Object val, Node next) {
+            this.key  = key;
+            this.val  = val;
+            this.next = next;
+        }
+    }
+
+    /**
+     * Initializes an empty B-tree.
+     */
+    public BTree() {
+        root = new Node(0);
+    }
+ 
+    /**
+     * Returns true if this symbol table is empty.
+     * @return {@code true} if this symbol table is empty; {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns the height of this B-tree (for debugging).
+     *
+     * @return the height of this B-tree
+     */
+    public int height() {
+        return height;
+    }
+
+
+    /**
+     * Returns the value associated with the given key.
+     *
+     * @param  key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *         and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null");
+        return search(root, key, height);
+    }
+
+    private Value search(Node x, Key key, int ht) {
+        Entry[] children = x.children;
+
+        // external node
+        if (ht == 0) {
+            for (int j = 0; j < x.m; j++) {
+                if (eq(key, children[j].key)) return (Value) children[j].val;
+            }
+        }
+
+        // internal node
+        else {
+            for (int j = 0; j < x.m; j++) {
+                if (j+1 == x.m || less(key, children[j+1].key))
+                    return search(children[j].next, key, ht-1);
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * Inserts the key-value pair into the symbol table, overwriting the old value
+     * with the new value if the key is already in the symbol table.
+     * If the value is {@code null}, this effectively deletes the key from the symbol table.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("argument key to put() is null");
+        Node u = insert(root, key, val, height); 
+        n++;
+        if (u == null) return;
+
+        // need to split root
+        Node t = new Node(2);
+        t.children[0] = new Entry(root.children[0].key, null, root);
+        t.children[1] = new Entry(u.children[0].key, null, u);
+        root = t;
+        height++;
+    }
+
+    private Node insert(Node h, Key key, Value val, int ht) {
+        int j;
+        Entry t = new Entry(key, val, null);
+
+        // external node
+        if (ht == 0) {
+            for (j = 0; j < h.m; j++) {
+                if (less(key, h.children[j].key)) break;
+            }
+        }
+
+        // internal node
+        else {
+            for (j = 0; j < h.m; j++) {
+                if ((j+1 == h.m) || less(key, h.children[j+1].key)) {
+                    Node u = insert(h.children[j++].next, key, val, ht-1);
+                    if (u == null) return null;
+                    t.key = u.children[0].key;
+                    t.val = null;
+                    t.next = u;
+                    break;
+                }
+            }
+        }
+
+        for (int i = h.m; i > j; i--)
+            h.children[i] = h.children[i-1];
+        h.children[j] = t;
+        h.m++;
+        if (h.m < M) return null;
+        else         return split(h);
+    }
+
+    // split node in half
+    private Node split(Node h) {
+        Node t = new Node(M/2);
+        h.m = M/2;
+        for (int j = 0; j < M/2; j++)
+            t.children[j] = h.children[M/2+j]; 
+        return t;    
+    }
+
+    /**
+     * Returns a string representation of this B-tree (for debugging).
+     *
+     * @return a string representation of this B-tree.
+     */
+    public String toString() {
+        return toString(root, height, "") + "\n";
+    }
+
+    private String toString(Node h, int ht, String indent) {
+        StringBuilder s = new StringBuilder();
+        Entry[] children = h.children;
+
+        if (ht == 0) {
+            for (int j = 0; j < h.m; j++) {
+                s.append(indent + children[j].key + " " + children[j].val + "\n");
+            }
+        }
+        else {
+            for (int j = 0; j < h.m; j++) {
+                if (j > 0) s.append(indent + "(" + children[j].key + ")\n");
+                s.append(toString(children[j].next, ht-1, indent + "     "));
+            }
+        }
+        return s.toString();
+    }
+
+
+    // comparison functions - make Comparable instead of Key to avoid casts
+    private boolean less(Comparable k1, Comparable k2) {
+        return k1.compareTo(k2) < 0;
+    }
+
+    private boolean eq(Comparable k1, Comparable k2) {
+        return k1.compareTo(k2) == 0;
+    }
+
+
+    /**
+     * Unit tests the {@code BTree} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        BTree<String, String> st = new BTree<String, String>();
+
+        st.put("www.cs.princeton.edu", "128.112.136.12");
+        st.put("www.cs.princeton.edu", "128.112.136.11");
+        st.put("www.princeton.edu",    "128.112.128.15");
+        st.put("www.yale.edu",         "130.132.143.21");
+        st.put("www.simpsons.com",     "209.052.165.60");
+        st.put("www.apple.com",        "17.112.152.32");
+        st.put("www.amazon.com",       "207.171.182.16");
+        st.put("www.ebay.com",         "66.135.192.87");
+        st.put("www.cnn.com",          "64.236.16.20");
+        st.put("www.google.com",       "216.239.41.99");
+        st.put("www.nytimes.com",      "199.239.136.200");
+        st.put("www.microsoft.com",    "207.126.99.140");
+        st.put("www.dell.com",         "143.166.224.230");
+        st.put("www.slashdot.org",     "66.35.250.151");
+        st.put("www.espn.com",         "199.181.135.201");
+        st.put("www.weather.com",      "63.111.66.11");
+        st.put("www.yahoo.com",        "216.109.118.65");
+
+
+        StdOut.println("cs.princeton.edu:  " + st.get("www.cs.princeton.edu"));
+        StdOut.println("hardvardsucks.com: " + st.get("www.harvardsucks.com"));
+        StdOut.println("simpsons.com:      " + st.get("www.simpsons.com"));
+        StdOut.println("apple.com:         " + st.get("www.apple.com"));
+        StdOut.println("ebay.com:          " + st.get("www.ebay.com"));
+        StdOut.println("dell.com:          " + st.get("www.dell.com"));
+        StdOut.println();
+
+        StdOut.println("size:    " + st.size());
+        StdOut.println("height:  " + st.height());
+        StdOut.println(st);
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Bag.java b/src/main/java/edu/princeton/cs/algs4/Bag.java
new file mode 100644
index 0000000..86610a4
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Bag.java
@@ -0,0 +1,176 @@
+/******************************************************************************
+ *  Compilation:  javac Bag.java
+ *  Execution:    java Bag < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *
+ *  A generic bag or multiset, implemented using a singly linked list.
+ *
+ *  % more tobe.txt 
+ *  to be or not to - be - - that - - - is
+ *
+ *  % java Bag < tobe.txt
+ *  size of bag = 14
+ *  is
+ *  -
+ *  -
+ *  -
+ *  that
+ *  -
+ *  -
+ *  be
+ *  -
+ *  to
+ *  not
+ *  or
+ *  be
+ *  to
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code Bag} class represents a bag (or multiset) of 
+ *  generic items. It supports insertion and iterating over the 
+ *  items in arbitrary order.
+ *  <p>
+ *  This implementation uses a singly linked list with a static nested class Node.
+ *  See {@link LinkedBag} for the version from the
+ *  textbook that uses a non-static nested class.
+ *  See {@link ResizingArrayBag} for a version that uses a resizing array.
+ *  The <em>add</em>, <em>isEmpty</em>, and <em>size</em> operations
+ *  take constant time. Iteration takes time proportional to the number of items.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Item> the generic type of an item in this bag
+ */
+public class Bag<Item> implements Iterable<Item> {
+    private Node<Item> first;    // beginning of bag
+    private int n;               // number of elements in bag
+
+    // helper linked list class
+    private static class Node<Item> {
+        private Item item;
+        private Node<Item> next;
+    }
+
+    /**
+     * Initializes an empty bag.
+     */
+    public Bag() {
+        first = null;
+        n = 0;
+    }
+
+    /**
+     * Returns true if this bag is empty.
+     *
+     * @return {@code true} if this bag is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return first == null;
+    }
+
+    /**
+     * Returns the number of items in this bag.
+     *
+     * @return the number of items in this bag
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Adds the item to this bag.
+     *
+     * @param  item the item to add to this bag
+     */
+    public void add(Item item) {
+        Node<Item> oldfirst = first;
+        first = new Node<Item>();
+        first.item = item;
+        first.next = oldfirst;
+        n++;
+    }
+
+
+    /**
+     * Returns an iterator that iterates over the items in this bag in arbitrary order.
+     *
+     * @return an iterator that iterates over the items in this bag in arbitrary order
+     */
+    public Iterator<Item> iterator()  {
+        return new LinkedIterator(first);  
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class LinkedIterator implements Iterator<Item> {
+        private Node<Item> current;
+
+        public LinkedIterator(Node<Item> first) {
+            current = first;
+        }
+
+        public boolean hasNext()  { return current != null;                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = current.item;
+            current = current.next; 
+            return item;
+        }
+    }
+
+    /**
+     * Unit tests the {@code Bag} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Bag<String> bag = new Bag<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            bag.add(item);
+        }
+
+        StdOut.println("size of bag = " + bag.size());
+        for (String s : bag) {
+            StdOut.println(s);
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BellmanFordSP.java b/src/main/java/edu/princeton/cs/algs4/BellmanFordSP.java
new file mode 100644
index 0000000..b6df2a3
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BellmanFordSP.java
@@ -0,0 +1,333 @@
+/******************************************************************************
+ *  Compilation:  javac BellmanFordSP.java
+ *  Execution:    java BellmanFordSP filename.txt s
+ *  Dependencies: EdgeWeightedDigraph.java DirectedEdge.java Queue.java
+ *                EdgeWeightedDirectedCycle.java
+ *  Data files:   https://algs4.cs.princeton.edu/44sp/tinyEWDn.txt
+ *                https://algs4.cs.princeton.edu/44sp/mediumEWDnc.txt
+ *
+ *  Bellman-Ford shortest path algorithm. Computes the shortest path tree in
+ *  edge-weighted digraph G from vertex s, or finds a negative cost cycle
+ *  reachable from s.
+ *
+ *  % java BellmanFordSP tinyEWDn.txt 0
+ *  0 to 0 ( 0.00)  
+ *  0 to 1 ( 0.93)  0->2  0.26   2->7  0.34   7->3  0.39   3->6  0.52   6->4 -1.25   4->5  0.35   5->1  0.32
+ *  0 to 2 ( 0.26)  0->2  0.26   
+ *  0 to 3 ( 0.99)  0->2  0.26   2->7  0.34   7->3  0.39   
+ *  0 to 4 ( 0.26)  0->2  0.26   2->7  0.34   7->3  0.39   3->6  0.52   6->4 -1.25   
+ *  0 to 5 ( 0.61)  0->2  0.26   2->7  0.34   7->3  0.39   3->6  0.52   6->4 -1.25   4->5  0.35
+ *  0 to 6 ( 1.51)  0->2  0.26   2->7  0.34   7->3  0.39   3->6  0.52   
+ *  0 to 7 ( 0.60)  0->2  0.26   2->7  0.34   
+ *
+ *  % java BellmanFordSP tinyEWDnc.txt 0
+ *  4->5  0.35
+ *  5->4 -0.66
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BellmanFordSP} class represents a data type for solving the
+ *  single-source shortest paths problem in edge-weighted digraphs with
+ *  no negative cycles. 
+ *  The edge weights can be positive, negative, or zero.
+ *  This class finds either a shortest path from the source vertex <em>s</em>
+ *  to every other vertex or a negative cycle reachable from the source vertex.
+ *  <p>
+ *  This implementation uses a queue-based implementation of 
+ *  the Bellman-Ford-Moore algorithm.
+ *  The constructor takes &Theta;(<em>E</em> <em>V</em>) time
+ *  in the worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges. In practice, it performs much better.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the
+ *  edge-weighted digraph).
+ *  <p>
+ *  This correctly computes shortest paths if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>. Since all intermediate
+ *  results are sums of edge weights, they are bounded by <em>V C</em>,
+ *  where <em>V</em> is the number of vertices and <em>C</em> is the maximum
+ *  absolute value of any edge weight.
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of    
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BellmanFordSP {
+    // for floating-point precision issues
+    private static final double EPSILON = 1E-14;
+
+    private double[] distTo;               // distTo[v] = distance  of shortest s->v path
+    private DirectedEdge[] edgeTo;         // edgeTo[v] = last edge on shortest s->v path
+    private boolean[] onQueue;             // onQueue[v] = is v currently on the queue?
+    private Queue<Integer> queue;          // queue of vertices to relax
+    private int cost;                      // number of calls to relax()
+    private Iterable<DirectedEdge> cycle;  // negative cycle (or null if no such cycle)
+
+    /**
+     * Computes a shortest paths tree from {@code s} to every other vertex in
+     * the edge-weighted digraph {@code G}.
+     * @param G the acyclic digraph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public BellmanFordSP(EdgeWeightedDigraph G, int s) {
+        distTo  = new double[G.V()];
+        edgeTo  = new DirectedEdge[G.V()];
+        onQueue = new boolean[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = Double.POSITIVE_INFINITY;
+        distTo[s] = 0.0;
+
+        // Bellman-Ford algorithm
+        queue = new Queue<Integer>();
+        queue.enqueue(s);
+        onQueue[s] = true;
+        while (!queue.isEmpty() && !hasNegativeCycle()) {
+            int v = queue.dequeue();
+            onQueue[v] = false;
+            relax(G, v);
+        }
+
+        assert check(G, s);
+    }
+
+    // relax vertex v and put other endpoints on queue if changed
+    private void relax(EdgeWeightedDigraph G, int v) {
+        for (DirectedEdge e : G.adj(v)) {
+            int w = e.to();
+            if (distTo[w] > distTo[v] + e.weight() + EPSILON) {
+                distTo[w] = distTo[v] + e.weight();
+                edgeTo[w] = e;
+                if (!onQueue[w]) {
+                    queue.enqueue(w);
+                    onQueue[w] = true;
+                }
+            }
+            if (++cost % G.V() == 0) {
+                findNegativeCycle();
+                if (hasNegativeCycle()) return;  // found a negative cycle
+            }
+        }
+    }
+
+    /**
+     * Is there a negative cycle reachable from the source vertex {@code s}?
+     * @return {@code true} if there is a negative cycle reachable from the
+     *    source vertex {@code s}, and {@code false} otherwise
+     */
+    public boolean hasNegativeCycle() {
+        return cycle != null;
+    }
+
+    /**
+     * Returns a negative cycle reachable from the source vertex {@code s}, or {@code null}
+     * if there is no such cycle.
+     * @return a negative cycle reachable from the soruce vertex {@code s} 
+     *    as an iterable of edges, and {@code null} if there is no such cycle
+     */
+    public Iterable<DirectedEdge> negativeCycle() {
+        return cycle;
+    }
+
+    // by finding a cycle in predecessor graph
+    private void findNegativeCycle() {
+        int V = edgeTo.length;
+        EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
+        for (int v = 0; v < V; v++)
+            if (edgeTo[v] != null)
+                spt.addEdge(edgeTo[v]);
+
+        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
+        cycle = finder.cycle();
+    }
+
+    /**
+     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
+     *         {@code Double.POSITIVE_INFINITY} if no such path
+     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
+     *         from the source vertex {@code s}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public double distTo(int v) {
+        validateVertex(v);
+        if (hasNegativeCycle())
+            throw new UnsupportedOperationException("Negative cost cycle exists");
+        return distTo[v];
+    }
+
+    /**
+     * Is there a path from the source {@code s} to vertex {@code v}?
+     * @param  v the destination vertex
+     * @return {@code true} if there is a path from the source vertex
+     *         {@code s} to vertex {@code v}, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return distTo[v] < Double.POSITIVE_INFINITY;
+    }
+
+    /**
+     * Returns a shortest path from the source {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return a shortest path from the source {@code s} to vertex {@code v}
+     *         as an iterable of edges, and {@code null} if no such path
+     * @throws UnsupportedOperationException if there is a negative cost cycle reachable
+     *         from the source vertex {@code s}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> pathTo(int v) {
+        validateVertex(v);
+        if (hasNegativeCycle())
+            throw new UnsupportedOperationException("Negative cost cycle exists");
+        if (!hasPathTo(v)) return null;
+        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
+        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
+            path.push(e);
+        }
+        return path;
+    }
+
+    // check optimality conditions: either 
+    // (i) there exists a negative cycle reacheable from s
+    //     or 
+    // (ii)  for all edges e = v->w:            distTo[w] <= distTo[v] + e.weight()
+    // (ii') for all edges e = v->w on the SPT: distTo[w] == distTo[v] + e.weight()
+    private boolean check(EdgeWeightedDigraph G, int s) {
+
+        // has a negative cycle
+        if (hasNegativeCycle()) {
+            double weight = 0.0;
+            for (DirectedEdge e : negativeCycle()) {
+                weight += e.weight();
+            }
+            if (weight >= 0.0) {
+                System.err.println("error: weight of negative cycle = " + weight);
+                return false;
+            }
+        }
+
+        // no negative cycle reachable from source
+        else {
+
+            // check that distTo[v] and edgeTo[v] are consistent
+            if (distTo[s] != 0.0 || edgeTo[s] != null) {
+                System.err.println("distanceTo[s] and edgeTo[s] inconsistent");
+                return false;
+            }
+            for (int v = 0; v < G.V(); v++) {
+                if (v == s) continue;
+                if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
+                    System.err.println("distTo[] and edgeTo[] inconsistent");
+                    return false;
+                }
+            }
+
+            // check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()
+            for (int v = 0; v < G.V(); v++) {
+                for (DirectedEdge e : G.adj(v)) {
+                    int w = e.to();
+                    if (distTo[v] + e.weight() < distTo[w]) {
+                        System.err.println("edge " + e + " not relaxed");
+                        return false;
+                    }
+                }
+            }
+
+            // check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()
+            for (int w = 0; w < G.V(); w++) {
+                if (edgeTo[w] == null) continue;
+                DirectedEdge e = edgeTo[w];
+                int v = e.from();
+                if (w != e.to()) return false;
+                if (distTo[v] + e.weight() != distTo[w]) {
+                    System.err.println("edge " + e + " on shortest path not tight");
+                    return false;
+                }
+            }
+        }
+
+        StdOut.println("Satisfies optimality conditions");
+        StdOut.println();
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = distTo.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code BellmanFordSP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        int s = Integer.parseInt(args[1]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
+
+        BellmanFordSP sp = new BellmanFordSP(G, s);
+
+        // print negative cycle
+        if (sp.hasNegativeCycle()) {
+            for (DirectedEdge e : sp.negativeCycle())
+                StdOut.println(e);
+        }
+
+        // print shortest paths
+        else {
+            for (int v = 0; v < G.V(); v++) {
+                if (sp.hasPathTo(v)) {
+                    StdOut.printf("%d to %d (%5.2f)  ", s, v, sp.distTo(v));
+                    for (DirectedEdge e : sp.pathTo(v)) {
+                        StdOut.print(e + "   ");
+                    }
+                    StdOut.println();
+                }
+                else {
+                    StdOut.printf("%d to %d           no path\n", s, v);
+                }
+            }
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinaryDump.java b/src/main/java/edu/princeton/cs/algs4/BinaryDump.java
new file mode 100644
index 0000000..70dc8cf
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinaryDump.java
@@ -0,0 +1,98 @@
+/******************************************************************************
+ *  Compilation:  javac BinaryDump.java
+ *  Execution:    java BinaryDump n < file
+ *  Dependencies: BinaryStdIn.java
+ *  Data file:    https://introcs.cs.princeton.edu/stdlib/abra.txt
+ *  
+ *  Reads in a binary file and writes out the bits, n per line.
+ *
+ *  % more abra.txt 
+ *  ABRACADABRA!
+ *
+ *  % java BinaryDump 16 < abra.txt
+ *  0100000101000010
+ *  0101001001000001
+ *  0100001101000001
+ *  0100010001000001
+ *  0100001001010010
+ *  0100000100100001
+ *  96 bits
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BinaryDump} class provides a client for displaying the contents
+ *  of a binary file in binary.
+ *  <p>
+ *  For more full-featured versions, see the Unix utilities
+ *  {@code od} (octal dump) and {@code hexdump} (hexadecimal dump).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  <p>
+ *  See also {@link HexDump} and {@link PictureDump}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BinaryDump {
+
+    // Do not instantiate.
+    private BinaryDump() { }
+
+    /**
+     * Reads in a sequence of bytes from standard input and writes
+     * them to standard output in binary, k bits per line,
+     * where k is given as a command-line integer (defaults
+     * to 16 if no integer is specified); also writes the number
+     * of bits.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int bitsPerLine = 16;
+        if (args.length == 1) {
+            bitsPerLine = Integer.parseInt(args[0]);
+        }
+
+        int count;
+        for (count = 0; !BinaryStdIn.isEmpty(); count++) {
+            if (bitsPerLine == 0) {
+                BinaryStdIn.readBoolean();
+                continue;
+            }
+            else if (count != 0 && count % bitsPerLine == 0) StdOut.println();
+            if (BinaryStdIn.readBoolean()) StdOut.print(1);
+            else                           StdOut.print(0);
+        }
+        if (bitsPerLine != 0) StdOut.println();
+        StdOut.println(count + " bits");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinaryIn.java b/src/main/java/edu/princeton/cs/algs4/BinaryIn.java
new file mode 100644
index 0000000..89dc7ca
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinaryIn.java
@@ -0,0 +1,405 @@
+/******************************************************************************
+ *  Compilation:  javac BinaryIn.java
+ *  Execution:    java BinaryIn input output
+ *  Dependencies: none             
+ *  
+ *  This library is for reading binary data from an input stream.
+ *
+ *  % java BinaryIn https://introcs.cs.princeton.edu/java/cover.png output.png
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Socket;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.NoSuchElementException;
+
+/**
+ *  <i>Binary input</i>. This class provides methods for reading
+ *  in bits from a binary input stream, either
+ *  one bit at a time (as a {@code boolean}),
+ *  8 bits at a time (as a {@code byte} or {@code char}),
+ *  16 bits at a time (as a {@code short}),
+ *  32 bits at a time (as an {@code int} or {@code float}), or
+ *  64 bits at a time (as a {@code double} or {@code long}).
+ *  <p>
+ *  The binary input stream can be from standard input, a filename,
+ *  a URL name, a Socket, or an InputStream.
+ *  <p>
+ *  All primitive types are assumed to be represented using their 
+ *  standard Java representations, in big-endian (most significant
+ *  byte first) order.
+ *  <p>
+ *  The client should not intermix calls to {@code BinaryIn} with calls
+ *  to {@code In}; otherwise unexpected behavior will result.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class BinaryIn {
+    private static final int EOF = -1;   // end of file
+
+    private BufferedInputStream in;      // the input stream
+    private int buffer;                  // one character buffer
+    private int n;                       // number of bits left in buffer
+
+   /**
+     * Initializes a binary input stream from standard input.
+     */
+    public BinaryIn() {
+        in = new BufferedInputStream(System.in);
+        fillBuffer();
+    }
+
+   /**
+     * Initializes a binary input stream from an {@code InputStream}.
+     *
+     * @param is the {@code InputStream} object
+     */
+    public BinaryIn(InputStream is) {
+        in = new BufferedInputStream(is);
+        fillBuffer();
+    }
+
+   /**
+     * Initializes a binary input stream from a socket.
+     *
+     * @param socket the socket
+     */
+    public BinaryIn(Socket socket) {
+        try {
+            InputStream is = socket.getInputStream();
+            in = new BufferedInputStream(is);
+            fillBuffer();
+        }
+        catch (IOException ioe) {
+            System.err.println("Could not open " + socket);
+        }
+    }
+
+   /**
+     * Initializes a binary input stream from a URL.
+     *
+     * @param url the URL
+     */
+    public BinaryIn(URL url) {
+        try {
+            URLConnection site = url.openConnection();
+            InputStream is     = site.getInputStream();
+            in = new BufferedInputStream(is);
+            fillBuffer();
+        }
+        catch (IOException ioe) {
+            System.err.println("Could not open " + url);
+        }
+    }
+
+   /**
+     * Initializes a binary input stream from a filename or URL name.
+     *
+     * @param name the name of the file or URL
+     */
+    public BinaryIn(String name) {
+
+        try {
+            // first try to read file from local file system
+            File file = new File(name);
+            if (file.exists()) {
+                FileInputStream fis = new FileInputStream(file);
+                in = new BufferedInputStream(fis);
+                fillBuffer();
+                return;
+            }
+
+            // next try for files included in jar
+            URL url = getClass().getResource(name);
+
+            // or URL from web
+            if (url == null) {
+                url = new URL(name);
+            }
+
+            URLConnection site = url.openConnection();
+            InputStream is     = site.getInputStream();
+            in = new BufferedInputStream(is);
+            fillBuffer();
+        }
+        catch (IOException ioe) {
+            System.err.println("Could not open " + name);
+        }
+    }
+
+    private void fillBuffer() {
+        try {
+            buffer = in.read();
+            n = 8;
+        }
+        catch (IOException e) {
+            System.err.println("EOF");
+            buffer = EOF;
+            n = -1;
+        }
+    }
+
+    /**
+     * Returns true if this binary input stream exists.
+     *
+     * @return {@code true} if this binary input stream exists;
+     *         {@code false} otherwise
+     */
+    public boolean exists()  {
+        return in != null;
+    }
+
+   /**
+     * Returns true if this binary input stream is empty.
+     *
+     * @return {@code true} if this binary input stream is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return buffer == EOF;
+    }
+
+   /**
+     * Reads the next bit of data from this binary input stream and return as a boolean.
+     *
+     * @return the next bit of data from this binary input stream as a {@code boolean}
+     * @throws NoSuchElementException if this binary input stream is empty
+     */
+    public boolean readBoolean() {
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+        n--;
+        boolean bit = ((buffer >> n) & 1) == 1;
+        if (n == 0) fillBuffer();
+        return bit;
+    }
+
+   /**
+     * Reads the next 8 bits from this binary input stream and return as an 8-bit char.
+     *
+     * @return the next 8 bits of data from this binary input stream as a {@code char}
+     * @throws NoSuchElementException if there are fewer than 8 bits available
+     */
+    public char readChar() {
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+
+        // special case when aligned byte
+        if (n == 8) {
+            int x = buffer;
+            fillBuffer();
+            return (char) (x & 0xff);
+        }
+
+        // combine last N bits of current buffer with first 8-N bits of new buffer
+        int x = buffer;
+        x <<= (8 - n);
+        int oldN = n;
+        fillBuffer();
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+        n = oldN;
+        x |= (buffer >>> n);
+        return (char) (x & 0xff);
+        // the above code doesn't quite work for the last character if N = 8
+        // because buffer will be -1
+    }
+
+
+   /**
+     * Reads the next <em>r</em> bits from this binary input stream and return
+     * as an <em>r</em>-bit character.
+     *
+     * @param  r number of bits to read
+     * @return the next {@code r} bits of data from this binary input streamt as a {@code char}
+     * @throws NoSuchElementException if there are fewer than {@code r} bits available
+     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}
+     */
+    public char readChar(int r) {
+        if (r < 1 || r > 16) throw new IllegalArgumentException("Illegal value of r = " + r);
+
+        // optimize r = 8 case
+        if (r == 8) return readChar();
+
+        char x = 0;
+        for (int i = 0; i < r; i++) {
+            x <<= 1;
+            boolean bit = readBoolean();
+            if (bit) x |= 1;
+        }
+        return x;
+    }
+
+
+   /**
+     * Reads the remaining bytes of data from this binary input stream and return as a string. 
+     *
+     * @return the remaining bytes of data from this binary input stream as a {@code String}
+     * @throws NoSuchElementException if this binary input stream is empty or if the number of bits
+     *         available is not a multiple of 8 (byte-aligned)
+     */
+    public String readString() {
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+
+        StringBuilder sb = new StringBuilder();
+        while (!isEmpty()) {
+            char c = readChar();
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+
+   /**
+     * Reads the next 16 bits from this binary input stream and return as a 16-bit short.
+     *
+     * @return the next 16 bits of data from this binary input stream as a {@code short}
+     * @throws NoSuchElementException if there are fewer than 16 bits available
+     */
+    public short readShort() {
+        short x = 0;
+        for (int i = 0; i < 2; i++) {
+            char c = readChar();
+            x <<= 8;
+            x |= c;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next 32 bits from this binary input stream and return as a 32-bit int.
+     *
+     * @return the next 32 bits of data from this binary input stream as a {@code int}
+     * @throws NoSuchElementException if there are fewer than 32 bits available
+     */
+    public int readInt() {
+        int x = 0;
+        for (int i = 0; i < 4; i++) {
+            char c = readChar();
+            x <<= 8;
+            x |= c;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next <em>r</em> bits from this binary input stream return
+     * as an <em>r</em>-bit int.
+     *
+     * @param  r number of bits to read
+     * @return the next {@code r} bits of data from this binary input stream as a {@code int}
+     * @throws NoSuchElementException if there are fewer than r bits available
+     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}
+     */
+    public int readInt(int r) {
+        if (r < 1 || r > 32) throw new IllegalArgumentException("Illegal value of r = " + r);
+
+        // optimize r = 32 case
+        if (r == 32) return readInt();
+
+        int x = 0;
+        for (int i = 0; i < r; i++) {
+            x <<= 1;
+            boolean bit = readBoolean();
+            if (bit) x |= 1;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next 64 bits from this binary input stream and return as a 64-bit long.
+     *
+     * @return the next 64 bits of data from this binary input stream as a {@code long}
+     * @throws NoSuchElementException if there are fewer than 64 bits available
+     */
+    public long readLong() {
+        long x = 0;
+        for (int i = 0; i < 8; i++) {
+            char c = readChar();
+            x <<= 8;
+            x |= c;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next 64 bits from this binary input stream and return as a 64-bit double.
+     *
+     * @return the next 64 bits of data from this binary input stream as a {@code double}
+     * @throws NoSuchElementException if there are fewer than 64 bits available
+     */
+    public double readDouble() {
+        return Double.longBitsToDouble(readLong());
+    }
+
+   /**
+     * Reads the next 32 bits from this binary input stream and return as a 32-bit float.
+     *
+     * @return the next 32 bits of data from this binary input stream as a {@code float}
+     * @throws NoSuchElementException if there are fewer than 32 bits available
+     */
+    public float readFloat() {
+        return Float.intBitsToFloat(readInt());
+    }
+
+
+   /**
+     * Reads the next 8 bits from this binary input stream and return as an 8-bit byte.
+     *
+     * @return the next 8 bits of data from this binary input stream as a {@code byte}
+     * @throws NoSuchElementException if there are fewer than 8 bits available
+     */
+    public byte readByte() {
+        char c = readChar();
+        return (byte) (c & 0xff);
+    }
+    
+   /**
+     * Unit tests the {@code BinaryIn} data type.
+     * Reads the name of a file or URL (first command-line argument)
+     * and writes it to a file (second command-line argument).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        BinaryIn  in  = new BinaryIn(args[0]);
+        BinaryOut out = new BinaryOut(args[1]);
+
+        // read one 8-bit char at a time
+        while (!in.isEmpty()) {
+            char c = in.readChar();
+            out.write(c);
+        }
+        out.flush();
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinaryInsertion.java b/src/main/java/edu/princeton/cs/algs4/BinaryInsertion.java
new file mode 100644
index 0000000..12afbc6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinaryInsertion.java
@@ -0,0 +1,148 @@
+/******************************************************************************
+ *  Compilation:  javac BinaryInsertion.java
+ *  Execution:    java BinaryInsertion < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/21elementary/tiny.txt
+ *                https://algs4.cs.princeton.edu/21elementary/words3.txt
+ *  
+ *  Sorts a sequence of strings from standard input using 
+ *  binary insertion sort with half exchanges.
+ *
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java BinaryInsertion < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *
+ *  % java BinaryInsertion < words3.txt
+ *  all bad bed bug dad ... yes yet zoo   [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BinaryInsertion} class provides a static method for sorting an
+ *  array using an optimized binary insertion sort with half exchanges.
+ *  <p>
+ *  In the worst case, this implementation makes
+ *  ~ <em>n</em> log<sub>2</sub><em>n</em> compares to sort an array of length
+ *  <em>n</em>. However, in the worst case, the running time is
+ *  &Theta;(<em>n</em><sup>2</sup>) because the number of array accesses
+ *  can be quadratic.
+ *  As such, it is not suitable for sorting large arrays
+ *  (unless the number of inversions is small).
+ *  <p>
+ *  This sorting algorithm is stable.
+ *  It uses &Theta;(1) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/21elementary">Section 2.1</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Ivan Pesin
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BinaryInsertion {
+
+    // This class should not be instantiated.
+    private BinaryInsertion() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        int n = a.length;
+        for (int i = 1; i < n; i++) {
+
+            // binary search to determine index j at which to insert a[i]
+            Comparable v = a[i];
+            int lo = 0, hi = i;
+            while (lo < hi) {
+                int mid = lo + (hi - lo) / 2; 
+                if (less(v, a[mid])) hi = mid;
+                else                 lo = mid + 1;
+            }
+
+            // insetion sort with "half exchanges"
+            // (insert a[i] at index j and shift a[j], ..., a[i-1] to right)
+            for (int j = i; j > lo; --j)
+                a[j] = a[j-1];
+            a[lo] = v;
+        }
+        assert isSorted(a);
+    }
+
+
+
+   /***************************************************************************
+    *  Helper sorting function.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length - 1);
+    }
+
+    // is the array sorted from a[lo] to a[hi]
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo+1; i <= hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; insertion sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        BinaryInsertion.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinaryOut.java b/src/main/java/edu/princeton/cs/algs4/BinaryOut.java
new file mode 100644
index 0000000..7585680
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinaryOut.java
@@ -0,0 +1,365 @@
+/******************************************************************************
+ *  Compilation:  javac BinaryOut.java
+ *  Execution:    java BinaryOut
+ *  Dependencies: none
+ *
+ *  Write binary data to an output stream, either one 1-bit boolean,
+ *  one 8-bit char, one 32-bit int, one 64-bit double, one 32-bit float,
+ *  or one 64-bit long at a time. The output stream can be standard
+ *  output, a file, an OutputStream or a Socket.
+ *
+ *  The bytes written are not aligned.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.BufferedOutputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.Socket;
+
+/**
+ *  <i>Binary output</i>. This class provides methods for converting
+ *  primtive type variables ({@code boolean}, {@code byte}, {@code char},
+ *  {@code int}, {@code long}, {@code float}, and {@code double})
+ *  to sequences of bits and writing them to an output stream.
+ *  The output stream can be standard output, a file, an OutputStream or a Socket.
+ *  Uses big-endian (most-significant byte first).
+ *  <p>
+ *  The client must {@code flush()} the output stream when finished writing bits.
+ *  <p>
+ *  The client should not intermix calls to {@code BinaryOut} with calls
+ *  to {@code Out}; otherwise unexpected behavior will result.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class BinaryOut {
+
+    private BufferedOutputStream out;  // the output stream
+    private int buffer;                // 8-bit buffer of bits to write out
+    private int n;                     // number of bits remaining in buffer
+
+
+   /**
+     * Initializes a binary output stream from standard output.
+     */
+    public BinaryOut() {
+        out = new BufferedOutputStream(System.out);
+    }
+
+   /**
+     * Initializes a binary output stream from an {@code OutputStream}.
+     * @param os the {@code OutputStream}
+     */
+    public BinaryOut(OutputStream os) {
+        out = new BufferedOutputStream(os);
+    }
+
+   /**
+     * Initializes a binary output stream from a file.
+     * @param filename the name of the file
+     */
+    public BinaryOut(String filename) {
+        try {
+            OutputStream os = new FileOutputStream(filename);
+            out = new BufferedOutputStream(os);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+   /**
+     * Initializes a binary output stream from a socket.
+     * @param socket the socket
+     */
+    public BinaryOut(Socket socket) {
+        try {
+            OutputStream os = socket.getOutputStream();
+            out = new BufferedOutputStream(os);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+
+   /**
+     * Writes the specified bit to the binary output stream.
+     * @param x the bit
+     */
+    private void writeBit(boolean x) {
+        // add bit to buffer
+        buffer <<= 1;
+        if (x) buffer |= 1;
+
+        // if buffer is full (8 bits), write out as a single byte
+        n++;
+        if (n == 8) clearBuffer();
+    } 
+
+   /**
+     * Writes the 8-bit byte to the binary output stream.
+     * @param x the byte
+     */
+    private void writeByte(int x) {
+        assert x >= 0 && x < 256;
+
+        // optimized if byte-aligned
+        if (n == 0) {
+            try {
+                out.write(x);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+            return;
+        }
+
+        // otherwise write one bit at a time
+        for (int i = 0; i < 8; i++) {
+            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;
+            writeBit(bit);
+        }
+    }
+
+    // write out any remaining bits in buffer to the binary output stream, padding with 0s
+    private void clearBuffer() {
+        if (n == 0) return;
+        if (n > 0) buffer <<= (8 - n);
+        try {
+            out.write(buffer);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+        n = 0;
+        buffer = 0;
+    }
+
+   /**
+     * Flushes the binary output stream, padding 0s if number of bits written so far
+     * is not a multiple of 8.
+     */
+    public void flush() {
+        clearBuffer();
+        try {
+            out.flush();
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+   /**
+     * Flushes and closes the binary output stream.
+     * Once it is closed, bits can no longer be written.
+     */
+    public void close() {
+        flush();
+        try {
+            out.close();
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+
+   /**
+     * Writes the specified bit to the binary output stream.
+     * @param x the {@code boolean} to write
+     */
+    public void write(boolean x) {
+        writeBit(x);
+    } 
+
+   /**
+     * Writes the 8-bit byte to the binary output stream.
+     * @param x the {@code byte} to write.
+     */
+    public void write(byte x) {
+        writeByte(x & 0xff);
+    }
+
+   /**
+     * Writes the 32-bit int to the binary output stream.
+     * @param x the {@code int} to write
+     */
+    public void write(int x) {
+        writeByte((x >>> 24) & 0xff);
+        writeByte((x >>> 16) & 0xff);
+        writeByte((x >>>  8) & 0xff);
+        writeByte((x >>>  0) & 0xff);
+    }
+
+   /**
+     * Writes the <em>r</em>-bit int to the binary output stream.
+     *
+     * @param  x the {@code int} to write
+     * @param  r the number of relevant bits in the char
+     * @throws IllegalArgumentException unless {@code r} is between 1 and 32
+     * @throws IllegalArgumentException unless {@code x} is between 0 and 2<sup>r</sup> - 1
+     */
+    public void write(int x, int r) {
+        if (r == 32) {
+            write(x);
+            return;
+        }
+        if (r < 1 || r > 32) throw new IllegalArgumentException("Illegal value for r = " + r);
+        if (x >= (1 << r))   throw new IllegalArgumentException("Illegal " + r + "-bit char = " + x);
+        for (int i = 0; i < r; i++) {
+            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
+            writeBit(bit);
+        }
+    }
+
+
+   /**
+     * Writes the 64-bit double to the binary output stream.
+     * @param x the {@code double} to write
+     */
+    public void write(double x) {
+        write(Double.doubleToRawLongBits(x));
+    }
+
+   /**
+     * Writes the 64-bit long to the binary output stream.
+     * @param x the {@code long} to write
+     */
+    public void write(long x) {
+        writeByte((int) ((x >>> 56) & 0xff));
+        writeByte((int) ((x >>> 48) & 0xff));
+        writeByte((int) ((x >>> 40) & 0xff));
+        writeByte((int) ((x >>> 32) & 0xff));
+        writeByte((int) ((x >>> 24) & 0xff));
+        writeByte((int) ((x >>> 16) & 0xff));
+        writeByte((int) ((x >>>  8) & 0xff));
+        writeByte((int) ((x >>>  0) & 0xff));
+    }
+
+   /**
+     * Writes the 32-bit float to the binary output stream.
+     * @param x the {@code float} to write
+     */
+    public void write(float x) {
+        write(Float.floatToRawIntBits(x));
+    }
+
+   /**
+     * Write the 16-bit int to the binary output stream.
+     * @param x the {@code short} to write.
+     */
+    public void write(short x) {
+        writeByte((x >>>  8) & 0xff);
+        writeByte((x >>>  0) & 0xff);
+    }
+
+   /**
+     * Writes the 8-bit char to the binary output stream.
+     *
+     * @param  x the {@code char} to write
+     * @throws IllegalArgumentException unless {@code x} is betwen 0 and 255
+     */
+    public void write(char x) {
+        if (x < 0 || x >= 256) throw new IllegalArgumentException("Illegal 8-bit char = " + x);
+        writeByte(x);
+    }
+
+   /**
+     * Writes the <em>r</em>-bit char to the binary output stream.
+     *
+     * @param  x the {@code char} to write
+     * @param  r the number of relevant bits in the char
+     * @throws IllegalArgumentException unless {@code r} is between 1 and 16
+     * @throws IllegalArgumentException unless {@code x} is between 0 and 2<sup>r</sup> - 1
+     */
+    public void write(char x, int r) {
+        if (r == 8) {
+            write(x);
+            return;
+        }
+        if (r < 1 || r > 16) throw new IllegalArgumentException("Illegal value for r = " + r);
+        if (x >= (1 << r))   throw new IllegalArgumentException("Illegal " + r + "-bit char = " + x);
+        for (int i = 0; i < r; i++) {
+            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
+            writeBit(bit);
+        }
+    }
+
+   /**
+     * Writes the string of 8-bit characters to the binary output stream.
+     *
+     * @param  s the {@code String} to write
+     * @throws IllegalArgumentException if any character in the string is not
+     *         between 0 and 255
+     */
+    public void write(String s) {
+        for (int i = 0; i < s.length(); i++)
+            write(s.charAt(i));
+    }
+
+
+   /**
+     * Writes the string of <em>r</em>-bit characters to the binary output stream.
+     * @param  s the {@code String} to write
+     * @param  r the number of relevants bits in each character
+     * @throws IllegalArgumentException unless r is between 1 and 16
+     * @throws IllegalArgumentException if any character in the string is not
+     *         between 0 and 2<sup>r</sup> - 1
+     */
+    public void write(String s, int r) {
+        for (int i = 0; i < s.length(); i++)
+            write(s.charAt(i), r);
+    }
+
+
+   /**
+     * Test client. Read bits from standard input and write to the file
+     * specified on command line.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // create binary output stream to write to file
+        String filename = args[0];
+        BinaryOut out = new BinaryOut(filename);
+        BinaryIn  in  = new BinaryIn();
+
+        // read from standard input and write to file
+        while (!in.isEmpty()) {
+            char c = in.readChar();
+            out.write(c);
+        }
+        out.flush();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinarySearch.java b/src/main/java/edu/princeton/cs/algs4/BinarySearch.java
new file mode 100644
index 0000000..6b0c2fb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinarySearch.java
@@ -0,0 +1,131 @@
+/******************************************************************************
+ *  Compilation:  javac BinarySearch.java
+ *  Execution:    java BinarySearch allowlist.txt < input.txt
+ *  Dependencies: In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/11model/tinyAllowlist.txt
+ *                https://algs4.cs.princeton.edu/11model/tinyText.txt
+ *                https://algs4.cs.princeton.edu/11model/largeAllowlist.txt
+ *                https://algs4.cs.princeton.edu/11model/largeText.txt
+ *
+ *  % java BinarySearch tinyAllowlist.txt < tinyText.txt
+ *  50
+ *  99
+ *  13
+ *
+ *  % java BinarySearch largeAllowlist.txt < largeText.txt | more
+ *  499569
+ *  984875
+ *  295754
+ *  207807
+ *  140925
+ *  161828
+ *  [367,966 total values]
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ *  The {@code BinarySearch} class provides a static method for binary
+ *  searching for an integer in a sorted array of integers.
+ *  <p>
+ *  The <em>indexOf</em> operations takes logarithmic time in the worst case.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/11model">Section 1.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BinarySearch {
+
+    /**
+     * This class should not be instantiated.
+     */
+    private BinarySearch() { }
+
+    /**
+     * Returns the index of the specified key in the specified array.
+     *
+     * @param  a the array of integers, must be sorted in ascending order
+     * @param  key the search key
+     * @return index of key in array {@code a} if present; {@code -1} otherwise
+     */
+    public static int indexOf(int[] a, int key) {
+        int lo = 0;
+        int hi = a.length - 1;
+        while (lo <= hi) {
+            // Key is in a[lo..hi] or not present.
+            int mid = lo + (hi - lo) / 2;
+            if      (key < a[mid]) hi = mid - 1;
+            else if (key > a[mid]) lo = mid + 1;
+            else return mid;
+        }
+        return -1;
+    }
+
+    /**
+     * Returns the index of the specified key in the specified array.
+     * This function is poorly named because it does not give the <em>rank</em>
+     * if the array has duplicate keys or if the key is not in the array.
+     *
+     * @param  key the search key
+     * @param  a the array of integers, must be sorted in ascending order
+     * @return index of key in array {@code a} if present; {@code -1} otherwise
+     * @deprecated Replaced by {@link #indexOf(int[], int)}.
+     */
+    @Deprecated
+    public static int rank(int key, int[] a) {
+        return indexOf(a, key);
+    }
+
+    /**
+     * Reads in a sequence of integers from the allowlist file, specified as
+     * a command-line argument; reads in integers from standard input;
+     * prints to standard output those integers that do <em>not</em> appear in the file.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read the integers from a file
+        In in = new In(args[0]);
+        int[] allowlist = in.readAllInts();
+
+        // sort the array
+        Arrays.sort(allowlist);
+
+        // read integer key from standard input; print if not in allowlist
+        while (!StdIn.isEmpty()) {
+            int key = StdIn.readInt();
+            if (BinarySearch.indexOf(allowlist, key) == -1)
+                StdOut.println(key);
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinarySearchST.java b/src/main/java/edu/princeton/cs/algs4/BinarySearchST.java
new file mode 100644
index 0000000..5cbab58
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinarySearchST.java
@@ -0,0 +1,459 @@
+/******************************************************************************
+ *  Compilation:  javac BinarySearchST.java
+ *  Execution:    java BinarySearchST
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/31elementary/tinyST.txt  
+ *  
+ *  Symbol table implementation with binary search in an ordered array.
+ *
+ *  % more tinyST.txt
+ *  S E A R C H E X A M P L E
+ *  
+ *  % java BinarySearchST < tinyST.txt
+ *  A 8
+ *  C 4
+ *  E 12
+ *  H 5
+ *  L 11
+ *  M 9
+ *  P 10
+ *  R 3
+ *  S 0
+ *  X 7
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code BST} class represents an ordered symbol table of generic
+ *  key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides ordered methods for finding the <em>minimum</em>,
+ *  <em>maximum</em>, <em>floor</em>, <em>select</em>, and <em>ceiling</em>.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  It requires that
+ *  the key type implements the {@code Comparable} interface and calls the
+ *  {@code compareTo()} and method to compare two keys. It does not call either
+ *  {@code equals()} or {@code hashCode()}.
+ *  <p>
+ *  This implementation uses a <em>sorted array</em>.
+ *  The <em>put</em> and <em>remove</em> operations take &Theta;(<em>n</em>)
+ *  time in the worst case.
+ *  The <em>contains</em>, <em>ceiling</em>, <em>floor</em>,
+ *  and <em>rank</em> operations take &Theta;(log <em>n</em>) time in the worst
+ *  case.
+ *  The <em>size</em>, <em>is-empty</em>, <em>minimum</em>, <em>maximum</em>,
+ *  and <em>select</em> operations take &Theta;(1) time.
+ *  Construction takes &Theta;(1) time.
+ *  <p>
+ *  For alternative implementations of the symbol table API,
+ *  see {@link ST}, {@link BST}, {@link SequentialSearchST}, {@link RedBlackBST},
+ *  {@link SeparateChainingHashST}, and {@link LinearProbingHashST},
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/31elementary">Section 3.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class BinarySearchST<Key extends Comparable<Key>, Value> {
+    private static final int INIT_CAPACITY = 2;
+    private Key[] keys;
+    private Value[] vals;
+    private int n = 0;
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public BinarySearchST() {
+        this(INIT_CAPACITY);
+    }
+
+    /**
+     * Initializes an empty symbol table with the specified initial capacity.
+     * @param capacity the maximum capacity
+     */
+    public BinarySearchST(int capacity) { 
+        keys = (Key[]) new Comparable[capacity]; 
+        vals = (Value[]) new Object[capacity]; 
+    }   
+
+    // resize the underlying arrays
+    private void resize(int capacity) {
+        assert capacity >= n;
+        Key[]   tempk = (Key[])   new Comparable[capacity];
+        Value[] tempv = (Value[]) new Object[capacity];
+        for (int i = 0; i < n; i++) {
+            tempk[i] = keys[i];
+            tempv[i] = vals[i];
+        }
+        vals = tempv;
+        keys = tempk;
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     *
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns true if this symbol table is empty.
+     *
+     * @return {@code true} if this symbol table is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+
+    /**
+     * Does this symbol table contain the given key?
+     *
+     * @param  key the key
+     * @return {@code true} if this symbol table contains {@code key} and
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        return get(key) != null;
+    }
+
+    /**
+     * Returns the value associated with the given key in this symbol table.
+     *
+     * @param  key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *         and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null"); 
+        if (isEmpty()) return null;
+        int i = rank(key); 
+        if (i < n && keys[i].compareTo(key) == 0) return vals[i];
+        return null;
+    } 
+
+    /**
+     * Returns the number of keys in this symbol table strictly less than {@code key}.
+     *
+     * @param  key the key
+     * @return the number of keys in the symbol table strictly less than {@code key}
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public int rank(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to rank() is null"); 
+
+        int lo = 0, hi = n-1; 
+        while (lo <= hi) { 
+            int mid = lo + (hi - lo) / 2; 
+            int cmp = key.compareTo(keys[mid]);
+            if      (cmp < 0) hi = mid - 1; 
+            else if (cmp > 0) lo = mid + 1; 
+            else return mid; 
+        } 
+        return lo;
+    } 
+
+
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val)  {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null"); 
+
+        if (val == null) {
+            delete(key);
+            return;
+        }
+
+        int i = rank(key);
+
+        // key is already in table
+        if (i < n && keys[i].compareTo(key) == 0) {
+            vals[i] = val;
+            return;
+        }
+
+        // insert new key-value pair
+        if (n == keys.length) resize(2*keys.length);
+
+        for (int j = n; j > i; j--)  {
+            keys[j] = keys[j-1];
+            vals[j] = vals[j-1];
+        }
+        keys[i] = key;
+        vals[i] = val;
+        n++;
+
+        assert check();
+    } 
+
+    /**
+     * Removes the specified key and associated value from this symbol table
+     * (if the key is in the symbol table).
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null"); 
+        if (isEmpty()) return;
+
+        // compute rank
+        int i = rank(key);
+
+        // key not in table
+        if (i == n || keys[i].compareTo(key) != 0) {
+            return;
+        }
+
+        for (int j = i; j < n-1; j++)  {
+            keys[j] = keys[j+1];
+            vals[j] = vals[j+1];
+        }
+
+        n--;
+        keys[n] = null;  // to avoid loitering
+        vals[n] = null;
+
+        // resize if 1/4 full
+        if (n > 0 && n == keys.length/4) resize(keys.length/2);
+
+        assert check();
+    } 
+
+    /**
+     * Removes the smallest key and associated value from this symbol table.
+     *
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMin() {
+        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow error");
+        delete(min());
+    }
+
+    /**
+     * Removes the largest key and associated value from this symbol table.
+     *
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMax() {
+        if (isEmpty()) throw new NoSuchElementException("Symbol table underflow error");
+        delete(max());
+    }
+
+
+   /***************************************************************************
+    *  Ordered symbol table methods.
+    ***************************************************************************/
+
+   /**
+     * Returns the smallest key in this symbol table.
+     *
+     * @return the smallest key in this symbol table
+     * @throws NoSuchElementException if this symbol table is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("called min() with empty symbol table");
+        return keys[0]; 
+    }
+
+    /**
+     * Returns the largest key in this symbol table.
+     *
+     * @return the largest key in this symbol table
+     * @throws NoSuchElementException if this symbol table is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("called max() with empty symbol table");
+        return keys[n-1];
+    }
+
+    /**
+     * Return the kth smallest key in this symbol table.
+     *
+     * @param  k the order statistic
+     * @return the {@code k}th smallest key in this symbol table
+     * @throws IllegalArgumentException unless {@code k} is between 0 and
+     *        <em>n</em>‚Äì1
+     */
+    public Key select(int k) {
+        if (k < 0 || k >= size()) {
+            throw new IllegalArgumentException("called select() with invalid argument: " + k);
+        }
+        return keys[k];
+    }
+
+    /**
+     * Returns the largest key in this symbol table less than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the largest key in this symbol table less than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key floor(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to floor() is null"); 
+        int i = rank(key);
+        if (i < n && key.compareTo(keys[i]) == 0) return keys[i];
+        if (i == 0) throw new NoSuchElementException("argument to floor() is too small");
+        else return keys[i-1];
+    }
+
+    /**
+     * Returns the smallest key in this symbol table greater than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the smallest key in this symbol table greater than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key ceiling(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null"); 
+        int i = rank(key);
+        if (i == n) throw new NoSuchElementException("argument to ceiling() is too large");
+        else return keys[i];
+    }
+
+    /**
+     * Returns the number of keys in this symbol table in the specified range.
+     *
+     * @param lo minimum endpoint
+     * @param hi maximum endpoint
+     * @return the number of keys in this symbol table between {@code lo} 
+     *         (inclusive) and {@code hi} (inclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *         is {@code null}
+     */
+    public int size(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to size() is null"); 
+        if (hi == null) throw new IllegalArgumentException("second argument to size() is null"); 
+
+        if (lo.compareTo(hi) > 0) return 0;
+        if (contains(hi)) return rank(hi) - rank(lo) + 1;
+        else              return rank(hi) - rank(lo);
+    }
+
+    /**
+     * Returns all keys in this symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     *
+     * @return all keys in this symbol table
+     */
+    public Iterable<Key> keys() {
+        return keys(min(), max());
+    }
+
+    /**
+     * Returns all keys in this symbol table in the given range,
+     * as an {@code Iterable}.
+     *
+     * @param lo minimum endpoint
+     * @param hi maximum endpoint
+     * @return all keys in this symbol table between {@code lo} 
+     *         (inclusive) and {@code hi} (inclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *         is {@code null}
+     */
+    public Iterable<Key> keys(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null"); 
+        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null"); 
+
+        Queue<Key> queue = new Queue<Key>(); 
+        if (lo.compareTo(hi) > 0) return queue;
+        for (int i = rank(lo); i < rank(hi); i++) 
+            queue.enqueue(keys[i]);
+        if (contains(hi)) queue.enqueue(keys[rank(hi)]);
+        return queue; 
+    }
+
+
+   /***************************************************************************
+    *  Check internal invariants.
+    ***************************************************************************/
+
+    private boolean check() {
+        return isSorted() && rankCheck();
+    }
+
+    // are the items in the array in ascending order?
+    private boolean isSorted() {
+        for (int i = 1; i < size(); i++)
+            if (keys[i].compareTo(keys[i-1]) < 0) return false;
+        return true;
+    }
+
+    // check that rank(select(i)) = i
+    private boolean rankCheck() {
+        for (int i = 0; i < size(); i++)
+            if (i != rank(select(i))) return false;
+        for (int i = 0; i < size(); i++)
+            if (keys[i].compareTo(select(rank(keys[i]))) != 0) return false;
+        return true;
+    }
+
+
+    /**
+     * Unit tests the {@code BinarySearchST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        BinarySearchST<String, Integer> st = new BinarySearchST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+        for (String s : st.keys())
+            StdOut.println(s + " " + st.get(s));
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinaryStdIn.java b/src/main/java/edu/princeton/cs/algs4/BinaryStdIn.java
new file mode 100644
index 0000000..692f4f7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinaryStdIn.java
@@ -0,0 +1,323 @@
+/******************************************************************************
+ *  Compilation:  javac BinaryStdIn.java
+ *  Execution:    java BinaryStdIn < input > output
+ *  Dependencies: none             
+ *  
+ *  Supports reading binary data from standard input.
+ *
+ *  % java BinaryStdIn < input.jpg > output.jpg
+ *  % diff input.jpg output.jpg
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.util.NoSuchElementException;
+
+/**
+ *  <i>Binary standard input</i>. This class provides methods for reading
+ *  in bits from standard input, either one bit at a time (as a {@code boolean}),
+ *  8 bits at a time (as a {@code byte} or {@code char}),
+ *  16 bits at a time (as a {@code short}), 32 bits at a time
+ *  (as an {@code int} or {@code float}), or 64 bits at a time (as a
+ *  {@code double} or {@code long}).
+ *  <p>
+ *  All primitive types are assumed to be represented using their 
+ *  standard Java representations, in big-endian (most significant
+ *  byte first) order.
+ *  <p>
+ *  The client should not intermix calls to {@code BinaryStdIn} with calls
+ *  to {@code StdIn} or {@code System.in};
+ *  otherwise unexpected behavior will result.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class BinaryStdIn {
+    private static final int EOF = -1;      // end of file
+
+    private static BufferedInputStream in;  // input stream
+    private static int buffer;              // one character buffer
+    private static int n;                   // number of bits left in buffer
+    private static boolean isInitialized;   // has BinaryStdIn been called for first time?
+
+    // don't instantiate
+    private BinaryStdIn() { }
+
+    // fill buffer
+    private static void initialize() {
+        in = new BufferedInputStream(System.in);
+        buffer = 0;
+        n = 0;
+        fillBuffer();
+        isInitialized = true;
+    }
+
+    private static void fillBuffer() {
+        try {
+            buffer = in.read();
+            n = 8;
+        }
+        catch (IOException e) {
+            System.out.println("EOF");
+            buffer = EOF;
+            n = -1;
+        }
+    }
+
+   /**
+     * Close this input stream and release any associated system resources.
+     */
+    public static void close() {
+        if (!isInitialized) initialize();
+        try {
+            in.close();
+            isInitialized = false;
+        }
+        catch (IOException ioe) {
+            throw new IllegalStateException("Could not close BinaryStdIn", ioe);
+        }
+    }
+
+   /**
+     * Returns true if standard input is empty.
+     * @return true if and only if standard input is empty
+     */
+    public static boolean isEmpty() {
+        if (!isInitialized) initialize();
+        return buffer == EOF;
+    }
+
+   /**
+     * Reads the next bit of data from standard input and return as a boolean.
+     *
+     * @return the next bit of data from standard input as a {@code boolean}
+     * @throws NoSuchElementException if standard input is empty
+     */
+    public static boolean readBoolean() {
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+        n--;
+        boolean bit = ((buffer >> n) & 1) == 1;
+        if (n == 0) fillBuffer();
+        return bit;
+    }
+
+   /**
+     * Reads the next 8 bits from standard input and return as an 8-bit char.
+     * Note that {@code char} is a 16-bit type;
+     * to read the next 16 bits as a char, use {@code readChar(16)}.
+     *
+     * @return the next 8 bits of data from standard input as a {@code char}
+     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input
+     */
+    public static char readChar() {
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+
+        // special case when aligned byte
+        if (n == 8) {
+            int x = buffer;
+            fillBuffer();
+            return (char) (x & 0xff);
+        }
+
+        // combine last n bits of current buffer with first 8-n bits of new buffer
+        int x = buffer;
+        x <<= (8 - n);
+        int oldN = n;
+        fillBuffer();
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+        n = oldN;
+        x |= (buffer >>> n);
+        return (char) (x & 0xff);
+        // the above code doesn't quite work for the last character if n = 8
+        // because buffer will be -1, so there is a special case for aligned byte
+    }
+
+   /**
+     * Reads the next <em>r</em> bits from standard input and return as an <em>r</em>-bit character.
+     *
+     * @param  r number of bits to read.
+     * @return the next r bits of data from standard input as a {@code char}
+     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input
+     * @throws IllegalArgumentException unless {@code 1 <= r <= 16}
+     */
+    public static char readChar(int r) {
+        if (r < 1 || r > 16) throw new IllegalArgumentException("Illegal value of r = " + r);
+
+        // optimize r = 8 case
+        if (r == 8) return readChar();
+
+        char x = 0;
+        for (int i = 0; i < r; i++) {
+            x <<= 1;
+            boolean bit = readBoolean();
+            if (bit) x |= 1;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the remaining bytes of data from standard input and return as a string. 
+     *
+     * @return the remaining bytes of data from standard input as a {@code String}
+     * @throws NoSuchElementException if standard input is empty or if the number of bits
+     *         available on standard input is not a multiple of 8 (byte-aligned)
+     */
+    public static String readString() {
+        if (isEmpty()) throw new NoSuchElementException("Reading from empty input stream");
+
+        StringBuilder sb = new StringBuilder();
+        while (!isEmpty()) {
+            char c = readChar();
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+
+   /**
+     * Reads the next 16 bits from standard input and return as a 16-bit short.
+     *
+     * @return the next 16 bits of data from standard input as a {@code short}
+     * @throws NoSuchElementException if there are fewer than 16 bits available on standard input
+     */
+    public static short readShort() {
+        short x = 0;
+        for (int i = 0; i < 2; i++) {
+            char c = readChar();
+            x <<= 8;
+            x |= c;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next 32 bits from standard input and return as a 32-bit int.
+     *
+     * @return the next 32 bits of data from standard input as a {@code int}
+     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input
+     */
+    public static int readInt() {
+        int x = 0;
+        for (int i = 0; i < 4; i++) {
+            char c = readChar();
+            x <<= 8;
+            x |= c;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next <em>r</em> bits from standard input and return as an <em>r</em>-bit int.
+     *
+     * @param  r number of bits to read.
+     * @return the next r bits of data from standard input as a {@code int}
+     * @throws NoSuchElementException if there are fewer than {@code r} bits available on standard input
+     * @throws IllegalArgumentException unless {@code 1 <= r <= 32}
+     */
+    public static int readInt(int r) {
+        if (r < 1 || r > 32) throw new IllegalArgumentException("Illegal value of r = " + r);
+
+        // optimize r = 32 case
+        if (r == 32) return readInt();
+
+        int x = 0;
+        for (int i = 0; i < r; i++) {
+            x <<= 1;
+            boolean bit = readBoolean();
+            if (bit) x |= 1;
+        }
+        return x;
+    }
+
+   /**
+     * Reads the next 64 bits from standard input and return as a 64-bit long.
+     *
+     * @return the next 64 bits of data from standard input as a {@code long}
+     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input
+     */
+    public static long readLong() {
+        long x = 0;
+        for (int i = 0; i < 8; i++) {
+            char c = readChar();
+            x <<= 8;
+            x |= c;
+        }
+        return x;
+    }
+
+
+   /**
+     * Reads the next 64 bits from standard input and return as a 64-bit double.
+     *
+     * @return the next 64 bits of data from standard input as a {@code double}
+     * @throws NoSuchElementException if there are fewer than 64 bits available on standard input
+     */
+    public static double readDouble() {
+        return Double.longBitsToDouble(readLong());
+    }
+
+   /**
+     * Reads the next 32 bits from standard input and return as a 32-bit float.
+     *
+     * @return the next 32 bits of data from standard input as a {@code float}
+     * @throws NoSuchElementException if there are fewer than 32 bits available on standard input
+     */
+    public static float readFloat() {
+        return Float.intBitsToFloat(readInt());
+    }
+
+
+   /**
+     * Reads the next 8 bits from standard input and return as an 8-bit byte.
+     *
+     * @return the next 8 bits of data from standard input as a {@code byte}
+     * @throws NoSuchElementException if there are fewer than 8 bits available on standard input
+     */
+    public static byte readByte() {
+        char c = readChar();
+        return (byte) (c & 0xff);
+    }
+    
+   /**
+     * Test client. Reads in a binary input file from standard input and writes
+     * it to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read one 8-bit char at a time
+        while (!BinaryStdIn.isEmpty()) {
+            char c = BinaryStdIn.readChar();
+            BinaryStdOut.write(c);
+        }
+        BinaryStdOut.flush();
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinaryStdOut.java b/src/main/java/edu/princeton/cs/algs4/BinaryStdOut.java
new file mode 100644
index 0000000..c6d89d7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinaryStdOut.java
@@ -0,0 +1,323 @@
+/******************************************************************************
+ *  Compilation:  javac BinaryStdOut.java
+ *  Execution:    java BinaryStdOut
+ *  Dependencies: none
+ *
+ *  Write binary data to standard output, either one 1-bit boolean,
+ *  one 8-bit char, one 32-bit int, one 64-bit double, one 32-bit float,
+ *  or one 64-bit long at a time.
+ *
+ *  The bytes written are not aligned.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+
+/**
+ *  <i>Binary standard output</i>. This class provides methods for converting
+ *  primtive type variables ({@code boolean}, {@code byte}, {@code char},
+ *  {@code int}, {@code long}, {@code float}, and {@code double})
+ *  to sequences of bits and writing them to standard output.
+ *  Uses big-endian (most-significant byte first).
+ *  <p>
+ *  The client must {@code flush()} the output stream when finished writing bits.
+ *  <p>
+ *  The client should not intermix calls to {@code BinaryStdOut} with calls
+ *  to {@code StdOut} or {@code System.out}; otherwise unexpected behavior 
+ *  will result.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class BinaryStdOut {
+    private static BufferedOutputStream out;  // output stream (standard output)
+    private static int buffer;                // 8-bit buffer of bits to write
+    private static int n;                     // number of bits remaining in buffer
+    private static boolean isInitialized;     // has BinaryStdOut been called for first time?
+
+    // don't instantiate
+    private BinaryStdOut() { }
+
+    // initialize BinaryStdOut
+    private static void initialize() {
+        out = new BufferedOutputStream(System.out);
+        buffer = 0;
+        n = 0;
+        isInitialized = true;
+    }
+
+   /**
+     * Writes the specified bit to standard output.
+     */
+    private static void writeBit(boolean bit) {
+        if (!isInitialized) initialize();
+
+        // add bit to buffer
+        buffer <<= 1;
+        if (bit) buffer |= 1;
+
+        // if buffer is full (8 bits), write out as a single byte
+        n++;
+        if (n == 8) clearBuffer();
+    } 
+
+   /**
+     * Writes the 8-bit byte to standard output.
+     */
+    private static void writeByte(int x) {
+        if (!isInitialized) initialize();
+
+        assert x >= 0 && x < 256;
+
+        // optimized if byte-aligned
+        if (n == 0) {
+            try {
+                out.write(x);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+            return;
+        }
+
+        // otherwise write one bit at a time
+        for (int i = 0; i < 8; i++) {
+            boolean bit = ((x >>> (8 - i - 1)) & 1) == 1;
+            writeBit(bit);
+        }
+    }
+
+    // write out any remaining bits in buffer to standard output, padding with 0s
+    private static void clearBuffer() {
+        if (!isInitialized) initialize();
+
+        if (n == 0) return;
+        if (n > 0) buffer <<= (8 - n);
+        try {
+            out.write(buffer);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+        n = 0;
+        buffer = 0;
+    }
+
+   /**
+     * Flushes standard output, padding 0s if number of bits written so far
+     * is not a multiple of 8.
+     */
+    public static void flush() {
+        clearBuffer();
+        try {
+            out.flush();
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+   /**
+     * Flushes and closes standard output. Once standard output is closed, you can no
+     * longer write bits to it.
+     */
+    public static void close() {
+        flush();
+        try {
+            out.close();
+            isInitialized = false;
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+
+   /**
+     * Writes the specified bit to standard output.
+     * @param x the {@code boolean} to write.
+     */
+    public static void write(boolean x) {
+        writeBit(x);
+    } 
+
+   /**
+     * Writes the 8-bit byte to standard output.
+     * @param x the {@code byte} to write.
+     */
+    public static void write(byte x) {
+        writeByte(x & 0xff);
+    }
+
+   /**
+     * Writes the 32-bit int to standard output.
+     * @param x the {@code int} to write.
+     */
+    public static void write(int x) {
+        writeByte((x >>> 24) & 0xff);
+        writeByte((x >>> 16) & 0xff);
+        writeByte((x >>>  8) & 0xff);
+        writeByte((x >>>  0) & 0xff);
+    }
+
+   /**
+     * Writes the <em>r</em>-bit int to standard output.
+     * @param x the {@code int} to write.
+     * @param r the number of relevant bits in the char.
+     * @throws IllegalArgumentException if {@code r} is not between 1 and 32.
+     * @throws IllegalArgumentException if {@code x} is not between 0 and 2<sup>r</sup> - 1.
+     */
+    public static void write(int x, int r) {
+        if (r == 32) {
+            write(x);
+            return;
+        }
+        if (r < 1 || r > 32)        throw new IllegalArgumentException("Illegal value for r = " + r);
+        if (x < 0 || x >= (1 << r)) throw new IllegalArgumentException("Illegal " + r + "-bit char = " + x);
+        for (int i = 0; i < r; i++) {
+            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
+            writeBit(bit);
+        }
+    }
+
+
+
+
+
+   /**
+     * Writes the 64-bit double to standard output.
+     * @param x the {@code double} to write.
+     */
+    public static void write(double x) {
+        write(Double.doubleToRawLongBits(x));
+    }
+
+   /**
+     * Writes the 64-bit long to standard output.
+     * @param x the {@code long} to write.
+     */
+    public static void write(long x) {
+        writeByte((int) ((x >>> 56) & 0xff));
+        writeByte((int) ((x >>> 48) & 0xff));
+        writeByte((int) ((x >>> 40) & 0xff));
+        writeByte((int) ((x >>> 32) & 0xff));
+        writeByte((int) ((x >>> 24) & 0xff));
+        writeByte((int) ((x >>> 16) & 0xff));
+        writeByte((int) ((x >>>  8) & 0xff));
+        writeByte((int) ((x >>>  0) & 0xff));
+    }
+
+   /**
+     * Writes the 32-bit float to standard output.
+     * @param x the {@code float} to write.
+     */
+    public static void write(float x) {
+        write(Float.floatToRawIntBits(x));
+    }
+
+   /**
+     * Writes the 16-bit int to standard output.
+     * @param x the {@code short} to write.
+     */
+    public static void write(short x) {
+        writeByte((x >>>  8) & 0xff);
+        writeByte((x >>>  0) & 0xff);
+    }
+
+   /**
+     * Writes the 8-bit char to standard output.
+     * @param x the {@code char} to write.
+     * @throws IllegalArgumentException if {@code x} is not betwen 0 and 255.
+     */
+    public static void write(char x) {
+        if (x < 0 || x >= 256) throw new IllegalArgumentException("Illegal 8-bit char = " + x);
+        writeByte(x);
+    }
+
+   /**
+     * Writes the <em>r</em>-bit char to standard output.
+     * @param x the {@code char} to write.
+     * @param r the number of relevant bits in the char.
+     * @throws IllegalArgumentException if {@code r} is not between 1 and 16.
+     * @throws IllegalArgumentException if {@code x} is not between 0 and 2<sup>r</sup> - 1.
+     */
+    public static void write(char x, int r) {
+        if (r == 8) {
+            write(x);
+            return;
+        }
+        if (r < 1 || r > 16) throw new IllegalArgumentException("Illegal value for r = " + r);
+        if (x >= (1 << r))   throw new IllegalArgumentException("Illegal " + r + "-bit char = " + x);
+        for (int i = 0; i < r; i++) {
+            boolean bit = ((x >>> (r - i - 1)) & 1) == 1;
+            writeBit(bit);
+        }
+    }
+
+   /**
+     * Writes the string of 8-bit characters to standard output.
+     * @param s the {@code String} to write.
+     * @throws IllegalArgumentException if any character in the string is not
+     * between 0 and 255.
+     */
+    public static void write(String s) {
+        for (int i = 0; i < s.length(); i++)
+            write(s.charAt(i));
+    }
+
+   /**
+     * Writes the string of <em>r</em>-bit characters to standard output.
+     * @param s the {@code String} to write.
+     * @param r the number of relevants bits in each character.
+     * @throws IllegalArgumentException if r is not between 1 and 16.
+     * @throws IllegalArgumentException if any character in the string is not
+     * between 0 and 2<sup>r</sup> - 1.
+     */
+    public static void write(String s, int r) {
+        for (int i = 0; i < s.length(); i++)
+            write(s.charAt(i), r);
+    }
+
+   /**
+     * Tests the methods in this class.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int m = Integer.parseInt(args[0]);
+
+        // write n integers to binary standard output
+        for (int i = 0; i < m; i++) {
+            BinaryStdOut.write(i);
+        }
+        BinaryStdOut.flush();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BinomialMinPQ.java b/src/main/java/edu/princeton/cs/algs4/BinomialMinPQ.java
new file mode 100644
index 0000000..dfd5c9e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BinomialMinPQ.java
@@ -0,0 +1,328 @@
+/******************************************************************************
+ *  Compilation: javac BinomialMinPQ.java
+ *  Execution:
+ *  
+ *  A binomial heap.
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.Comparator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The BinomialMinPQ class represents a priority queue of generic keys.
+ *  It supports the usual insert and delete-the-minimum operations, 
+ *  along with the merging of two heaps together.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  It is possible to build the priority queue using a Comparator.
+ *  If not, the natural order relation between the keys will be used.
+ *  
+ *  This implementation uses a binomial heap.
+ *  The insert, delete-the-minimum, union, min-key
+ *  and size operations take logarithmic time.
+ *  The is-empty and constructor operations take constant time.
+ * 
+ *  @author Tristan Claverie
+ */
+public class BinomialMinPQ<Key> implements Iterable<Key> {
+	private Node head;    				//head of the list of roots
+	private final Comparator<Key> comp;	//Comparator over the keys
+	
+	//Represents a Node of a Binomial Tree
+	private class Node {
+		Key key;						//Key contained by the Node
+		int order;						//The order of the Binomial Tree rooted by this Node
+		Node child, sibling;			//child and sibling of this Node
+	}
+	
+	/**
+	 * Initializes an empty priority queue
+	 * Worst case is O(1)
+	 */
+	public BinomialMinPQ() {
+		comp = new MyComparator();
+	}
+	
+	/**
+	 * Initializes an empty priority queue using the given Comparator
+	 * Worst case is O(1)
+	 * @param C a comparator over the keys
+	 */
+	public BinomialMinPQ(Comparator<Key> C) {
+		comp = C;
+	}
+	
+	/**
+	 * Initializes a priority queue with given keys
+	 * Worst case is O(n*log(n))
+	 * @param a an array of keys
+	 */
+	public BinomialMinPQ(Key[] a) {
+		comp = new MyComparator();
+		for (Key k : a) insert(k);
+	}
+	
+	/**
+	 * Initializes a priority queue with given keys using the given Comparator
+	 * Worst case is O(n*log(n))
+	 * @param C a comparator over the keys
+	 * @param a an array of keys
+	 */
+	public BinomialMinPQ(Comparator<Key> C, Key[] a) {
+		comp = C;
+		for (Key k : a) insert(k);
+	}
+
+	/**
+	 * Whether the priority queue is empty
+	 * Worst case is O(1)
+	 * @return true if the priority queue is empty, false if not
+	 */
+	public boolean isEmpty() {
+		return head == null;
+	}
+
+	/**
+	 * Number of elements currently on the priority queue
+	 * Worst case is O(log(n))
+	 * @throws java.lang.ArithmeticException if there are more than 2^63-1 elements in the queue
+	 * @return the number of elements on the priority queue
+	 */
+	public int size() {
+		int result = 0, tmp;
+		for (Node node = head; node != null; node = node.sibling) {
+			if (node.order > 30) { throw new ArithmeticException("The number of elements cannot be evaluated, but the priority queue is still valid."); }
+			tmp = 1 << node.order;
+			result |= tmp;
+		}
+		return result;
+	}
+
+	/**
+	 * Puts a Key in the heap
+	 * Worst case is O(log(n))
+	 * @param key a Key
+	 */
+	public void insert(Key key) {
+		Node x = new Node();
+		x.key = key;
+		x.order = 0;
+		BinomialMinPQ<Key> H = new BinomialMinPQ<Key>(); //The Comparator oh the H heap is not used
+		H.head = x;
+		this.head = this.union(H).head;
+	}
+
+	/**
+	 * Get the minimum key currently in the queue
+	 * Worst case is O(log(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key currently in the priority queue
+	 */
+	public Key minKey() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		Node min = head;
+		Node current = head;
+		while (current.sibling != null) {
+			min = (greater(min.key, current.sibling.key)) ? current : min;
+			current = current.sibling;
+		}
+		return min.key;
+	}
+
+	/**
+	 * Deletes the minimum key
+	 * Worst case is O(log(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key
+	 */
+	public Key delMin() {
+		if(isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		Node min = eraseMin();
+		Node x = (min.child == null) ? min : min.child;
+		if (min.child != null) {
+			min.child = null;
+			Node prevx = null, nextx = x.sibling;
+			while (nextx != null) {
+				x.sibling = prevx;
+				prevx = x;
+				x = nextx;nextx = nextx.sibling;
+			}
+			x.sibling = prevx;
+			BinomialMinPQ<Key> H = new BinomialMinPQ<Key>();
+			H.head = x;
+			head = union(H).head;
+		}
+		return min.key;
+	}
+	
+	/**
+	 * Merges two Binomial heaps together
+	 * This operation is destructive
+	 * Worst case is O(log(n))
+	 * @param heap a Binomial Heap to be merged with the current heap
+	 * @throws java.lang.IllegalArgumentException if the heap in parameter is null
+	 * @return the union of two heaps
+	 */
+	public BinomialMinPQ<Key> union(BinomialMinPQ<Key> heap) {
+		if (heap == null) throw new IllegalArgumentException("Cannot merge a Binomial Heap with null");
+		this.head = merge(new Node(), this.head, heap.head).sibling;
+		Node x = this.head;
+		Node prevx = null, nextx = x.sibling;
+		while (nextx != null) {
+			if (x.order < nextx.order ||
+			   (nextx.sibling != null && nextx.sibling.order == x.order)) {
+				prevx = x; x = nextx;
+			} else if (greater(nextx.key, x.key)) {
+				x.sibling = nextx.sibling;
+				link(nextx, x);
+			} else {
+				if (prevx == null) { this.head = nextx; }
+				else { prevx.sibling = nextx; }
+				link(x, nextx);
+				x = nextx;
+			}
+			nextx = x.sibling;
+		}
+		return this;
+	}
+	
+	/*************************************************
+	 * General helper functions
+	 ************************************************/
+	
+	//Compares two keys
+	private boolean greater(Key n, Key m) {
+		if (n == null) return false;
+		if (m == null) return true;
+		return comp.compare(n, m) > 0;
+	}
+	
+	//Assuming root1 holds a greater key than root2, root2 becomes the new root
+	private void link(Node root1, Node root2) {
+		root1.sibling = root2.child;
+		root2.child = root1;
+		root2.order++;
+	}
+	
+	//Deletes and return the node containing the minimum key
+	private Node eraseMin() {
+		Node min = head;
+		Node previous = null;
+		Node current = head;
+		while (current.sibling != null) {
+			if (greater(min.key, current.sibling.key)) {
+				previous = current;
+				min = current.sibling;
+			}
+			current = current.sibling;
+		}
+		previous.sibling = min.sibling;
+		if (min == head) head = min.sibling;
+		return min;
+	}
+	
+	/**************************************************
+	 * Functions for inserting a key in the heap
+	 *************************************************/
+	
+	//Merges two root lists into one, there can be up to 2 Binomial Trees of same order
+        private Node merge(Node h, Node x, Node y) {
+            if (x == null && y == null) return h;
+            else if (x == null) h.sibling = merge(y, null, y.sibling);
+            else if (y == null) h.sibling = merge(x, x.sibling, null);
+            else if (x.order < y.order) h.sibling = merge(x, x.sibling, y);
+            else                        h.sibling = merge(y, x, y.sibling);
+            return h;
+	}
+	
+	/******************************************************************
+	 * Iterator
+	 *****************************************************************/
+	
+	/**
+	 * Gets an Iterator over the keys in the priority queue in ascending order
+	 * The Iterator does not implement the remove() method
+	 * iterator() : Worst case is O(n)
+	 * next() : 	Worst case is O(log(n))
+	 * hasNext() : 	Worst case is O(1)
+	 * @return an Iterator over the keys in the priority queue in ascending order
+	 */
+	public Iterator<Key> iterator() {
+		return new MyIterator();
+	}
+	
+	private class MyIterator implements Iterator<Key> {
+		BinomialMinPQ<Key> data;
+		
+		//Constructor clones recursively the elements in the queue
+		//It takes linear time
+		public MyIterator() {
+			data = new BinomialMinPQ<Key>(comp);
+			data.head = clone(head, null);
+		}
+		
+		private Node clone(Node x, Node parent) {
+			if (x == null) return null;
+			Node node = new Node();
+			node.key = x.key;
+			node.sibling = clone(x.sibling, parent);
+			node.child = clone(x.child, node);
+			return node;
+		}
+		
+		public boolean hasNext() {
+			return !data.isEmpty();
+		}
+		
+		public Key next() {
+                        if (!hasNext()) throw new NoSuchElementException();
+			return data.delMin();
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
+	
+	/***************************
+	 * Comparator
+	 **************************/
+	
+	//default Comparator
+	private class MyComparator implements Comparator<Key> {
+		@Override
+		public int compare(Key key1, Key key2) {
+			return ((Comparable<Key>) key1).compareTo(key2);
+		}
+	}
+	
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Bipartite.java b/src/main/java/edu/princeton/cs/algs4/Bipartite.java
new file mode 100644
index 0000000..7965fbe
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Bipartite.java
@@ -0,0 +1,236 @@
+/******************************************************************************
+ *  Compilation:  javac Bipartite.java
+ *  Execution:    java  Bipartite V E F
+ *  Dependencies: Graph.java 
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *                https://algs4.cs.princeton.edu/41graph/largeG.txt
+ *
+ *  Given a graph, find either (i) a bipartition or (ii) an odd-length cycle.
+ *  Runs in O(E + V) time.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code Bipartite} class represents a data type for 
+ *  determining whether an undirected graph is <em>bipartite</em> or whether
+ *  it has an <em>odd-length cycle</em>.
+ *  A graph is bipartite if and only if it has no odd-length cycle.
+ *  The <em>isBipartite</em> operation determines whether the graph is
+ *  bipartite. If so, the <em>color</em> operation determines a
+ *  bipartition; if not, the <em>oddCycle</em> operation determines a
+ *  cycle with an odd number of edges.
+ *  <p>
+ *  This implementation uses <em>depth-first search</em>.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in
+ *  the worst case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  See {@link BipartiteX} for a nonrecursive version that uses breadth-first
+ *  search.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Bipartite {
+    private boolean isBipartite;   // is the graph bipartite?
+    private boolean[] color;       // color[v] gives vertices on one side of bipartition
+    private boolean[] marked;      // marked[v] = true iff v has been visited in DFS
+    private int[] edgeTo;          // edgeTo[v] = last edge on path to v
+    private Stack<Integer> cycle;  // odd-length cycle
+
+    /**
+     * Determines whether an undirected graph is bipartite and finds either a
+     * bipartition or an odd-length cycle.
+     *
+     * @param  G the graph
+     */
+    public Bipartite(Graph G) {
+        isBipartite = true;
+        color  = new boolean[G.V()];
+        marked = new boolean[G.V()];
+        edgeTo = new int[G.V()];
+
+        for (int v = 0; v < G.V(); v++) {
+            if (!marked[v]) {
+                dfs(G, v);
+            }
+        }
+        assert check(G);
+    }
+
+    private void dfs(Graph G, int v) { 
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+
+            // short circuit if odd-length cycle found
+            if (cycle != null) return;
+
+            // found uncolored vertex, so recur
+            if (!marked[w]) {
+                edgeTo[w] = v;
+                color[w] = !color[v];
+                dfs(G, w);
+            } 
+
+            // if v-w create an odd-length cycle, find it
+            else if (color[w] == color[v]) {
+                isBipartite = false;
+                cycle = new Stack<Integer>();
+                cycle.push(w);  // don't need this unless you want to include start vertex twice
+                for (int x = v; x != w; x = edgeTo[x]) {
+                    cycle.push(x);
+                }
+                cycle.push(w);
+            }
+        }
+    }
+
+    /**
+     * Returns true if the graph is bipartite.
+     *
+     * @return {@code true} if the graph is bipartite; {@code false} otherwise
+     */
+    public boolean isBipartite() {
+        return isBipartite;
+    }
+ 
+    /**
+     * Returns the side of the bipartite that vertex {@code v} is on.
+     *
+     * @param  v the vertex
+     * @return the side of the bipartition that vertex {@code v} is on; two vertices
+     *         are in the same side of the bipartition if and only if they have the
+     *         same color
+     * @throws IllegalArgumentException unless {@code 0 <= v < V} 
+     * @throws UnsupportedOperationException if this method is called when the graph
+     *         is not bipartite
+     */
+    public boolean color(int v) {
+        validateVertex(v);
+        if (!isBipartite)
+            throw new UnsupportedOperationException("graph is not bipartite");
+        return color[v];
+    }
+
+    /**
+     * Returns an odd-length cycle if the graph is not bipartite, and
+     * {@code null} otherwise.
+     *
+     * @return an odd-length cycle if the graph is not bipartite
+     *         (and hence has an odd-length cycle), and {@code null}
+     *         otherwise
+     */
+    public Iterable<Integer> oddCycle() {
+        return cycle; 
+    }
+
+    private boolean check(Graph G) {
+        // graph is bipartite
+        if (isBipartite) {
+            for (int v = 0; v < G.V(); v++) {
+                for (int w : G.adj(v)) {
+                    if (color[v] == color[w]) {
+                        System.err.printf("edge %d-%d with %d and %d in same side of bipartition\n", v, w, v, w);
+                        return false;
+                    }
+                }
+            }
+        }
+
+        // graph has an odd-length cycle
+        else {
+            // verify cycle
+            int first = -1, last = -1;
+            for (int v : oddCycle()) {
+                if (first == -1) first = v;
+                last = v;
+            }
+            if (first != last) {
+                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code Bipartite} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V1 = Integer.parseInt(args[0]);
+        int V2 = Integer.parseInt(args[1]);
+        int E  = Integer.parseInt(args[2]);
+        int F  = Integer.parseInt(args[3]);
+
+        // create random bipartite graph with V1 vertices on left side,
+        // V2 vertices on right side, and E edges; then add F random edges
+        Graph G = GraphGenerator.bipartite(V1, V2, E);
+        for (int i = 0; i < F; i++) {
+            int v = StdRandom.uniform(V1 + V2);
+            int w = StdRandom.uniform(V1 + V2);
+            G.addEdge(v, w);
+        }
+
+        StdOut.println(G);
+
+
+        Bipartite b = new Bipartite(G);
+        if (b.isBipartite()) {
+            StdOut.println("Graph is bipartite");
+            for (int v = 0; v < G.V(); v++) {
+                StdOut.println(v + ": " + b.color(v));
+            }
+        }
+        else {
+            StdOut.print("Graph has an odd-length cycle: ");
+            for (int x : b.oddCycle()) {
+                StdOut.print(x + " ");
+            }
+            StdOut.println();
+        }
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BipartiteMatching.java b/src/main/java/edu/princeton/cs/algs4/BipartiteMatching.java
new file mode 100644
index 0000000..9ace823
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BipartiteMatching.java
@@ -0,0 +1,370 @@
+/******************************************************************************
+ *  Compilation:  javac BipartiteMatching.java
+ *  Execution:    java BipartiteMatching V1 V2 E
+ *  Dependencies: BipartiteX.java
+ *
+ *  Find a maximum cardinality matching (and minimum cardinality vertex cover)
+ *  in a bipartite graph using the alternating path algorithm.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BipartiteMatching} class represents a data type for computing a
+ *  <em>maximum (cardinality) matching</em> and a
+ *  <em>minimum (cardinality) vertex cover</em> in a bipartite graph.
+ *  A <em>bipartite graph</em> in a graph whose vertices can be partitioned
+ *  into two disjoint sets such that every edge has one endpoint in either set.
+ *  A <em>matching</em> in a graph is a subset of its edges with no common
+ *  vertices. A <em>maximum matching</em> is a matching with the maximum number
+ *  of edges.
+ *  A <em>perfect matching</em> is a matching which matches all vertices in the graph.
+ *  A <em>vertex cover</em> in a graph is a subset of its vertices such that
+ *  every edge is incident to at least one vertex. A <em>minimum vertex cover</em>
+ *  is a vertex cover with the minimum number of vertices.
+ *  By Konig's theorem, in any biparite
+ *  graph, the maximum number of edges in matching equals the minimum number
+ *  of vertices in a vertex cover.
+ *  The maximum matching problem in <em>nonbipartite</em> graphs is
+ *  also important, but all known algorithms for this more general problem
+ *  are substantially more complicated.
+ *  <p>
+ *  This implementation uses the <em>alternating-path algorithm</em>.
+ *  It is equivalent to reducing to the maximum-flow problem and running
+ *  the augmenting-path algorithm on the resulting flow network, but it
+ *  does so with less overhead.
+ *  The constructor takes <em>O</em>((<em>E</em> + <em>V</em>) <em>V</em>)
+ *  time, where <em>E</em> is the number of edges and <em>V</em> is the
+ *  number of vertices in the graph.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  <p>
+ *  See also {@link HopcroftKarp}, which solves the problem in
+ *  <em>O</em>(<em>E</em> sqrt(<em>V</em>)) using the Hopcroft-Karp
+ *  algorithm and
+ *  <a href = "https://algs4.cs.princeton.edu/65reductions/BipartiteMatchingToMaxflow.java.html">BipartiteMatchingToMaxflow</a>,
+ *  which solves the problem in <em>O</em>((<em>E</em> + <em>V</em>) <em>V</em>)
+ *  time via a reduction to maxflow.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/65reductions">Section 6.5</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BipartiteMatching {
+    private static final int UNMATCHED = -1;
+
+    private final int V;                 // number of vertices in the graph
+    private BipartiteX bipartition;      // the bipartition
+    private int cardinality;             // cardinality of current matching
+    private int[] mate;                  // mate[v] =  w if v-w is an edge in current matching
+                                         //         = -1 if v is not in current matching
+    private boolean[] inMinVertexCover;  // inMinVertexCover[v] = true iff v is in min vertex cover
+    private boolean[] marked;            // marked[v] = true iff v is reachable via alternating path
+    private int[] edgeTo;                // edgeTo[v] = last edge on alternating path to v
+
+    /**
+     * Determines a maximum matching (and a minimum vertex cover)
+     * in a bipartite graph.
+     *
+     * @param  G the bipartite graph
+     * @throws IllegalArgumentException if {@code G} is not bipartite
+     */
+    public BipartiteMatching(Graph G) {
+        bipartition = new BipartiteX(G);
+        if (!bipartition.isBipartite()) {
+            throw new IllegalArgumentException("graph is not bipartite");
+        }
+
+        this.V = G.V();
+
+        // initialize empty matching
+        mate = new int[V];
+        for (int v = 0; v < V; v++)
+            mate[v] = UNMATCHED;
+
+        // alternating path algorithm
+        while (hasAugmentingPath(G)) {
+
+            // find one endpoint t in alternating path
+            int t = -1;
+            for (int v = 0; v < G.V(); v++) {
+                if (!isMatched(v) && edgeTo[v] != -1) {
+                    t = v;
+                    break;
+                }
+            }
+
+            // update the matching according to alternating path in edgeTo[] array
+            for (int v = t; v != -1; v = edgeTo[edgeTo[v]]) {
+                int w = edgeTo[v];
+                mate[v] = w;
+                mate[w] = v;
+            }
+            cardinality++;
+        }
+
+        // find min vertex cover from marked[] array
+        inMinVertexCover = new boolean[V];
+        for (int v = 0; v < V; v++) {
+            if (bipartition.color(v) && !marked[v]) inMinVertexCover[v] = true;
+            if (!bipartition.color(v) && marked[v]) inMinVertexCover[v] = true;
+        }
+
+        assert certifySolution(G);
+    }
+
+
+    /*
+     * is there an augmenting path?
+     *   - if so, upon termination adj[] contains the level graph;
+     *   - if not, upon termination marked[] specifies those vertices reachable via an alternating
+     *     path from one side of the bipartition
+     *
+     * an alternating path is a path whose edges belong alternately to the matching and not
+     * to the matching
+     *
+     * an augmenting path is an alternating path that starts and ends at unmatched vertices
+     *
+     * this implementation finds a shortest augmenting path (fewest number of edges), though there
+     * is no particular advantage to do so here
+     */
+    private boolean hasAugmentingPath(Graph G) {
+        marked = new boolean[V];
+
+        edgeTo = new int[V];
+        for (int v = 0; v < V; v++)
+            edgeTo[v] = -1;
+
+        // breadth-first search (starting from all unmatched vertices on one side of bipartition)
+        Queue<Integer> queue = new Queue<Integer>();
+        for (int v = 0; v < V; v++) {
+            if (bipartition.color(v) && !isMatched(v)) {
+                queue.enqueue(v);
+                marked[v] = true;
+            }
+        }
+
+        // run BFS, stopping as soon as an alternating path is found
+        while (!queue.isEmpty()) {
+            int v = queue.dequeue();
+            for (int w : G.adj(v)) {
+
+                // either (1) forward edge not in matching or (2) backward edge in matching
+                if (isResidualGraphEdge(v, w) && !marked[w]) {
+                    edgeTo[w] = v;
+                    marked[w] = true;
+                    if (!isMatched(w)) return true;
+                    queue.enqueue(w);
+                }
+            }
+        }
+
+        return false;
+    }
+
+    // is the edge v-w a forward edge not in the matching or a reverse edge in the matching?
+    private boolean isResidualGraphEdge(int v, int w) {
+        if ((mate[v] != w) &&  bipartition.color(v)) return true;
+        if ((mate[v] == w) && !bipartition.color(v)) return true;
+        return false;
+    }
+
+    /**
+     * Returns the vertex to which the specified vertex is matched in
+     * the maximum matching computed by the algorithm.
+     *
+     * @param  v the vertex
+     * @return the vertex to which vertex {@code v} is matched in the
+     *         maximum matching; {@code -1} if the vertex is not matched
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     *
+     */
+    public int mate(int v) {
+        validate(v);
+        return mate[v];
+    }
+
+    /**
+     * Returns true if the specified vertex is matched in the maximum matching
+     * computed by the algorithm.
+     *
+     * @param  v the vertex
+     * @return {@code true} if vertex {@code v} is matched in maximum matching;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     *
+     */
+    public boolean isMatched(int v) {
+        validate(v);
+        return mate[v] != UNMATCHED;
+    }
+
+    /**
+     * Returns the number of edges in a maximum matching.
+     *
+     * @return the number of edges in a maximum matching
+     */
+    public int size() {
+        return cardinality;
+    }
+
+    /**
+     * Returns true if the graph contains a perfect matching.
+     * That is, the number of edges in a maximum matching is equal to one half
+     * of the number of vertices in the graph (so that every vertex is matched).
+     *
+     * @return {@code true} if the graph contains a perfect matching;
+     *         {@code false} otherwise
+     */
+    public boolean isPerfect() {
+        return cardinality * 2 == V;
+    }
+
+    /**
+     * Returns true if the specified vertex is in the minimum vertex cover
+     * computed by the algorithm.
+     *
+     * @param  v the vertex
+     * @return {@code true} if vertex {@code v} is in the minimum vertex cover;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean inMinVertexCover(int v) {
+        validate(v);
+        return inMinVertexCover[v];
+    }
+
+    private void validate(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // check that mate[] and inVertexCover[] define a max matching and min vertex cover, respectively
+    private boolean certifySolution(Graph G) {
+
+        // check that mate(v) = w iff mate(w) = v
+        for (int v = 0; v < V; v++) {
+            if (mate(v) == -1) continue;
+            if (mate(mate(v)) != v) return false;
+        }
+
+        // check that size() is consistent with mate()
+        int matchedVertices = 0;
+        for (int v = 0; v < V; v++) {
+            if (mate(v) != -1) matchedVertices++;
+        }
+        if (2*size() != matchedVertices) return false;
+
+        // check that size() is consistent with minVertexCover()
+        int sizeOfMinVertexCover = 0;
+        for (int v = 0; v < V; v++)
+            if (inMinVertexCover(v)) sizeOfMinVertexCover++;
+        if (size() != sizeOfMinVertexCover) return false;
+
+        // check that mate() uses each vertex at most once
+        boolean[] isMatched = new boolean[V];
+        for (int v = 0; v < V; v++) {
+            int w = mate[v];
+            if (w == -1) continue;
+            if (v == w) return false;
+            if (v >= w) continue;
+            if (isMatched[v] || isMatched[w]) return false;
+            isMatched[v] = true;
+            isMatched[w] = true;
+        }
+
+        // check that mate() uses only edges that appear in the graph
+        for (int v = 0; v < V; v++) {
+            if (mate(v) == -1) continue;
+            boolean isEdge = false;
+            for (int w : G.adj(v)) {
+                if (mate(v) == w) isEdge = true;
+            }
+            if (!isEdge) return false;
+        }
+
+        // check that inMinVertexCover() is a vertex cover
+        for (int v = 0; v < V; v++)
+            for (int w : G.adj(v))
+                if (!inMinVertexCover(v) && !inMinVertexCover(w)) return false;
+
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code HopcroftKarp} data type.
+     * Takes three command-line arguments {@code V1}, {@code V2}, and {@code E};
+     * creates a random bipartite graph with {@code V1} + {@code V2} vertices
+     * and {@code E} edges; computes a maximum matching and minimum vertex cover;
+     * and prints the results.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V1 = Integer.parseInt(args[0]);
+        int V2 = Integer.parseInt(args[1]);
+        int E  = Integer.parseInt(args[2]);
+        Graph G = GraphGenerator.bipartite(V1, V2, E);
+
+        if (G.V() < 1000) StdOut.println(G);
+
+        BipartiteMatching matching = new BipartiteMatching(G);
+        
+        // print maximum matching
+        StdOut.printf("Number of edges in max matching        = %d\n", matching.size());
+        StdOut.printf("Number of vertices in min vertex cover = %d\n", matching.size());
+        StdOut.printf("Graph has a perfect matching           = %b\n", matching.isPerfect());
+        StdOut.println();
+
+        if (G.V() >= 1000) return;
+
+        StdOut.print("Max matching: ");
+        for (int v = 0; v < G.V(); v++) {
+            int w = matching.mate(v);
+            if (matching.isMatched(v) && v < w)  // print each edge only once
+                StdOut.print(v + "-" + w + " ");
+        }
+        StdOut.println();
+
+        // print minimum vertex cover
+        StdOut.print("Min vertex cover: ");
+        for (int v = 0; v < G.V(); v++)
+            if (matching.inMinVertexCover(v))
+                StdOut.print(v + " ");
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BipartiteX.java b/src/main/java/edu/princeton/cs/algs4/BipartiteX.java
new file mode 100644
index 0000000..1735feb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BipartiteX.java
@@ -0,0 +1,251 @@
+/******************************************************************************
+ *  Compilation:  javac BipartiteX.java
+ *  Execution:    java  Bipartite V E F
+ *  Dependencies: Graph.java 
+ *
+ *  Given a graph, find either (i) a bipartition or (ii) an odd-length cycle.
+ *  Runs in O(E + V) time.
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code BipartiteX} class represents a data type for 
+ *  determining whether an undirected graph is <em>bipartite</em> or whether
+ *  it has an <em>odd-length cycle</em>.
+ *  A graph is bipartite if and only if it has no odd-length cycle.
+ *  The <em>isBipartite</em> operation determines whether the graph is
+ *  bipartite. If so, the <em>color</em> operation determines a
+ *  bipartition; if not, the <em>oddCycle</em> operation determines a
+ *  cycle with an odd number of edges.
+ *  <p>
+ *  This implementation uses <em>breadth-first search</em> and is nonrecursive.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in
+ *  in the worst case, where <em>V</em> is the number of vertices
+ *  and <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  See {@link Bipartite} for a recursive version that uses depth-first search.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BipartiteX {
+    private static final boolean WHITE = false;
+    private static final boolean BLACK = true;
+
+    private boolean isBipartite;   // is the graph bipartite?
+    private boolean[] color;       // color[v] gives vertices on one side of bipartition
+    private boolean[] marked;      // marked[v] = true iff v has been visited in DFS
+    private int[] edgeTo;          // edgeTo[v] = last edge on path to v
+    private Queue<Integer> cycle;  // odd-length cycle
+
+    /**
+     * Determines whether an undirected graph is bipartite and finds either a
+     * bipartition or an odd-length cycle.
+     *
+     * @param  G the graph
+     */
+    public BipartiteX(Graph G) {
+        isBipartite = true;
+        color  = new boolean[G.V()];
+        marked = new boolean[G.V()];
+        edgeTo = new int[G.V()];
+
+        for (int v = 0; v < G.V() && isBipartite; v++) {
+            if (!marked[v]) {
+                bfs(G, v);
+            }
+        }
+        assert check(G);
+    }
+
+    private void bfs(Graph G, int s) { 
+        Queue<Integer> q = new Queue<Integer>();
+        color[s] = WHITE;
+        marked[s] = true;
+        q.enqueue(s);
+
+        while (!q.isEmpty()) {
+            int v = q.dequeue();
+            for (int w : G.adj(v)) {
+                if (!marked[w]) {
+                    marked[w] = true;
+                    edgeTo[w] = v;
+                    color[w] = !color[v];
+                    q.enqueue(w);
+                }
+                else if (color[w] == color[v]) {
+                    isBipartite = false;
+
+                    // to form odd cycle, consider s-v path and s-w path
+                    // and let x be closest node to v and w common to two paths
+                    // then (w-x path) + (x-v path) + (edge v-w) is an odd-length cycle
+                    // Note: distTo[v] == distTo[w];
+                    cycle = new Queue<Integer>();
+                    Stack<Integer> stack = new Stack<Integer>();
+                    int x = v, y = w;
+                    while (x != y) {
+                        stack.push(x);
+                        cycle.enqueue(y);
+                        x = edgeTo[x];
+                        y = edgeTo[y];
+                    }
+                    stack.push(x);
+                    while (!stack.isEmpty())
+                        cycle.enqueue(stack.pop());
+                    cycle.enqueue(w);
+                    return;
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns true if the graph is bipartite.
+     *
+     * @return {@code true} if the graph is bipartite; {@code false} otherwise
+     */
+    public boolean isBipartite() {
+        return isBipartite;
+    }
+ 
+    /**
+     * Returns the side of the bipartite that vertex {@code v} is on.
+     *
+     * @param  v the vertex
+     * @return the side of the bipartition that vertex {@code v} is on; two vertices
+     *         are in the same side of the bipartition if and only if they have the
+     *         same color
+     * @throws IllegalArgumentException unless {@code 0 <= v < V} 
+     * @throws UnsupportedOperationException if this method is called when the graph
+     *         is not bipartite
+     */
+    public boolean color(int v) {
+        validateVertex(v);
+        if (!isBipartite)
+            throw new UnsupportedOperationException("Graph is not bipartite");
+        return color[v];
+    }
+
+
+    /**
+     * Returns an odd-length cycle if the graph is not bipartite, and
+     * {@code null} otherwise.
+     *
+     * @return an odd-length cycle if the graph is not bipartite
+     *         (and hence has an odd-length cycle), and {@code null}
+     *         otherwise
+     */
+    public Iterable<Integer> oddCycle() {
+        return cycle; 
+    }
+
+    private boolean check(Graph G) {
+        // graph is bipartite
+        if (isBipartite) {
+            for (int v = 0; v < G.V(); v++) {
+                for (int w : G.adj(v)) {
+                    if (color[v] == color[w]) {
+                        System.err.printf("edge %d-%d with %d and %d in same side of bipartition\n", v, w, v, w);
+                        return false;
+                    }
+                }
+            }
+        }
+
+        // graph has an odd-length cycle
+        else {
+            // verify cycle
+            int first = -1, last = -1;
+            for (int v : oddCycle()) {
+                if (first == -1) first = v;
+                last = v;
+            }
+            if (first != last) {
+                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code BipartiteX} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V1 = Integer.parseInt(args[0]);
+        int V2 = Integer.parseInt(args[1]);
+        int E  = Integer.parseInt(args[2]);
+        int F  = Integer.parseInt(args[3]);
+
+        // create random bipartite graph with V1 vertices on left side,
+        // V2 vertices on right side, and E edges; then add F random edges
+        Graph G = GraphGenerator.bipartite(V1, V2, E);
+        for (int i = 0; i < F; i++) {
+            int v = StdRandom.uniform(V1 + V2);
+            int w = StdRandom.uniform(V1 + V2);
+            G.addEdge(v, w);
+        }
+
+        StdOut.println(G);
+
+
+        BipartiteX b = new BipartiteX(G);
+        if (b.isBipartite()) {
+            StdOut.println("Graph is bipartite");
+            for (int v = 0; v < G.V(); v++) {
+                StdOut.println(v + ": " + b.color(v));
+            }
+        }
+        else {
+            StdOut.print("Graph has an odd-length cycle: ");
+            for (int x : b.oddCycle()) {
+                StdOut.print(x + " ");
+            }
+            StdOut.println();
+        }
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BlockFilter.java b/src/main/java/edu/princeton/cs/algs4/BlockFilter.java
new file mode 100644
index 0000000..c861223
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BlockFilter.java
@@ -0,0 +1,92 @@
+/******************************************************************************
+ *  Compilation:  javac BlockFilter.java
+ *  Execution:    java BlockFilter blocklist.txt < input.txt
+ *  Dependencies: SET In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/tinyTale.txt
+ *                https://algs4.cs.princeton.edu/35applications/blocklist.txt
+ *
+ *  Read in a blocklist of words from a file. Then read in a list of
+ *  words from standard input and print out all those words that
+ *  are not in the first file.
+ * 
+ *  % more tinyTale.txt 
+ *  it was the best of times it was the worst of times 
+ *  it was the age of wisdom it was the age of foolishness 
+ *  it was the epoch of belief it was the epoch of incredulity 
+ *  it was the season of light it was the season of darkness 
+ *  it was the spring of hope it was the winter of despair
+ *
+ *  % more list.txt 
+ *  was it the of 
+ * 
+ *  % java BlockFilter list.txt < tinyTale.txt 
+ *  best times worst times 
+ *  age wisdom age foolishness 
+ *  epoch belief epoch incredulity 
+ *  season light season darkness 
+ *  spring hope winter despair 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BlockFilter} class provides a client for reading in a <em>blocklist</em>
+ *  of words from a file; then, reading in a sequence of words from standard input, 
+ *  printing out each word that <em>does not</em> appear in the file. 
+ *  It is useful as a test client for various symbol table implementations.   
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BlockFilter {  
+
+    // Do not instantiate.
+    private BlockFilter() { }
+
+    public static void main(String[] args) {
+        SET<String> set = new SET<String>();
+
+        // read in strings and add to set
+        In in = new In(args[0]);
+        while (!in.isEmpty()) {
+            String word = in.readString();
+            set.add(word);
+        }
+
+        // read in string from standard input, printing out all exceptions
+        while (!StdIn.isEmpty()) {
+            String word = StdIn.readString();
+            if (!set.contains(word))
+                StdOut.println(word);
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BoruvkaMST.java b/src/main/java/edu/princeton/cs/algs4/BoruvkaMST.java
new file mode 100644
index 0000000..7011033
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BoruvkaMST.java
@@ -0,0 +1,227 @@
+/******************************************************************************
+ *  Compilation:  javac BoruvkaMST.java
+ *  Execution:    java BoruvkaMST filename.txt
+ *  Dependencies: EdgeWeightedGraph.java Edge.java Bag.java
+ *                UF.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/largeEWG.txt
+ *
+ *  Compute a minimum spanning forest using Boruvka's algorithm.
+ *
+ *  % java BoruvkaMST tinyEWG.txt 
+ *  0-2 0.26000
+ *  6-2 0.40000
+ *  5-7 0.28000
+ *  4-5 0.35000
+ *  2-3 0.17000
+ *  1-7 0.19000
+ *  0-7 0.16000
+ *  1.81000
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BoruvkaMST} class represents a data type for computing a
+ *  <em>minimum spanning tree</em> in an edge-weighted graph.
+ *  The edge weights can be positive, zero, or negative and need not
+ *  be distinct. If the graph is not connected, it computes a <em>minimum
+ *  spanning forest</em>, which is the union of minimum spanning trees
+ *  in each connected component. The {@code weight()} method returns the 
+ *  weight of a minimum spanning tree and the {@code edges()} method
+ *  returns its edges.
+ *  <p>
+ *  This implementation uses <em>Boruvka's algorithm</em> and the union-find
+ *  data type.
+ *  The constructor takes &Theta;(<em>E</em> log <em>V</em>) time in
+ *  the worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the
+ *  edge-weighted graph).
+ *  <p>
+ *  This {@code weight()} method correctly computes the weight of the MST
+ *  if all arithmetic performed is without floating-point rounding error
+ *  or arithmetic overflow.
+ *  This is the case if all edge weights are non-negative integers
+ *  and the weight of the MST does not exceed 2<sup>52</sup>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For alternate implementations, see {@link LazyPrimMST}, {@link PrimMST},
+ *  and {@link KruskalMST}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BoruvkaMST {
+    private static final double FLOATING_POINT_EPSILON = 1E-12;
+
+    private Bag<Edge> mst = new Bag<Edge>();    // edges in MST
+    private double weight;                      // weight of MST
+
+    /**
+     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
+     * @param G the edge-weighted graph
+     */
+    public BoruvkaMST(EdgeWeightedGraph G) {
+        UF uf = new UF(G.V());
+
+        // repeat at most log V times or until we have V-1 edges
+        for (int t = 1; t < G.V() && mst.size() < G.V() - 1; t = t + t) {
+
+            // foreach tree in forest, find closest edge
+            // if edge weights are equal, ties are broken in favor of first edge in G.edges()
+            Edge[] closest = new Edge[G.V()];
+            for (Edge e : G.edges()) {
+                int v = e.either(), w = e.other(v);
+                int i = uf.find(v), j = uf.find(w);
+                if (i == j) continue;   // same tree
+                if (closest[i] == null || less(e, closest[i])) closest[i] = e;
+                if (closest[j] == null || less(e, closest[j])) closest[j] = e;
+            }
+
+            // add newly discovered edges to MST
+            for (int i = 0; i < G.V(); i++) {
+                Edge e = closest[i];
+                if (e != null) {
+                    int v = e.either(), w = e.other(v);
+                    // don't add the same edge twice
+                    if (uf.find(v) != uf.find(w)) {
+                        mst.add(e);
+                        weight += e.weight();
+                        uf.union(v, w);
+                    }
+                }
+            }
+        }
+
+        // check optimality conditions
+        assert check(G);
+    }
+
+    /**
+     * Returns the edges in a minimum spanning tree (or forest).
+     * @return the edges in a minimum spanning tree (or forest) as
+     *    an iterable of edges
+     */
+    public Iterable<Edge> edges() {
+        return mst;
+    }
+
+
+    /**
+     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
+     * @return the sum of the edge weights in a minimum spanning tree (or forest)
+     */
+    public double weight() {
+        return weight;
+    }
+
+    // is the weight of edge e strictly less than that of edge f?
+    private static boolean less(Edge e, Edge f) {
+        return e.compareTo(f) < 0;
+    }
+
+    // check optimality conditions (takes time proportional to E V lg* V)
+    private boolean check(EdgeWeightedGraph G) {
+
+        // check weight
+        double totalWeight = 0.0;
+        for (Edge e : edges()) {
+            totalWeight += e.weight();
+        }
+        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
+            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
+            return false;
+        }
+
+        // check that it is acyclic
+        UF uf = new UF(G.V());
+        for (Edge e : edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) == uf.find(w)) {
+                System.err.println("Not a forest");
+                return false;
+            }
+            uf.union(v, w);
+        }
+
+        // check that it is a spanning forest
+        for (Edge e : G.edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) != uf.find(w)) {
+                System.err.println("Not a spanning forest");
+                return false;
+            }
+        }
+
+        // check that it is a minimal spanning forest (cut optimality conditions)
+        for (Edge e : edges()) {
+
+            // all edges in MST except e
+            uf = new UF(G.V());
+            for (Edge f : mst) {
+                int x = f.either(), y = f.other(x);
+                if (f != e) uf.union(x, y);
+            }
+
+            // check that e is min weight edge in crossing cut
+            for (Edge f : G.edges()) {
+                int x = f.either(), y = f.other(x);
+                if (uf.find(x) != uf.find(y)) {
+                    if (f.weight() < e.weight()) {
+                        System.err.println("Edge " + f + " violates cut optimality conditions");
+                        return false;
+                    }
+                }
+            }
+
+        }
+
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code BoruvkaMST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        BoruvkaMST mst = new BoruvkaMST(G);
+        for (Edge e : mst.edges()) {
+            StdOut.println(e);
+        }
+        StdOut.printf("%.5f\n", mst.weight());
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BoyerMoore.java b/src/main/java/edu/princeton/cs/algs4/BoyerMoore.java
new file mode 100644
index 0000000..db21c7c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BoyerMoore.java
@@ -0,0 +1,198 @@
+/******************************************************************************
+ *  Compilation:  javac BoyerMoore.java
+ *  Execution:    java BoyerMoore pattern text
+ *  Dependencies: StdOut.java
+ *
+ *  Reads in two strings, the pattern and the input text, and
+ *  searches for the pattern in the input text using the
+ *  bad-character rule part of the Boyer-Moore algorithm.
+ *  (does not implement the strong good suffix rule)
+ *
+ *  % java BoyerMoore abracadabra abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  pattern:               abracadabra
+ *
+ *  % java BoyerMoore rab abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  pattern:         rab
+ *
+ *  % java BoyerMoore bcara abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  pattern:                                   bcara
+ *
+ *  % java BoyerMoore rabrabracad abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad
+ *  pattern:                        rabrabracad
+ *
+ *  % java BoyerMoore abacad abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad
+ *  pattern: abacad
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BoyerMoore} class finds the first occurrence of a pattern string
+ *  in a text string.
+ *  <p>
+ *  This implementation uses the Boyer-Moore algorithm (with the bad-character
+ *  rule, but not the strong good suffix rule).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/53substring">Section 5.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class BoyerMoore {
+    private final int R;     // the radix
+    private int[] right;     // the bad-character skip array
+
+    private char[] pattern;  // store the pattern as a character array
+    private String pat;      // or as a string
+
+    /**
+     * Preprocesses the pattern string.
+     *
+     * @param pat the pattern string
+     */
+    public BoyerMoore(String pat) {
+        this.R = 256;
+        this.pat = pat;
+
+        // position of rightmost occurrence of c in the pattern
+        right = new int[R];
+        for (int c = 0; c < R; c++)
+            right[c] = -1;
+        for (int j = 0; j < pat.length(); j++)
+            right[pat.charAt(j)] = j;
+    }
+
+    /**
+     * Preprocesses the pattern string.
+     *
+     * @param pattern the pattern string
+     * @param R the alphabet size
+     */
+    public BoyerMoore(char[] pattern, int R) {
+        this.R = R;
+        this.pattern = new char[pattern.length];
+        for (int j = 0; j < pattern.length; j++)
+            this.pattern[j] = pattern[j];
+
+        // position of rightmost occurrence of c in the pattern
+        right = new int[R];
+        for (int c = 0; c < R; c++)
+            right[c] = -1;
+        for (int j = 0; j < pattern.length; j++)
+            right[pattern[j]] = j;
+    }
+
+    /**
+     * Returns the index of the first occurrrence of the pattern string
+     * in the text string.
+     *
+     * @param  txt the text string
+     * @return the index of the first occurrence of the pattern string
+     *         in the text string; n if no such match
+     */
+    public int search(String txt) {
+        int m = pat.length();
+        int n = txt.length();
+        int skip;
+        for (int i = 0; i <= n - m; i += skip) {
+            skip = 0;
+            for (int j = m-1; j >= 0; j--) {
+                if (pat.charAt(j) != txt.charAt(i+j)) {
+                    skip = Math.max(1, j - right[txt.charAt(i+j)]);
+                    break;
+                }
+            }
+            if (skip == 0) return i;    // found
+        }
+        return n;                       // not found
+    }
+
+
+    /**
+     * Returns the index of the first occurrrence of the pattern string
+     * in the text string.
+     *
+     * @param  text the text string
+     * @return the index of the first occurrence of the pattern string
+     *         in the text string; n if no such match
+     */
+    public int search(char[] text) {
+        int m = pattern.length;
+        int n = text.length;
+        int skip;
+        for (int i = 0; i <= n - m; i += skip) {
+            skip = 0;
+            for (int j = m-1; j >= 0; j--) {
+                if (pattern[j] != text[i+j]) {
+                    skip = Math.max(1, j - right[text[i+j]]);
+                    break;
+                }
+            }
+            if (skip == 0) return i;    // found
+        }
+        return n;                       // not found
+    }
+
+
+    /**
+     * Takes a pattern string and an input string as command-line arguments;
+     * searches for the pattern string in the text string; and prints
+     * the first occurrence of the pattern string in the text string.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String pat = args[0];
+        String txt = args[1];
+        char[] pattern = pat.toCharArray();
+        char[] text    = txt.toCharArray();
+
+        BoyerMoore boyermoore1 = new BoyerMoore(pat);
+        BoyerMoore boyermoore2 = new BoyerMoore(pattern, 256);
+        int offset1 = boyermoore1.search(txt);
+        int offset2 = boyermoore2.search(text);
+
+        // print results
+        StdOut.println("text:    " + txt);
+
+        StdOut.print("pattern: ");
+        for (int i = 0; i < offset1; i++)
+            StdOut.print(" ");
+        StdOut.println(pat);
+
+        StdOut.print("pattern: ");
+        for (int i = 0; i < offset2; i++)
+            StdOut.print(" ");
+        StdOut.println(pat);
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BreadthFirstDirectedPaths.java b/src/main/java/edu/princeton/cs/algs4/BreadthFirstDirectedPaths.java
new file mode 100644
index 0000000..f69c658
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BreadthFirstDirectedPaths.java
@@ -0,0 +1,256 @@
+/******************************************************************************
+ *  Compilation:  javac BreadthFirstDirectedPaths.java
+ *  Execution:    java BreadthFirstDirectedPaths digraph.txt s
+ *  Dependencies: Digraph.java Queue.java Stack.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Run breadth-first search on a digraph.
+ *  Runs in O(E + V) time.
+ *
+ *  % java BreadthFirstDirectedPaths tinyDG.txt 3
+ *  3 to 0 (2):  3->2->0
+ *  3 to 1 (3):  3->2->0->1
+ *  3 to 2 (1):  3->2
+ *  3 to 3 (0):  3
+ *  3 to 4 (2):  3->5->4
+ *  3 to 5 (1):  3->5
+ *  3 to 6 (-):  not connected
+ *  3 to 7 (-):  not connected
+ *  3 to 8 (-):  not connected
+ *  3 to 9 (-):  not connected
+ *  3 to 10 (-):  not connected
+ *  3 to 11 (-):  not connected
+ *  3 to 12 (-):  not connected
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code BreadthDirectedFirstPaths} class represents a data type for
+ *  finding shortest paths (number of edges) from a source vertex <em>s</em>
+ *  (or set of source vertices) to every other vertex in the digraph.
+ *  <p>
+ *  This implementation uses breadth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and <em>E</em> is
+ *  the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BreadthFirstDirectedPaths {
+    private static final int INFINITY = Integer.MAX_VALUE;
+    private boolean[] marked;  // marked[v] = is there an s->v path?
+    private int[] edgeTo;      // edgeTo[v] = last edge on shortest s->v path
+    private int[] distTo;      // distTo[v] = length of shortest s->v path
+
+    /**
+     * Computes the shortest path from {@code s} and every other vertex in graph {@code G}.
+     * @param G the digraph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public BreadthFirstDirectedPaths(Digraph G, int s) {
+        marked = new boolean[G.V()];
+        distTo = new int[G.V()];
+        edgeTo = new int[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = INFINITY;
+        validateVertex(s);
+        bfs(G, s);
+    }
+
+    /**
+     * Computes the shortest path from any one of the source vertices in {@code sources}
+     * to every other vertex in graph {@code G}.
+     * @param G the digraph
+     * @param sources the source vertices
+     * @throws IllegalArgumentException if {@code sources} is {@code null}
+     * @throws IllegalArgumentException unless each vertex {@code v} in
+     *         {@code sources} satisfies {@code 0 <= v < V}
+     */
+    public BreadthFirstDirectedPaths(Digraph G, Iterable<Integer> sources) {
+        marked = new boolean[G.V()];
+        distTo = new int[G.V()];
+        edgeTo = new int[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = INFINITY;
+        validateVertices(sources);
+        bfs(G, sources);
+    }
+
+    // BFS from single source
+    private void bfs(Digraph G, int s) {
+        Queue<Integer> q = new Queue<Integer>();
+        marked[s] = true;
+        distTo[s] = 0;
+        q.enqueue(s);
+        while (!q.isEmpty()) {
+            int v = q.dequeue();
+            for (int w : G.adj(v)) {
+                if (!marked[w]) {
+                    edgeTo[w] = v;
+                    distTo[w] = distTo[v] + 1;
+                    marked[w] = true;
+                    q.enqueue(w);
+                }
+            }
+        }
+    }
+
+    // BFS from multiple sources
+    private void bfs(Digraph G, Iterable<Integer> sources) {
+        Queue<Integer> q = new Queue<Integer>();
+        for (int s : sources) {
+            marked[s] = true;
+            distTo[s] = 0;
+            q.enqueue(s);
+        }
+        while (!q.isEmpty()) {
+            int v = q.dequeue();
+            for (int w : G.adj(v)) {
+                if (!marked[w]) {
+                    edgeTo[w] = v;
+                    distTo[w] = distTo[v] + 1;
+                    marked[w] = true;
+                    q.enqueue(w);
+                }
+            }
+        }
+    }
+
+    /**
+     * Is there a directed path from the source {@code s} (or sources) to vertex {@code v}?
+     * @param v the vertex
+     * @return {@code true} if there is a directed path, {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    /**
+     * Returns the number of edges in a shortest path from the source {@code s}
+     * (or sources) to vertex {@code v}?
+     * @param v the vertex
+     * @return the number of edges in such a shortest path
+     *         (or {@code Integer.MAX_VALUE} if there is no such path)
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int distTo(int v) {
+        validateVertex(v);
+        return distTo[v];
+    }
+
+    /**
+     * Returns a shortest path from {@code s} (or sources) to {@code v}, or
+     * {@code null} if no such path.
+     * @param v the vertex
+     * @return the sequence of vertices on a shortest path, as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Integer> pathTo(int v) {
+        validateVertex(v);
+
+        if (!hasPathTo(v)) return null;
+        Stack<Integer> path = new Stack<Integer>();
+        int x;
+        for (x = v; distTo[x] != 0; x = edgeTo[x])
+            path.push(x);
+        path.push(x);
+        return path;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    // throw an IllegalArgumentException if vertices is null, has zero vertices,
+    // or has a vertex not between 0 and V-1
+    private void validateVertices(Iterable<Integer> vertices) {
+        if (vertices == null) {
+            throw new IllegalArgumentException("argument is null");
+        }
+        int V = marked.length;
+        int count = 0;
+        for (Integer v : vertices) {
+            count++;
+            if (v == null) {
+                throw new IllegalArgumentException("vertex is null");
+            }
+            validateVertex(v);
+        }
+        if (count == 0) {
+            throw new IllegalArgumentException("zero vertices");
+        }
+    }
+
+    /**
+     * Unit tests the {@code BreadthFirstDirectedPaths} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        // StdOut.println(G);
+
+        int s = Integer.parseInt(args[1]);
+        BreadthFirstDirectedPaths bfs = new BreadthFirstDirectedPaths(G, s);
+
+        for (int v = 0; v < G.V(); v++) {
+            if (bfs.hasPathTo(v)) {
+                StdOut.printf("%d to %d (%d):  ", s, v, bfs.distTo(v));
+                for (int x : bfs.pathTo(v)) {
+                    if (x == s) StdOut.print(x);
+                    else        StdOut.print("->" + x);
+                }
+                StdOut.println();
+            }
+
+            else {
+                StdOut.printf("%d to %d (-):  not connected\n", s, v);
+            }
+
+        }
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/BreadthFirstPaths.java b/src/main/java/edu/princeton/cs/algs4/BreadthFirstPaths.java
new file mode 100644
index 0000000..883b9a8
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/BreadthFirstPaths.java
@@ -0,0 +1,319 @@
+/******************************************************************************
+ *  Compilation:  javac BreadthFirstPaths.java
+ *  Execution:    java BreadthFirstPaths G s
+ *  Dependencies: Graph.java Queue.java Stack.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyCG.txt
+ *                https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *                https://algs4.cs.princeton.edu/41graph/largeG.txt
+ *
+ *  Run breadth first search on an undirected graph.
+ *  Runs in O(E + V) time.
+ *
+ *  %  java Graph tinyCG.txt
+ *  6 8
+ *  0: 2 1 5 
+ *  1: 0 2 
+ *  2: 0 1 3 4 
+ *  3: 5 4 2 
+ *  4: 3 2 
+ *  5: 3 0 
+ *
+ *  %  java BreadthFirstPaths tinyCG.txt 0
+ *  0 to 0 (0):  0
+ *  0 to 1 (1):  0-1
+ *  0 to 2 (1):  0-2
+ *  0 to 3 (2):  0-2-3
+ *  0 to 4 (2):  0-2-4
+ *  0 to 5 (1):  0-5
+ *
+ *  %  java BreadthFirstPaths largeG.txt 0
+ *  0 to 0 (0):  0
+ *  0 to 1 (418):  0-932942-474885-82707-879889-971961-...
+ *  0 to 2 (323):  0-460790-53370-594358-780059-287921-...
+ *  0 to 3 (168):  0-713461-75230-953125-568284-350405-...
+ *  0 to 4 (144):  0-460790-53370-310931-440226-380102-...
+ *  0 to 5 (566):  0-932942-474885-82707-879889-971961-...
+ *  0 to 6 (349):  0-932942-474885-82707-879889-971961-...
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code BreadthFirstPaths} class represents a data type for finding
+ *  shortest paths (number of edges) from a source vertex <em>s</em>
+ *  (or a set of source vertices)
+ *  to every other vertex in an undirected graph.
+ *  <p>
+ *  This implementation uses breadth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class BreadthFirstPaths {
+    private static final int INFINITY = Integer.MAX_VALUE;
+    private boolean[] marked;  // marked[v] = is there an s-v path
+    private int[] edgeTo;      // edgeTo[v] = previous edge on shortest s-v path
+    private int[] distTo;      // distTo[v] = number of edges shortest s-v path
+
+    /**
+     * Computes the shortest path between the source vertex {@code s}
+     * and every other vertex in the graph {@code G}.
+     * @param G the graph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public BreadthFirstPaths(Graph G, int s) {
+        marked = new boolean[G.V()];
+        distTo = new int[G.V()];
+        edgeTo = new int[G.V()];
+        validateVertex(s);
+        bfs(G, s);
+
+        assert check(G, s);
+    }
+
+    /**
+     * Computes the shortest path between any one of the source vertices in {@code sources}
+     * and every other vertex in graph {@code G}.
+     * @param G the graph
+     * @param sources the source vertices
+     * @throws IllegalArgumentException if {@code sources} is {@code null}
+     * @throws IllegalArgumentException unless {@code 0 <= s < V} for each vertex
+     *         {@code s} in {@code sources}
+     */
+    public BreadthFirstPaths(Graph G, Iterable<Integer> sources) {
+        marked = new boolean[G.V()];
+        distTo = new int[G.V()];
+        edgeTo = new int[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = INFINITY;
+        validateVertices(sources);
+        bfs(G, sources);
+    }
+
+
+    // breadth-first search from a single source
+    private void bfs(Graph G, int s) {
+        Queue<Integer> q = new Queue<Integer>();
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = INFINITY;
+        distTo[s] = 0;
+        marked[s] = true;
+        q.enqueue(s);
+
+        while (!q.isEmpty()) {
+            int v = q.dequeue();
+            for (int w : G.adj(v)) {
+                if (!marked[w]) {
+                    edgeTo[w] = v;
+                    distTo[w] = distTo[v] + 1;
+                    marked[w] = true;
+                    q.enqueue(w);
+                }
+            }
+        }
+    }
+
+    // breadth-first search from multiple sources
+    private void bfs(Graph G, Iterable<Integer> sources) {
+        Queue<Integer> q = new Queue<Integer>();
+        for (int s : sources) {
+            marked[s] = true;
+            distTo[s] = 0;
+            q.enqueue(s);
+        }
+        while (!q.isEmpty()) {
+            int v = q.dequeue();
+            for (int w : G.adj(v)) {
+                if (!marked[w]) {
+                    edgeTo[w] = v;
+                    distTo[w] = distTo[v] + 1;
+                    marked[w] = true;
+                    q.enqueue(w);
+                }
+            }
+        }
+    }
+
+    /**
+     * Is there a path between the source vertex {@code s} (or sources) and vertex {@code v}?
+     * @param v the vertex
+     * @return {@code true} if there is a path, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    /**
+     * Returns the number of edges in a shortest path between the source vertex {@code s}
+     * (or sources) and vertex {@code v}?
+     * @param v the vertex
+     * @return the number of edges in such a shortest path
+     *         (or {@code Integer.MAX_VALUE} if there is no such path)
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int distTo(int v) {
+        validateVertex(v);
+        return distTo[v];
+    }
+
+    /**
+     * Returns a shortest path between the source vertex {@code s} (or sources)
+     * and {@code v}, or {@code null} if no such path.
+     * @param  v the vertex
+     * @return the sequence of vertices on a shortest path, as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Integer> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<Integer> path = new Stack<Integer>();
+        int x;
+        for (x = v; distTo[x] != 0; x = edgeTo[x])
+            path.push(x);
+        path.push(x);
+        return path;
+    }
+
+
+    // check optimality conditions for single source
+    private boolean check(Graph G, int s) {
+
+        // check that the distance of s = 0
+        if (distTo[s] != 0) {
+            StdOut.println("distance of source " + s + " to itself = " + distTo[s]);
+            return false;
+        }
+
+        // check that for each edge v-w dist[w] <= dist[v] + 1
+        // provided v is reachable from s
+        for (int v = 0; v < G.V(); v++) {
+            for (int w : G.adj(v)) {
+                if (hasPathTo(v) != hasPathTo(w)) {
+                    StdOut.println("edge " + v + "-" + w);
+                    StdOut.println("hasPathTo(" + v + ") = " + hasPathTo(v));
+                    StdOut.println("hasPathTo(" + w + ") = " + hasPathTo(w));
+                    return false;
+                }
+                if (hasPathTo(v) && (distTo[w] > distTo[v] + 1)) {
+                    StdOut.println("edge " + v + "-" + w);
+                    StdOut.println("distTo[" + v + "] = " + distTo[v]);
+                    StdOut.println("distTo[" + w + "] = " + distTo[w]);
+                    return false;
+                }
+            }
+        }
+
+        // check that v = edgeTo[w] satisfies distTo[w] = distTo[v] + 1
+        // provided v is reachable from s
+        for (int w = 0; w < G.V(); w++) {
+            if (!hasPathTo(w) || w == s) continue;
+            int v = edgeTo[w];
+            if (distTo[w] != distTo[v] + 1) {
+                StdOut.println("shortest path edge " + v + "-" + w);
+                StdOut.println("distTo[" + v + "] = " + distTo[v]);
+                StdOut.println("distTo[" + w + "] = " + distTo[w]);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    // throw an IllegalArgumentException if vertices is null, has zero vertices,
+    // or has a vertex not between 0 and V-1
+    private void validateVertices(Iterable<Integer> vertices) {
+        if (vertices == null) {
+            throw new IllegalArgumentException("argument is null");
+        }
+        int V = marked.length;
+        int count = 0;
+        for (Integer v : vertices) {
+            count++;
+            if (v == null) {
+                throw new IllegalArgumentException("vertex is null");
+            }
+            validateVertex(v);
+        }
+        if (count == 0) {
+            throw new IllegalArgumentException("zero vertices");
+        }
+    }
+
+    /**
+     * Unit tests the {@code BreadthFirstPaths} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        // StdOut.println(G);
+
+        int s = Integer.parseInt(args[1]);
+        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
+
+        for (int v = 0; v < G.V(); v++) {
+            if (bfs.hasPathTo(v)) {
+                StdOut.printf("%d to %d (%d):  ", s, v, bfs.distTo(v));
+                for (int x : bfs.pathTo(v)) {
+                    if (x == s) StdOut.print(x);
+                    else        StdOut.print("-" + x);
+                }
+                StdOut.println();
+            }
+
+            else {
+                StdOut.printf("%d to %d (-):  not connected\n", s, v);
+            }
+
+        }
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/CC.java b/src/main/java/edu/princeton/cs/algs4/CC.java
new file mode 100644
index 0000000..6447c65
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/CC.java
@@ -0,0 +1,260 @@
+/******************************************************************************
+ *  Compilation:  javac CC.java
+ *  Execution:    java CC filename.txt
+ *  Dependencies: Graph.java StdOut.java Queue.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *                https://algs4.cs.princeton.edu/41graph/largeG.txt
+ *
+ *  Compute connected components using depth first search.
+ *  Runs in O(E + V) time.
+ *
+ *  % java CC tinyG.txt
+ *  3 components
+ *  0 1 2 3 4 5 6
+ *  7 8 
+ *  9 10 11 12
+ *
+ *  % java CC mediumG.txt 
+ *  1 components
+ *  0 1 2 3 4 5 6 7 8 9 10 ...
+ *
+ *  % java -Xss50m CC largeG.txt 
+ *  1 components
+ *  0 1 2 3 4 5 6 7 8 9 10 ...
+ *
+ *  Note: This implementation uses a recursive DFS. To avoid needing
+ *        a potentially very large stack size, replace with a non-recurisve
+ *        DFS ala NonrecursiveDFS.java.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code CC} class represents a data type for 
+ *  determining the connected components in an undirected graph.
+ *  The <em>id</em> operation determines in which connected component
+ *  a given vertex lies; the <em>connected</em> operation
+ *  determines whether two vertices are in the same connected component;
+ *  the <em>count</em> operation determines the number of connected
+ *  components; and the <em>size</em> operation determines the number
+ *  of vertices in the connect component containing a given vertex.
+
+ *  The <em>component identifier</em> of a connected component is one of the
+ *  vertices in the connected component: two vertices have the same component
+ *  identifier if and only if they are in the same connected component.
+
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time,
+ *  where <em>V</em> is the number of vertices and <em>E</em> is the
+ *  number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  <p>
+ *  For additional documentation, see 
+ *  <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <em>Algorithms, 4th Edition</em> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class CC {
+    private boolean[] marked;   // marked[v] = has vertex v been marked?
+    private int[] id;           // id[v] = id of connected component containing v
+    private int[] size;         // size[id] = number of vertices in given component
+    private int count;          // number of connected components
+
+    /**
+     * Computes the connected components of the undirected graph {@code G}.
+     *
+     * @param G the undirected graph
+     */
+    public CC(Graph G) {
+        marked = new boolean[G.V()];
+        id = new int[G.V()];
+        size = new int[G.V()];
+        for (int v = 0; v < G.V(); v++) {
+            if (!marked[v]) {
+                dfs(G, v);
+                count++;
+            }
+        }
+    }
+
+    /**
+     * Computes the connected components of the edge-weighted graph {@code G}.
+     *
+     * @param G the edge-weighted graph
+     */
+    public CC(EdgeWeightedGraph G) {
+        marked = new boolean[G.V()];
+        id = new int[G.V()];
+        size = new int[G.V()];
+        for (int v = 0; v < G.V(); v++) {
+            if (!marked[v]) {
+                dfs(G, v);
+                count++;
+            }
+        }
+    }
+
+    // depth-first search for a Graph
+    private void dfs(Graph G, int v) {
+        marked[v] = true;
+        id[v] = count;
+        size[count]++;
+        for (int w : G.adj(v)) {
+            if (!marked[w]) {
+                dfs(G, w);
+            }
+        }
+    }
+
+    // depth-first search for an EdgeWeightedGraph
+    private void dfs(EdgeWeightedGraph G, int v) {
+        marked[v] = true;
+        id[v] = count;
+        size[count]++;
+        for (Edge e : G.adj(v)) {
+            int w = e.other(v);
+            if (!marked[w]) {
+                dfs(G, w);
+            }
+        }
+    }
+
+
+    /**
+     * Returns the component id of the connected component containing vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the component id of the connected component containing vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int id(int v) {
+        validateVertex(v);
+        return id[v];
+    }
+
+    /**
+     * Returns the number of vertices in the connected component containing vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the number of vertices in the connected component containing vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int size(int v) {
+        validateVertex(v);
+        return size[id[v]];
+    }
+
+    /**
+     * Returns the number of connected components in the graph {@code G}.
+     *
+     * @return the number of connected components in the graph {@code G}
+     */
+    public int count() {
+        return count;
+    }
+
+    /**
+     * Returns true if vertices {@code v} and {@code w} are in the same
+     * connected component.
+     *
+     * @param  v one vertex
+     * @param  w the other vertex
+     * @return {@code true} if vertices {@code v} and {@code w} are in the same
+     *         connected component; {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @throws IllegalArgumentException unless {@code 0 <= w < V}
+     */
+    public boolean connected(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        return id(v) == id(w);
+    }
+
+    /**
+     * Returns true if vertices {@code v} and {@code w} are in the same
+     * connected component.
+     *
+     * @param  v one vertex
+     * @param  w the other vertex
+     * @return {@code true} if vertices {@code v} and {@code w} are in the same
+     *         connected component; {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @throws IllegalArgumentException unless {@code 0 <= w < V}
+     * @deprecated Replaced by {@link #connected(int, int)}.
+     */
+    @Deprecated
+    public boolean areConnected(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        return id(v) == id(w);
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code CC} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        CC cc = new CC(G);
+
+        // number of connected components
+        int m = cc.count();
+        StdOut.println(m + " components");
+
+        // compute list of vertices in each connected component
+        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
+        for (int i = 0; i < m; i++) {
+            components[i] = new Queue<Integer>();
+        }
+        for (int v = 0; v < G.V(); v++) {
+            components[cc.id(v)].enqueue(v);
+        }
+
+        // print results
+        for (int i = 0; i < m; i++) {
+            for (int v : components[i]) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/CPM.java b/src/main/java/edu/princeton/cs/algs4/CPM.java
new file mode 100644
index 0000000..13239c9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/CPM.java
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *  Compilation:  javac CPM.java
+ *  Execution:    java CPM < input.txt
+ *  Dependencies: EdgeWeightedDigraph.java AcyclicDigraphLP.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/44sp/jobsPC.txt
+ *
+ *  Critical path method.
+ *
+ *  % java CPM < jobsPC.txt
+ *   job   start  finish
+ *  --------------------
+ *     0     0.0    41.0
+ *     1    41.0    92.0
+ *     2   123.0   173.0
+ *     3    91.0   127.0
+ *     4    70.0   108.0
+ *     5     0.0    45.0
+ *     6    70.0    91.0
+ *     7    41.0    73.0
+ *     8    91.0   123.0
+ *     9    41.0    70.0
+ *  Finish time:   173.0
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code CPM} class provides a client that solves the
+ *  parallel precedence-constrained job scheduling problem
+ *  via the <em>critical path method</em>. It reduces the problem
+ *  to the longest-paths problem in edge-weighted DAGs.
+ *  It builds an edge-weighted digraph (which must be a DAG)
+ *  from the job-scheduling problem specification,
+ *  finds the longest-paths tree, and computes the longest-paths
+ *  lengths (which are precisely the start times for each job).
+ *  <p>
+ *  This implementation uses {@link AcyclicLP} to find a longest
+ *  path in a DAG.
+ *  The program takes &Theta;(<em>V</em> + <em>E</em>) time in
+ *  the worst case, where <em>V</em> is the number of jobs and
+ *  <em>E</em> is the number of precedence constraints.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class CPM {
+
+    // this class cannot be instantiated
+    private CPM() { }
+
+    /**
+     *  Reads the precedence constraints from standard input
+     *  and prints a feasible schedule to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // number of jobs
+        int n = StdIn.readInt();
+
+        // source and sink
+        int source = 2*n;
+        int sink   = 2*n + 1;
+
+        // build network
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(2*n + 2);
+        for (int i = 0; i < n; i++) {
+            double duration = StdIn.readDouble();
+            G.addEdge(new DirectedEdge(source, i, 0.0));
+            G.addEdge(new DirectedEdge(i+n, sink, 0.0));
+            G.addEdge(new DirectedEdge(i, i+n,    duration));
+
+            // precedence constraints
+            int m = StdIn.readInt();
+            for (int j = 0; j < m; j++) {
+                int precedent = StdIn.readInt();
+                G.addEdge(new DirectedEdge(n+i, precedent, 0.0));
+            }
+        }
+
+        // compute longest path
+        AcyclicLP lp = new AcyclicLP(G, source);
+
+        // print results
+        StdOut.println(" job   start  finish");
+        StdOut.println("--------------------");
+        for (int i = 0; i < n; i++) {
+            StdOut.printf("%4d %7.1f %7.1f\n", i, lp.distTo(i), lp.distTo(i+n));
+        }
+        StdOut.printf("Finish time: %7.1f\n", lp.distTo(sink));
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Cat.java b/src/main/java/edu/princeton/cs/algs4/Cat.java
new file mode 100644
index 0000000..475ad1c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Cat.java
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *  Compilation:  javac Cat.java
+ *  Execution:    java Cat input0.txt input1.txt ... output.txt
+ *  Dependencies: In.java Out.java
+ *  Data files:   https://algs4.cs.princeton.edu/11model/in1.txt
+ *                https://algs4.cs.princeton.edu/11model/in2.txt
+ *
+ *  Reads in text files specified as the first command-line 
+ *  arguments, concatenates them, and writes the result to
+ *  filename specified as the last command-line arguments.
+ *
+ *  % more in1.txt
+ *  This is
+ *
+ *  % more in2.txt 
+ *  a tiny
+ *  test.
+ * 
+ *  % java Cat in1.txt in2.txt out.txt
+ *
+ *  % more out.txt
+ *  This is
+ *  a tiny
+ *  test.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Cat} class provides a client for concatenating the results
+ *  of several text files.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/11model">Section 1.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Cat { 
+
+    // this class should not be instantiated
+    private Cat() { }
+
+    /**
+     * Reads in a sequence of text files specified as the first command-line
+     * arguments, concatenates them, and writes the results to the file
+     * specified as the last command-line argument.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        Out out = new Out(args[args.length - 1]);
+        for (int i = 0; i < args.length - 1; i++) {
+            In in = new In(args[i]);
+            String s = in.readAll();
+            out.println(s);
+            in.close();
+        }
+        out.close();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/ClosestPair.java b/src/main/java/edu/princeton/cs/algs4/ClosestPair.java
new file mode 100644
index 0000000..1e129b8
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ClosestPair.java
@@ -0,0 +1,232 @@
+/******************************************************************************
+ *  Compilation:  javac ClosestPair.java
+ *  Execution:    java ClosestPair < input.txt
+ *  Dependencies: Point2D.java
+ *  Data files:   https://algs4.cs.princeton.edu/99hull/rs1423.txt
+ *                https://algs4.cs.princeton.edu/99hull/kw1260.txt
+ *  
+ *  Given n points in the plane, find the closest pair in n log n time.
+ *
+ *  Note: could speed it up by comparing square of Euclidean distances
+ *  instead of Euclidean distances.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ *  The {@code ClosestPair} data type computes a closest pair of points
+ *  in a set of <em>n</em> points in the plane and provides accessor methods 
+ *  for getting the closest pair of points and the distance between them.
+ *  The distance between two points is their Euclidean distance.
+ *  <p>
+ *  This implementation uses a divide-and-conquer algorithm. 
+ *  It runs in O(<em>n</em> log <em>n</em>) time in the worst case and uses
+ *  O(<em>n</em>) extra space.
+ *  <p>
+ *  See also {@link FarthestPair}.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/99hull">Section 9.9</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class ClosestPair {
+
+    // closest pair of points and their Euclidean distance
+    private Point2D best1, best2;
+    private double bestDistance = Double.POSITIVE_INFINITY;
+
+    /**
+     * Computes the closest pair of points in the specified array of points.
+     *
+     * @param  points the array of points
+     * @throws IllegalArgumentException if {@code points} is {@code null} or if any
+     *         entry in {@code points[]} is {@code null}
+     */
+    public ClosestPair(Point2D[] points) {
+        if (points == null) throw new IllegalArgumentException("constructor argument is null");
+        for (int i = 0; i < points.length; i++) {
+            if (points[i] == null) throw new IllegalArgumentException("array element " + i + " is null");
+        }
+
+        int n = points.length;
+        if (n <= 1) return;
+
+        // sort by x-coordinate (breaking ties by y-coordinate via stability)
+        Point2D[] pointsByX = new Point2D[n];
+        for (int i = 0; i < n; i++)
+            pointsByX[i] = points[i];
+        Arrays.sort(pointsByX, Point2D.Y_ORDER);
+        Arrays.sort(pointsByX, Point2D.X_ORDER);
+
+        // check for coincident points
+        for (int i = 0; i < n-1; i++) {
+            if (pointsByX[i].equals(pointsByX[i+1])) {
+                bestDistance = 0.0;
+                best1 = pointsByX[i];
+                best2 = pointsByX[i+1];
+                return;
+            }
+        }
+
+        // sort by y-coordinate (but not yet sorted) 
+        Point2D[] pointsByY = new Point2D[n];
+        for (int i = 0; i < n; i++)
+            pointsByY[i] = pointsByX[i];
+
+        // auxiliary array
+        Point2D[] aux = new Point2D[n];
+
+        closest(pointsByX, pointsByY, aux, 0, n-1);
+    }
+
+    // find closest pair of points in pointsByX[lo..hi]
+    // precondition:  pointsByX[lo..hi] and pointsByY[lo..hi] are the same sequence of points
+    // precondition:  pointsByX[lo..hi] sorted by x-coordinate
+    // postcondition: pointsByY[lo..hi] sorted by y-coordinate
+    private double closest(Point2D[] pointsByX, Point2D[] pointsByY, Point2D[] aux, int lo, int hi) {
+        if (hi <= lo) return Double.POSITIVE_INFINITY;
+
+        int mid = lo + (hi - lo) / 2;
+        Point2D median = pointsByX[mid];
+
+        // compute closest pair with both endpoints in left subarray or both in right subarray
+        double delta1 = closest(pointsByX, pointsByY, aux, lo, mid);
+        double delta2 = closest(pointsByX, pointsByY, aux, mid+1, hi);
+        double delta = Math.min(delta1, delta2);
+
+        // merge back so that pointsByY[lo..hi] are sorted by y-coordinate
+        merge(pointsByY, aux, lo, mid, hi);
+
+        // aux[0..m-1] = sequence of points closer than delta, sorted by y-coordinate
+        int m = 0;
+        for (int i = lo; i <= hi; i++) {
+            if (Math.abs(pointsByY[i].x() - median.x()) < delta)
+                aux[m++] = pointsByY[i];
+        }
+
+        // compare each point to its neighbors with y-coordinate closer than delta
+        for (int i = 0; i < m; i++) {
+            // a geometric packing argument shows that this loop iterates at most 7 times
+            for (int j = i+1; (j < m) && (aux[j].y() - aux[i].y() < delta); j++) {
+                double distance = aux[i].distanceTo(aux[j]);
+                if (distance < delta) {
+                    delta = distance;
+                    if (distance < bestDistance) {
+                        bestDistance = delta;
+                        best1 = aux[i];
+                        best2 = aux[j];
+                        // StdOut.println("better distance = " + delta + " from " + best1 + " to " + best2);
+                    }
+                }
+            }
+        }
+        return delta;
+    }
+
+    /**
+     * Returns one of the points in the closest pair of points.
+     *
+     * @return one of the two points in the closest pair of points;
+     *         {@code null} if no such point (because there are fewer than 2 points)
+     */
+    public Point2D either() {
+        return best1;
+    }
+
+    /**
+     * Returns the other point in the closest pair of points.
+     *
+     * @return the other point in the closest pair of points
+     *         {@code null} if no such point (because there are fewer than 2 points)
+     */
+    public Point2D other() {
+        return best2;
+    }
+
+    /**
+     * Returns the Eucliden distance between the closest pair of points.
+     *
+     * @return the Euclidean distance between the closest pair of points
+     *         {@code Double.POSITIVE_INFINITY} if no such pair of points
+     *         exist (because there are fewer than 2 points)
+     */
+    public double distance() {
+        return bestDistance;
+    }
+
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+
+    // stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi]
+    // precondition: a[lo .. mid] and a[mid+1 .. hi] are sorted subarrays
+    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {
+        // copy to aux[]
+        for (int k = lo; k <= hi; k++) {
+            aux[k] = a[k];
+        }
+    
+        // merge back to a[] 
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)              a[k] = aux[j++];
+            else if (j > hi)               a[k] = aux[i++];
+            else if (less(aux[j], aux[i])) a[k] = aux[j++];
+            else                           a[k] = aux[i++];
+        }
+    }
+
+
+
+   /**
+     * Unit tests the {@code ClosestPair} data type.
+     * Reads in an integer {@code n} and {@code n} points (specified by
+     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
+     * computes a closest pair of points; and prints the pair to standard
+     * output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        Point2D[] points = new Point2D[n];
+        for (int i = 0; i < n; i++) {
+            double x = StdIn.readDouble();
+            double y = StdIn.readDouble();
+            points[i] = new Point2D(x, y);
+        }
+        ClosestPair closest = new ClosestPair(points);
+        StdOut.println(closest.distance() + " from " + closest.either() + " to " + closest.other());
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/CollisionSystem.java b/src/main/java/edu/princeton/cs/algs4/CollisionSystem.java
new file mode 100644
index 0000000..d6a9479
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/CollisionSystem.java
@@ -0,0 +1,243 @@
+/******************************************************************************
+ *  Compilation:  javac CollisionSystem.java
+ *  Execution:    java CollisionSystem n               (n random particles)
+ *                java CollisionSystem < input.txt     (from a file) 
+ *  Dependencies: StdDraw.java Particle.java MinPQ.java
+ *  Data files:   https://algs4.cs.princeton.edu/61event/diffusion.txt
+ *                https://algs4.cs.princeton.edu/61event/diffusion2.txt
+ *                https://algs4.cs.princeton.edu/61event/diffusion3.txt
+ *                https://algs4.cs.princeton.edu/61event/brownian.txt
+ *                https://algs4.cs.princeton.edu/61event/brownian2.txt
+ *                https://algs4.cs.princeton.edu/61event/billiards5.txt
+ *                https://algs4.cs.princeton.edu/61event/pendulum.txt
+ *  
+ *  Creates n random particles and simulates their motion according
+ *  to the laws of elastic collisions.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.Color;
+
+/**
+ *  The {@code CollisionSystem} class represents a collection of particles
+ *  moving in the unit box, according to the laws of elastic collision.
+ *  This event-based simulation relies on a priority queue.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/61event">Section 6.1</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class CollisionSystem {
+    private static final double HZ = 0.5;    // number of redraw events per clock tick
+
+    private MinPQ<Event> pq;          // the priority queue
+    private double t  = 0.0;          // simulation clock time
+    private Particle[] particles;     // the array of particles
+
+    /**
+     * Initializes a system with the specified collection of particles.
+     * The individual particles will be mutated during the simulation.
+     *
+     * @param  particles the array of particles
+     */
+    public CollisionSystem(Particle[] particles) {
+        this.particles = particles.clone();   // defensive copy
+    }
+
+    // updates priority queue with all new events for particle a
+    private void predict(Particle a, double limit) {
+        if (a == null) return;
+
+        // particle-particle collisions
+        for (int i = 0; i < particles.length; i++) {
+            double dt = a.timeToHit(particles[i]);
+            if (t + dt <= limit)
+                pq.insert(new Event(t + dt, a, particles[i]));
+        }
+
+        // particle-wall collisions
+        double dtX = a.timeToHitVerticalWall();
+        double dtY = a.timeToHitHorizontalWall();
+        if (t + dtX <= limit) pq.insert(new Event(t + dtX, a, null));
+        if (t + dtY <= limit) pq.insert(new Event(t + dtY, null, a));
+    }
+
+    // redraw all particles
+    private void redraw(double limit) {
+        StdDraw.clear();
+        for (int i = 0; i < particles.length; i++) {
+            particles[i].draw();
+        }
+        StdDraw.show();
+        StdDraw.pause(20);
+        if (t < limit) {
+            pq.insert(new Event(t + 1.0 / HZ, null, null));
+        }
+    }
+
+      
+    /**
+     * Simulates the system of particles for the specified amount of time.
+     *
+     * @param  limit the amount of time
+     */
+    public void simulate(double limit) {
+        
+        // initialize PQ with collision events and redraw event
+        pq = new MinPQ<Event>();
+        for (int i = 0; i < particles.length; i++) {
+            predict(particles[i], limit);
+        }
+        pq.insert(new Event(0, null, null));        // redraw event
+
+
+        // the main event-driven simulation loop
+        while (!pq.isEmpty()) { 
+
+            // get impending event, discard if invalidated
+            Event e = pq.delMin();
+            if (!e.isValid()) continue;
+            Particle a = e.a;
+            Particle b = e.b;
+
+            // physical collision, so update positions, and then simulation clock
+            for (int i = 0; i < particles.length; i++)
+                particles[i].move(e.time - t);
+            t = e.time;
+
+            // process event
+            if      (a != null && b != null) a.bounceOff(b);              // particle-particle collision
+            else if (a != null && b == null) a.bounceOffVerticalWall();   // particle-wall collision
+            else if (a == null && b != null) b.bounceOffHorizontalWall(); // particle-wall collision
+            else if (a == null && b == null) redraw(limit);               // redraw event
+
+            // update the priority queue with new collisions involving a or b
+            predict(a, limit);
+            predict(b, limit);
+        }
+    }
+
+
+   /***************************************************************************
+    *  An event during a particle collision simulation. Each event contains
+    *  the time at which it will occur (assuming no supervening actions)
+    *  and the particles a and b involved.
+    *
+    *    -  a and b both null:      redraw event
+    *    -  a null, b not null:     collision with vertical wall
+    *    -  a not null, b null:     collision with horizontal wall
+    *    -  a and b both not null:  binary collision between a and b
+    *
+    ***************************************************************************/
+    private static class Event implements Comparable<Event> {
+        private final double time;         // time that event is scheduled to occur
+        private final Particle a, b;       // particles involved in event, possibly null
+        private final int countA, countB;  // collision counts at event creation
+                
+        
+        // create a new event to occur at time t involving a and b
+        public Event(double t, Particle a, Particle b) {
+            this.time = t;
+            this.a    = a;
+            this.b    = b;
+            if (a != null) countA = a.count();
+            else           countA = -1;
+            if (b != null) countB = b.count();
+            else           countB = -1;
+        }
+
+        // compare times when two events will occur
+        public int compareTo(Event that) {
+            return Double.compare(this.time, that.time);
+        }
+        
+        // has any collision occurred between when event was created and now?
+        public boolean isValid() {
+            if (a != null && a.count() != countA) return false;
+            if (b != null && b.count() != countB) return false;
+            return true;
+        }
+   
+    }
+
+
+    /**
+     * Unit tests the {@code CollisionSystem} data type.
+     * Reads in the particle collision system from a standard input
+     * (or generates {@code N} random particles if a command-line integer
+     * is specified); simulates the system.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        StdDraw.setCanvasSize(600, 600);
+
+        // enable double buffering
+        StdDraw.enableDoubleBuffering();
+
+        // the array of particles
+        Particle[] particles;
+
+        // create n random particles
+        if (args.length == 1) {
+            int n = Integer.parseInt(args[0]);
+            particles = new Particle[n];
+            for (int i = 0; i < n; i++)
+                particles[i] = new Particle();
+        }
+
+        // or read from standard input
+        else {
+            int n = StdIn.readInt();
+            particles = new Particle[n];
+            for (int i = 0; i < n; i++) {
+                double rx     = StdIn.readDouble();
+                double ry     = StdIn.readDouble();
+                double vx     = StdIn.readDouble();
+                double vy     = StdIn.readDouble();
+                double radius = StdIn.readDouble();
+                double mass   = StdIn.readDouble();
+                int r         = StdIn.readInt();
+                int g         = StdIn.readInt();
+                int b         = StdIn.readInt();
+                Color color   = new Color(r, g, b);
+                particles[i] = new Particle(rx, ry, vx, vy, radius, mass, color);
+            }
+        }
+
+        // create collision system and simulate
+        CollisionSystem system = new CollisionSystem(particles);
+        system.simulate(10000);
+    }
+      
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Complex.java b/src/main/java/edu/princeton/cs/algs4/Complex.java
new file mode 100644
index 0000000..6f5dade
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Complex.java
@@ -0,0 +1,290 @@
+/******************************************************************************
+ *  Compilation:  javac Complex.java
+ *  Execution:    java Complex
+ *  Dependencies: StdOut.java
+ *
+ *  Data type for complex numbers.
+ *
+ *  The data type is "immutable" so once you create and initialize
+ *  a Complex object, you cannot change it. The "final" keyword
+ *  when declaring re and im enforces this rule, making it a
+ *  compile-time error to change the .re or .im fields after
+ *  they've been initialized.
+ *
+ *  % java Complex
+ *  a            = 5.0 + 6.0i
+ *  b            = -3.0 + 4.0i
+ *  Re(a)        = 5.0
+ *  Im(a)        = 6.0
+ *  b + a        = 2.0 + 10.0i
+ *  a - b        = 8.0 + 2.0i
+ *  a * b        = -39.0 + 2.0i
+ *  b * a        = -39.0 + 2.0i
+ *  a / b        = 0.36 - 1.52i
+ *  (a / b) * b  = 5.0 + 6.0i
+ *  conj(a)      = 5.0 - 6.0i
+ *  |a|          = 7.810249675906654
+ *  tan(a)       = -6.685231390246571E-6 + 1.0000103108981198i
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Complex} class represents a complex number.
+ *  Complex numbers are immutable: their values cannot be changed after they
+ *  are created.
+ *  It includes methods for addition, subtraction, multiplication, division,
+ *  conjugation, and other common functions on complex numbers.
+ *  <p>
+ *  This computes correct results if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.  
+ *  In practice, there will be floating-point rounding error.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/99scientific">Section 9.9</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Complex {
+    private final double re;   // the real part
+    private final double im;   // the imaginary part
+
+    /**
+     * Initializes a complex number from the specified real and imaginary parts.
+     *
+     * @param real the real part
+     * @param imag the imaginary part
+     */
+    public Complex(double real, double imag) {
+        re = real;
+        im = imag;
+    }
+
+    /**
+     * Returns a string representation of this complex number.
+     *
+     * @return a string representation of this complex number,
+     *         of the form 34 - 56i.
+     */
+    public String toString() {
+        if (im == 0) return re + "";
+        if (re == 0) return im + "i";
+        if (im <  0) return re + " - " + (-im) + "i";
+        return re + " + " + im + "i";
+    }
+
+    /**
+     * Returns the absolute value of this complex number.
+     * This quantity is also known as the <em>modulus</em> or <em>magnitude</em>.
+     *
+     * @return the absolute value of this complex number
+     */
+    public double abs() {
+        return Math.hypot(re, im);
+    }
+
+    /**
+     * Returns the phase of this complex number.
+     * This quantity is also known as the <em>angle</em> or <em>argument</em>.
+     *
+     * @return the phase of this complex number, a real number between -pi and pi
+     */
+    public double phase() {
+        return Math.atan2(im, re);
+    }
+
+    /**
+     * Returns the sum of this complex number and the specified complex number.
+     *
+     * @param  that the other complex number
+     * @return the complex number whose value is {@code (this + that)}
+     */
+    public Complex plus(Complex that) {
+        double real = this.re + that.re;
+        double imag = this.im + that.im;
+        return new Complex(real, imag);
+    }
+
+    /**
+     * Returns the result of subtracting the specified complex number from
+     * this complex number.
+     *
+     * @param  that the other complex number
+     * @return the complex number whose value is {@code (this - that)}
+     */
+    public Complex minus(Complex that) {
+        double real = this.re - that.re;
+        double imag = this.im - that.im;
+        return new Complex(real, imag);
+    }
+
+    /**
+     * Returns the product of this complex number and the specified complex number.
+     *
+     * @param  that the other complex number
+     * @return the complex number whose value is {@code (this * that)}
+     */
+    public Complex times(Complex that) {
+        double real = this.re * that.re - this.im * that.im;
+        double imag = this.re * that.im + this.im * that.re;
+        return new Complex(real, imag);
+    }
+
+    /**
+     * Returns the product of this complex number and the specified scalar.
+     *
+     * @param  alpha the scalar
+     * @return the complex number whose value is {@code (alpha * this)}
+     */
+    public Complex scale(double alpha) {
+        return new Complex(alpha * re, alpha * im);
+    }
+
+    /**
+     * Returns the product of this complex number and the specified scalar.
+     *
+     * @param  alpha the scalar
+     * @return the complex number whose value is {@code (alpha * this)}
+     * @deprecated Replaced by {@link #scale(double)}.
+     */
+    @Deprecated
+    public Complex times(double alpha) {
+        return new Complex(alpha * re, alpha * im);
+    }
+
+    /**
+     * Returns the complex conjugate of this complex number.
+     *
+     * @return the complex conjugate of this complex number
+     */
+    public Complex conjugate() {
+        return new Complex(re, -im);
+    }
+
+    /**
+     * Returns the reciprocal of this complex number.
+     *
+     * @return the complex number whose value is {@code (1 / this)}
+     */
+    public Complex reciprocal() {
+        double scale = re*re + im*im;
+        return new Complex(re / scale, -im / scale);
+    }
+
+    /**
+     * Returns the real part of this complex number.
+     *
+     * @return the real part of this complex number
+     */
+    public double re() {
+        return re;
+    }
+
+    /**
+     * Returns the imaginary part of this complex number.
+     *
+     * @return the imaginary part of this complex number
+     */
+    public double im() {
+        return im;
+    }
+
+    /**
+     * Returns the result of dividing the specified complex number into
+     * this complex number.
+     *
+     * @param  that the other complex number
+     * @return the complex number whose value is {@code (this / that)}
+     */
+    public Complex divides(Complex that) {
+        return this.times(that.reciprocal());
+    }
+
+    /**
+     * Returns the complex exponential of this complex number.
+     *
+     * @return the complex exponential of this complex number
+     */
+    public Complex exp() {
+        return new Complex(Math.exp(re) * Math.cos(im), Math.exp(re) * Math.sin(im));
+    }
+
+    /**
+     * Returns the complex sine of this complex number.
+     *
+     * @return the complex sine of this complex number
+     */
+    public Complex sin() {
+        return new Complex(Math.sin(re) * Math.cosh(im), Math.cos(re) * Math.sinh(im));
+    }
+
+    /**
+     * Returns the complex cosine of this complex number.
+     *
+     * @return the complex cosine of this complex number
+     */
+    public Complex cos() {
+        return new Complex(Math.cos(re) * Math.cosh(im), -Math.sin(re) * Math.sinh(im));
+    }
+
+    /**
+     * Returns the complex tangent of this complex number.
+     *
+     * @return the complex tangent of this complex number
+     */
+    public Complex tan() {
+        return sin().divides(cos());
+    }
+    
+
+    /**
+     * Unit tests the {@code Complex} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Complex a = new Complex(5.0, 6.0);
+        Complex b = new Complex(-3.0, 4.0);
+
+        StdOut.println("a            = " + a);
+        StdOut.println("b            = " + b);
+        StdOut.println("Re(a)        = " + a.re());
+        StdOut.println("Im(a)        = " + a.im());
+        StdOut.println("b + a        = " + b.plus(a));
+        StdOut.println("a - b        = " + a.minus(b));
+        StdOut.println("a * b        = " + a.times(b));
+        StdOut.println("b * a        = " + b.times(a));
+        StdOut.println("a / b        = " + a.divides(b));
+        StdOut.println("(a / b) * b  = " + a.divides(b).times(b));
+        StdOut.println("conj(a)      = " + a.conjugate());
+        StdOut.println("|a|          = " + a.abs());
+        StdOut.println("tan(a)       = " + a.tan());
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Count.java b/src/main/java/edu/princeton/cs/algs4/Count.java
new file mode 100644
index 0000000..7fbde70
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Count.java
@@ -0,0 +1,99 @@
+/******************************************************************************
+ *  Compilation:  javac Count.java
+ *  Execution:    java Count alpha < input.txt
+ *  Dependencies: Alphabet.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/50strings/abra.txt
+ *                https://algs4.cs.princeton.edu/50strings/pi.txt
+ *
+ *  Create an alphabet specified on the command line, read in a 
+ *  sequence of characters over that alphabet (ignoring characters
+ *  not in the alphabet), computes the frequency of occurrence of
+ *  each character, and print out the results.
+ *
+ *  %  java Count ABCDR < abra.txt 
+ *  A 5
+ *  B 2
+ *  C 1
+ *  D 1
+ *  R 2
+ *
+ *  % java Count 0123456789 < pi.txt
+ *  0 99959
+ *  1 99757
+ *  2 100026
+ *  3 100230
+ *  4 100230
+ *  5 100359
+ *  6 99548
+ *  7 99800
+ *  8 99985
+ *  9 100106
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code Count} class provides an {@link Alphabet} client for reading
+ *  in a piece of text and computing the frequency of occurrence of each
+ *  character over a given alphabet.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compress">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Count {
+
+    // Do not instantiate.
+    private Count() { }
+
+    /**
+     * Reads in text from standard input; calculates the frequency of
+     * occurrence of each character over the alphabet specified as a
+     * commmand-line argument; and prints the frequencies to standard
+     * output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Alphabet alphabet = new Alphabet(args[0]);
+        final int R = alphabet.radix();
+        int[] count = new int[R];
+        while (StdIn.hasNextChar()) {
+            char c = StdIn.readChar();
+            if (alphabet.contains(c))
+                count[alphabet.toIndex(c)]++;
+        }
+        for (int c = 0; c < R; c++)
+            StdOut.println(alphabet.toChar(c) + " " + count[c]);
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Counter.java b/src/main/java/edu/princeton/cs/algs4/Counter.java
new file mode 100644
index 0000000..6490d6e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Counter.java
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *  Compilation:  javac Counter.java
+ *  Execution:    java Counter n trials
+ *  Dependencies: StdRandom.java StdOut.java
+ *
+ *  A mutable data type for an integer counter.
+ *
+ *  The test clients create n counters and performs trials increment
+ *  operations on random counters.
+ *
+ * java Counter 6 600000
+ *  100140 counter0
+ *  100273 counter1
+ *  99848 counter2
+ *  100129 counter3
+ *  99973 counter4
+ *  99637 counter5
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Counter} class is a mutable data type to encapsulate a counter.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Counter implements Comparable<Counter> {
+
+    private final String name;     // counter name
+    private int count = 0;         // current value
+
+    /**
+     * Initializes a new counter starting at 0, with the given id.
+     *
+     * @param id the name of the counter
+     */
+    public Counter(String id) {
+        name = id;
+    } 
+
+    /**
+     * Increments the counter by 1.
+     */
+    public void increment() {
+        count++;
+    } 
+
+    /**
+     * Returns the current value of this counter.
+     *
+     * @return the current value of this counter
+     */
+    public int tally() {
+        return count;
+    } 
+
+    /**
+     * Returns a string representation of this counter.
+     *
+     * @return a string representation of this counter
+     */
+    public String toString() {
+        return count + " " + name;
+    } 
+
+    /**
+     * Compares this counter to the specified counter.
+     *
+     * @param  that the other counter
+     * @return {@code 0} if the value of this counter equals
+     *         the value of that counter; a negative integer if
+     *         the value of this counter is less than the value of
+     *         that counter; and a positive integer if the value
+     *         of this counter is greater than the value of that
+     *         counter
+     */
+    @Override
+    public int compareTo(Counter that) {
+        if      (this.count < that.count) return -1;
+        else if (this.count > that.count) return +1;
+        else                              return  0;
+    }
+
+
+    /**
+     * Reads two command-line integers n and trials; creates n counters;
+     * increments trials counters at random; and prints results.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        int n = Integer.parseInt(args[0]);
+        int trials = Integer.parseInt(args[1]);
+
+        // create n counters
+        Counter[] hits = new Counter[n];
+        for (int i = 0; i < n; i++) {
+            hits[i] = new Counter("counter" + i);
+        }
+
+        // increment trials counters at random
+        for (int t = 0; t < trials; t++) {
+            hits[StdRandom.uniform(n)].increment();
+        }
+
+        // print results
+        for (int i = 0; i < n; i++) {
+            StdOut.println(hits[i]);
+        }
+    } 
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Cycle.java b/src/main/java/edu/princeton/cs/algs4/Cycle.java
new file mode 100644
index 0000000..d987809
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Cycle.java
@@ -0,0 +1,206 @@
+/******************************************************************************
+ *  Compilation:  javac Cycle.java
+ *  Execution:    java  Cycle filename.txt
+ *  Dependencies: Graph.java Stack.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *                https://algs4.cs.princeton.edu/41graph/largeG.txt  
+ *
+ *  Identifies a cycle.
+ *  Runs in O(E + V) time.
+ *
+ *  % java Cycle tinyG.txt
+ *  3 4 5 3 
+ * 
+ *  % java Cycle mediumG.txt 
+ *  15 0 225 15 
+ * 
+ *  % java Cycle largeG.txt 
+ *  996673 762 840164 4619 785187 194717 996673 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Cycle} class represents a data type for 
+ *  determining whether an undirected graph has a simple cycle.
+ *  The <em>hasCycle</em> operation determines whether the graph has
+ *  a cycle and, if so, the <em>cycle</em> operation returns one.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  (The depth-first search part takes only <em>O</em>(<em>V</em>) time;
+ *  however, checking for self-loops and parallel edges takes
+ *  &Theta;(<em>V</em> + <em>E</em>) time in the worst case.)
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Cycle {
+    private boolean[] marked;
+    private int[] edgeTo;
+    private Stack<Integer> cycle;
+
+    /**
+     * Determines whether the undirected graph {@code G} has a cycle and,
+     * if so, finds such a cycle.
+     *
+     * @param G the undirected graph
+     */
+    public Cycle(Graph G) {
+        // need special case to identify parallel edge as a cycle
+        if (hasParallelEdges(G)) return;
+
+        // don't need special case to identify self-loop as a cycle
+        // if (hasSelfLoop(G)) return;
+
+        marked = new boolean[G.V()];
+        edgeTo = new int[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            if (!marked[v])
+                dfs(G, -1, v);
+    }
+
+
+    // does this graph have a self loop?
+    // side effect: initialize cycle to be self loop
+    private boolean hasSelfLoop(Graph G) {
+        for (int v = 0; v < G.V(); v++) {
+            for (int w : G.adj(v)) {
+                if (v == w) {
+                    cycle = new Stack<Integer>();
+                    cycle.push(v);
+                    cycle.push(v);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    // does this graph have two parallel edges?
+    // side effect: initialize cycle to be two parallel edges
+    private boolean hasParallelEdges(Graph G) {
+        marked = new boolean[G.V()];
+
+        for (int v = 0; v < G.V(); v++) {
+
+            // check for parallel edges incident to v
+            for (int w : G.adj(v)) {
+                if (marked[w]) {
+                    cycle = new Stack<Integer>();
+                    cycle.push(v);
+                    cycle.push(w);
+                    cycle.push(v);
+                    return true;
+                }
+                marked[w] = true;
+            }
+
+            // reset so marked[v] = false for all v
+            for (int w : G.adj(v)) {
+                marked[w] = false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if the graph {@code G} has a cycle.
+     *
+     * @return {@code true} if the graph has a cycle; {@code false} otherwise
+     */
+    public boolean hasCycle() {
+        return cycle != null;
+    }
+
+     /**
+     * Returns a cycle in the graph {@code G}.
+     * @return a cycle if the graph {@code G} has a cycle,
+     *         and {@code null} otherwise
+     */
+    public Iterable<Integer> cycle() {
+        return cycle;
+    }
+
+    private void dfs(Graph G, int u, int v) {
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+
+            // short circuit if cycle already found
+            if (cycle != null) return;
+
+            if (!marked[w]) {
+                edgeTo[w] = v;
+                dfs(G, v, w);
+            }
+
+            // check for cycle (but disregard reverse of edge leading to v)
+            else if (w != u) {
+                cycle = new Stack<Integer>();
+                for (int x = v; x != w; x = edgeTo[x]) {
+                    cycle.push(x);
+                }
+                cycle.push(w);
+                cycle.push(v);
+            }
+        }
+    }
+
+    /**
+     * Unit tests the {@code Cycle} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        Cycle finder = new Cycle(G);
+        if (finder.hasCycle()) {
+            for (int v : finder.cycle()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+        else {
+            StdOut.println("Graph is acyclic");
+        }
+    }
+
+
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Date.java b/src/main/java/edu/princeton/cs/algs4/Date.java
new file mode 100644
index 0000000..eb8b326
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Date.java
@@ -0,0 +1,235 @@
+/******************************************************************************
+ *  Compilation:  javac Date.java
+ *  Execution:    java Date
+ *  Dependencies: StdOut.java
+ *
+ *  An immutable data type for dates.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Date} class is an immutable data type to encapsulate a
+ *  date (day, month, and year).
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Date implements Comparable<Date> {
+    private static final int[] DAYS = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+
+    private final int month;   // month (between 1 and 12)
+    private final int day;     // day   (between 1 and DAYS[month]
+    private final int year;    // year
+
+   /**
+     * Initializes a new date from the month, day, and year.
+     * @param month the month (between 1 and 12)
+     * @param day the day (between 1 and 28-31, depending on the month)
+     * @param year the year
+     * @throws IllegalArgumentException if this date is invalid
+     */
+    public Date(int month, int day, int year) {
+        if (!isValid(month, day, year)) throw new IllegalArgumentException("Invalid date");
+        this.month = month;
+        this.day   = day;
+        this.year  = year;
+    }
+
+    /**
+     * Initializes new date specified as a string in form MM/DD/YYYY.
+     * @param date the string representation of this date
+     * @throws IllegalArgumentException if this date is invalid
+     */
+    public Date(String date) {
+        String[] fields = date.split("/");
+        if (fields.length != 3) {
+            throw new IllegalArgumentException("Invalid date");
+        }
+        month = Integer.parseInt(fields[0]);
+        day   = Integer.parseInt(fields[1]);
+        year  = Integer.parseInt(fields[2]);
+        if (!isValid(month, day, year)) throw new IllegalArgumentException("Invalid date");
+    }
+
+    /**
+     * Return the month.
+     * @return the month (an integer between 1 and 12)
+     */
+    public int month() {
+        return month;
+    }
+
+    /**
+     * Returns the day.
+     * @return the day (an integer between 1 and 31)
+     */
+    public int day() {
+        return day;
+    }
+
+    /**
+     * Returns the year.
+     * @return the year
+     */
+    public int year() {
+        return year;
+    }
+
+
+    // is the given date valid?
+    private static boolean isValid(int m, int d, int y) {
+        if (m < 1 || m > 12)      return false;
+        if (d < 1 || d > DAYS[m]) return false;
+        if (m == 2 && d == 29 && !isLeapYear(y)) return false;
+        return true;
+    }
+
+    // is y a leap year?
+    private static boolean isLeapYear(int y) {
+        if (y % 400 == 0) return true;
+        if (y % 100 == 0) return false;
+        return y % 4 == 0;
+    }
+
+    /**
+     * Returns the next date in the calendar.
+     *
+     * @return a date that represents the next day after this day
+     */
+    public Date next() {
+        if (isValid(month, day + 1, year))    return new Date(month, day + 1, year);
+        else if (isValid(month + 1, 1, year)) return new Date(month + 1, 1, year);
+        else                                  return new Date(1, 1, year + 1);
+    }
+
+    /**
+     * Compares two dates chronologically.
+     *
+     * @param  that the other date
+     * @return {@code true} if this date is after that date; {@code false} otherwise
+     */
+    public boolean isAfter(Date that) {
+        return compareTo(that) > 0;
+    }
+
+    /**
+     * Compares two dates chronologically.
+     *
+     * @param  that the other date
+     * @return {@code true} if this date is before that date; {@code false} otherwise
+     */
+    public boolean isBefore(Date that) {
+        return compareTo(that) < 0;
+    }
+
+    /**
+     * Compares two dates chronologically.
+     *
+     * @return the value {@code 0} if the argument date is equal to this date;
+     *         a negative integer if this date is chronologically less than
+     *         the argument date; and a positive ineger if this date is chronologically
+     *         after the argument date
+     */
+    @Override
+    public int compareTo(Date that) {
+        if (this.year  < that.year)  return -1;
+        if (this.year  > that.year)  return +1;
+        if (this.month < that.month) return -1;
+        if (this.month > that.month) return +1;
+        if (this.day   < that.day)   return -1;
+        if (this.day   > that.day)   return +1;
+        return 0;
+    }
+
+    /**
+     * Returns a string representation of this date.
+     *
+     * @return the string representation in the format MM/DD/YYYY
+     */
+    @Override
+    public String toString() {
+        return month + "/" + day + "/" + year;
+    }
+
+    /**
+     * Compares this date to the specified date.
+     *
+     * @param  other the other date
+     * @return {@code true} if this date equals {@code other}; {@code false} otherwise
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Date that = (Date) other;
+        return (this.month == that.month) && (this.day == that.day) && (this.year == that.year);
+    }
+
+    /**
+     * Returns an integer hash code for this date.
+     *
+     * @return an integer hash code for this date
+     */
+    @Override
+    public int hashCode() {
+        return day + 31*month + 31*12*year;
+    }
+
+    /**
+     * Unit tests the {@code Date} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Date today = new Date(2, 25, 2004);
+        StdOut.println(today);
+        for (int i = 0; i < 10; i++) {
+            today = today.next();
+            StdOut.println(today);
+        }
+
+        StdOut.println(today.isAfter(today.next()));
+        StdOut.println(today.isAfter(today));
+        StdOut.println(today.next().isAfter(today));
+
+
+        Date birthday = new Date(10, 16, 1971);
+        StdOut.println(birthday);
+        for (int i = 0; i < 10; i++) {
+            birthday = birthday.next();
+            StdOut.println(birthday);
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DeDup.java b/src/main/java/edu/princeton/cs/algs4/DeDup.java
new file mode 100644
index 0000000..5e7d5fc
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DeDup.java
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *  Compilation:  javac DeDup.java
+ *  Execution:    java DeDup < input.txt
+ *  Dependencies: SET StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/tinyTale.txt
+ *
+ *  Read in a list of words from standard input and print out
+ *  each word, removing any duplicates.
+ *
+ *  % more tinyTale.txt 
+ *  it was the best of times it was the worst of times 
+ *  it was the age of wisdom it was the age of foolishness 
+ *  it was the epoch of belief it was the epoch of incredulity 
+ *  it was the season of light it was the season of darkness 
+ *  it was the spring of hope it was the winter of despair
+ *
+ *  % java DeDup < tinyTale.txt 
+ *  it
+ *  was
+ *  the
+ *  best
+ *  of
+ *  times
+ *  worst
+ *  age
+ *  wisdom
+ *  ...
+ *  winter
+ *  despair
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DeDup} class provides a client for reading in a sequence of
+ *  words from standard input and printing each word, removing any duplicates.
+ *  It is useful as a test client for various symbol table implementations.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DeDup {  
+
+    // Do not instantiate.
+    private DeDup() { }
+
+    public static void main(String[] args) {
+        SET<String> set = new SET<String>();
+
+        // read in strings and add to set
+        while (!StdIn.isEmpty()) {
+            String key = StdIn.readString();
+            if (!set.contains(key)) {
+                set.add(key);
+                StdOut.println(key);
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DegreesOfSeparation.java b/src/main/java/edu/princeton/cs/algs4/DegreesOfSeparation.java
new file mode 100644
index 0000000..a4e7d73
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DegreesOfSeparation.java
@@ -0,0 +1,153 @@
+/******************************************************************************
+ *  Compilation:  javac DegreesOfSeparation.java
+ *  Execution:    java DegreesOfSeparation filename delimiter source
+ *  Dependencies: SymbolGraph.java Graph.java BreadthFirstPaths.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/routes.txt
+ *                https://algs4.cs.princeton.edu/41graph/movies.txt
+ *  
+ *  
+ *  %  java DegreesOfSeparation routes.txt " " "JFK"
+ *  LAS
+ *     JFK
+ *     ORD
+ *     DEN
+ *     LAS
+ *  DFW
+ *     JFK
+ *     ORD
+ *     DFW
+ *  EWR
+ *     Not in database.
+ *
+ *  % java DegreesOfSeparation movies.txt "/" "Bacon, Kevin"
+ *  Kidman, Nicole
+ *     Bacon, Kevin
+ *     Woodsman, The (2004)
+ *     Grier, David Alan
+ *     Bewitched (2005)
+ *     Kidman, Nicole
+ *  Grant, Cary
+ *     Bacon, Kevin
+ *     Planes, Trains & Automobiles (1987)
+ *     Martin, Steve (I)
+ *     Dead Men Don't Wear Plaid (1982)
+ *     Grant, Cary
+ *
+ *  % java DegreesOfSeparation movies.txt "/" "Animal House (1978)"
+ *  Titanic (1997)
+ *     Animal House (1978)
+ *     Allen, Karen (I)
+ *     Raiders of the Lost Ark (1981)
+ *     Taylor, Rocky (I)
+ *     Titanic (1997)
+ *  To Catch a Thief (1955)
+ *     Animal House (1978)
+ *     Vernon, John (I)
+ *     Topaz (1969)
+ *     Hitchcock, Alfred (I)
+ *     To Catch a Thief (1955)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DegreesOfSeparation} class provides a client for finding
+ *  the degree of separation between one distinguished individual and
+ *  every other individual in a social network.
+ *  As an example, if the social network consists of actors in which
+ *  two actors are connected by a link if they appeared in the same movie,
+ *  and Kevin Bacon is the distinguished individual, then the client
+ *  computes the Kevin Bacon number of every actor in the network.
+ *  <p>
+ *  The running time is proportional to the number of individuals and
+ *  connections in the network. If the connections are given implicitly,
+ *  as in the movie network example (where every two actors are connected
+ *  if they appear in the same movie), the efficiency of the algorithm
+ *  is improved by allowing both movie and actor vertices and connecting
+ *  each movie to all of the actors that appear in that movie.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DegreesOfSeparation {
+
+    // this class cannot be instantiated
+    private DegreesOfSeparation() { }
+
+    /**
+     *  Reads in a social network from a file, and then repeatedly reads in
+     *  individuals from standard input and prints out their degrees of
+     *  separation.
+     *  Takes three command-line arguments: the name of a file,
+     *  a delimiter, and the name of the distinguished individual.
+     *  Each line in the file contains the name of a vertex, followed by a
+     *  list of the names of the vertices adjacent to that vertex,
+     *  separated by the delimiter.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String filename  = args[0];
+        String delimiter = args[1];
+        String source    = args[2];
+
+        // StdOut.println("Source: " + source);
+
+        SymbolGraph sg = new SymbolGraph(filename, delimiter);
+        Graph G = sg.graph();
+        if (!sg.contains(source)) {
+            StdOut.println(source + " not in database.");
+            return;
+        }
+
+        int s = sg.indexOf(source);
+        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
+
+        while (!StdIn.isEmpty()) {
+            String sink = StdIn.readLine();
+            if (sg.contains(sink)) {
+                int t = sg.indexOf(sink);
+                if (bfs.hasPathTo(t)) {
+                    for (int v : bfs.pathTo(t)) {
+                        StdOut.println("   " + sg.nameOf(v));
+                    }
+                }
+                else {
+                    StdOut.println("Not connected");
+                }
+            }
+            else {
+                StdOut.println("   Not in database.");
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DepthFirstDirectedPaths.java b/src/main/java/edu/princeton/cs/algs4/DepthFirstDirectedPaths.java
new file mode 100644
index 0000000..d2981e5
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DepthFirstDirectedPaths.java
@@ -0,0 +1,173 @@
+/******************************************************************************
+ *  Compilation:  javac DepthFirstDirectedPaths.java
+ *  Execution:    java DepthFirstDirectedPaths digraph.txt s
+ *  Dependencies: Digraph.java Stack.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Determine reachability in a digraph from a given vertex using
+ *  depth-first search.
+ *  Runs in O(E + V) time.
+ *
+ *  % java DepthFirstDirectedPaths tinyDG.txt 3
+ *  3 to 0:  3-5-4-2-0
+ *  3 to 1:  3-5-4-2-0-1
+ *  3 to 2:  3-5-4-2
+ *  3 to 3:  3
+ *  3 to 4:  3-5-4
+ *  3 to 5:  3-5
+ *  3 to 6:  not connected
+ *  3 to 7:  not connected
+ *  3 to 8:  not connected
+ *  3 to 9:  not connected
+ *  3 to 10:  not connected
+ *  3 to 11:  not connected
+ *  3 to 12:  not connected
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DepthFirstDirectedPaths} class represents a data type for
+ *  finding directed paths from a source vertex <em>s</em> to every
+ *  other vertex in the digraph.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  See {@link DepthFirstDirectedPaths} for a nonrecursive implementation.
+ *  For additional documentation,  
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of  
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DepthFirstDirectedPaths {
+    private boolean[] marked;  // marked[v] = true iff v is reachable from s
+    private int[] edgeTo;      // edgeTo[v] = last edge on path from s to v
+    private final int s;       // source vertex
+
+    /**
+     * Computes a directed path from {@code s} to every other vertex in digraph {@code G}.
+     * @param  G the digraph
+     * @param  s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DepthFirstDirectedPaths(Digraph G, int s) {
+        marked = new boolean[G.V()];
+        edgeTo = new int[G.V()];
+        this.s = s;
+        validateVertex(s);
+        dfs(G, s);
+    }
+
+    private void dfs(Digraph G, int v) { 
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+            if (!marked[w]) {
+                edgeTo[w] = v;
+                dfs(G, w);
+            }
+        }
+    }
+
+    /**
+     * Is there a directed path from the source vertex {@code s} to vertex {@code v}?
+     * @param  v the vertex
+     * @return {@code true} if there is a directed path from the source
+     *         vertex {@code s} to vertex {@code v}, {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    
+    /**
+     * Returns a directed path from the source vertex {@code s} to vertex {@code v}, or
+     * {@code null} if no such path.
+     * @param  v the vertex
+     * @return the sequence of vertices on a directed path from the source vertex
+     *         {@code s} to vertex {@code v}, as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Integer> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<Integer> path = new Stack<Integer>();
+        for (int x = v; x != s; x = edgeTo[x])
+            path.push(x);
+        path.push(s);
+        return path;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code DepthFirstDirectedPaths} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        // StdOut.println(G);
+
+        int s = Integer.parseInt(args[1]);
+        DepthFirstDirectedPaths dfs = new DepthFirstDirectedPaths(G, s);
+
+        for (int v = 0; v < G.V(); v++) {
+            if (dfs.hasPathTo(v)) {
+                StdOut.printf("%d to %d:  ", s, v);
+                for (int x : dfs.pathTo(v)) {
+                    if (x == s) StdOut.print(x);
+                    else        StdOut.print("-" + x);
+                }
+                StdOut.println();
+            }
+
+            else {
+                StdOut.printf("%d to %d:  not connected\n", s, v);
+            }
+
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DepthFirstOrder.java b/src/main/java/edu/princeton/cs/algs4/DepthFirstOrder.java
new file mode 100644
index 0000000..8433921
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DepthFirstOrder.java
@@ -0,0 +1,267 @@
+/******************************************************************************
+ *  Compilation:  javac DepthFirstOrder.java
+ *  Execution:    java DepthFirstOrder digraph.txt
+ *  Dependencies: Digraph.java Queue.java Stack.java StdOut.java
+ *                EdgeWeightedDigraph.java DirectedEdge.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDAG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *
+ *  Compute preorder and postorder for a digraph or edge-weighted digraph.
+ *  Runs in O(E + V) time.
+ *
+ *  % java DepthFirstOrder tinyDAG.txt
+ *     v  pre post
+ *  --------------
+ *     0    0    8
+ *     1    3    2
+ *     2    9   10
+ *     3   10    9
+ *     4    2    0
+ *     5    1    1
+ *     6    4    7
+ *     7   11   11
+ *     8   12   12
+ *     9    5    6
+ *    10    8    5
+ *    11    6    4
+ *    12    7    3
+ *  Preorder:  0 5 4 1 6 9 11 12 10 2 3 7 8 
+ *  Postorder: 4 5 1 12 11 10 9 6 0 3 2 7 8 
+ *  Reverse postorder: 8 7 2 3 0 6 9 10 11 12 1 5 4 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DepthFirstOrder} class represents a data type for 
+ *  determining depth-first search ordering of the vertices in a digraph
+ *  or edge-weighted digraph, including preorder, postorder, and reverse postorder.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  Each constructor takes &Theta;(<em>V</em> + <em>E</em>) time,
+ *  where <em>V</em> is the number of vertices and <em>E</em> is the
+ *  number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DepthFirstOrder {
+    private boolean[] marked;          // marked[v] = has v been marked in dfs?
+    private int[] pre;                 // pre[v]    = preorder  number of v
+    private int[] post;                // post[v]   = postorder number of v
+    private Queue<Integer> preorder;   // vertices in preorder
+    private Queue<Integer> postorder;  // vertices in postorder
+    private int preCounter;            // counter or preorder numbering
+    private int postCounter;           // counter for postorder numbering
+
+    /**
+     * Determines a depth-first order for the digraph {@code G}.
+     * @param G the digraph
+     */
+    public DepthFirstOrder(Digraph G) {
+        pre    = new int[G.V()];
+        post   = new int[G.V()];
+        postorder = new Queue<Integer>();
+        preorder  = new Queue<Integer>();
+        marked    = new boolean[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            if (!marked[v]) dfs(G, v);
+
+        assert check();
+    }
+
+    /**
+     * Determines a depth-first order for the edge-weighted digraph {@code G}.
+     * @param G the edge-weighted digraph
+     */
+    public DepthFirstOrder(EdgeWeightedDigraph G) {
+        pre    = new int[G.V()];
+        post   = new int[G.V()];
+        postorder = new Queue<Integer>();
+        preorder  = new Queue<Integer>();
+        marked    = new boolean[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            if (!marked[v]) dfs(G, v);
+    }
+
+    // run DFS in digraph G from vertex v and compute preorder/postorder
+    private void dfs(Digraph G, int v) {
+        marked[v] = true;
+        pre[v] = preCounter++;
+        preorder.enqueue(v);
+        for (int w : G.adj(v)) {
+            if (!marked[w]) {
+                dfs(G, w);
+            }
+        }
+        postorder.enqueue(v);
+        post[v] = postCounter++;
+    }
+
+    // run DFS in edge-weighted digraph G from vertex v and compute preorder/postorder
+    private void dfs(EdgeWeightedDigraph G, int v) {
+        marked[v] = true;
+        pre[v] = preCounter++;
+        preorder.enqueue(v);
+        for (DirectedEdge e : G.adj(v)) {
+            int w = e.to();
+            if (!marked[w]) {
+                dfs(G, w);
+            }
+        }
+        postorder.enqueue(v);
+        post[v] = postCounter++;
+    }
+
+    /**
+     * Returns the preorder number of vertex {@code v}.
+     * @param  v the vertex
+     * @return the preorder number of vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int pre(int v) {
+        validateVertex(v);
+        return pre[v];
+    }
+
+    /**
+     * Returns the postorder number of vertex {@code v}.
+     * @param  v the vertex
+     * @return the postorder number of vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int post(int v) {
+        validateVertex(v);
+        return post[v];
+    }
+
+    /**
+     * Returns the vertices in postorder.
+     * @return the vertices in postorder, as an iterable of vertices
+     */
+    public Iterable<Integer> post() {
+        return postorder;
+    }
+
+    /**
+     * Returns the vertices in preorder.
+     * @return the vertices in preorder, as an iterable of vertices
+     */
+    public Iterable<Integer> pre() {
+        return preorder;
+    }
+
+    /**
+     * Returns the vertices in reverse postorder.
+     * @return the vertices in reverse postorder, as an iterable of vertices
+     */
+    public Iterable<Integer> reversePost() {
+        Stack<Integer> reverse = new Stack<Integer>();
+        for (int v : postorder)
+            reverse.push(v);
+        return reverse;
+    }
+
+
+    // check that pre() and post() are consistent with pre(v) and post(v)
+    private boolean check() {
+
+        // check that post(v) is consistent with post()
+        int r = 0;
+        for (int v : post()) {
+            if (post(v) != r) {
+                StdOut.println("post(v) and post() inconsistent");
+                return false;
+            }
+            r++;
+        }
+
+        // check that pre(v) is consistent with pre()
+        r = 0;
+        for (int v : pre()) {
+            if (pre(v) != r) {
+                StdOut.println("pre(v) and pre() inconsistent");
+                return false;
+            }
+            r++;
+        }
+
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code DepthFirstOrder} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+
+        DepthFirstOrder dfs = new DepthFirstOrder(G);
+        StdOut.println("   v  pre post");
+        StdOut.println("--------------");
+        for (int v = 0; v < G.V(); v++) {
+            StdOut.printf("%4d %4d %4d\n", v, dfs.pre(v), dfs.post(v));
+        }
+
+        StdOut.print("Preorder:  ");
+        for (int v : dfs.pre()) {
+            StdOut.print(v + " ");
+        }
+        StdOut.println();
+
+        StdOut.print("Postorder: ");
+        for (int v : dfs.post()) {
+            StdOut.print(v + " ");
+        }
+        StdOut.println();
+
+        StdOut.print("Reverse postorder: ");
+        for (int v : dfs.reversePost()) {
+            StdOut.print(v + " ");
+        }
+        StdOut.println();
+
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DepthFirstPaths.java b/src/main/java/edu/princeton/cs/algs4/DepthFirstPaths.java
new file mode 100644
index 0000000..43debd2
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DepthFirstPaths.java
@@ -0,0 +1,170 @@
+/******************************************************************************
+ *  Compilation:  javac DepthFirstPaths.java
+ *  Execution:    java DepthFirstPaths G s
+ *  Dependencies: Graph.java Stack.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyCG.txt
+ *                https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *                https://algs4.cs.princeton.edu/41graph/largeG.txt
+ *
+ *  Run depth-first search on an undirected graph.
+ *
+ *  %  java Graph tinyCG.txt
+ *  6 8
+ *  0: 2 1 5 
+ *  1: 0 2 
+ *  2: 0 1 3 4 
+ *  3: 5 4 2 
+ *  4: 3 2 
+ *  5: 3 0 
+ *
+ *  % java DepthFirstPaths tinyCG.txt 0
+ *  0 to 0:  0
+ *  0 to 1:  0-2-1
+ *  0 to 2:  0-2
+ *  0 to 3:  0-2-3
+ *  0 to 4:  0-2-3-4
+ *  0 to 5:  0-2-3-5
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DepthFirstPaths} class represents a data type for finding
+ *  paths from a source vertex <em>s</em> to every other vertex
+ *  in an undirected graph.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DepthFirstPaths {
+    private boolean[] marked;    // marked[v] = is there an s-v path?
+    private int[] edgeTo;        // edgeTo[v] = last edge on s-v path
+    private final int s;         // source vertex
+
+    /**
+     * Computes a path between {@code s} and every other vertex in graph {@code G}.
+     * @param G the graph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DepthFirstPaths(Graph G, int s) {
+        this.s = s;
+        edgeTo = new int[G.V()];
+        marked = new boolean[G.V()];
+        validateVertex(s);
+        dfs(G, s);
+    }
+
+    // depth first search from v
+    private void dfs(Graph G, int v) {
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+            if (!marked[w]) {
+                edgeTo[w] = v;
+                dfs(G, w);
+            }
+        }
+    }
+
+    /**
+     * Is there a path between the source vertex {@code s} and vertex {@code v}?
+     * @param v the vertex
+     * @return {@code true} if there is a path, {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    /**
+     * Returns a path between the source vertex {@code s} and vertex {@code v}, or
+     * {@code null} if no such path.
+     * @param  v the vertex
+     * @return the sequence of vertices on a path between the source vertex
+     *         {@code s} and vertex {@code v}, as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Integer> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<Integer> path = new Stack<Integer>();
+        for (int x = v; x != s; x = edgeTo[x])
+            path.push(x);
+        path.push(s);
+        return path;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code DepthFirstPaths} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        int s = Integer.parseInt(args[1]);
+        DepthFirstPaths dfs = new DepthFirstPaths(G, s);
+
+        for (int v = 0; v < G.V(); v++) {
+            if (dfs.hasPathTo(v)) {
+                StdOut.printf("%d to %d:  ", s, v);
+                for (int x : dfs.pathTo(v)) {
+                    if (x == s) StdOut.print(x);
+                    else        StdOut.print("-" + x);
+                }
+                StdOut.println();
+            }
+
+            else {
+                StdOut.printf("%d to %d:  not connected\n", s, v);
+            }
+
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DepthFirstSearch.java b/src/main/java/edu/princeton/cs/algs4/DepthFirstSearch.java
new file mode 100644
index 0000000..6ce065f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DepthFirstSearch.java
@@ -0,0 +1,142 @@
+/******************************************************************************
+ *  Compilation:  javac DepthFirstSearch.java
+ *  Execution:    java DepthFirstSearch filename.txt s
+ *  Dependencies: Graph.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *
+ *  Run depth first search on an undirected graph.
+ *  Runs in O(E + V) time.
+ *
+ *  % java DepthFirstSearch tinyG.txt 0
+ *  0 1 2 3 4 5 6 
+ *  NOT connected
+ *
+ *  % java DepthFirstSearch tinyG.txt 9
+ *  9 10 11 12 
+ *  NOT connected
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DepthFirstSearch} class represents a data type for 
+ *  determining the vertices connected to a given source vertex <em>s</em>
+ *  in an undirected graph. For versions that find the paths, see
+ *  {@link DepthFirstPaths} and {@link BreadthFirstPaths}.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  See {@link NonrecursiveDFS} for a non-recursive version.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the worst
+ *  case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph). 
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DepthFirstSearch {
+    private boolean[] marked;    // marked[v] = is there an s-v path?
+    private int count;           // number of vertices connected to s
+
+    /**
+     * Computes the vertices in graph {@code G} that are
+     * connected to the source vertex {@code s}.
+     * @param G the graph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DepthFirstSearch(Graph G, int s) {
+        marked = new boolean[G.V()];
+        validateVertex(s);
+        dfs(G, s);
+    }
+
+    // depth first search from v
+    private void dfs(Graph G, int v) {
+        count++;
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+            if (!marked[w]) {
+                dfs(G, w);
+            }
+        }
+    }
+
+    /**
+     * Is there a path between the source vertex {@code s} and vertex {@code v}?
+     * @param v the vertex
+     * @return {@code true} if there is a path, {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean marked(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    /**
+     * Returns the number of vertices connected to the source vertex {@code s}.
+     * @return the number of vertices connected to the source vertex {@code s}
+     */
+    public int count() {
+        return count;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code DepthFirstSearch} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        int s = Integer.parseInt(args[1]);
+        DepthFirstSearch search = new DepthFirstSearch(G, s);
+        for (int v = 0; v < G.V(); v++) {
+            if (search.marked(v))
+                StdOut.print(v + " ");
+        }
+
+        StdOut.println();
+        if (search.count() != G.V()) StdOut.println("NOT connected");
+        else                         StdOut.println("connected");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Digraph.java b/src/main/java/edu/princeton/cs/algs4/Digraph.java
new file mode 100644
index 0000000..0955267
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Digraph.java
@@ -0,0 +1,308 @@
+/******************************************************************************
+ *  Compilation:  javac Digraph.java
+ *  Execution:    java Digraph filename.txt
+ *  Dependencies: Bag.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt  
+ *
+ *  A graph, implemented using an array of lists.
+ *  Parallel edges and self-loops are permitted.
+ *
+ *  % java Digraph tinyDG.txt
+ *  13 vertices, 22 edges
+ *  0: 5 1 
+ *  1: 
+ *  2: 0 3 
+ *  3: 5 2 
+ *  4: 3 2 
+ *  5: 4 
+ *  6: 9 4 8 0 
+ *  7: 6 9
+ *  8: 6 
+ *  9: 11 10 
+ *  10: 12 
+ *  11: 4 12 
+ *  12: 9 
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code Digraph} class represents a directed graph of vertices
+ *  named 0 through <em>V</em> - 1.
+ *  It supports the following two primary operations: add an edge to the digraph,
+ *  iterate over all of the vertices adjacent from a given vertex.
+ *  It also provides
+ *  methods for returning the indegree or outdegree of a vertex, 
+ *  the number of vertices <em>V</em> in the digraph, 
+ *  the number of edges <em>E</em> in the digraph, and the reverse digraph.
+ *  Parallel edges and self-loops are permitted.
+ *  <p>
+ *  This implementation uses an <em>adjacency-lists representation</em>, which
+ *  is a vertex-indexed array of {@link Bag} objects.
+ *  It uses &Theta;(<em>E</em> + <em>V</em>) space, where <em>E</em> is
+ *  the number of edges and <em>V</em> is the number of vertices.
+ *  The <code>reverse()</code> method takes &Theta;(<em>E</em> + <em>V</em>) time
+ *  and space; all other instancce methods take &Theta;(1) time. (Though, iterating over
+ *  the vertices returned by {@link #adj(int)} takes time proportional
+ *  to the outdegree of the vertex.)
+ *  Constructing an empty digraph with <em>V</em> vertices takes
+ *  &Theta;(<em>V</em>) time; constructing a digraph with <em>E</em> edges
+ *  and <em>V</em> vertices takes &Theta;(<em>E</em> + <em>V</em>) time.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class Digraph {
+    private static final String NEWLINE = System.getProperty("line.separator");
+
+    private final int V;           // number of vertices in this digraph
+    private int E;                 // number of edges in this digraph
+    private Bag<Integer>[] adj;    // adj[v] = adjacency list for vertex v
+    private int[] indegree;        // indegree[v] = indegree of vertex v
+    
+    /**
+     * Initializes an empty digraph with <em>V</em> vertices.
+     *
+     * @param  V the number of vertices
+     * @throws IllegalArgumentException if {@code V < 0}
+     */
+    public Digraph(int V) {
+        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be non-negative");
+        this.V = V;
+        this.E = 0;
+        indegree = new int[V];
+        adj = (Bag<Integer>[]) new Bag[V];
+        for (int v = 0; v < V; v++) {
+            adj[v] = new Bag<Integer>();
+        }
+    }
+
+    /**  
+     * Initializes a digraph from the specified input stream.
+     * The format is the number of vertices <em>V</em>,
+     * followed by the number of edges <em>E</em>,
+     * followed by <em>E</em> pairs of vertices, with each entry separated by whitespace.
+     *
+     * @param  in the input stream
+     * @throws IllegalArgumentException if {@code in} is {@code null}
+     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
+     * @throws IllegalArgumentException if the number of vertices or edges is negative
+     * @throws IllegalArgumentException if the input stream is in the wrong format
+     */
+    public Digraph(In in) {
+        if (in == null) throw new IllegalArgumentException("argument is null");
+        try {
+            this.V = in.readInt();
+            if (V < 0) throw new IllegalArgumentException("number of vertices in a Digraph must be non-negative");
+            indegree = new int[V];
+            adj = (Bag<Integer>[]) new Bag[V];
+            for (int v = 0; v < V; v++) {
+                adj[v] = new Bag<Integer>();
+            }
+            int E = in.readInt();
+            if (E < 0) throw new IllegalArgumentException("number of edges in a Digraph must be non-negative");
+            for (int i = 0; i < E; i++) {
+                int v = in.readInt();
+                int w = in.readInt();
+                addEdge(v, w); 
+            }
+        }
+        catch (NoSuchElementException e) {
+            throw new IllegalArgumentException("invalid input format in Digraph constructor", e);
+        }
+    }
+
+    /**
+     * Initializes a new digraph that is a deep copy of the specified digraph.
+     *
+     * @param  G the digraph to copy
+     * @throws IllegalArgumentException if {@code G} is {@code null}
+     */
+    public Digraph(Digraph G) {
+        if (G == null) throw new IllegalArgumentException("argument is null");
+
+        this.V = G.V();
+        this.E = G.E();
+        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be non-negative");
+
+        // update indegrees
+        indegree = new int[V];
+        for (int v = 0; v < V; v++)
+            this.indegree[v] = G.indegree(v);
+
+        // update adjacency lists
+        adj = (Bag<Integer>[]) new Bag[V];
+        for (int v = 0; v < V; v++) {
+            adj[v] = new Bag<Integer>();
+        }
+
+        for (int v = 0; v < G.V(); v++) {
+            // reverse so that adjacency list is in same order as original
+            Stack<Integer> reverse = new Stack<Integer>();
+            for (int w : G.adj[v]) {
+                reverse.push(w);
+            }
+            for (int w : reverse) {
+                adj[v].add(w);
+            }
+        }
+    }
+        
+    /**
+     * Returns the number of vertices in this digraph.
+     *
+     * @return the number of vertices in this digraph
+     */
+    public int V() {
+        return V;
+    }
+
+    /**
+     * Returns the number of edges in this digraph.
+     *
+     * @return the number of edges in this digraph
+     */
+    public int E() {
+        return E;
+    }
+
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Adds the directed edge v‚Üíw to this digraph.
+     *
+     * @param  v the tail vertex
+     * @param  w the head vertex
+     * @throws IllegalArgumentException unless both {@code 0 <= v < V} and {@code 0 <= w < V}
+     */
+    public void addEdge(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        adj[v].add(w);
+        indegree[w]++;
+        E++;
+    }
+
+    /**
+     * Returns the vertices adjacent from vertex {@code v} in this digraph.
+     *
+     * @param  v the vertex
+     * @return the vertices adjacent from vertex {@code v} in this digraph, as an iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Integer> adj(int v) {
+        validateVertex(v);
+        return adj[v];
+    }
+
+    /**
+     * Returns the number of directed edges incident from vertex {@code v}.
+     * This is known as the <em>outdegree</em> of vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the outdegree of vertex {@code v}               
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int outdegree(int v) {
+        validateVertex(v);
+        return adj[v].size();
+    }
+
+    /**
+     * Returns the number of directed edges incident to vertex {@code v}.
+     * This is known as the <em>indegree</em> of vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the indegree of vertex {@code v}               
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int indegree(int v) {
+        validateVertex(v);
+        return indegree[v];
+    }
+
+    /**
+     * Returns the reverse of the digraph.
+     *
+     * @return the reverse of the digraph
+     */
+    public Digraph reverse() {
+        Digraph reverse = new Digraph(V);
+        for (int v = 0; v < V; v++) {
+            for (int w : adj(v)) {
+                reverse.addEdge(w, v);
+            }
+        }
+        return reverse;
+    }
+
+    /**
+     * Returns a string representation of the graph.
+     *
+     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,  
+     *         followed by the <em>V</em> adjacency lists
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(V + " vertices, " + E + " edges " + NEWLINE);
+        for (int v = 0; v < V; v++) {
+            s.append(String.format("%d: ", v));
+            for (int w : adj[v]) {
+                s.append(String.format("%d ", w));
+            }
+            s.append(NEWLINE);
+        }
+        return s.toString();
+    }
+
+    /**
+     * Unit tests the {@code Digraph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        StdOut.println(G);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DigraphGenerator.java b/src/main/java/edu/princeton/cs/algs4/DigraphGenerator.java
new file mode 100644
index 0000000..6b855fa
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DigraphGenerator.java
@@ -0,0 +1,573 @@
+/******************************************************************************
+ *  Compilation:  javac DigraphGenerator.java
+ *  Execution:    java DigraphGenerator V E
+ *  Dependencies: Digraph.java
+ *
+ *  A digraph generator.
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DigraphGenerator} class provides static methods for creating
+ *  various digraphs, including Erdos-Renyi random digraphs, random DAGs,
+ *  random rooted trees, random rooted DAGs, random tournaments, path digraphs,
+ *  cycle digraphs, and the complete digraph.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DigraphGenerator {
+    private static final class Edge implements Comparable<Edge> {
+        private final int v;
+        private final int w;
+
+        private Edge(int v, int w) {
+            this.v = v;
+            this.w = w;
+        }
+
+        public int compareTo(Edge that) {
+            if (this.v < that.v) return -1;
+            if (this.v > that.v) return +1;
+            if (this.w < that.w) return -1;
+            if (this.w > that.w) return +1;
+            return 0;
+        }
+    }
+
+    // this class cannot be instantiated
+    private DigraphGenerator() { }
+
+    /**
+     * Returns a random simple digraph containing {@code V} vertices and {@code E} edges.
+     * @param V the number of vertices
+     * @param E the number of vertices
+     * @return a random simple digraph on {@code V} vertices, containing a total
+     *     of {@code E} edges
+     * @throws IllegalArgumentException if no such simple digraph exists
+     */
+    public static Digraph simple(int V, int E) {
+        if (E > (long) V*(V-1)) throw new IllegalArgumentException("Too many edges");
+        if (E < 0)              throw new IllegalArgumentException("Too few edges");
+        Digraph G = new Digraph(V);
+        SET<Edge> set = new SET<Edge>();
+        while (G.E() < E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            Edge e = new Edge(v, w);
+            if ((v != w) && !set.contains(e)) {
+                set.add(e);
+                G.addEdge(v, w);
+            }
+        }
+        return G;
+    }
+
+   /**
+     * Returns a random simple digraph on {@code V} vertices, with an 
+     * edge between any two vertices with probability {@code p}. This is sometimes
+     * referred to as the Erdos-Renyi random digraph model.
+     * This implementations takes time propotional to V^2 (even if {@code p} is small).
+     * @param V the number of vertices
+     * @param p the probability of choosing an edge
+     * @return a random simple digraph on {@code V} vertices, with an edge between
+     *     any two vertices with probability {@code p}
+     * @throws IllegalArgumentException if probability is not between 0 and 1
+     */
+    public static Digraph simple(int V, double p) {
+        if (p < 0.0 || p > 1.0)
+            throw new IllegalArgumentException("Probability must be between 0 and 1");
+        Digraph G = new Digraph(V);
+        for (int v = 0; v < V; v++)
+            for (int w = 0; w < V; w++)
+                if (v != w)
+                    if (StdRandom.bernoulli(p))
+                        G.addEdge(v, w);
+        return G;
+    }
+
+    /**
+     * Returns the complete digraph on {@code V} vertices.
+     * In a complete digraph, every pair of distinct vertices is connected
+     * by two antiparallel edges. There are {@code V*(V-1)} edges.
+     * @param V the number of vertices
+     * @return the complete digraph on {@code V} vertices
+     */
+    public static Digraph complete(int V) {
+        Digraph G = new Digraph(V);
+        for (int v = 0; v < V; v++)
+            for (int w = 0; w < V; w++)
+                    if (v != w) G.addEdge(v, w);
+        return G;
+    }
+
+    /**
+     * Returns a random simple DAG containing {@code V} vertices and {@code E} edges.
+     * Note: it is not uniformly selected at random among all such DAGs.
+     * @param V the number of vertices
+     * @param E the number of vertices
+     * @return a random simple DAG on {@code V} vertices, containing a total
+     *     of {@code E} edges
+     * @throws IllegalArgumentException if no such simple DAG exists
+     */
+    public static Digraph dag(int V, int E) {
+        if (E > (long) V*(V-1) / 2) throw new IllegalArgumentException("Too many edges");
+        if (E < 0)                  throw new IllegalArgumentException("Too few edges");
+        Digraph G = new Digraph(V);
+        SET<Edge> set = new SET<Edge>();
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        while (G.E() < E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            Edge e = new Edge(v, w);
+            if ((v < w) && !set.contains(e)) {
+                set.add(e);
+                G.addEdge(vertices[v], vertices[w]);
+            }
+        }
+        return G;
+    }
+
+    /**
+     * Returns a random tournament digraph on {@code V} vertices. A tournament digraph
+     * is a digraph in which, for every pair of vertices, there is one and only one
+     * directed edge connecting them. A tournament is an oriented complete graph.
+     * @param V the number of vertices
+     * @return a random tournament digraph on {@code V} vertices
+     */
+    public static Digraph tournament(int V) {
+        Digraph G = new Digraph(V);
+        for (int v = 0; v < G.V(); v++) {
+            for (int w = v+1; w < G.V(); w++) {
+                if (StdRandom.bernoulli(0.5)) G.addEdge(v, w);
+                else                          G.addEdge(w, v);
+            }
+        }
+        return G;
+    }
+
+    /**
+     * Returns a complete rooted-in DAG on {@code V} vertices.
+     * A rooted in-tree is a DAG in which there is a single vertex
+     * reachable from every other vertex. A complete rooted in-DAG
+     * has V*(V-1)/2 edges.
+     * @param V the number of vertices
+     * @return a complete rooted-in DAG on {@code V} vertices
+     */
+    public static Digraph completeRootedInDAG(int V) {
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V; i++)
+            for (int j = i+1; j < V; j++)
+                 G.addEdge(vertices[i], vertices[j]);
+
+        return G;
+    }
+
+    /**
+     * Returns a random rooted-in DAG on {@code V} vertices and {@code E} edges.
+     * A rooted in-tree is a DAG in which there is a single vertex
+     * reachable from every other vertex.
+     * The DAG returned is not chosen uniformly at random among all such DAGs.
+     * @param V the number of vertices
+     * @param E the number of edges
+     * @return a random rooted-in DAG on {@code V} vertices and {@code E} edges
+     */
+    public static Digraph rootedInDAG(int V, int E) {
+        if (E > (long) V*(V-1) / 2) throw new IllegalArgumentException("Too many edges");
+        if (E < V-1)                throw new IllegalArgumentException("Too few edges");
+        Digraph G = new Digraph(V);
+        SET<Edge> set = new SET<Edge>();
+
+        // fix a topological order
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+
+        // one edge pointing from each vertex, other than the root = vertices[V-1]
+        for (int v = 0; v < V-1; v++) {
+            int w = StdRandom.uniform(v+1, V);
+            Edge e = new Edge(v, w);
+            set.add(e);
+            G.addEdge(vertices[v], vertices[w]);
+        }
+
+        while (G.E() < E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            Edge e = new Edge(v, w);
+            if ((v < w) && !set.contains(e)) {
+                set.add(e);
+                G.addEdge(vertices[v], vertices[w]);
+            }
+        }
+        return G;
+    }
+
+    /**
+     * Returns a complete rooted-out DAG on {@code V} vertices.
+     * A rooted out-tree is a DAG in which every vertex is reachable
+     * from a single vertex. A complete rooted in-DAG has V*(V-1)/2 edges.
+     * @param V the number of vertices
+     * @return a complete rooted-out DAG on {@code V} vertices
+     */
+    public static Digraph completeRootedOutDAG(int V) {
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V; i++)
+            for (int j = i+1; j < V; j++)
+                 G.addEdge(vertices[j], vertices[i]);
+
+        return G;
+    }
+
+    /**
+     * Returns a random rooted-out DAG on {@code V} vertices and {@code E} edges.
+     * A rooted out-tree is a DAG in which every vertex is reachable from a
+     * single vertex.
+     * The DAG returned is not chosen uniformly at random among all such DAGs.
+     * @param V the number of vertices
+     * @param E the number of edges
+     * @return a random rooted-out DAG on {@code V} vertices and {@code E} edges
+     */
+    public static Digraph rootedOutDAG(int V, int E) {
+        if (E > (long) V*(V-1) / 2) throw new IllegalArgumentException("Too many edges");
+        if (E < V-1)                throw new IllegalArgumentException("Too few edges");
+        Digraph G = new Digraph(V);
+        SET<Edge> set = new SET<Edge>();
+
+        // fix a topological order
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+
+        // one edge pointing from each vertex, other than the root = vertices[V-1]
+        for (int v = 0; v < V-1; v++) {
+            int w = StdRandom.uniform(v+1, V);
+            Edge e = new Edge(w, v);
+            set.add(e);
+            G.addEdge(vertices[w], vertices[v]);
+        }
+
+        while (G.E() < E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            Edge e = new Edge(w, v);
+            if ((v < w) && !set.contains(e)) {
+                set.add(e);
+                G.addEdge(vertices[w], vertices[v]);
+            }
+        }
+        return G;
+    }
+
+    /**
+     * Returns a random rooted-in tree on {@code V} vertices.
+     * A rooted in-tree is an oriented tree in which there is a single vertex
+     * reachable from every other vertex.
+     * The tree returned is not chosen uniformly at random among all such trees.
+     * @param V the number of vertices
+     * @return a random rooted-in tree on {@code V} vertices
+     */
+    public static Digraph rootedInTree(int V) {
+        return rootedInDAG(V, V-1);
+    }
+
+    /**
+     * Returns a random rooted-out tree on {@code V} vertices. A rooted out-tree
+     * is an oriented tree in which each vertex is reachable from a single vertex.
+     * It is also known as a <em>arborescence</em> or <em>branching</em>.
+     * The tree returned is not chosen uniformly at random among all such trees.
+     * @param V the number of vertices
+     * @return a random rooted-out tree on {@code V} vertices
+     */
+    public static Digraph rootedOutTree(int V) {
+        return rootedOutDAG(V, V-1);
+    }
+
+    /**
+     * Returns a path digraph on {@code V} vertices.
+     * @param V the number of vertices in the path
+     * @return a digraph that is a directed path on {@code V} vertices
+     */
+    public static Digraph path(int V) {
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        return G;
+    }
+
+    /**
+     * Returns a complete binary tree digraph on {@code V} vertices.
+     * @param V the number of vertices in the binary tree
+     * @return a digraph that is a complete binary tree on {@code V} vertices
+     */
+    public static Digraph binaryTree(int V) {
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 1; i < V; i++) {
+            G.addEdge(vertices[i], vertices[(i-1)/2]);
+        }
+        return G;
+    }
+
+    /**
+     * Returns a cycle digraph on {@code V} vertices.
+     * @param V the number of vertices in the cycle
+     * @return a digraph that is a directed cycle on {@code V} vertices
+     */
+    public static Digraph cycle(int V) {
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        G.addEdge(vertices[V-1], vertices[0]);
+        return G;
+    }
+
+    /**
+     * Returns an Eulerian cycle digraph on {@code V} vertices.
+     *
+     * @param  V the number of vertices in the cycle
+     * @param  E the number of edges in the cycle
+     * @return a digraph that is a directed Eulerian cycle on {@code V} vertices
+     *         and {@code E} edges
+     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E <= 0}
+     */
+    public static Digraph eulerianCycle(int V, int E) {
+        if (E <= 0)
+            throw new IllegalArgumentException("An Eulerian cycle must have at least one edge");
+        if (V <= 0)
+            throw new IllegalArgumentException("An Eulerian cycle must have at least one vertex");
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[E];
+        for (int i = 0; i < E; i++)
+            vertices[i] = StdRandom.uniform(V);
+        for (int i = 0; i < E-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        G.addEdge(vertices[E-1], vertices[0]);
+        return G;
+    }
+
+    /**
+     * Returns an Eulerian path digraph on {@code V} vertices.
+     *
+     * @param  V the number of vertices in the path
+     * @param  E the number of edges in the path
+     * @return a digraph that is a directed Eulerian path on {@code V} vertices
+     *         and {@code E} edges
+     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E < 0}
+     */
+    public static Digraph eulerianPath(int V, int E) {
+        if (E < 0)
+            throw new IllegalArgumentException("negative number of edges");
+        if (V <= 0)
+            throw new IllegalArgumentException("An Eulerian path must have at least one vertex");
+        Digraph G = new Digraph(V);
+        int[] vertices = new int[E+1];
+        for (int i = 0; i < E+1; i++)
+            vertices[i] = StdRandom.uniform(V);
+        for (int i = 0; i < E; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        return G;
+    }
+
+   /**
+     * Returns a random simple digraph on {@code V} vertices, {@code E}
+     * edges and (at least) {@code c} strong components. The vertices are randomly
+     * assigned integer labels between {@code 0} and {@code c-1} (corresponding to 
+     * strong components). Then, a strong component is creates among the vertices
+     * with the same label. Next, random edges (either between two vertices with
+     * the same labels or from a vetex with a smaller label to a vertex with a 
+     * larger label). The number of components will be equal to the number of
+     * distinct labels that are assigned to vertices.
+     *
+     * @param V the number of vertices
+     * @param E the number of edges
+     * @param c the (maximum) number of strong components
+     * @return a random simple digraph on {@code V} vertices and
+               {@code E} edges, with (at most) {@code c} strong components
+     * @throws IllegalArgumentException if {@code c} is larger than {@code V}
+     */
+    public static Digraph strong(int V, int E, int c) {
+        if (c >= V || c <= 0)
+            throw new IllegalArgumentException("Number of components must be between 1 and V");
+        if (E <= 2*(V-c))
+            throw new IllegalArgumentException("Number of edges must be at least 2(V-c)");
+        if (E > (long) V*(V-1) / 2)
+            throw new IllegalArgumentException("Too many edges");
+
+        // the digraph
+        Digraph G = new Digraph(V);
+
+        // edges added to G (to avoid duplicate edges)
+        SET<Edge> set = new SET<Edge>();
+
+        int[] label = new int[V];
+        for (int v = 0; v < V; v++)
+            label[v] = StdRandom.uniform(c);
+
+        // make all vertices with label c a strong component by
+        // combining a rooted in-tree and a rooted out-tree
+        for (int i = 0; i < c; i++) {
+            // how many vertices in component c
+            int count = 0;
+            for (int v = 0; v < G.V(); v++) {
+                if (label[v] == i) count++;
+            }
+
+            // if (count == 0) System.err.println("less than desired number of strong components");
+
+            int[] vertices = new int[count];
+            int j = 0;
+            for (int v = 0; v < V; v++) {
+                if (label[v] == i) vertices[j++] = v;
+            }
+            StdRandom.shuffle(vertices);
+
+            // rooted-in tree with root = vertices[count-1]
+            for (int v = 0; v < count-1; v++) {
+                int w = StdRandom.uniform(v+1, count);
+                Edge e = new Edge(w, v);
+                set.add(e);
+                G.addEdge(vertices[w], vertices[v]);
+            }
+
+            // rooted-out tree with root = vertices[count-1]
+            for (int v = 0; v < count-1; v++) {
+                int w = StdRandom.uniform(v+1, count);
+                Edge e = new Edge(v, w);
+                set.add(e);
+                G.addEdge(vertices[v], vertices[w]);
+            }
+        }
+
+        while (G.E() < E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            Edge e = new Edge(v, w);
+            if (!set.contains(e) && v != w && label[v] <= label[w]) {
+                set.add(e);
+                G.addEdge(v, w);
+            }
+        }
+
+        return G;
+    }
+
+    /**
+     * Unit tests the {@code DigraphGenerator} library.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        StdOut.println("complete graph");
+        StdOut.println(complete(V));
+        StdOut.println();
+
+        StdOut.println("simple");
+        StdOut.println(simple(V, E));
+        StdOut.println();
+
+        StdOut.println("path");
+        StdOut.println(path(V));
+        StdOut.println();
+
+        StdOut.println("cycle");
+        StdOut.println(cycle(V));
+        StdOut.println();
+
+        StdOut.println("Eulierian path");
+        StdOut.println(eulerianPath(V, E));
+        StdOut.println();
+
+        StdOut.println("Eulierian cycle");
+        StdOut.println(eulerianCycle(V, E));
+        StdOut.println();
+
+        StdOut.println("binary tree");
+        StdOut.println(binaryTree(V));
+        StdOut.println();
+
+        StdOut.println("tournament");
+        StdOut.println(tournament(V));
+        StdOut.println();
+
+        StdOut.println("DAG");
+        StdOut.println(dag(V, E));
+        StdOut.println();
+
+        StdOut.println("rooted-in DAG");
+        StdOut.println(rootedInDAG(V, E));
+        StdOut.println();
+
+        StdOut.println("rooted-out DAG");
+        StdOut.println(rootedOutDAG(V, E));
+        StdOut.println();
+
+        StdOut.println("rooted-in tree");
+        StdOut.println(rootedInTree(V));
+        StdOut.println();
+
+        StdOut.println("rooted-out DAG");
+        StdOut.println(rootedOutTree(V));
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DijkstraAllPairsSP.java b/src/main/java/edu/princeton/cs/algs4/DijkstraAllPairsSP.java
new file mode 100644
index 0000000..ed4847e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DijkstraAllPairsSP.java
@@ -0,0 +1,173 @@
+/******************************************************************************
+ *  Compilation:  javac DijkstraAllPairsSP.java
+ *  Execution:    none
+ *  Dependencies: EdgeWeightedDigraph.java Dijkstra.java
+ *
+ *  Dijkstra's algorithm run from each vertex. 
+ *  Takes time proportional to E V log V and space proportional to EV.
+ *
+ *  % java DijkstraAllPairsSP tinyEWD.txt
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DijkstraAllPairsSP} class represents a data type for solving the
+ *  all-pairs shortest paths problem in edge-weighted digraphs
+ *  where the edge weights are non-negative.
+ *  <p>
+ *  This implementation runs Dijkstra's algorithm from each vertex.
+ *  The constructor takes &Theta;(<em>V</em> (<em>E</em> log <em>V</em>)) time
+ *  in the worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em><sup>2</sup>) extra space (not including the
+ *  edge-weighted digraph).
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of    
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DijkstraAllPairsSP {
+    private DijkstraSP[] all;
+
+    /**
+     * Computes a shortest paths tree from each vertex to to every other vertex in
+     * the edge-weighted digraph {@code G}.
+     * @param G the edge-weighted digraph
+     * @throws IllegalArgumentException if an edge weight is negative
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DijkstraAllPairsSP(EdgeWeightedDigraph G) {
+        all  = new DijkstraSP[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            all[v] = new DijkstraSP(G, v);
+    }
+
+    /**
+     * Returns a shortest path from vertex {@code s} to vertex {@code t}.
+     * @param  s the source vertex
+     * @param  t the destination vertex
+     * @return a shortest path from vertex {@code s} to vertex {@code t}
+     *         as an iterable of edges, and {@code null} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     * @throws IllegalArgumentException unless {@code 0 <= t < V}
+     */
+    public Iterable<DirectedEdge> path(int s, int t) {
+        validateVertex(s);
+        validateVertex(t);
+        return all[s].pathTo(t);
+    }
+
+    /**
+     * Is there a path from the vertex {@code s} to vertex {@code t}?
+     * @param  s the source vertex
+     * @param  t the destination vertex
+     * @return {@code true} if there is a path from vertex {@code s} 
+     *         to vertex {@code t}, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     * @throws IllegalArgumentException unless {@code 0 <= t < V}
+     */
+    public boolean hasPath(int s, int t) {
+        validateVertex(s);
+        validateVertex(t);
+        return dist(s, t) < Double.POSITIVE_INFINITY;
+    }
+
+    /**
+     * Returns the length of a shortest path from vertex {@code s} to vertex {@code t}.
+     * @param  s the source vertex
+     * @param  t the destination vertex
+     * @return the length of a shortest path from vertex {@code s} to vertex {@code t};
+     *         {@code Double.POSITIVE_INFINITY} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     * @throws IllegalArgumentException unless {@code 0 <= t < V}
+     */
+    public double dist(int s, int t) {
+        validateVertex(s);
+        validateVertex(t);
+        return all[s].distTo(t);
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = all.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+
+    /**
+     * Unit tests the {@code DijkstraAllPairsSP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read edge-weighted digraph
+        In in = new In(args[0]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
+
+        // compute shortest paths between all pairs of vertices
+        DijkstraAllPairsSP spt = new DijkstraAllPairsSP(G);
+
+        // print all-pairs shortest path distances
+        StdOut.printf("  ");
+        for (int v = 0; v < G.V(); v++) {
+            StdOut.printf("%6d ", v);
+        }
+        StdOut.println();
+        for (int v = 0; v < G.V(); v++) {
+            StdOut.printf("%3d: ", v);
+            for (int w = 0; w < G.V(); w++) {
+                if (spt.hasPath(v, w)) StdOut.printf("%6.2f ", spt.dist(v, w));
+                else StdOut.printf("  Inf ");
+            }
+            StdOut.println();
+        }
+        StdOut.println();
+
+        // print all-pairs shortest paths
+        for (int v = 0; v < G.V(); v++) {
+            for (int w = 0; w < G.V(); w++) {
+                if (spt.hasPath(v, w)) {
+                    StdOut.printf("%d to %d (%5.2f)  ", v, w, spt.dist(v, w));
+                    for (DirectedEdge e : spt.path(v, w))
+                        StdOut.print(e + "  ");
+                    StdOut.println();
+                }
+                else {
+                    StdOut.printf("%d to %d no path\n", v, w);
+                }
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DijkstraSP.java b/src/main/java/edu/princeton/cs/algs4/DijkstraSP.java
new file mode 100644
index 0000000..7629185
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DijkstraSP.java
@@ -0,0 +1,271 @@
+/******************************************************************************
+ *  Compilation:  javac DijkstraSP.java
+ *  Execution:    java DijkstraSP input.txt s
+ *  Dependencies: EdgeWeightedDigraph.java IndexMinPQ.java Stack.java DirectedEdge.java
+ *  Data files:   https://algs4.cs.princeton.edu/44sp/tinyEWD.txt
+ *                https://algs4.cs.princeton.edu/44sp/mediumEWD.txt
+ *                https://algs4.cs.princeton.edu/44sp/largeEWD.txt
+ *
+ *  Dijkstra's algorithm. Computes the shortest path tree.
+ *  Assumes all weights are non-negative.
+ *
+ *  % java DijkstraSP tinyEWD.txt 0
+ *  0 to 0 (0.00)  
+ *  0 to 1 (1.05)  0->4  0.38   4->5  0.35   5->1  0.32   
+ *  0 to 2 (0.26)  0->2  0.26   
+ *  0 to 3 (0.99)  0->2  0.26   2->7  0.34   7->3  0.39   
+ *  0 to 4 (0.38)  0->4  0.38   
+ *  0 to 5 (0.73)  0->4  0.38   4->5  0.35   
+ *  0 to 6 (1.51)  0->2  0.26   2->7  0.34   7->3  0.39   3->6  0.52   
+ *  0 to 7 (0.60)  0->2  0.26   2->7  0.34   
+ *
+ *  % java DijkstraSP mediumEWD.txt 0
+ *  0 to 0 (0.00)  
+ *  0 to 1 (0.71)  0->44  0.06   44->93  0.07   ...  107->1  0.07   
+ *  0 to 2 (0.65)  0->44  0.06   44->231  0.10  ...  42->2  0.11   
+ *  0 to 3 (0.46)  0->97  0.08   97->248  0.09  ...  45->3  0.12   
+ *  0 to 4 (0.42)  0->44  0.06   44->93  0.07   ...  77->4  0.11   
+ *  ...
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code DijkstraSP} class represents a data type for solving the
+ *  single-source shortest paths problem in edge-weighted digraphs
+ *  where the edge weights are non-negative.
+ *  <p>
+ *  This implementation uses <em>Dijkstra's algorithm</em> with a
+ *  <em>binary heap</em>. The constructor takes
+ *  &Theta;(<em>E</em> log <em>V</em>) time in the worst case,
+ *  where <em>V</em> is the number of vertices and <em>E</em> is
+ *  the number of edges. Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the
+ *  edge-weighted digraph).
+ *  <p>
+ *  This correctly computes shortest paths if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>. Since all intermediate
+ *  results are sums of edge weights, they are bounded by <em>V C</em>,
+ *  where <em>V</em> is the number of vertices and <em>C</em> is the maximum
+ *  weight of any edge.
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of    
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DijkstraSP {
+    private double[] distTo;          // distTo[v] = distance  of shortest s->v path
+    private DirectedEdge[] edgeTo;    // edgeTo[v] = last edge on shortest s->v path
+    private IndexMinPQ<Double> pq;    // priority queue of vertices
+
+    /**
+     * Computes a shortest-paths tree from the source vertex {@code s} to every other
+     * vertex in the edge-weighted digraph {@code G}.
+     *
+     * @param  G the edge-weighted digraph
+     * @param  s the source vertex
+     * @throws IllegalArgumentException if an edge weight is negative
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DijkstraSP(EdgeWeightedDigraph G, int s) {
+        for (DirectedEdge e : G.edges()) {
+            if (e.weight() < 0)
+                throw new IllegalArgumentException("edge " + e + " has negative weight");
+        }
+
+        distTo = new double[G.V()];
+        edgeTo = new DirectedEdge[G.V()];
+
+        validateVertex(s);
+
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = Double.POSITIVE_INFINITY;
+        distTo[s] = 0.0;
+
+        // relax vertices in order of distance from s
+        pq = new IndexMinPQ<Double>(G.V());
+        pq.insert(s, distTo[s]);
+        while (!pq.isEmpty()) {
+            int v = pq.delMin();
+            for (DirectedEdge e : G.adj(v))
+                relax(e);
+        }
+
+        // check optimality conditions
+        assert check(G, s);
+    }
+
+    // relax edge e and update pq if changed
+    private void relax(DirectedEdge e) {
+        int v = e.from(), w = e.to();
+        if (distTo[w] > distTo[v] + e.weight()) {
+            distTo[w] = distTo[v] + e.weight();
+            edgeTo[w] = e;
+            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
+            else                pq.insert(w, distTo[w]);
+        }
+    }
+
+    /**
+     * Returns the length of a shortest path from the source vertex {@code s} to vertex {@code v}.
+     * @param  v the destination vertex
+     * @return the length of a shortest path from the source vertex {@code s} to vertex {@code v};
+     *         {@code Double.POSITIVE_INFINITY} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public double distTo(int v) {
+        validateVertex(v);
+        return distTo[v];
+    }
+
+    /**
+     * Returns true if there is a path from the source vertex {@code s} to vertex {@code v}.
+     *
+     * @param  v the destination vertex
+     * @return {@code true} if there is a path from the source vertex
+     *         {@code s} to vertex {@code v}; {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return distTo[v] < Double.POSITIVE_INFINITY;
+    }
+
+    /**
+     * Returns a shortest path from the source vertex {@code s} to vertex {@code v}.
+     *
+     * @param  v the destination vertex
+     * @return a shortest path from the source vertex {@code s} to vertex {@code v}
+     *         as an iterable of edges, and {@code null} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
+        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
+            path.push(e);
+        }
+        return path;
+    }
+
+
+    // check optimality conditions:
+    // (i) for all edges e:            distTo[e.to()] <= distTo[e.from()] + e.weight()
+    // (ii) for all edge e on the SPT: distTo[e.to()] == distTo[e.from()] + e.weight()
+    private boolean check(EdgeWeightedDigraph G, int s) {
+
+        // check that edge weights are non-negative
+        for (DirectedEdge e : G.edges()) {
+            if (e.weight() < 0) {
+                System.err.println("negative edge weight detected");
+                return false;
+            }
+        }
+
+        // check that distTo[v] and edgeTo[v] are consistent
+        if (distTo[s] != 0.0 || edgeTo[s] != null) {
+            System.err.println("distTo[s] and edgeTo[s] inconsistent");
+            return false;
+        }
+        for (int v = 0; v < G.V(); v++) {
+            if (v == s) continue;
+            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
+                System.err.println("distTo[] and edgeTo[] inconsistent");
+                return false;
+            }
+        }
+
+        // check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()
+        for (int v = 0; v < G.V(); v++) {
+            for (DirectedEdge e : G.adj(v)) {
+                int w = e.to();
+                if (distTo[v] + e.weight() < distTo[w]) {
+                    System.err.println("edge " + e + " not relaxed");
+                    return false;
+                }
+            }
+        }
+
+        // check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()
+        for (int w = 0; w < G.V(); w++) {
+            if (edgeTo[w] == null) continue;
+            DirectedEdge e = edgeTo[w];
+            int v = e.from();
+            if (w != e.to()) return false;
+            if (distTo[v] + e.weight() != distTo[w]) {
+                System.err.println("edge " + e + " on shortest path not tight");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = distTo.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code DijkstraSP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
+        int s = Integer.parseInt(args[1]);
+
+        // compute shortest paths
+        DijkstraSP sp = new DijkstraSP(G, s);
+
+
+        // print shortest path
+        for (int t = 0; t < G.V(); t++) {
+            if (sp.hasPathTo(t)) {
+                StdOut.printf("%d to %d (%.2f)  ", s, t, sp.distTo(t));
+                for (DirectedEdge e : sp.pathTo(t)) {
+                    StdOut.print(e + "   ");
+                }
+                StdOut.println();
+            }
+            else {
+                StdOut.printf("%d to %d         no path\n", s, t);
+            }
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DijkstraUndirectedSP.java b/src/main/java/edu/princeton/cs/algs4/DijkstraUndirectedSP.java
new file mode 100644
index 0000000..9ef745c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DijkstraUndirectedSP.java
@@ -0,0 +1,283 @@
+/******************************************************************************
+ *  Compilation:  javac DijkstraUndirectedSP.java
+ *  Execution:    java DijkstraUndirectedSP input.txt s
+ *  Dependencies: EdgeWeightedGraph.java IndexMinPQ.java Stack.java Edge.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/largeEWG.txt
+ *
+ *  Dijkstra's algorithm. Computes the shortest path tree.
+ *  Assumes all weights are non-negative.
+ *
+ *  % java DijkstraUndirectedSP tinyEWG.txt 6
+ *  6 to 0 (0.58)  6-0 0.58000
+ *  6 to 1 (0.76)  6-2 0.40000   1-2 0.36000
+ *  6 to 2 (0.40)  6-2 0.40000
+ *  6 to 3 (0.52)  3-6 0.52000
+ *  6 to 4 (0.93)  6-4 0.93000
+ *  6 to 5 (1.02)  6-2 0.40000   2-7 0.34000   5-7 0.28000
+ *  6 to 6 (0.00)
+ *  6 to 7 (0.74)  6-2 0.40000   2-7 0.34000
+ *
+ *  % java DijkstraUndirectedSP mediumEWG.txt 0
+ *  0 to 0 (0.00)
+ *  0 to 1 (0.71)  0-44 0.06471   44-93  0.06793  ...   1-107 0.07484
+ *  0 to 2 (0.65)  0-44 0.06471   44-231 0.10384  ...   2-42  0.11456
+ *  0 to 3 (0.46)  0-97 0.07705   97-248 0.08598  ...   3-45  0.11902
+ *  ...
+ *
+ *  % java DijkstraUndirectedSP largeEWG.txt 0
+ *  0 to 0 (0.00)  
+ *  0 to 1 (0.78)  0-460790 0.00190  460790-696678 0.00173   ...   1-826350 0.00191
+ *  0 to 2 (0.61)  0-15786  0.00130  15786-53370   0.00113   ...   2-793420 0.00040
+ *  0 to 3 (0.31)  0-460790 0.00190  460790-752483 0.00194   ...   3-698373 0.00172
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code DijkstraUndirectedSP} class represents a data type for solving
+ *  the single-source shortest paths problem in edge-weighted graphs
+ *  where the edge weights are non-negative.
+ *  <p>
+ *  This implementation uses Dijkstra's algorithm with a binary heap.
+ *  The constructor takes &Theta;(<em>E</em> log <em>V</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the
+ *  edge-weighted graph).
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of    
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *  See {@link DijkstraSP} for a version on edge-weighted digraphs.
+ *  <p>
+ *  This correctly computes shortest paths if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>. Since all intermediate
+ *  results are sums of edge weights, they are bounded by <em>V C</em>,
+ *  where <em>V</em> is the number of vertices and <em>C</em> is the maximum
+ *  weight of any edge.
+ *  <p>
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *  @author Nate Liu
+ */
+public class DijkstraUndirectedSP {
+    private double[] distTo;          // distTo[v] = distance  of shortest s->v path
+    private Edge[] edgeTo;            // edgeTo[v] = last edge on shortest s->v path
+    private IndexMinPQ<Double> pq;    // priority queue of vertices
+
+    /**
+     * Computes a shortest-paths tree from the source vertex {@code s} to every
+     * other vertex in the edge-weighted graph {@code G}.
+     *
+     * @param  G the edge-weighted digraph
+     * @param  s the source vertex
+     * @throws IllegalArgumentException if an edge weight is negative
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DijkstraUndirectedSP(EdgeWeightedGraph G, int s) {
+        for (Edge e : G.edges()) {
+            if (e.weight() < 0)
+                throw new IllegalArgumentException("edge " + e + " has negative weight");
+        }
+
+        distTo = new double[G.V()];
+        edgeTo = new Edge[G.V()];
+
+        validateVertex(s);
+
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = Double.POSITIVE_INFINITY;
+        distTo[s] = 0.0;
+
+        // relax vertices in order of distance from s
+        pq = new IndexMinPQ<Double>(G.V());
+        pq.insert(s, distTo[s]);
+        while (!pq.isEmpty()) {
+            int v = pq.delMin();
+            for (Edge e : G.adj(v))
+                relax(e, v);
+        }
+
+        // check optimality conditions
+        assert check(G, s);
+    }
+
+    // relax edge e and update pq if changed
+    private void relax(Edge e, int v) {
+        int w = e.other(v);
+        if (distTo[w] > distTo[v] + e.weight()) {
+            distTo[w] = distTo[v] + e.weight();
+            edgeTo[w] = e;
+            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
+            else                pq.insert(w, distTo[w]);
+        }
+    }
+
+    /**
+     * Returns the length of a shortest path between the source vertex {@code s} and
+     * vertex {@code v}.
+     *
+     * @param  v the destination vertex
+     * @return the length of a shortest path between the source vertex {@code s} and
+     *         the vertex {@code v}; {@code Double.POSITIVE_INFINITY} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public double distTo(int v) {
+        validateVertex(v);
+        return distTo[v];
+    }
+
+    /**
+     * Returns true if there is a path between the source vertex {@code s} and
+     * vertex {@code v}.
+     *
+     * @param  v the destination vertex
+     * @return {@code true} if there is a path between the source vertex
+     *         {@code s} to vertex {@code v}; {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean hasPathTo(int v) {
+        validateVertex(v);
+        return distTo[v] < Double.POSITIVE_INFINITY;
+    }
+
+    /**
+     * Returns a shortest path between the source vertex {@code s} and vertex {@code v}.
+     *
+     * @param  v the destination vertex
+     * @return a shortest path between the source vertex {@code s} and vertex {@code v};
+     *         {@code null} if no such path
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Edge> pathTo(int v) {
+        validateVertex(v);
+        if (!hasPathTo(v)) return null;
+        Stack<Edge> path = new Stack<Edge>();
+        int x = v;
+        for (Edge e = edgeTo[v]; e != null; e = edgeTo[x]) {
+            path.push(e);
+            x = e.other(x);
+        }
+        return path;
+    }
+
+
+    // check optimality conditions:
+    // (i) for all edges e = v-w:            distTo[w] <= distTo[v] + e.weight()
+    // (ii) for all edge e = v-w on the SPT: distTo[w] == distTo[v] + e.weight()
+    private boolean check(EdgeWeightedGraph G, int s) {
+
+        // check that edge weights are non-negative
+        for (Edge e : G.edges()) {
+            if (e.weight() < 0) {
+                System.err.println("negative edge weight detected");
+                return false;
+            }
+        }
+
+        // check that distTo[v] and edgeTo[v] are consistent
+        if (distTo[s] != 0.0 || edgeTo[s] != null) {
+            System.err.println("distTo[s] and edgeTo[s] inconsistent");
+            return false;
+        }
+        for (int v = 0; v < G.V(); v++) {
+            if (v == s) continue;
+            if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
+                System.err.println("distTo[] and edgeTo[] inconsistent");
+                return false;
+            }
+        }
+
+        // check that all edges e = v-w satisfy distTo[w] <= distTo[v] + e.weight()
+        for (int v = 0; v < G.V(); v++) {
+            for (Edge e : G.adj(v)) {
+                int w = e.other(v);
+                if (distTo[v] + e.weight() < distTo[w]) {
+                    System.err.println("edge " + e + " not relaxed");
+                    return false;
+                }
+            }
+        }
+
+        // check that all edges e = v-w on SPT satisfy distTo[w] == distTo[v] + e.weight()
+        for (int w = 0; w < G.V(); w++) {
+            if (edgeTo[w] == null) continue;
+            Edge e = edgeTo[w];
+            if (w != e.either() && w != e.other(e.either())) return false;
+            int v = e.other(w);
+            if (distTo[v] + e.weight() != distTo[w]) {
+                System.err.println("edge " + e + " on shortest path not tight");
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = distTo.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code DijkstraUndirectedSP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        int s = Integer.parseInt(args[1]);
+
+        // compute shortest paths
+        DijkstraUndirectedSP sp = new DijkstraUndirectedSP(G, s);
+
+
+        // print shortest path
+        for (int t = 0; t < G.V(); t++) {
+            if (sp.hasPathTo(t)) {
+                StdOut.printf("%d to %d (%.2f)  ", s, t, sp.distTo(t));
+                for (Edge e : sp.pathTo(t)) {
+                    StdOut.print(e + "   ");
+                }
+                StdOut.println();
+            }
+            else {
+                StdOut.printf("%d to %d         no path\n", s, t);
+            }
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DirectedCycle.java b/src/main/java/edu/princeton/cs/algs4/DirectedCycle.java
new file mode 100644
index 0000000..b30660e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DirectedCycle.java
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *  Compilation:  javac DirectedCycle.java
+ *  Execution:    java DirectedCycle input.txt
+ *  Dependencies: Digraph.java Stack.java StdOut.java In.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/tinyDAG.txt
+ *
+ *  Finds a directed cycle in a digraph.
+ *
+ *  % java DirectedCycle tinyDG.txt 
+ *  Directed cycle: 3 5 4 3 
+ *
+ *  %  java DirectedCycle tinyDAG.txt 
+ *  No directed cycle
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DirectedCycle} class represents a data type for 
+ *  determining whether a digraph has a directed cycle.
+ *  The <em>hasCycle</em> operation determines whether the digraph has
+ *  a simple directed cycle and, if so, the <em>cycle</em> operation
+ *  returns one.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the worst
+ *  case, where <em>V</em> is the number of vertices and <em>E</em> is
+ *  the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  See {@link Topological} to compute a topological order if the
+ *  digraph is acyclic.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DirectedCycle {
+    private boolean[] marked;        // marked[v] = has vertex v been marked?
+    private int[] edgeTo;            // edgeTo[v] = previous vertex on path to v
+    private boolean[] onStack;       // onStack[v] = is vertex on the stack?
+    private Stack<Integer> cycle;    // directed cycle (or null if no such cycle)
+
+    /**
+     * Determines whether the digraph {@code G} has a directed cycle and, if so,
+     * finds such a cycle.
+     * @param G the digraph
+     */
+    public DirectedCycle(Digraph G) {
+        marked  = new boolean[G.V()];
+        onStack = new boolean[G.V()];
+        edgeTo  = new int[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            if (!marked[v] && cycle == null) dfs(G, v);
+    }
+
+    // run DFS and find a directed cycle (if one exists)
+    private void dfs(Digraph G, int v) {
+        onStack[v] = true;
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+
+            // short circuit if directed cycle found
+            if (cycle != null) return;
+
+            // found new vertex, so recur
+            else if (!marked[w]) {
+                edgeTo[w] = v;
+                dfs(G, w);
+            }
+
+            // trace back directed cycle
+            else if (onStack[w]) {
+                cycle = new Stack<Integer>();
+                for (int x = v; x != w; x = edgeTo[x]) {
+                    cycle.push(x);
+                }
+                cycle.push(w);
+                cycle.push(v);
+                assert check();
+            }
+        }
+        onStack[v] = false;
+    }
+
+    /**
+     * Does the digraph have a directed cycle?
+     * @return {@code true} if the digraph has a directed cycle, {@code false} otherwise
+     */
+    public boolean hasCycle() {
+        return cycle != null;
+    }
+
+    /**
+     * Returns a directed cycle if the digraph has a directed cycle, and {@code null} otherwise.
+     * @return a directed cycle (as an iterable) if the digraph has a directed cycle,
+     *    and {@code null} otherwise
+     */
+    public Iterable<Integer> cycle() {
+        return cycle;
+    }
+
+
+    // certify that digraph has a directed cycle if it reports one
+    private boolean check() {
+
+        if (hasCycle()) {
+            // verify cycle
+            int first = -1, last = -1;
+            for (int v : cycle()) {
+                if (first == -1) first = v;
+                last = v;
+            }
+            if (first != last) {
+                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
+                return false;
+            }
+        }
+
+
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code DirectedCycle} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+
+        DirectedCycle finder = new DirectedCycle(G);
+        if (finder.hasCycle()) {
+            StdOut.print("Directed cycle: ");
+            for (int v : finder.cycle()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+
+        else {
+            StdOut.println("No directed cycle");
+        }
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DirectedCycleX.java b/src/main/java/edu/princeton/cs/algs4/DirectedCycleX.java
new file mode 100644
index 0000000..1e5f054
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DirectedCycleX.java
@@ -0,0 +1,194 @@
+/******************************************************************************
+ *  Compilation:  javac DirectedCycleX.java
+ *  Execution:    java DirectedCycleX V E F
+ *  Dependencies: Queue.java Digraph.java Stack.java
+ *
+ *  Find a directed cycle in a digraph, using a nonrecursive, queue-based
+ *  algorithm. Runs in O(E + V) time.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DirectedCycleX} class represents a data type for 
+ *  determining whether a digraph has a directed cycle.
+ *  The <em>hasCycle</em> operation determines whether the digraph has
+ *  a simple directed cycle and, if so, the <em>cycle</em> operation
+ *  returns one.
+ *  <p>
+ *  This implementation uses a nonrecursive, queue-based algorithm.
+ *  The constructor takes time proportional to <em>V</em> + <em>E</em>
+ *  (in the worst case),
+ *  where <em>V</em> is the number of vertices and <em>E</em> is the
+ *  number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  See {@link DirectedCycle} for a recursive version that uses depth-first search.
+ *  See {@link Topological} or {@link TopologicalX} to compute a topological order
+ *  when the digraph is acyclic.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class DirectedCycleX {
+    private Stack<Integer> cycle;     // the directed cycle; null if digraph is acyclic
+
+    public DirectedCycleX(Digraph G) {
+
+        // indegrees of remaining vertices
+        int[] indegree = new int[G.V()];
+        for (int v = 0; v < G.V(); v++) {
+            indegree[v] = G.indegree(v);
+        }
+
+        // initialize queue to contain all vertices with indegree = 0
+        Queue<Integer> queue = new Queue<Integer>();
+        for (int v = 0; v < G.V(); v++)
+            if (indegree[v] == 0) queue.enqueue(v);
+
+        while (!queue.isEmpty()) {
+            int v = queue.dequeue();
+            for (int w : G.adj(v)) {
+                indegree[w]--;
+                if (indegree[w] == 0) queue.enqueue(w);
+            }
+        }
+
+        // there is a directed cycle in subgraph of vertices with indegree >= 1.
+        int[] edgeTo = new int[G.V()];
+        int root = -1;  // any vertex with indegree >= -1
+        for (int v = 0; v < G.V(); v++) {
+            if (indegree[v] == 0) continue;
+            else root = v;
+            for (int w : G.adj(v)) {
+                if (indegree[w] > 0) {
+                    edgeTo[w] = v;
+                }
+            }
+        }
+
+        if (root != -1) {
+
+            // find any vertex on cycle
+            boolean[] visited = new boolean[G.V()];
+            while (!visited[root]) {
+                visited[root] = true;
+                root = edgeTo[root];
+            }
+
+            // extract cycle
+            cycle = new Stack<Integer>();
+            int v = root;
+            do {
+                cycle.push(v);
+                v = edgeTo[v];
+            } while (v != root);
+            cycle.push(root);
+        }
+
+        assert check();
+    }
+
+    /**
+     * Returns a directed cycle if the digraph has a directed cycle, and {@code null} otherwise.
+     * @return a directed cycle (as an iterable) if the digraph has a directed cycle,
+     *    and {@code null} otherwise
+     */
+    public Iterable<Integer> cycle() {
+        return cycle;
+    }
+
+    /**
+     * Does the digraph have a directed cycle?
+     * @return {@code true} if the digraph has a directed cycle, {@code false} otherwise
+     */
+    public boolean hasCycle() {
+        return cycle != null;
+    }
+
+    // certify that digraph has a directed cycle if it reports one
+    private boolean check() {
+
+        if (hasCycle()) {
+            // verify cycle
+            int first = -1, last = -1;
+            for (int v : cycle()) {
+                if (first == -1) first = v;
+                last = v;
+            }
+            if (first != last) {
+                System.err.printf("cycle begins with %d and ends with %d\n", first, last);
+                return false;
+            }
+        }
+
+
+        return true;
+    }
+
+
+    public static void main(String[] args) {
+
+        // create random DAG with V vertices and E edges; then add F random edges
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        int F = Integer.parseInt(args[2]);
+        Digraph G = DigraphGenerator.dag(V, E);
+
+        // add F extra edges
+        for (int i = 0; i < F; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            G.addEdge(v, w);
+        }
+
+        StdOut.println(G);
+
+
+        DirectedCycleX finder = new DirectedCycleX(G);
+        if (finder.hasCycle()) {
+            StdOut.print("Directed cycle: ");
+            for (int v : finder.cycle()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+
+        else {
+            StdOut.println("No directed cycle");
+        }
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DirectedDFS.java b/src/main/java/edu/princeton/cs/algs4/DirectedDFS.java
new file mode 100644
index 0000000..2ffc419
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DirectedDFS.java
@@ -0,0 +1,188 @@
+/******************************************************************************
+ *  Compilation:  javac DirectedDFS.java
+ *  Execution:    java DirectedDFS digraph.txt s
+ *  Dependencies: Digraph.java Bag.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Determine single-source or multiple-source reachability in a digraph
+ *  using depth first search.
+ *  Runs in O(E + V) time.
+ *
+ *  % java DirectedDFS tinyDG.txt 1
+ *  1
+ *
+ *  % java DirectedDFS tinyDG.txt 2
+ *  0 1 2 3 4 5
+ *
+ *  % java DirectedDFS tinyDG.txt 1 2 6
+ *  0 1 2 3 4 5 6 8 9 10 11 12 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+/**
+ *  The {@code DirectedDFS} class represents a data type for 
+ *  determining the vertices reachable from a given source vertex <em>s</em>
+ *  (or set of source vertices) in a digraph. For versions that find the paths,
+ *  see {@link DepthFirstDirectedPaths} and {@link BreadthFirstDirectedPaths}.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes time proportional to <em>V</em> + <em>E</em>
+ *  (in the worst case),
+ *  where <em>V</em> is the number of vertices and <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DirectedDFS {
+    private boolean[] marked;  // marked[v] = true iff v is reachable from source(s)
+    private int count;         // number of vertices reachable from source(s)
+
+    /**
+     * Computes the vertices in digraph {@code G} that are
+     * reachable from the source vertex {@code s}.
+     * @param G the digraph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public DirectedDFS(Digraph G, int s) {
+        marked = new boolean[G.V()];
+        validateVertex(s);
+        dfs(G, s);
+    }
+
+    /**
+     * Computes the vertices in digraph {@code G} that are
+     * connected to any of the source vertices {@code sources}.
+     * @param G the graph
+     * @param sources the source vertices
+     * @throws IllegalArgumentException if {@code sources} is {@code null}
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     *         for each vertex {@code s} in {@code sources}
+     */
+    public DirectedDFS(Digraph G, Iterable<Integer> sources) {
+        marked = new boolean[G.V()];
+        validateVertices(sources);
+        for (int v : sources) {
+            if (!marked[v]) dfs(G, v);
+        }
+    }
+
+    private void dfs(Digraph G, int v) { 
+        count++;
+        marked[v] = true;
+        for (int w : G.adj(v)) {
+            if (!marked[w]) dfs(G, w);
+        }
+    }
+
+    /**
+     * Is there a directed path from the source vertex (or any
+     * of the source vertices) and vertex {@code v}?
+     * @param  v the vertex
+     * @return {@code true} if there is a directed path, {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean marked(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    /**
+     * Returns the number of vertices reachable from the source vertex
+     * (or source vertices).
+     * @return the number of vertices reachable from the source vertex
+     *   (or source vertices)
+     */
+    public int count() {
+        return count;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    // throw an IllegalArgumentException if vertices is null, has zero vertices,
+    // or has a vertex not between 0 and V-1
+    private void validateVertices(Iterable<Integer> vertices) {
+        if (vertices == null) {
+            throw new IllegalArgumentException("argument is null");
+        }
+        int V = marked.length;
+        int count = 0;
+        for (Integer v : vertices) {
+            count++;
+            if (v == null) {
+                throw new IllegalArgumentException("vertex is null");
+            }
+            validateVertex(v);
+        }
+        if (count == 0) {
+            throw new IllegalArgumentException("zero vertices");
+        }
+    }
+
+    /**
+     * Unit tests the {@code DirectedDFS} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read in digraph from command-line argument
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+
+        // read in sources from command-line arguments
+        Bag<Integer> sources = new Bag<Integer>();
+        for (int i = 1; i < args.length; i++) {
+            int s = Integer.parseInt(args[i]);
+            sources.add(s);
+        }
+
+        // multiple-source reachability
+        DirectedDFS dfs = new DirectedDFS(G, sources);
+
+        // print out vertices reachable from sources
+        for (int v = 0; v < G.V(); v++) {
+            if (dfs.marked(v)) StdOut.print(v + " ");
+        }
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DirectedEdge.java b/src/main/java/edu/princeton/cs/algs4/DirectedEdge.java
new file mode 100644
index 0000000..ed8f67a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DirectedEdge.java
@@ -0,0 +1,115 @@
+/******************************************************************************
+ *  Compilation:  javac DirectedEdge.java
+ *  Execution:    java DirectedEdge
+ *  Dependencies: StdOut.java
+ *
+ *  Immutable weighted directed edge.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+/**
+ *  The {@code DirectedEdge} class represents a weighted edge in an 
+ *  {@link EdgeWeightedDigraph}. Each edge consists of two integers
+ *  (naming the two vertices) and a real-value weight. The data type
+ *  provides methods for accessing the two endpoints of the directed edge and
+ *  the weight.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class DirectedEdge { 
+    private final int v;
+    private final int w;
+    private final double weight;
+
+    /**
+     * Initializes a directed edge from vertex {@code v} to vertex {@code w} with
+     * the given {@code weight}.
+     * @param v the tail vertex
+     * @param w the head vertex
+     * @param weight the weight of the directed edge
+     * @throws IllegalArgumentException if either {@code v} or {@code w}
+     *    is a negative integer
+     * @throws IllegalArgumentException if {@code weight} is {@code NaN}
+     */
+    public DirectedEdge(int v, int w, double weight) {
+        if (v < 0) throw new IllegalArgumentException("Vertex names must be non-negative integers");
+        if (w < 0) throw new IllegalArgumentException("Vertex names must be non-negative integers");
+        if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
+        this.v = v;
+        this.w = w;
+        this.weight = weight;
+    }
+
+    /**
+     * Returns the tail vertex of the directed edge.
+     * @return the tail vertex of the directed edge
+     */
+    public int from() {
+        return v;
+    }
+
+    /**
+     * Returns the head vertex of the directed edge.
+     * @return the head vertex of the directed edge
+     */
+    public int to() {
+        return w;
+    }
+
+    /**
+     * Returns the weight of the directed edge.
+     * @return the weight of the directed edge
+     */
+    public double weight() {
+        return weight;
+    }
+
+    /**
+     * Returns a string representation of the directed edge.
+     * @return a string representation of the directed edge
+     */
+    public String toString() {
+        return v + "->" + w + " " + String.format("%5.2f", weight);
+    }
+
+    /**
+     * Unit tests the {@code DirectedEdge} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        DirectedEdge e = new DirectedEdge(12, 34, 5.67);
+        StdOut.println(e);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DirectedEulerianCycle.java b/src/main/java/edu/princeton/cs/algs4/DirectedEulerianCycle.java
new file mode 100644
index 0000000..fc6679f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DirectedEulerianCycle.java
@@ -0,0 +1,276 @@
+/******************************************************************************
+ *  Compilation:  javac DirectedEulerianCycle.java
+ *  Execution:    java DirectedEulerianCycle V E
+ *  Dependencies: Digraph.java Stack.java StdOut.java
+ *                BreadthFirstPaths.java
+ *                DigraphGenerator.java StdRandom.java
+ *
+ *  Find an Eulerian cycle in a digraph, if one exists.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code DirectedEulerianCycle} class represents a data type
+ *  for finding an Eulerian cycle or path in a digraph.
+ *  An <em>Eulerian cycle</em> is a cycle (not necessarily simple) that
+ *  uses every edge in the digraph exactly once.
+ *  <p>
+ *  This implementation uses a nonrecursive depth-first search.
+ *  The constructor takes &Theta;(<em>E</em> + <em>V</em>) time in the worst
+ *  case, where <em>E</em> is the number of edges and <em>V</em> is the
+ *  number of vertices
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  To compute Eulerian paths in digraphs, see {@link DirectedEulerianPath}.
+ *  To compute Eulerian cycles and paths in undirected graphs, see
+ *  {@link EulerianCycle} and {@link EulerianPath}.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ * 
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *  @author Nate Liu
+ */
+public class DirectedEulerianCycle {
+    private Stack<Integer> cycle = null;  // Eulerian cycle; null if no such cylce
+
+    /**
+     * Computes an Eulerian cycle in the specified digraph, if one exists.
+     * 
+     * @param G the digraph
+     */
+    public DirectedEulerianCycle(Digraph G) {
+
+        // must have at least one edge
+        if (G.E() == 0) return;
+
+        // necessary condition: indegree(v) = outdegree(v) for each vertex v
+        // (without this check, DFS might return a path instead of a cycle)
+        for (int v = 0; v < G.V(); v++)
+            if (G.outdegree(v) != G.indegree(v))
+                return;
+
+        // create local view of adjacency lists, to iterate one vertex at a time
+        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            adj[v] = G.adj(v).iterator();
+
+        // initialize stack with any non-isolated vertex
+        int s = nonIsolatedVertex(G);
+        Stack<Integer> stack = new Stack<Integer>();
+        stack.push(s);
+
+        // greedily add to putative cycle, depth-first search style
+        cycle = new Stack<Integer>();
+        while (!stack.isEmpty()) {
+            int v = stack.pop();
+            while (adj[v].hasNext()) {
+                stack.push(v);
+                v = adj[v].next();
+            }
+            // add vertex with no more leaving edges to cycle
+            cycle.push(v);
+        }
+
+        // check if all edges have been used
+        // (in case there are two or more vertex-disjoint Eulerian cycles)
+        if (cycle.size() != G.E() + 1)
+            cycle = null;
+
+        assert certifySolution(G);
+    }
+
+    /**
+     * Returns the sequence of vertices on an Eulerian cycle.
+     * 
+     * @return the sequence of vertices on an Eulerian cycle;
+     *         {@code null} if no such cycle
+     */
+    public Iterable<Integer> cycle() {
+        return cycle;
+    }
+
+    /**
+     * Returns true if the digraph has an Eulerian cycle.
+     * 
+     * @return {@code true} if the digraph has an Eulerian cycle;
+     *         {@code false} otherwise
+     */
+    public boolean hasEulerianCycle() {
+        return cycle != null;
+    }
+
+    // returns any non-isolated vertex; -1 if no such vertex
+    private static int nonIsolatedVertex(Digraph G) {
+        for (int v = 0; v < G.V(); v++)
+            if (G.outdegree(v) > 0)
+                return v;
+        return -1;
+    }
+
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // Determines whether a digraph has an Eulerian cycle using necessary
+    // and sufficient conditions (without computing the cycle itself):
+    //    - at least one edge
+    //    - indegree(v) = outdegree(v) for every vertex
+    //    - the graph is connected, when viewed as an undirected graph
+    //      (ignoring isolated vertices)
+    private static boolean satisfiesNecessaryAndSufficientConditions(Digraph G) {
+
+        // Condition 0: at least 1 edge
+        if (G.E() == 0) return false;
+
+        // Condition 1: indegree(v) == outdegree(v) for every vertex
+        for (int v = 0; v < G.V(); v++)
+            if (G.outdegree(v) != G.indegree(v))
+                return false;
+
+        // Condition 2: graph is connected, ignoring isolated vertices
+        Graph H = new Graph(G.V());
+        for (int v = 0; v < G.V(); v++)
+            for (int w : G.adj(v))
+                H.addEdge(v, w);
+        
+        // check that all non-isolated vertices are conneted
+        int s = nonIsolatedVertex(G);
+        BreadthFirstPaths bfs = new BreadthFirstPaths(H, s);
+        for (int v = 0; v < G.V(); v++)
+            if (H.degree(v) > 0 && !bfs.hasPathTo(v))
+                return false;
+
+        return true;
+    }
+
+    // check that solution is correct
+    private boolean certifySolution(Digraph G) {
+
+        // internal consistency check
+        if (hasEulerianCycle() == (cycle() == null)) return false;
+
+        // hashEulerianCycle() returns correct value
+        if (hasEulerianCycle() != satisfiesNecessaryAndSufficientConditions(G)) return false;
+
+        // nothing else to check if no Eulerian cycle
+        if (cycle == null) return true;
+
+        // check that cycle() uses correct number of edges
+        if (cycle.size() != G.E() + 1) return false;
+
+        // check that cycle() is a directed cycle of G
+        // TODO
+
+        return true;
+    }
+
+
+    private static void unitTest(Digraph G, String description) {
+        StdOut.println(description);
+        StdOut.println("-------------------------------------");
+        StdOut.print(G);
+
+        DirectedEulerianCycle euler = new DirectedEulerianCycle(G);
+
+        StdOut.print("Eulerian cycle: ");
+        if (euler.hasEulerianCycle()) {
+            for (int v : euler.cycle()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+        else {
+            StdOut.println("none");
+        }
+        StdOut.println();
+    }
+
+
+    /**
+     * Unit tests the {@code DirectedEulerianCycle} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+
+        // Eulerian cycle
+        Digraph G1 = DigraphGenerator.eulerianCycle(V, E);
+        unitTest(G1, "Eulerian cycle");
+
+        // Eulerian path
+        Digraph G2 = DigraphGenerator.eulerianPath(V, E);
+        unitTest(G2, "Eulerian path");
+
+        // empty digraph
+        Digraph G3 = new Digraph(V);
+        unitTest(G3, "empty digraph");
+
+        // self loop
+        Digraph G4 = new Digraph(V);
+        int v4 = StdRandom.uniform(V);
+        G4.addEdge(v4, v4);
+        unitTest(G4, "single self loop");
+
+        // union of two disjoint cycles
+        Digraph H1 = DigraphGenerator.eulerianCycle(V/2, E/2);
+        Digraph H2 = DigraphGenerator.eulerianCycle(V - V/2, E - E/2);
+        int[] perm = new int[V];
+        for (int i = 0; i < V; i++)
+            perm[i] = i;
+        StdRandom.shuffle(perm);
+        Digraph G5 = new Digraph(V);
+        for (int v = 0; v < H1.V(); v++)
+            for (int w : H1.adj(v))
+                G5.addEdge(perm[v], perm[w]);
+        for (int v = 0; v < H2.V(); v++)
+            for (int w : H2.adj(v))
+                G5.addEdge(perm[V/2 + v], perm[V/2 + w]);
+        unitTest(G5, "Union of two disjoint cycles");
+
+        // random digraph
+        Digraph G6 = DigraphGenerator.simple(V, E);
+        unitTest(G6, "simple digraph");
+
+        // 4-vertex digraph
+        Digraph G7 = new Digraph(new In("eulerianD.txt"));
+        unitTest(G7, "4-vertex Eulerian digraph");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DirectedEulerianPath.java b/src/main/java/edu/princeton/cs/algs4/DirectedEulerianPath.java
new file mode 100644
index 0000000..4c52100
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DirectedEulerianPath.java
@@ -0,0 +1,278 @@
+/******************************************************************************
+ *  Compilation:  javac DirectedEulerianPath.java
+ *  Execution:    java DirectedEulerianPath V E
+ *  Dependencies: Digraph.java Stack.java StdOut.java
+ *                BreadthFirstPaths.java
+ *                DigraphGenerator.java StdRandom.java
+ *
+ *  Find an Eulerian path in a digraph, if one exists.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code DirectedEulerianPath} class represents a data type
+ *  for finding an Eulerian path in a digraph.
+ *  An <em>Eulerian path</em> is a path (not necessarily simple) that
+ *  uses every edge in the digraph exactly once.
+ *  <p>
+ *  This implementation uses a nonrecursive depth-first search.
+ *  The constructor take &Theta;(<em>E</em> + <em>V</em>) time
+ *  in the worst case, where <em>E</em> is the number of edges and
+ *  <em>V</em> is the number of vertices.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph). 
+ *  <p>
+ *  To compute Eulerian cycles in digraphs, see {@link DirectedEulerianCycle}.
+ *  To compute Eulerian cycles and paths in undirected graphs, see
+ *  {@link EulerianCycle} and {@link EulerianPath}.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ * 
+ * @author Robert Sedgewick
+ * @author Kevin Wayne
+ * @author Nate Liu
+ */
+public class DirectedEulerianPath {
+    private Stack<Integer> path = null;   // Eulerian path; null if no suh path
+
+    /**
+     * Computes an Eulerian path in the specified digraph, if one exists.
+     * 
+     * @param G the digraph
+     */
+    public DirectedEulerianPath(Digraph G) {
+
+        // find vertex from which to start potential Eulerian path:
+        // a vertex v with outdegree(v) > indegree(v) if it exits;
+        // otherwise a vertex with outdegree(v) > 0
+        int deficit = 0;
+        int s = nonIsolatedVertex(G);
+        for (int v = 0; v < G.V(); v++) {
+            if (G.outdegree(v) > G.indegree(v)) {
+                deficit += (G.outdegree(v) - G.indegree(v));
+                s = v;
+            }
+        }
+
+        // digraph can't have an Eulerian path
+        // (this condition is needed)
+        if (deficit > 1) return;
+
+        // special case for digraph with zero edges (has a degenerate Eulerian path)
+        if (s == -1) s = 0;
+
+        // create local view of adjacency lists, to iterate one vertex at a time
+        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            adj[v] = G.adj(v).iterator();
+
+        // greedily add to cycle, depth-first search style
+        Stack<Integer> stack = new Stack<Integer>();
+        stack.push(s);
+        path = new Stack<Integer>();
+        while (!stack.isEmpty()) {
+            int v = stack.pop();
+            while (adj[v].hasNext()) {
+                stack.push(v);
+                v = adj[v].next();
+            }
+            // push vertex with no more available edges to path
+            path.push(v);
+        }
+            
+        // check if all edges have been used
+        if (path.size() != G.E() + 1)
+            path = null;
+
+        assert check(G);
+    }
+
+    /**
+     * Returns the sequence of vertices on an Eulerian path.
+     * 
+     * @return the sequence of vertices on an Eulerian path;
+     *         {@code null} if no such path
+     */
+    public Iterable<Integer> path() {
+        return path;
+    }
+
+    /**
+     * Returns true if the digraph has an Eulerian path.
+     * 
+     * @return {@code true} if the digraph has an Eulerian path;
+     *         {@code false} otherwise
+     */
+    public boolean hasEulerianPath() {
+        return path != null;
+    }
+
+
+    // returns any non-isolated vertex; -1 if no such vertex
+    private static int nonIsolatedVertex(Digraph G) {
+        for (int v = 0; v < G.V(); v++)
+            if (G.outdegree(v) > 0)
+                return v;
+        return -1;
+    }
+
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // Determines whether a digraph has an Eulerian path using necessary
+    // and sufficient conditions (without computing the path itself):
+    //    - indegree(v) = outdegree(v) for every vertex,
+    //      except one vertex v may have outdegree(v) = indegree(v) + 1
+    //      (and one vertex v may have indegree(v) = outdegree(v) + 1)
+    //    - the graph is connected, when viewed as an undirected graph
+    //      (ignoring isolated vertices)
+    private static boolean satisfiesNecessaryAndSufficientConditions(Digraph G) {
+        if (G.E() == 0) return true;
+
+        // Condition 1: indegree(v) == outdegree(v) for every vertex,
+        // except one vertex may have outdegree(v) = indegree(v) + 1
+        int deficit = 0;
+        for (int v = 0; v < G.V(); v++)
+            if (G.outdegree(v) > G.indegree(v))
+                deficit += (G.outdegree(v) - G.indegree(v));
+        if (deficit > 1) return false;
+
+        // Condition 2: graph is connected, ignoring isolated vertices
+        Graph H = new Graph(G.V());
+        for (int v = 0; v < G.V(); v++)
+            for (int w : G.adj(v))
+                H.addEdge(v, w);
+        
+        // check that all non-isolated vertices are connected
+        int s = nonIsolatedVertex(G);
+        BreadthFirstPaths bfs = new BreadthFirstPaths(H, s);
+        for (int v = 0; v < G.V(); v++)
+            if (H.degree(v) > 0 && !bfs.hasPathTo(v))
+                return false;
+
+        return true;
+    }
+
+
+    private boolean check(Digraph G) {
+
+        // internal consistency check
+        if (hasEulerianPath() == (path() == null)) return false;
+
+        // hashEulerianPath() returns correct value
+        if (hasEulerianPath() != satisfiesNecessaryAndSufficientConditions(G)) return false;
+
+        // nothing else to check if no Eulerian path
+        if (path == null) return true;
+
+        // check that path() uses correct number of edges
+        if (path.size() != G.E() + 1) return false;
+
+        // check that path() is a directed path in G
+        // TODO
+
+        return true;
+    }
+
+
+    private static void unitTest(Digraph G, String description) {
+        StdOut.println(description);
+        StdOut.println("-------------------------------------");
+        StdOut.print(G);
+
+        DirectedEulerianPath euler = new DirectedEulerianPath(G);
+
+        StdOut.print("Eulerian path:  ");
+        if (euler.hasEulerianPath()) {
+            for (int v : euler.path()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+        else {
+            StdOut.println("none");
+        }
+        StdOut.println();
+    }
+
+    /**
+     * Unit tests the {@code DirectedEulerianPath} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+
+
+        // Eulerian cycle
+        Digraph G1 = DigraphGenerator.eulerianCycle(V, E);
+        unitTest(G1, "Eulerian cycle");
+
+        // Eulerian path
+        Digraph G2 = DigraphGenerator.eulerianPath(V, E);
+        unitTest(G2, "Eulerian path");
+
+        // add one random edge
+        Digraph G3 = new Digraph(G2);
+        G3.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
+        unitTest(G3, "one random edge added to Eulerian path");
+
+        // self loop
+        Digraph G4 = new Digraph(V);
+        int v4 = StdRandom.uniform(V);
+        G4.addEdge(v4, v4);
+        unitTest(G4, "single self loop");
+
+        // single edge
+        Digraph G5 = new Digraph(V);
+        G5.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
+        unitTest(G5, "single edge");
+
+        // empty digraph
+        Digraph G6 = new Digraph(V);
+        unitTest(G6, "empty digraph");
+
+        // random digraph
+        Digraph G7 = DigraphGenerator.simple(V, E);
+        unitTest(G7, "simple digraph");
+
+        // 4-vertex digraph
+        Digraph G8 = new Digraph(new In("eulerianD.txt"));
+        unitTest(G8, "4-vertex Eulerian digraph");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DoublingRatio.java b/src/main/java/edu/princeton/cs/algs4/DoublingRatio.java
new file mode 100644
index 0000000..97141c0
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DoublingRatio.java
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *  Compilation:  javac DoublingRatio.java
+ *  Execution:    java DoublingRatio
+ *  Dependencies: ThreeSum.java Stopwatch.java StdRandom.java StdOut.java
+ *
+ *
+ *  % java DoublingRatio
+ *      250     0.0   2.7
+ *      500     0.0   4.8
+ *     1000     0.1   6.9
+ *     2000     0.6   7.7
+ *     4000     4.5   8.0
+ *     8000    35.7   8.0
+ *     4000     3.9   6.6
+ *  ...
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DoublingRatio} class provides a client for measuring
+ *  the running time of a method using a doubling ratio test.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/14analysis">Section 1.4</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DoublingRatio {
+    private static final int MAXIMUM_INTEGER = 1000000;
+
+    // This class should not be instantiated.
+    private DoublingRatio() { }
+
+    /**
+     * Returns the amount of time to call {@code ThreeSum.count()} with <em>n</em>
+     * random 6-digit integers.
+     * @param n the number of integers
+     * @return amount of time (in seconds) to call {@code ThreeSum.count()}
+     *   with <em>n</em> random 6-digit integers
+     */
+    public static double timeTrial(int n) {
+        int[] a = new int[n];
+        for (int i = 0; i < n; i++) {
+            a[i] = StdRandom.uniform(-MAXIMUM_INTEGER, MAXIMUM_INTEGER);
+        }
+        Stopwatch timer = new Stopwatch();
+        ThreeSum.count(a);
+        return timer.elapsedTime();
+    }
+
+    /**
+     * Prints table of running times to call {@code ThreeSum.count()}
+     * for arrays of size 250, 500, 1000, 2000, and so forth, along
+     * with ratios of running times between successive array sizes.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        double prev = timeTrial(125);
+        for (int n = 250; true; n += n) {
+            double time = timeTrial(n);
+            StdOut.printf("%7d %7.1f %5.1f\n", n, time, time/prev);
+            prev = time;
+        } 
+    } 
+} 
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DoublingTest.java b/src/main/java/edu/princeton/cs/algs4/DoublingTest.java
new file mode 100644
index 0000000..d2d2564
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DoublingTest.java
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *  Compilation:  javac DoublingTest.java
+ *  Execution:    java DoublingTest
+ *  Dependencies: ThreeSum.java Stopwatch.java StdRandom.java StdOut.java
+ *
+ *  % java DoublingTest 
+ *      250     0.0
+ *      500     0.0
+ *     1000     0.1
+ *     2000     0.6
+ *     4000     4.5
+ *     8000    35.7
+ *  ...
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code DoublingTest} class provides a client for measuring
+ *  the running time of a method using a doubling test.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/14analysis">Section 1.4</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class DoublingTest {
+    private static final int MAXIMUM_INTEGER = 1000000;
+
+    // This class should not be instantiated.
+    private DoublingTest() { }
+
+    /**
+     * Returns the amount of time to call {@code ThreeSum.count()} with <em>n</em>
+     * random 6-digit integers.
+     * @param n the number of integers
+     * @return amount of time (in seconds) to call {@code ThreeSum.count()}
+     *   with <em>n</em> random 6-digit integers
+     */
+    public static double timeTrial(int n) {
+        int[] a = new int[n];
+        for (int i = 0; i < n; i++) {
+            a[i] = StdRandom.uniform(-MAXIMUM_INTEGER, MAXIMUM_INTEGER);
+        }
+        Stopwatch timer = new Stopwatch();
+        ThreeSum.count(a);
+        return timer.elapsedTime();
+    }
+
+    /**
+     * Prints table of running times to call {@code ThreeSum.count()}
+     * for arrays of size 250, 500, 1000, 2000, and so forth.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        for (int n = 250; true; n += n) {
+            double time = timeTrial(n);
+            StdOut.printf("%7d %7.1f\n", n, time);
+        } 
+    } 
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Draw.java b/src/main/java/edu/princeton/cs/algs4/Draw.java
new file mode 100644
index 0000000..0175d4e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Draw.java
@@ -0,0 +1,1718 @@
+/******************************************************************************
+ *  Compilation:  javac Draw.java
+ *  Execution:    java Draw
+ *  Dependencies: none
+ *
+ *  Drawing library. This class provides a basic capability for creating
+ *  drawings with your programs. It uses a simple graphics model that
+ *  allows you to create drawings consisting of points, lines, and curves
+ *  in a window on your computer and to save the drawings to a file.
+ *  This is the object-oriented version of standard draw; it supports
+ *  multiple indepedent drawing windows.
+ *
+ *  Todo
+ *  ----
+ *    -  Add support for gradient fill, etc.
+ *
+ *  Remarks
+ *  -------
+ *    -  don't use AffineTransform for rescaling since it inverts
+ *       images and strings
+ *    -  careful using setFont in inner loop within an animation -
+ *       it can cause flicker
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.FileDialog;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Image;
+import java.awt.MediaTracker;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+
+import java.awt.geom.Arc2D;
+import java.awt.geom.Ellipse2D;
+import java.awt.geom.GeneralPath;
+import java.awt.geom.Line2D;
+import java.awt.geom.Rectangle2D;
+
+import java.awt.image.BufferedImage;
+import java.awt.image.DirectColorModel;
+import java.awt.image.WritableRaster;
+
+import java.io.File;
+import java.io.IOException;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.TreeSet;
+
+import javax.imageio.ImageIO;
+
+import javax.swing.ImageIcon;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.KeyStroke;
+
+/**
+ *  <i>Draw</i>. This class provides a basic capability for
+ *  creating drawings with your programs. It uses a simple graphics model that
+ *  allows you to create drawings consisting of points, lines, and curves
+ *  in a window on your computer and to save the drawings to a file.
+ *  This is the object-oriented version of standard draw; it supports
+ *  multiple indepedent drawing windows.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class Draw implements ActionListener, MouseListener, MouseMotionListener, KeyListener {
+
+    /**
+     *  The color black.
+     */
+    public static final Color BLACK = Color.BLACK;
+
+    /**
+     *  The color blue.
+     */
+    public static final Color BLUE = Color.BLUE;
+
+    /**
+     *  The color cyan.
+     */
+    public static final Color CYAN = Color.CYAN;
+
+    /**
+     *  The color dark gray.
+     */
+    public static final Color DARK_GRAY = Color.DARK_GRAY;
+
+    /**
+     *  The color gray.
+     */
+    public static final Color GRAY = Color.GRAY;
+
+    /**
+     *  The color green.
+     */
+    public static final Color GREEN  = Color.GREEN;
+
+    /**
+     *  The color light gray.
+     */
+    public static final Color LIGHT_GRAY = Color.LIGHT_GRAY;
+
+    /**
+     *  The color magenta.
+     */
+    public static final Color MAGENTA = Color.MAGENTA;
+
+    /**
+     *  The color orange.
+     */
+    public static final Color ORANGE = Color.ORANGE;
+
+    /**
+     *  The color pink.
+     */
+    public static final Color PINK = Color.PINK;
+
+    /**
+     *  The color red.
+     */
+    public static final Color RED = Color.RED;
+
+    /**
+     *  The color white.
+     */
+    public static final Color WHITE = Color.WHITE;
+
+    /**
+     *  The color yellow.
+     */
+    public static final Color YELLOW = Color.YELLOW;
+
+    /**
+     * Shade of blue used in Introduction to Programming in Java.
+     * It is Pantone 300U. The RGB values are approximately (9, 90, 166).
+     */
+    public static final Color BOOK_BLUE = new Color(9, 90, 166);
+
+    /**
+     * Shade of light blue used in Introduction to Programming in Java.
+     * The RGB values are approximately (103, 198, 243).
+     */
+    public static final Color BOOK_LIGHT_BLUE = new Color(103, 198, 243);
+    
+    /**
+     * Shade of red used in <em>Algorithms, 4th edition</em>.
+     * It is Pantone 1805U. The RGB values are approximately (150, 35, 31).
+     */
+    public static final Color BOOK_RED = new Color(150, 35, 31);
+
+    /**
+     * Shade of orange used in Princeton's identity.
+     * It is PMS 158. The RGB values are approximately (245, 128, 37).
+     */
+    public static final Color PRINCETON_ORANGE = new Color(245, 128, 37);
+
+    // default colors
+    private static final Color DEFAULT_PEN_COLOR   = BLACK;
+    private static final Color DEFAULT_CLEAR_COLOR = WHITE;
+
+    // boundary of drawing canvas, 0% border
+    private static final double BORDER = 0.0;
+    private static final double DEFAULT_XMIN = 0.0;
+    private static final double DEFAULT_XMAX = 1.0;
+    private static final double DEFAULT_YMIN = 0.0;
+    private static final double DEFAULT_YMAX = 1.0;
+
+    // default canvas size is SIZE-by-SIZE
+    private static final int DEFAULT_SIZE = 512;
+
+    // default pen radius
+    private static final double DEFAULT_PEN_RADIUS = 0.002;
+
+    // default font
+    private static final Font DEFAULT_FONT = new Font("SansSerif", Font.PLAIN, 16);
+
+    // current pen color
+    private Color penColor;
+
+    // canvas size
+    private int width  = DEFAULT_SIZE;
+    private int height = DEFAULT_SIZE;
+
+    // current pen radius
+    private double penRadius;
+
+    // show we draw immediately or wait until next show?
+    private boolean defer = false;
+
+    private double xmin, ymin, xmax, ymax;
+
+    // name of window
+    private String name = "Draw";
+
+    // for synchronization
+    private final Object mouseLock = new Object();
+    private final Object keyLock = new Object();
+
+    // current font
+    private Font font;
+
+    // the JLabel for drawing
+    private JLabel draw;
+
+    // double buffered graphics
+    private BufferedImage offscreenImage, onscreenImage;
+    private Graphics2D offscreen, onscreen;
+
+    // the frame for drawing to the screen
+    private JFrame frame = new JFrame();
+
+    // mouse state
+    private boolean isMousePressed = false;
+    private double mouseX = 0;
+    private double mouseY = 0;
+
+    // keyboard state
+    private final LinkedList<Character> keysTyped = new LinkedList<Character>();
+    private final TreeSet<Integer> keysDown = new TreeSet<Integer>();
+
+    // event-based listeners
+    private final ArrayList<DrawListener> listeners = new ArrayList<DrawListener>();
+
+
+    /**
+     * Initializes an empty drawing object with the given name.
+     *
+     * @param name the title of the drawing window.
+     */
+    public Draw(String name) {
+        this.name = name;
+        init();
+    }
+
+    /**
+     * Initializes an empty drawing object.
+     */
+    public Draw() {
+        init();
+    }
+
+    private void init() {
+        if (frame != null) frame.setVisible(false);
+        frame = new JFrame();
+        offscreenImage = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_ARGB);
+        onscreenImage  = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_ARGB);
+        offscreen = offscreenImage.createGraphics();
+        onscreen  = onscreenImage.createGraphics();
+        offscreen.scale(2.0, 2.0);  // since we made it 2x as big
+
+        setXscale();
+        setYscale();
+        offscreen.setColor(DEFAULT_CLEAR_COLOR);
+        offscreen.fillRect(0, 0, width, height);
+        setPenColor();
+        setPenRadius();
+        setFont();
+        clear();
+
+        // add antialiasing
+        RenderingHints hints = new RenderingHints(RenderingHints.KEY_ANTIALIASING,
+                                                  RenderingHints.VALUE_ANTIALIAS_ON);
+        hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
+        offscreen.addRenderingHints(hints);
+
+        // frame stuff
+        RetinaImageIcon icon = new RetinaImageIcon(onscreenImage);
+        draw = new JLabel(icon);
+
+        draw.addMouseListener(this);
+        draw.addMouseMotionListener(this);
+
+        frame.setContentPane(draw);
+        frame.addKeyListener(this);    // JLabel cannot get keyboard focus
+        frame.setResizable(false);
+        // frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            // closes all windows
+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);      // closes only current window
+        frame.setFocusTraversalKeysEnabled(false);  // to recognize VK_TAB with isKeyPressed()
+        frame.setTitle(name);
+        frame.setJMenuBar(createMenuBar());
+        frame.pack();
+        frame.requestFocusInWindow();
+        frame.setVisible(true);
+    }
+
+
+    /**
+     * Sets the upper-left hand corner of the drawing window to be (x, y), where (0, 0) is upper left.
+     *
+     * @param  x the number of pixels from the left
+     * @param  y the number of pixels from the top
+     * @throws IllegalArgumentException if the width or height is 0 or negative
+     */
+    public void setLocationOnScreen(int x, int y) {
+        if (x <= 0 || y <= 0) throw new IllegalArgumentException();
+        frame.setLocation(x, y);
+    }
+
+    /**
+     * Sets the default close operation.
+     *
+     * @param  value the value, typically {@code JFrame.EXIT_ON_CLOSE}
+     *         (close all windows) or {@code JFrame.DISPOSE_ON_CLOSE}
+     *         (close current window)
+     */
+    public void setDefaultCloseOperation(int value) {
+        frame.setDefaultCloseOperation(value);
+    }
+       
+
+    /**
+     * Sets the canvas (drawing area) to be <em>width</em>-by-<em>height</em> pixels.
+     * This also erases the current drawing and resets the coordinate system, pen radius,
+     * pen color, and font back to their default values.
+     * Ordinarly, this method is called once, at the very beginning of a program.
+     *
+     * @param  canvasWidth the width as a number of pixels
+     * @param  canvasHeight the height as a number of pixels
+     * @throws IllegalArgumentException unless both {@code canvasWidth}
+     *         and {@code canvasHeight} are positive
+     */
+    public void setCanvasSize(int canvasWidth, int canvasHeight) {
+        if (canvasWidth < 1 || canvasHeight < 1) {
+            throw new IllegalArgumentException("width and height must be positive");
+        }
+        width = canvasWidth;
+        height = canvasHeight;
+        init();
+    }
+
+
+    // create the menu bar (changed to private)
+    private JMenuBar createMenuBar() {
+        JMenuBar menuBar = new JMenuBar();
+        JMenu menu = new JMenu("File");
+        menuBar.add(menu);
+        JMenuItem menuItem1 = new JMenuItem(" Save...   ");
+        menuItem1.addActionListener(this);
+        // Java 10+: replace getMenuShortcutKeyMask() with getMenuShortcutKeyMaskEx()
+        menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,
+                                Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
+        menu.add(menuItem1);
+        return menuBar;
+    }
+
+
+   /***************************************************************************
+    *  User and screen coordinate systems.
+    ***************************************************************************/
+
+    // throw an IllegalArgumentException if x is NaN or infinite
+    private static void validate(double x, String name) {
+        if (Double.isNaN(x)) throw new IllegalArgumentException(name + " is NaN");
+        if (Double.isInfinite(x)) throw new IllegalArgumentException(name + " is infinite");
+    }
+
+    // throw an IllegalArgumentException if s is null
+    private static void validateNonnegative(double x, String name) {
+        if (x < 0) throw new IllegalArgumentException(name + " negative");
+    }
+
+    // throw an IllegalArgumentException if s is null
+    private static void validateNotNull(Object x, String name) {
+        if (x == null) throw new IllegalArgumentException(name + " is null");
+    }
+
+    /**
+     * Sets the x-scale to be the default (between 0.0 and 1.0).
+     */
+    public void setXscale() {
+        setXscale(DEFAULT_XMIN, DEFAULT_XMAX);
+    }
+
+    /**
+     * Sets the y-scale to be the default (between 0.0 and 1.0).
+     */
+    public void setYscale() {
+        setYscale(DEFAULT_YMIN, DEFAULT_YMAX);
+    }
+
+    /**
+     * Sets the x-scale.
+     *
+     * @param min the minimum value of the x-scale
+     * @param max the maximum value of the x-scale
+     * @throws IllegalArgumentException if {@code (max == min)}
+     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite
+     */
+    public void setXscale(double min, double max) {
+        validate(min, "min");
+        validate(max, "max");
+        double size = max - min;
+        if (size == 0.0) throw new IllegalArgumentException("the min and max are the same");
+        xmin = min - BORDER * size;
+        xmax = max + BORDER * size;
+    }
+
+    /**
+     * Sets the y-scale.
+     *
+     * @param min the minimum value of the y-scale
+     * @param max the maximum value of the y-scale
+     * @throws IllegalArgumentException if {@code (max == min)}
+     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite
+     */
+    public void setYscale(double min, double max) {
+        validate(min, "min");
+        validate(max, "max");
+        double size = max - min;
+        if (size == 0.0) throw new IllegalArgumentException("the min and max are the same");
+        ymin = min - BORDER * size;
+        ymax = max + BORDER * size;
+    }
+
+    // helper functions that scale from user coordinates to screen coordinates and back
+    private double  scaleX(double x) { return width  * (x - xmin) / (xmax - xmin); }
+    private double  scaleY(double y) { return height * (ymax - y) / (ymax - ymin); }
+    private double factorX(double w) { return w * width  / Math.abs(xmax - xmin);  }
+    private double factorY(double h) { return h * height / Math.abs(ymax - ymin);  }
+    private double   userX(double x) { return xmin + x * (xmax - xmin) / width;    }
+    private double   userY(double y) { return ymax - y * (ymax - ymin) / height;   }
+
+
+    /**
+     * Clears the screen to the default color (white).
+     */
+    public void clear() {
+        clear(DEFAULT_CLEAR_COLOR);
+    }
+
+    /**
+     * Clears the screen to the given color.
+     *
+     * @param color the color to make the background
+     * @throws IllegalArgumentException if {@code color} is {@code null}
+     */
+    public void clear(Color color) {
+        validateNotNull(color, "color");
+        offscreen.setColor(color);
+        offscreen.fillRect(0, 0, width, height);
+        offscreen.setColor(penColor);
+        draw();
+    }
+
+    /**
+     * Gets the current pen radius.
+     *
+     * @return the current pen radius
+     */
+    public double getPenRadius() {
+        return penRadius;
+    }
+
+    /**
+     * Sets the pen size to the default (.002).
+     */
+    public void setPenRadius() {
+        setPenRadius(DEFAULT_PEN_RADIUS);
+    }
+
+    /**
+     * Sets the radius of the pen to the given size.
+     *
+     * @param  radius the radius of the pen
+     * @throws IllegalArgumentException if {@code radius} is negative, NaN, or infinite
+     */
+    public void setPenRadius(double radius) {
+        validate(radius, "pen radius");
+        validateNonnegative(radius, "pen radius");
+
+        penRadius = radius * DEFAULT_SIZE;
+        BasicStroke stroke = new BasicStroke((float) penRadius, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
+        // BasicStroke stroke = new BasicStroke((float) penRadius);
+        offscreen.setStroke(stroke);
+    }
+
+    /**
+     * Gets the current pen color.
+     *
+     * @return the current pen color
+     */
+    public Color getPenColor() {
+        return penColor;
+    }
+
+    /**
+     * Sets the pen color to the default color (black).
+     */
+    public void setPenColor() {
+        setPenColor(DEFAULT_PEN_COLOR);
+    }
+
+    /**
+     * Sets the pen color to the given color.
+     *
+     * @param color the color to make the pen
+     * @throws IllegalArgumentException if {@code color} is {@code null}
+     */
+    public void setPenColor(Color color) {
+        validateNotNull(color, "color");
+        penColor = color;
+        offscreen.setColor(penColor);
+    }
+
+    /**
+     * Sets the pen color to the given RGB color.
+     *
+     * @param  red the amount of red (between 0 and 255)
+     * @param  green the amount of green (between 0 and 255)
+     * @param  blue the amount of blue (between 0 and 255)
+     * @throws IllegalArgumentException if {@code red}, {@code green},
+     *         or {@code blue} is outside its prescribed range
+     */
+    public void setPenColor(int red, int green, int blue) {
+        if (red   < 0 || red   >= 256) throw new IllegalArgumentException("red must be between 0 and 255");
+        if (green < 0 || green >= 256) throw new IllegalArgumentException("green must be between 0 and 255");
+        if (blue  < 0 || blue  >= 256) throw new IllegalArgumentException("blue must be between 0 and 255");
+        setPenColor(new Color(red, green, blue));
+    }
+
+
+    /**
+     * Turns on xor mode.
+     */
+    public void xorOn() {
+        offscreen.setXORMode(DEFAULT_CLEAR_COLOR);
+    }
+
+    /**
+     * Turns off xor mode.
+     */
+    public void xorOff() {
+        offscreen.setPaintMode();
+    }
+
+    /**
+     * Gets the current {@code JLabel} for use in some other GUI.
+     *
+     * @return the current {@code JLabel}
+     */
+    public JLabel getJLabel() {
+        return draw;
+    }
+
+    /**
+     * Gets the current font.
+     *
+     * @return the current font
+     */
+    public Font getFont() {
+        return font;
+    }
+
+    /**
+     * Sets the font to the default font (sans serif, 16 point).
+     */
+    public void setFont() {
+        setFont(DEFAULT_FONT);
+    }
+
+    /**
+     * Sets the font to the given value.
+     *
+     * @param font the font
+     * @throws IllegalArgumentException if {@code font} is {@code null}
+     */
+    public void setFont(Font font) {
+        validateNotNull(font, "font");
+        this.font = font;
+    }
+
+
+   /***************************************************************************
+    *  Drawing geometric shapes.
+    ***************************************************************************/
+
+    /**
+     * Draws a line from (x0, y0) to (x1, y1).
+     *
+     * @param x0 the x-coordinate of the starting point
+     * @param y0 the y-coordinate of the starting point
+     * @param x1 the x-coordinate of the destination point
+     * @param y1 the y-coordinate of the destination point
+     * @throws IllegalArgumentException if any coordinate is either NaN or infinite
+     */
+    public void line(double x0, double y0, double x1, double y1) {
+        validate(x0, "x0");
+        validate(y0, "y0");
+        validate(x1, "x1");
+        validate(y1, "y1");
+        offscreen.draw(new Line2D.Double(scaleX(x0), scaleY(y0), scaleX(x1), scaleY(y1)));
+        draw();
+    }
+
+    /**
+     * Draws one pixel at (x, y).
+     *
+     * @param x the x-coordinate of the pixel
+     * @param y the y-coordinate of the pixel
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    private void pixel(double x, double y) {
+        validate(x, "x");
+        validate(y, "y");
+        offscreen.fillRect((int) Math.round(scaleX(x)), (int) Math.round(scaleY(y)), 1, 1);
+    }
+
+    /**
+     * Draws a point at (x, y).
+     *
+     * @param x the x-coordinate of the point
+     * @param y the y-coordinate of the point
+     * @throws IllegalArgumentException if either {@code x} or {@code y} is either NaN or infinite
+     */
+    public void point(double x, double y) {
+        validate(x, "x");
+        validate(y, "y");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double r = penRadius;
+        // double ws = factorX(2*r);
+        // double hs = factorY(2*r);
+        // if (ws <= 1 && hs <= 1) pixel(x, y);
+        if (r <= 1) pixel(x, y);
+        else offscreen.fill(new Ellipse2D.Double(xs - r/2, ys - r/2, r, r));
+        draw();
+    }
+
+    /**
+     * Draws a circle of the specified radius, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the x-coordinate of the center of the circle
+     * @param  y the y-coordinate of the center of the circle
+     * @param  radius the radius of the circle
+     * @throws IllegalArgumentException if {@code radius} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void circle(double x, double y, double radius) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(radius, "radius");
+        validateNonnegative(radius, "radius");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*radius);
+        double hs = factorY(2*radius);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled circle of the specified radius, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the x-coordinate of the center of the circle
+     * @param  y the y-coordinate of the center of the circle
+     * @param  radius the radius of the circle
+     * @throws IllegalArgumentException if {@code radius} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void filledCircle(double x, double y, double radius) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(radius, "radius");
+        validateNonnegative(radius, "radius");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*radius);
+        double hs = factorY(2*radius);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+
+    /**
+     * Draws an ellipse with the specified semimajor and semiminor axes,
+     * centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the ellipse
+     * @param  y the <em>y</em>-coordinate of the center of the ellipse
+     * @param  semiMajorAxis is the semimajor axis of the ellipse
+     * @param  semiMinorAxis is the semiminor axis of the ellipse
+     * @throws IllegalArgumentException if either {@code semiMajorAxis}
+     *         or {@code semiMinorAxis} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void ellipse(double x, double y, double semiMajorAxis, double semiMinorAxis) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(semiMajorAxis, "semimajor axis");
+        validate(semiMinorAxis, "semiminor axis");
+        validateNonnegative(semiMajorAxis, "semimajor axis");
+        validateNonnegative(semiMinorAxis, "semiminor axis");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*semiMajorAxis);
+        double hs = factorY(2*semiMinorAxis);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled ellipse with the specified semimajor and semiminor axes,
+     * centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the ellipse
+     * @param  y the <em>y</em>-coordinate of the center of the ellipse
+     * @param  semiMajorAxis is the semimajor axis of the ellipse
+     * @param  semiMinorAxis is the semiminor axis of the ellipse
+     * @throws IllegalArgumentException if either {@code semiMajorAxis}
+     *         or {@code semiMinorAxis} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void filledEllipse(double x, double y, double semiMajorAxis, double semiMinorAxis) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(semiMajorAxis, "semimajor axis");
+        validate(semiMinorAxis, "semiminor axis");
+        validateNonnegative(semiMajorAxis, "semimajor axis");
+        validateNonnegative(semiMinorAxis, "semiminor axis");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*semiMajorAxis);
+        double hs = factorY(2*semiMinorAxis);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a circular arc of the specified radius,
+     * centered at (<em>x</em>, <em>y</em>), from angle1 to angle2 (in degrees).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the circle
+     * @param  y the <em>y</em>-coordinate of the center of the circle
+     * @param  radius the radius of the circle
+     * @param  angle1 the starting angle. 0 would mean an arc beginning at 3 o'clock.
+     * @param  angle2 the angle at the end of the arc. For example, if
+     *         you want a 90 degree arc, then angle2 should be angle1 + 90.
+     * @throws IllegalArgumentException if {@code radius} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void arc(double x, double y, double radius, double angle1, double angle2) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(radius, "arc radius");
+        validate(angle1, "angle1");
+        validate(angle2, "angle2");
+        validateNonnegative(radius, "arc radius");
+
+        while (angle2 < angle1) angle2 += 360;
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*radius);
+        double hs = factorY(2*radius);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Arc2D.Double(xs - ws/2, ys - hs/2, ws, hs, angle1, angle2 - angle1, Arc2D.OPEN));
+        draw();
+    }
+
+    /**
+     * Draws a square of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the square
+     * @param  y the <em>y</em>-coordinate of the center of the square
+     * @param  halfLength one half the length of any side of the square
+     * @throws IllegalArgumentException if {@code halfLength} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void square(double x, double y, double halfLength) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfLength, "halfLength");
+        validateNonnegative(halfLength, "half length");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfLength);
+        double hs = factorY(2*halfLength);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a square of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the square
+     * @param  y the <em>y</em>-coordinate of the center of the square
+     * @param  halfLength one half the length of any side of the square
+     * @throws IllegalArgumentException if {@code halfLength} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void filledSquare(double x, double y, double halfLength) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfLength, "halfLength");
+        validateNonnegative(halfLength, "half length");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfLength);
+        double hs = factorY(2*halfLength);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+
+    /**
+     * Draws a rectangle of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the rectangle
+     * @param  y the <em>y</em>-coordinate of the center of the rectangle
+     * @param  halfWidth one half the width of the rectangle
+     * @param  halfHeight one half the height of the rectangle
+     * @throws IllegalArgumentException if either {@code halfWidth} or {@code halfHeight} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void rectangle(double x, double y, double halfWidth, double halfHeight) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfWidth, "halfWidth");
+        validate(halfHeight, "halfHeight");
+        validateNonnegative(halfWidth, "half width");
+        validateNonnegative(halfHeight, "half height");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfWidth);
+        double hs = factorY(2*halfHeight);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled rectangle of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the rectangle
+     * @param  y the <em>y</em>-coordinate of the center of the rectangle
+     * @param  halfWidth one half the width of the rectangle
+     * @param  halfHeight one half the height of the rectangle
+     * @throws IllegalArgumentException if either {@code halfWidth} or {@code halfHeight} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public void filledRectangle(double x, double y, double halfWidth, double halfHeight) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfWidth, "halfWidth");
+        validate(halfHeight, "halfHeight");
+        validateNonnegative(halfWidth, "half width");
+        validateNonnegative(halfHeight, "half height");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfWidth);
+        double hs = factorY(2*halfHeight);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a polygon with the vertices 
+     * (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),
+     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ...,
+     * (<em>x</em><sub><em>n</em>‚Äì1</sub>, <em>y</em><sub><em>n</em>‚Äì1</sub>).
+     *
+     * @param  x an array of all the <em>x</em>-coordinates of the polygon
+     * @param  y an array of all the <em>y</em>-coordinates of the polygon
+     * @throws IllegalArgumentException unless {@code x[]} and {@code y[]}
+     *         are of the same length
+     * @throws IllegalArgumentException if any coordinate is either NaN or infinite
+     * @throws IllegalArgumentException if either {@code x[]} or {@code y[]} is {@code null}
+     */
+    public void polygon(double[] x, double[] y) {
+        validateNotNull(x, "x-coordinate array");
+        validateNotNull(y, "y-coordinate array");
+        for (int i = 0; i < x.length; i++) validate(x[i], "x[" + i + "]");
+        for (int i = 0; i < y.length; i++) validate(y[i], "y[" + i + "]");
+
+        int n1 = x.length;
+        int n2 = y.length;
+        if (n1 != n2) throw new IllegalArgumentException("arrays must be of the same length");
+        int n = n1;
+        if (n == 0) return;
+
+        GeneralPath path = new GeneralPath();
+        path.moveTo((float) scaleX(x[0]), (float) scaleY(y[0]));
+        for (int i = 0; i < n; i++)
+            path.lineTo((float) scaleX(x[i]), (float) scaleY(y[i]));
+        path.closePath();
+        offscreen.draw(path);
+        draw();
+    }
+
+    /**
+     * Draws a filled polygon with the vertices 
+     * (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),
+     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ...,
+     * (<em>x</em><sub><em>n</em>‚Äì1</sub>, <em>y</em><sub><em>n</em>‚Äì1</sub>).
+     *
+     * @param  x an array of all the <em>x</em>-coordinates of the polygon
+     * @param  y an array of all the <em>y</em>-coordinates of the polygon
+     * @throws IllegalArgumentException unless {@code x[]} and {@code y[]}
+     *         are of the same length
+     * @throws IllegalArgumentException if any coordinate is either NaN or infinite
+     * @throws IllegalArgumentException if either {@code x[]} or {@code y[]} is {@code null}
+     */
+    public void filledPolygon(double[] x, double[] y) {
+        validateNotNull(x, "x-coordinate array");
+        validateNotNull(y, "y-coordinate array");
+        for (int i = 0; i < x.length; i++) validate(x[i], "x[" + i + "]");
+        for (int i = 0; i < y.length; i++) validate(y[i], "y[" + i + "]");
+
+        int n1 = x.length;
+        int n2 = y.length;
+        if (n1 != n2) throw new IllegalArgumentException("arrays must be of the same length");
+        int n = n1;
+        if (n == 0) return;
+
+        GeneralPath path = new GeneralPath();
+        path.moveTo((float) scaleX(x[0]), (float) scaleY(y[0]));
+        for (int i = 0; i < n; i++)
+            path.lineTo((float) scaleX(x[i]), (float) scaleY(y[i]));
+        path.closePath();
+        offscreen.fill(path);
+        draw();
+    }
+
+
+
+   /***************************************************************************
+    *  Drawing images.
+    ***************************************************************************/
+
+    // get an image from the given filename
+    private static Image getImage(String filename) {
+        if (filename == null) throw new IllegalArgumentException();
+
+        // to read from file
+        ImageIcon icon = new ImageIcon(filename);
+
+        // try to read from URL
+        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
+            try {
+                URL url = new URL(filename);
+                icon = new ImageIcon(url);
+            }
+            catch (MalformedURLException e) {
+                /* not a url */
+            }
+        }
+
+        // in case file is inside a .jar (classpath relative to StdDraw)
+        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
+            URL url = StdDraw.class.getResource(filename);
+            if (url != null)
+                icon = new ImageIcon(url);
+        }
+
+        // in case file is inside a .jar (classpath relative to root of jar)
+        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
+            URL url = Draw.class.getResource("/" + filename);
+            if (url == null) throw new IllegalArgumentException("image " + filename + " not found");
+            icon = new ImageIcon(url);
+        }
+
+        return icon.getImage();
+    }
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>).
+     * The supported image formats are JPEG, PNG, and GIF.
+     * As an optimization, the picture is cached, so there is no performance
+     * penalty for redrawing the same image multiple times (e.g., in an animation).
+     * However, if you change the picture file after drawing it, subsequent
+     * calls will draw the original picture.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @throws IllegalArgumentException if the image filename is invalid
+     * @throws IllegalArgumentException if either {@code x} or {@code y} is either NaN or infinite
+     */
+    public void picture(double x, double y, String filename) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(filename, "filename");
+
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int ws = image.getWidth(null);
+        int hs = image.getHeight(null);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+
+        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0), (int) Math.round(ys - hs/2.0), null);
+        draw();
+    }
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>),
+     * rotated given number of degrees.
+     * The supported image formats are JPEG, PNG, and GIF.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @param  degrees is the number of degrees to rotate counterclockwise
+     * @throws IllegalArgumentException if the image filename is invalid
+     * @throws IllegalArgumentException if {@code x}, {@code y}, {@code degrees} is NaN or infinite
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public void picture(double x, double y, String filename, double degrees) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(degrees, "degrees");
+        validateNotNull(filename, "filename");
+
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int ws = image.getWidth(null);
+        int hs = image.getHeight(null);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+
+        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
+        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0), (int) Math.round(ys - hs/2.0), null);
+        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
+
+        draw();
+    }
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>),
+     * rescaled to the specified bounding box.
+     * The supported image formats are JPEG, PNG, and GIF.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @param  scaledWidth the width of the scaled image (in screen coordinates)
+     * @param  scaledHeight the height of the scaled image (in screen coordinates)
+     * @throws IllegalArgumentException if either {@code scaledWidth}
+     *         or {@code scaledHeight} is negative
+     * @throws IllegalArgumentException if the image filename is invalid
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public void picture(double x, double y, String filename, double scaledWidth, double scaledHeight) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(scaledWidth, "scaled width");
+        validate(scaledHeight, "scaled height");
+        validateNotNull(filename, "filename");
+        validateNonnegative(scaledWidth, "scaled width");
+        validateNonnegative(scaledHeight, "scaled height");
+
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(scaledWidth);
+        double hs = factorY(scaledHeight);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else {
+            offscreen.drawImage(image, (int) Math.round(xs - ws/2.0),
+                                       (int) Math.round(ys - hs/2.0),
+                                       (int) Math.round(ws),
+                                       (int) Math.round(hs), null);
+        }
+        draw();
+    }
+
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>), rotated
+     * given number of degrees, and rescaled to the specified bounding box.
+     * The supported image formats are JPEG, PNG, and GIF.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @param  scaledWidth the width of the scaled image (in screen coordinates)
+     * @param  scaledHeight the height of the scaled image (in screen coordinates)
+     * @param  degrees is the number of degrees to rotate counterclockwise
+     * @throws IllegalArgumentException if either {@code scaledWidth}
+     *         or {@code scaledHeight} is negative
+     * @throws IllegalArgumentException if the image filename is invalid
+     */
+    public void picture(double x, double y, String filename, double scaledWidth, double scaledHeight, double degrees) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(scaledWidth, "scaled width");
+        validate(scaledHeight, "scaled height");
+        validate(degrees, "degrees");
+        validateNotNull(filename, "filename");
+        validateNonnegative(scaledWidth, "scaled width");
+        validateNonnegative(scaledHeight, "scaled height");
+
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(scaledWidth);
+        double hs = factorY(scaledHeight);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+
+        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
+        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0),
+                                   (int) Math.round(ys - hs/2.0),
+                                   (int) Math.round(ws),
+                                   (int) Math.round(hs), null);
+        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
+
+        draw();
+    }
+
+
+   /***************************************************************************
+    *  Drawing text.
+    ***************************************************************************/
+
+    /**
+     * Writes the given text string in the current font, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the center <em>x</em>-coordinate of the text
+     * @param  y the center <em>y</em>-coordinate of the text
+     * @param  text the text to write
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    public void text(double x, double y, String text) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(text, "text");
+
+        offscreen.setFont(font);
+        FontMetrics metrics = offscreen.getFontMetrics();
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int ws = metrics.stringWidth(text);
+        int hs = metrics.getDescent();
+        offscreen.drawString(text, (float) (xs - ws/2.0), (float) (ys + hs));
+        draw();
+    }
+
+    /**
+     * Writes the given text string in the current font, centered at (<em>x</em>, <em>y</em>) and
+     * rotated by the specified number of degrees.
+     * @param  x the center <em>x</em>-coordinate of the text
+     * @param  y the center <em>y</em>-coordinate of the text
+     * @param  text the text to write
+     * @param  degrees is the number of degrees to rotate counterclockwise
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x}, {@code y}, or {@code degrees} is either NaN or infinite
+     */
+    public void text(double x, double y, String text, double degrees) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(degrees, "degrees");
+        validateNotNull(text, "text");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
+        text(x, y, text);
+        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
+    }
+
+    /**
+     * Writes the given text string in the current font, left-aligned at (<em>x</em>, <em>y</em>).
+     * @param  x the <em>x</em>-coordinate of the text
+     * @param  y the <em>y</em>-coordinate of the text
+     * @param  text the text
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    public void textLeft(double x, double y, String text) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(text, "text");
+
+        offscreen.setFont(font);
+        FontMetrics metrics = offscreen.getFontMetrics();
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        // int ws = metrics.stringWidth(text);
+        int hs = metrics.getDescent();
+        offscreen.drawString(text, (float) xs, (float) (ys + hs));
+        draw();
+    }
+
+    /**
+     * Writes the given text string in the current font, right-aligned at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the text
+     * @param  y the <em>y</em>-coordinate of the text
+     * @param  text the text to write
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    public void textRight(double x, double y, String text) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(text, "text");
+
+        offscreen.setFont(font);
+        FontMetrics metrics = offscreen.getFontMetrics();
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int ws = metrics.stringWidth(text);
+        int hs = metrics.getDescent();
+        offscreen.drawString(text, (float) (xs - ws), (float) (ys + hs));
+        draw();
+    }
+
+    /**
+     * Copies the offscreen buffer to the onscreen buffer, pauses for t milliseconds
+     * and enables double buffering.
+     * @param t number of milliseconds
+     * @deprecated replaced by {@link #enableDoubleBuffering()}, {@link #show()}, and {@link #pause(int t)}
+     */
+    @Deprecated
+    public void show(int t) {
+        show();
+        pause(t);
+        enableDoubleBuffering();
+    }
+
+    /**
+     * Pause for t milliseconds. This method is intended to support computer animations.
+     * @param t number of milliseconds
+     */
+    public void pause(int t) {
+        try {
+            Thread.sleep(t);
+        }
+        catch (InterruptedException e) {
+            System.out.println("Error sleeping");
+        }
+    }
+
+    /**
+     * Copies offscreen buffer to onscreen buffer. There is no reason to call
+     * this method unless double buffering is enabled.
+     */
+    public void show() {
+        onscreen.drawImage(offscreenImage, 0, 0, null);
+        frame.repaint();
+    }
+
+    // draw onscreen if defer is false
+    private void draw() {
+        if (!defer) show();
+    }
+
+    /**
+     * Enable double buffering. All subsequent calls to 
+     * drawing methods such as {@code line()}, {@code circle()},
+     * and {@code square()} will be deferred until the next call
+     * to show(). Useful for animations.
+     */
+    public void enableDoubleBuffering() {
+        defer = true;
+    }
+
+    /**
+     * Disable double buffering. All subsequent calls to 
+     * drawing methods such as {@code line()}, {@code circle()},
+     * and {@code square()} will be displayed on screen when called.
+     * This is the default.
+     */
+    public void disableDoubleBuffering() {
+        defer = false;
+    }
+
+    /**
+     * Saves the drawing to using the specified filename.
+     * The supported image formats are JPEG and PNG;
+     * the filename suffix must be {@code .jpg} or {@code .png}.
+     *
+     * @param  filename the name of the file with one of the required suffixes
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public void save(String filename) {
+        validateNotNull(filename, "filename");
+        File file = new File(filename);
+        String suffix = filename.substring(filename.lastIndexOf('.') + 1);
+
+        // png files
+        if ("png".equalsIgnoreCase(suffix)) {
+            try {
+                ImageIO.write(offscreenImage, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // need to change from ARGB to RGB for jpeg
+        // reference: http://archives.java.sun.com/cgi-bin/wa?A2=ind0404&L=java2d-interest&D=0&P=2727
+        else if ("jpg".equalsIgnoreCase(suffix)) {
+            WritableRaster raster = offscreenImage.getRaster();
+            WritableRaster newRaster;
+            newRaster = raster.createWritableChild(0, 0, width, height, 0, 0, new int[] {0, 1, 2});
+            DirectColorModel cm = (DirectColorModel) offscreenImage.getColorModel();
+            DirectColorModel newCM = new DirectColorModel(cm.getPixelSize(),
+                                                          cm.getRedMask(),
+                                                          cm.getGreenMask(),
+                                                          cm.getBlueMask());
+            BufferedImage rgbBuffer = new BufferedImage(newCM, newRaster, false,  null);
+            try {
+                ImageIO.write(rgbBuffer, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        else {
+            System.out.println("Invalid image file type: " + suffix);
+        }
+    }
+
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void actionPerformed(ActionEvent e) {
+        FileDialog chooser = new FileDialog(frame, "Use a .png or .jpg extension", FileDialog.SAVE);
+        chooser.setVisible(true);
+        String filename = chooser.getFile();
+        if (filename != null) {
+            save(chooser.getDirectory() + File.separator + chooser.getFile());
+        }
+    }
+
+
+
+   /***************************************************************************
+    *  Event-based interactions.
+    ***************************************************************************/
+
+    /**
+     * Adds a {@link DrawListener} to listen to keyboard and mouse events.
+     *
+     * @param listener the {\tt DrawListener} argument
+     */
+    public void addListener(DrawListener listener) {
+        // ensure there is a window for listenting to events
+        show();
+        listeners.add(listener);
+        frame.addKeyListener(this);
+        frame.addMouseListener(this);
+        frame.addMouseMotionListener(this);
+        frame.setFocusable(true); 
+    }
+
+
+
+
+   /***************************************************************************
+    *  Mouse interactions.
+    ***************************************************************************/
+
+    /**
+     * Returns true if the mouse is being pressed.
+     *
+     * @return {@code true} if the mouse is being pressed;
+     *         {@code false} otherwise
+     */
+    public boolean isMousePressed() {
+        synchronized (mouseLock) {
+            return isMousePressed;
+        }
+    }
+
+    /**
+     * Returns true if the mouse is being pressed.
+     *
+     * @return {@code true} if the mouse is being pressed;
+     *         {@code false} otherwise
+     * @deprecated replaced by {@link #isMousePressed()}
+     */
+    @Deprecated
+    public boolean mousePressed() {
+        synchronized (mouseLock) {
+            return isMousePressed;
+        }
+    }
+
+    /**
+     * Returns the x-coordinate of the mouse.
+     * @return the x-coordinate of the mouse
+     */
+    public double mouseX() {
+        synchronized (mouseLock) {
+            return mouseX;
+        }
+    }
+
+    /**
+     * Returns the y-coordinate of the mouse.
+     *
+     * @return the y-coordinate of the mouse
+     */
+    public double mouseY() {
+        synchronized (mouseLock) {
+            return mouseY;
+        }
+    }
+
+
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseEntered(MouseEvent e) {
+        // this body is intentionally left empty
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseExited(MouseEvent e) {
+        // this body is intentionally left empty
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mousePressed(MouseEvent e) {
+        synchronized (mouseLock) {
+            mouseX = userX(e.getX());
+            mouseY = userY(e.getY());
+            isMousePressed = true;
+        }
+        if (e.getButton() == MouseEvent.BUTTON1) {
+            for (DrawListener listener : listeners)
+                listener.mousePressed(userX(e.getX()), userY(e.getY()));
+        }
+
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseReleased(MouseEvent e) {
+        synchronized (mouseLock) {
+            isMousePressed = false;
+        }
+        if (e.getButton() == MouseEvent.BUTTON1) {
+            for (DrawListener listener : listeners)
+                listener.mouseReleased(userX(e.getX()), userY(e.getY()));
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseClicked(MouseEvent e) {
+        if (e.getButton() == MouseEvent.BUTTON1) {
+            for (DrawListener listener : listeners)
+                listener.mouseClicked(userX(e.getX()), userY(e.getY()));
+        }
+    }
+
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseDragged(MouseEvent e)  {
+        synchronized (mouseLock) {
+            mouseX = userX(e.getX());
+            mouseY = userY(e.getY());
+        }
+        // doesn't seem to work if a button is specified
+        for (DrawListener listener : listeners)
+            listener.mouseDragged(userX(e.getX()), userY(e.getY()));
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseMoved(MouseEvent e) {
+        synchronized (mouseLock) {
+            mouseX = userX(e.getX());
+            mouseY = userY(e.getY());
+        }
+    }
+
+
+   /***************************************************************************
+    *  Keyboard interactions.
+    ***************************************************************************/
+
+    /**
+     * Returns true if the user has typed a key.
+     *
+     * @return {@code true} if the user has typed a key; {@code false} otherwise
+     */
+    public boolean hasNextKeyTyped() {
+        synchronized (keyLock) {
+            return !keysTyped.isEmpty();
+        }
+    }
+
+    /**
+     * The next key typed by the user.
+     *
+     * @return the next key typed by the user
+     */
+    public char nextKeyTyped() {
+        synchronized (keyLock) {
+            return keysTyped.removeLast();
+        }
+    }
+
+   /**
+     * Returns true if the keycode is being pressed.
+     * <p>
+     * This method takes as an argument the keycode (corresponding to a physical key).
+     * It can handle action keys (such as F1 and arrow keys) and modifier keys
+     * (such as shift and control).
+     * See {@link KeyEvent} for a description of key codes.
+     *
+     * @param  keycode the keycode to check
+     * @return {@code true} if {@code keycode} is currently being pressed;
+     *         {@code false} otherwise
+     */
+    public boolean isKeyPressed(int keycode) {
+        synchronized (keyLock) {
+            return keysDown.contains(keycode);
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void keyTyped(KeyEvent e) {
+        synchronized (keyLock) {
+            keysTyped.addFirst(e.getKeyChar());
+        }
+
+        // notify all listeners
+        for (DrawListener listener : listeners)
+            listener.keyTyped(e.getKeyChar());
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void keyPressed(KeyEvent e) {
+        synchronized (keyLock) {
+            keysDown.add(e.getKeyCode());
+        }
+
+        // notify all listeners
+        for (DrawListener listener : listeners)
+            listener.keyPressed(e.getKeyCode());
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void keyReleased(KeyEvent e) {
+        synchronized (keyLock) {
+            keysDown.remove(e.getKeyCode());
+        }
+
+        // notify all listeners
+        for (DrawListener listener : listeners)
+            listener.keyReleased(e.getKeyCode());
+    }
+
+
+   /***************************************************************************
+    *  For improved resolution on Mac Retina displays.
+    ***************************************************************************/
+
+    private static class RetinaImageIcon extends ImageIcon {
+    
+        public RetinaImageIcon(Image image) {
+            super(image);
+        }
+
+        public int getIconWidth() {
+            return super.getIconWidth() / 2;
+        }
+
+        /**
+         * Gets the height of the icon.
+         *
+         * @return the height in pixels of this icon
+         */
+        public int getIconHeight() {
+            return super.getIconHeight() / 2;
+        }
+
+        public synchronized void paintIcon(Component c, Graphics g, int x, int y) {
+            Graphics2D g2 = (Graphics2D) g.create();
+            g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
+            g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
+            g2.scale(0.5, 0.5);
+            super.paintIcon(c, g2, x * 2, y * 2);
+            g2.dispose();
+        }
+    }
+
+    /**
+     * Test client.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // create one drawing window
+        Draw draw1 = new Draw("Test client 1");
+        draw1.square(0.2, 0.8, 0.1);
+        draw1.filledSquare(0.8, 0.8, 0.2);
+        draw1.circle(0.8, 0.2, 0.2);
+        draw1.setPenColor(Draw.MAGENTA);
+        draw1.setPenRadius(0.02);
+        draw1.arc(0.8, 0.2, 0.1, 200, 45);
+
+
+        // create another one
+        Draw draw2 = new Draw("Test client 2");
+        draw2.setCanvasSize(900, 200);
+        // draw a blue diamond
+        draw2.setPenRadius();
+        draw2.setPenColor(Draw.BLUE);
+        double[] x = { 0.1, 0.2, 0.3, 0.2 };
+        double[] y = { 0.2, 0.3, 0.2, 0.1 };
+        draw2.filledPolygon(x, y);
+
+        // text
+        draw2.setPenColor(Draw.BLACK);
+        draw2.text(0.2, 0.5, "bdfdfdfdlack text");
+        draw2.setPenColor(Draw.WHITE);
+        draw2.text(0.8, 0.8, "white text");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/DrawListener.java b/src/main/java/edu/princeton/cs/algs4/DrawListener.java
new file mode 100644
index 0000000..7b999dd
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/DrawListener.java
@@ -0,0 +1,104 @@
+/******************************************************************************
+ *  Compilation:  javac DrawListener.java
+ *  Execution:    none
+ *  Dependencies: none
+ *
+ *  Interface that accompanies Draw.java.
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  <i>DrawListener</i>. This interface provides a basic capability for
+ *  responding to keyboard in mouse events from {@link Draw} via callbacks.
+ *  You can see some examples in
+ *  <a href="https://introcs.cs.princeton.edu/java/36inheritance">Section 3.6</a>.
+ *
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public interface DrawListener {
+
+    /**
+     * Invoked when the mouse has been pressed.
+     *
+     * @param x the x-coordinate of the mouse
+     * @param y the y-coordinate of the mouse
+     */
+    void mousePressed(double x, double y);
+
+    /**
+     * Invoked when the mouse has been dragged.
+     *
+     * @param x the x-coordinate of the mouse
+     * @param y the y-coordinate of the mouse
+     */
+    void mouseDragged(double x, double y);
+
+    /**
+     * Invoked when the mouse has been released.
+     *
+     * @param x the x-coordinate of the mouse
+     * @param y the y-coordinate of the mouse
+     */
+    void mouseReleased(double x, double y);
+
+    /**
+     * Invoked when the mouse has been clicked (pressed and released).
+     *
+     * @param x the x-coordinate of the mouse
+     * @param y the y-coordinate of the mouse
+     */
+    void mouseClicked(double x, double y);
+
+    /**
+     * Invoked when a key has been typed.
+     *
+     * @param c the character typed
+     */
+    void keyTyped(char c);
+
+    /**
+     * Invoked when a key has been pressed.
+     *
+     * @param keycode the key combination pressed
+     */
+    void keyPressed(int keycode);
+
+    /**
+     * Invoked when a key has been released.
+     *
+     * @param keycode the key combination released
+     */
+    void keyReleased(int keycode);
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Edge.java b/src/main/java/edu/princeton/cs/algs4/Edge.java
new file mode 100644
index 0000000..728f879
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Edge.java
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *  Compilation:  javac Edge.java
+ *  Execution:    java Edge
+ *  Dependencies: StdOut.java
+ *
+ *  Immutable weighted edge.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Edge} class represents a weighted edge in an 
+ *  {@link EdgeWeightedGraph}. Each edge consists of two integers
+ *  (naming the two vertices) and a real-value weight. The data type
+ *  provides methods for accessing the two endpoints of the edge and
+ *  the weight. The natural order for this data type is by
+ *  ascending order of weight.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Edge implements Comparable<Edge> { 
+
+    private final int v;
+    private final int w;
+    private final double weight;
+
+    /**
+     * Initializes an edge between vertices {@code v} and {@code w} of
+     * the given {@code weight}.
+     *
+     * @param  v one vertex
+     * @param  w the other vertex
+     * @param  weight the weight of this edge
+     * @throws IllegalArgumentException if either {@code v} or {@code w} 
+     *         is a negative integer
+     * @throws IllegalArgumentException if {@code weight} is {@code NaN}
+     */
+    public Edge(int v, int w, double weight) {
+        if (v < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
+        if (w < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
+        if (Double.isNaN(weight)) throw new IllegalArgumentException("Weight is NaN");
+        this.v = v;
+        this.w = w;
+        this.weight = weight;
+    }
+
+    /**
+     * Returns the weight of this edge.
+     *
+     * @return the weight of this edge
+     */
+    public double weight() {
+        return weight;
+    }
+
+    /**
+     * Returns either endpoint of this edge.
+     *
+     * @return either endpoint of this edge
+     */
+    public int either() {
+        return v;
+    }
+
+    /**
+     * Returns the endpoint of this edge that is different from the given vertex.
+     *
+     * @param  vertex one endpoint of this edge
+     * @return the other endpoint of this edge
+     * @throws IllegalArgumentException if the vertex is not one of the
+     *         endpoints of this edge
+     */
+    public int other(int vertex) {
+        if      (vertex == v) return w;
+        else if (vertex == w) return v;
+        else throw new IllegalArgumentException("Illegal endpoint");
+    }
+
+    /**
+     * Compares two edges by weight.
+     * Note that {@code compareTo()} is not consistent with {@code equals()},
+     * which uses the reference equality implementation inherited from {@code Object}.
+     *
+     * @param  that the other edge
+     * @return a negative integer, zero, or positive integer depending on whether
+     *         the weight of this is less than, equal to, or greater than the
+     *         argument edge
+     */
+    @Override
+    public int compareTo(Edge that) {
+        return Double.compare(this.weight, that.weight);
+    }
+
+    /**
+     * Returns a string representation of this edge.
+     *
+     * @return a string representation of this edge
+     */
+    public String toString() {
+        return String.format("%d-%d %.5f", v, w, weight);
+    }
+
+    /**
+     * Unit tests the {@code Edge} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Edge e = new Edge(12, 34, 5.67);
+        StdOut.println(e);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/EdgeWeightedDigraph.java b/src/main/java/edu/princeton/cs/algs4/EdgeWeightedDigraph.java
new file mode 100644
index 0000000..fee2de0
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/EdgeWeightedDigraph.java
@@ -0,0 +1,303 @@
+/******************************************************************************
+ *  Compilation:  javac EdgeWeightedDigraph.java
+ *  Execution:    java EdgeWeightedDigraph digraph.txt
+ *  Dependencies: Bag.java DirectedEdge.java
+ *  Data files:   https://algs4.cs.princeton.edu/44sp/tinyEWD.txt
+ *                https://algs4.cs.princeton.edu/44sp/mediumEWD.txt
+ *                https://algs4.cs.princeton.edu/44sp/largeEWD.txt
+ *
+ *  An edge-weighted digraph, implemented using adjacency lists.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code EdgeWeightedDigraph} class represents a edge-weighted
+ *  digraph of vertices named 0 through <em>V</em> - 1, where each
+ *  directed edge is of type {@link DirectedEdge} and has a real-valued weight.
+ *  It supports the following two primary operations: add a directed edge
+ *  to the digraph and iterate over all of edges incident from a given vertex.
+ *  It also provides methods for returning the indegree or outdegree of a
+ *  vertex, the number of vertices <em>V</em> in the digraph, and
+ *  the number of edges <em>E</em> in the digraph.
+ *  Parallel edges and self-loops are permitted.
+ *  <p>
+ *  This implementation uses an <em>adjacency-lists representation</em>, which
+ *  is a vertex-indexed array of {@link Bag} objects.
+ *  It uses &Theta;(<em>E</em> + <em>V</em>) space, where <em>E</em> is
+ *  the number of edges and <em>V</em> is the number of vertices.
+ *  All instance methods take &Theta;(1) time. (Though, iterating over
+ *  the edges returned by {@link #adj(int)} takes time proportional
+ *  to the outdegree of the vertex.)
+ *  Constructing an empty edge-weighted digraph with <em>V</em> vertices
+ *  takes &Theta;(<em>V</em>) time; constructing an edge-weighted digraph
+ *  with <em>E</em> edges and <em>V</em> vertices takes
+ *  &Theta;(<em>E</em> + <em>V</em>) time. 
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class EdgeWeightedDigraph {
+    private static final String NEWLINE = System.getProperty("line.separator");
+
+    private final int V;                // number of vertices in this digraph
+    private int E;                      // number of edges in this digraph
+    private Bag<DirectedEdge>[] adj;    // adj[v] = adjacency list for vertex v
+    private int[] indegree;             // indegree[v] = indegree of vertex v
+    
+    /**
+     * Initializes an empty edge-weighted digraph with {@code V} vertices and 0 edges.
+     *
+     * @param  V the number of vertices
+     * @throws IllegalArgumentException if {@code V < 0}
+     */
+    public EdgeWeightedDigraph(int V) {
+        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be non-negative");
+        this.V = V;
+        this.E = 0;
+        this.indegree = new int[V];
+        adj = (Bag<DirectedEdge>[]) new Bag[V];
+        for (int v = 0; v < V; v++)
+            adj[v] = new Bag<DirectedEdge>();
+    }
+
+    /**
+     * Initializes a random edge-weighted digraph with {@code V} vertices and <em>E</em> edges.
+     *
+     * @param  V the number of vertices
+     * @param  E the number of edges
+     * @throws IllegalArgumentException if {@code V < 0}
+     * @throws IllegalArgumentException if {@code E < 0}
+     */
+    public EdgeWeightedDigraph(int V, int E) {
+        this(V);
+        if (E < 0) throw new IllegalArgumentException("Number of edges in a Digraph must be non-negative");
+        for (int i = 0; i < E; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            double weight = 0.01 * StdRandom.uniform(100);
+            DirectedEdge e = new DirectedEdge(v, w, weight);
+            addEdge(e);
+        }
+    }
+
+    /**  
+     * Initializes an edge-weighted digraph from the specified input stream.
+     * The format is the number of vertices <em>V</em>,
+     * followed by the number of edges <em>E</em>,
+     * followed by <em>E</em> pairs of vertices and edge weights,
+     * with each entry separated by whitespace.
+     *
+     * @param  in the input stream
+     * @throws IllegalArgumentException if {@code in} is {@code null}
+     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
+     * @throws IllegalArgumentException if the number of vertices or edges is negative
+     */
+    public EdgeWeightedDigraph(In in) {
+        if (in == null) throw new IllegalArgumentException("argument is null");
+        try {
+            this.V = in.readInt();
+            if (V < 0) throw new IllegalArgumentException("number of vertices in a Digraph must be non-negative");
+            indegree = new int[V];
+            adj = (Bag<DirectedEdge>[]) new Bag[V];
+            for (int v = 0; v < V; v++) {
+                adj[v] = new Bag<DirectedEdge>();
+            }
+
+            int E = in.readInt();
+            if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
+            for (int i = 0; i < E; i++) {
+                int v = in.readInt();
+                int w = in.readInt();
+                validateVertex(v);
+                validateVertex(w);
+                double weight = in.readDouble();
+                addEdge(new DirectedEdge(v, w, weight));
+            }
+        }   
+        catch (NoSuchElementException e) {
+            throw new IllegalArgumentException("invalid input format in EdgeWeightedDigraph constructor", e);
+        }
+    }
+
+    /**
+     * Initializes a new edge-weighted digraph that is a deep copy of {@code G}.
+     *
+     * @param  G the edge-weighted digraph to copy
+     */
+    public EdgeWeightedDigraph(EdgeWeightedDigraph G) {
+        this(G.V());
+        this.E = G.E();
+        for (int v = 0; v < G.V(); v++)
+            this.indegree[v] = G.indegree(v);
+        for (int v = 0; v < G.V(); v++) {
+            // reverse so that adjacency list is in same order as original
+            Stack<DirectedEdge> reverse = new Stack<DirectedEdge>();
+            for (DirectedEdge e : G.adj[v]) {
+                reverse.push(e);
+            }
+            for (DirectedEdge e : reverse) {
+                adj[v].add(e);
+            }
+        }
+    }
+
+    /**
+     * Returns the number of vertices in this edge-weighted digraph.
+     *
+     * @return the number of vertices in this edge-weighted digraph
+     */
+    public int V() {
+        return V;
+    }
+
+    /**
+     * Returns the number of edges in this edge-weighted digraph.
+     *
+     * @return the number of edges in this edge-weighted digraph
+     */
+    public int E() {
+        return E;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Adds the directed edge {@code e} to this edge-weighted digraph.
+     *
+     * @param  e the edge
+     * @throws IllegalArgumentException unless endpoints of edge are between {@code 0}
+     *         and {@code V-1}
+     */
+    public void addEdge(DirectedEdge e) {
+        int v = e.from();
+        int w = e.to();
+        validateVertex(v);
+        validateVertex(w);
+        adj[v].add(e);
+        indegree[w]++;
+        E++;
+    }
+
+
+    /**
+     * Returns the directed edges incident from vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the directed edges incident from vertex {@code v} as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> adj(int v) {
+        validateVertex(v);
+        return adj[v];
+    }
+
+    /**
+     * Returns the number of directed edges incident from vertex {@code v}.
+     * This is known as the <em>outdegree</em> of vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the outdegree of vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int outdegree(int v) {
+        validateVertex(v);
+        return adj[v].size();
+    }
+
+    /**
+     * Returns the number of directed edges incident to vertex {@code v}.
+     * This is known as the <em>indegree</em> of vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the indegree of vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int indegree(int v) {
+        validateVertex(v);
+        return indegree[v];
+    }
+
+    /**
+     * Returns all directed edges in this edge-weighted digraph.
+     * To iterate over the edges in this edge-weighted digraph, use foreach notation:
+     * {@code for (DirectedEdge e : G.edges())}.
+     *
+     * @return all edges in this edge-weighted digraph, as an iterable
+     */
+    public Iterable<DirectedEdge> edges() {
+        Bag<DirectedEdge> list = new Bag<DirectedEdge>();
+        for (int v = 0; v < V; v++) {
+            for (DirectedEdge e : adj(v)) {
+                list.add(e);
+            }
+        }
+        return list;
+    } 
+
+    /**
+     * Returns a string representation of this edge-weighted digraph.
+     *
+     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
+     *         followed by the <em>V</em> adjacency lists of edges
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(V + " " + E + NEWLINE);
+        for (int v = 0; v < V; v++) {
+            s.append(v + ": ");
+            for (DirectedEdge e : adj[v]) {
+                s.append(e + "  ");
+            }
+            s.append(NEWLINE);
+        }
+        return s.toString();
+    }
+
+    /**
+     * Unit tests the {@code EdgeWeightedDigraph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(in);
+        StdOut.println(G);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/EdgeWeightedDirectedCycle.java b/src/main/java/edu/princeton/cs/algs4/EdgeWeightedDirectedCycle.java
new file mode 100644
index 0000000..7b54cb9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/EdgeWeightedDirectedCycle.java
@@ -0,0 +1,219 @@
+/******************************************************************************
+ *  Compilation:  javac EdgeWeightedDirectedCycle.java
+ *  Execution:    java EdgeWeightedDirectedCycle V E F
+ *  Dependencies: EdgeWeightedDigraph.java DirectedEdge.java Stack.java
+ *
+ *  Finds a directed cycle in an edge-weighted digraph.
+ *  Runs in O(E + V) time.
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code EdgeWeightedDirectedCycle} class represents a data type for 
+ *  determining whether an edge-weighted digraph has a directed cycle.
+ *  The <em>hasCycle</em> operation determines whether the edge-weighted
+ *  digraph has a directed cycle and, if so, the <em>cycle</em> operation
+ *  returns one.
+ *  <p>
+ *  This implementation uses <em>depth-first search</em>.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the 
+ *  edge-weighted digraph).
+ *  <p>
+ *  See {@link Topological} to compute a topological order if the
+ *  edge-weighted digraph is acyclic.
+ *  <p>
+ *  For additional documentation,   
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of   
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class EdgeWeightedDirectedCycle {
+    private boolean[] marked;             // marked[v] = has vertex v been marked?
+    private DirectedEdge[] edgeTo;        // edgeTo[v] = previous edge on path to v
+    private boolean[] onStack;            // onStack[v] = is vertex on the stack?
+    private Stack<DirectedEdge> cycle;    // directed cycle (or null if no such cycle)
+
+    /**
+     * Determines whether the edge-weighted digraph {@code G} has a directed cycle and,
+     * if so, finds such a cycle.
+     * @param G the edge-weighted digraph
+     */
+    public EdgeWeightedDirectedCycle(EdgeWeightedDigraph G) {
+        marked  = new boolean[G.V()];
+        onStack = new boolean[G.V()];
+        edgeTo  = new DirectedEdge[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            if (!marked[v]) dfs(G, v);
+
+        // check that digraph has a cycle
+        assert check();
+    }
+
+    // check that algorithm computes either the topological order or finds a directed cycle
+    private void dfs(EdgeWeightedDigraph G, int v) {
+        onStack[v] = true;
+        marked[v] = true;
+        for (DirectedEdge e : G.adj(v)) {
+            int w = e.to();
+
+            // short circuit if directed cycle found
+            if (cycle != null) return;
+
+            // found new vertex, so recur
+            else if (!marked[w]) {
+                edgeTo[w] = e;
+                dfs(G, w);
+            }
+
+            // trace back directed cycle
+            else if (onStack[w]) {
+                cycle = new Stack<DirectedEdge>();
+
+                DirectedEdge f = e;
+                while (f.from() != w) {
+                    cycle.push(f);
+                    f = edgeTo[f.from()];
+                }
+                cycle.push(f);
+
+                return;
+            }
+        }
+
+        onStack[v] = false;
+    }
+
+    /**
+     * Does the edge-weighted digraph have a directed cycle?
+     * @return {@code true} if the edge-weighted digraph has a directed cycle,
+     * {@code false} otherwise
+     */
+    public boolean hasCycle() {
+        return cycle != null;
+    }
+
+    /**
+     * Returns a directed cycle if the edge-weighted digraph has a directed cycle,
+     * and {@code null} otherwise.
+     * @return a directed cycle (as an iterable) if the edge-weighted digraph
+     *    has a directed cycle, and {@code null} otherwise
+     */
+    public Iterable<DirectedEdge> cycle() {
+        return cycle;
+    }
+
+
+    // certify that digraph is either acyclic or has a directed cycle
+    private boolean check() {
+
+        // edge-weighted digraph is cyclic
+        if (hasCycle()) {
+            // verify cycle
+            DirectedEdge first = null, last = null;
+            for (DirectedEdge e : cycle()) {
+                if (first == null) first = e;
+                if (last != null) {
+                    if (last.to() != e.from()) {
+                        System.err.printf("cycle edges %s and %s not incident\n", last, e);
+                        return false;
+                    }
+                }
+                last = e;
+            }
+
+            if (last.to() != first.from()) {
+                System.err.printf("cycle edges %s and %s not incident\n", last, first);
+                return false;
+            }
+        }
+
+
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code EdgeWeightedDirectedCycle} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // create random DAG with V vertices and E edges; then add F random edges
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        int F = Integer.parseInt(args[2]);
+        EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < E; i++) {
+            int v, w;
+            do {
+                v = StdRandom.uniform(V);
+                w = StdRandom.uniform(V);
+            } while (v >= w);
+            double weight = StdRandom.uniform();
+            G.addEdge(new DirectedEdge(v, w, weight));
+        }
+
+        // add F extra edges
+        for (int i = 0; i < F; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            double weight = StdRandom.uniform(0.0, 1.0);
+            G.addEdge(new DirectedEdge(v, w, weight));
+        }
+
+        StdOut.println(G);
+
+        // find a directed cycle
+        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);
+        if (finder.hasCycle()) {
+            StdOut.print("Cycle: ");
+            for (DirectedEdge e : finder.cycle()) {
+                StdOut.print(e + " ");
+            }
+            StdOut.println();
+        }
+
+        // or give topologial sort
+        else {
+            StdOut.println("No directed cycle");
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/EdgeWeightedGraph.java b/src/main/java/edu/princeton/cs/algs4/EdgeWeightedGraph.java
new file mode 100644
index 0000000..5e61c3b
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/EdgeWeightedGraph.java
@@ -0,0 +1,309 @@
+/******************************************************************************
+ *  Compilation:  javac EdgeWeightedGraph.java
+ *  Execution:    java EdgeWeightedGraph filename.txt
+ *  Dependencies: Bag.java Edge.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/largeEWG.txt
+ *
+ *  An edge-weighted undirected graph, implemented using adjacency lists.
+ *  Parallel edges and self-loops are permitted.
+ *
+ *  % java EdgeWeightedGraph tinyEWG.txt 
+ *  8 16
+ *  0: 6-0 0.58000  0-2 0.26000  0-4 0.38000  0-7 0.16000  
+ *  1: 1-3 0.29000  1-2 0.36000  1-7 0.19000  1-5 0.32000  
+ *  2: 6-2 0.40000  2-7 0.34000  1-2 0.36000  0-2 0.26000  2-3 0.17000  
+ *  3: 3-6 0.52000  1-3 0.29000  2-3 0.17000  
+ *  4: 6-4 0.93000  0-4 0.38000  4-7 0.37000  4-5 0.35000  
+ *  5: 1-5 0.32000  5-7 0.28000  4-5 0.35000  
+ *  6: 6-4 0.93000  6-0 0.58000  3-6 0.52000  6-2 0.40000
+ *  7: 2-7 0.34000  1-7 0.19000  0-7 0.16000  5-7 0.28000  4-7 0.37000
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code EdgeWeightedGraph} class represents an edge-weighted
+ *  graph of vertices named 0 through <em>V</em> ‚Äì 1, where each
+ *  undirected edge is of type {@link Edge} and has a real-valued weight.
+ *  It supports the following two primary operations: add an edge to the graph,
+ *  iterate over all of the edges incident to a vertex. It also provides
+ *  methods for returning the degree of a vertex, the number of vertices
+ *  <em>V</em> in the graph, and the number of edges <em>E</em> in the graph.
+ *  Parallel edges and self-loops are permitted.
+ *  By convention, a self-loop <em>v</em>-<em>v</em> appears in the
+ *  adjacency list of <em>v</em> twice and contributes two to the degree
+ *  of <em>v</em>.
+ *  <p>
+ *  This implementation uses an <em>adjacency-lists representation</em>, which
+ *  is a vertex-indexed array of {@link Bag} objects.
+ *  It uses &Theta;(<em>E</em> + <em>V</em>) space, where <em>E</em> is
+ *  the number of edges and <em>V</em> is the number of vertices.
+ *  All instance methods take &Theta;(1) time. (Though, iterating over
+ *  the edges returned by {@link #adj(int)} takes time proportional
+ *  to the degree of the vertex.)
+ *  Constructing an empty edge-weighted graph with <em>V</em> vertices takes
+ *  &Theta;(<em>V</em>) time; constructing a edge-weighted graph with
+ *  <em>E</em> edges and <em>V</em> vertices takes
+ *  &Theta;(<em>E</em> + <em>V</em>) time. 
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class EdgeWeightedGraph {
+    private static final String NEWLINE = System.getProperty("line.separator");
+
+    private final int V;
+    private int E;
+    private Bag<Edge>[] adj;
+    
+    /**
+     * Initializes an empty edge-weighted graph with {@code V} vertices and 0 edges.
+     *
+     * @param  V the number of vertices
+     * @throws IllegalArgumentException if {@code V < 0}
+     */
+    public EdgeWeightedGraph(int V) {
+        if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");
+        this.V = V;
+        this.E = 0;
+        adj = (Bag<Edge>[]) new Bag[V];
+        for (int v = 0; v < V; v++) {
+            adj[v] = new Bag<Edge>();
+        }
+    }
+
+    /**
+     * Initializes a random edge-weighted graph with {@code V} vertices and <em>E</em> edges.
+     *
+     * @param  V the number of vertices
+     * @param  E the number of edges
+     * @throws IllegalArgumentException if {@code V < 0}
+     * @throws IllegalArgumentException if {@code E < 0}
+     */
+    public EdgeWeightedGraph(int V, int E) {
+        this(V);
+        if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
+        for (int i = 0; i < E; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            double weight = Math.round(100 * StdRandom.uniform()) / 100.0;
+            Edge e = new Edge(v, w, weight);
+            addEdge(e);
+        }
+    }
+
+    /**  
+     * Initializes an edge-weighted graph from an input stream.
+     * The format is the number of vertices <em>V</em>,
+     * followed by the number of edges <em>E</em>,
+     * followed by <em>E</em> pairs of vertices and edge weights,
+     * with each entry separated by whitespace.
+     *
+     * @param  in the input stream
+     * @throws IllegalArgumentException if {@code in} is {@code null}
+     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
+     * @throws IllegalArgumentException if the number of vertices or edges is negative
+     */
+    public EdgeWeightedGraph(In in) {
+        if (in == null) throw new IllegalArgumentException("argument is null");
+
+        try {
+            V = in.readInt();
+            adj = (Bag<Edge>[]) new Bag[V];
+            for (int v = 0; v < V; v++) {
+                adj[v] = new Bag<Edge>();
+            }
+
+            int E = in.readInt();
+            if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
+            for (int i = 0; i < E; i++) {
+                int v = in.readInt();
+                int w = in.readInt();
+                validateVertex(v);
+                validateVertex(w);
+                double weight = in.readDouble();
+                Edge e = new Edge(v, w, weight);
+                addEdge(e);
+            }
+        }   
+        catch (NoSuchElementException e) {
+            throw new IllegalArgumentException("invalid input format in EdgeWeightedGraph constructor", e);
+        }
+
+    }
+
+    /**
+     * Initializes a new edge-weighted graph that is a deep copy of {@code G}.
+     *
+     * @param  G the edge-weighted graph to copy
+     */
+    public EdgeWeightedGraph(EdgeWeightedGraph G) {
+        this(G.V());
+        this.E = G.E();
+        for (int v = 0; v < G.V(); v++) {
+            // reverse so that adjacency list is in same order as original
+            Stack<Edge> reverse = new Stack<Edge>();
+            for (Edge e : G.adj[v]) {
+                reverse.push(e);
+            }
+            for (Edge e : reverse) {
+                adj[v].add(e);
+            }
+        }
+    }
+
+
+    /**
+     * Returns the number of vertices in this edge-weighted graph.
+     *
+     * @return the number of vertices in this edge-weighted graph
+     */
+    public int V() {
+        return V;
+    }
+
+    /**
+     * Returns the number of edges in this edge-weighted graph.
+     *
+     * @return the number of edges in this edge-weighted graph
+     */
+    public int E() {
+        return E;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Adds the undirected edge {@code e} to this edge-weighted graph.
+     *
+     * @param  e the edge
+     * @throws IllegalArgumentException unless both endpoints are between {@code 0} and {@code V-1}
+     */
+    public void addEdge(Edge e) {
+        int v = e.either();
+        int w = e.other(v);
+        validateVertex(v);
+        validateVertex(w);
+        adj[v].add(e);
+        adj[w].add(e);
+        E++;
+    }
+
+    /**
+     * Returns the edges incident on vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the edges incident on vertex {@code v} as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Edge> adj(int v) {
+        validateVertex(v);
+        return adj[v];
+    }
+
+    /**
+     * Returns the degree of vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the degree of vertex {@code v}               
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int degree(int v) {
+        validateVertex(v);
+        return adj[v].size();
+    }
+
+    /**
+     * Returns all edges in this edge-weighted graph.
+     * To iterate over the edges in this edge-weighted graph, use foreach notation:
+     * {@code for (Edge e : G.edges())}.
+     *
+     * @return all edges in this edge-weighted graph, as an iterable
+     */
+    public Iterable<Edge> edges() {
+        Bag<Edge> list = new Bag<Edge>();
+        for (int v = 0; v < V; v++) {
+            int selfLoops = 0;
+            for (Edge e : adj(v)) {
+                if (e.other(v) > v) {
+                    list.add(e);
+                }
+                // add only one copy of each self loop (self loops will be consecutive)
+                else if (e.other(v) == v) {
+                    if (selfLoops % 2 == 0) list.add(e);
+                    selfLoops++;
+                }
+            }
+        }
+        return list;
+    }
+
+    /**
+     * Returns a string representation of the edge-weighted graph.
+     * This method takes time proportional to <em>E</em> + <em>V</em>.
+     *
+     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
+     *         followed by the <em>V</em> adjacency lists of edges
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(V + " " + E + NEWLINE);
+        for (int v = 0; v < V; v++) {
+            s.append(v + ": ");
+            for (Edge e : adj[v]) {
+                s.append(e + "  ");
+            }
+            s.append(NEWLINE);
+        }
+        return s.toString();
+    }
+
+    /**
+     * Unit tests the {@code EdgeWeightedGraph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        StdOut.println(G);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/EulerianCycle.java b/src/main/java/edu/princeton/cs/algs4/EulerianCycle.java
new file mode 100644
index 0000000..c093e06
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/EulerianCycle.java
@@ -0,0 +1,316 @@
+/******************************************************************************
+ *  Compilation:  javac EulerianCycle.java
+ *  Execution:    java  EulerianCycle V E
+ *  Dependencies: Graph.java Stack.java StdOut.java
+ *
+ *  Find an Eulerian cycle in a graph, if one exists.
+ *
+ *  Runs in O(E + V) time.
+ *
+ *  This implementation is tricker than the one for digraphs because
+ *  when we use edge v-w from v's adjacency list, we must be careful
+ *  not to use the second copy of the edge from w's adjaceny list.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code EulerianCycle} class represents a data type
+ *  for finding an Eulerian cycle or path in a graph.
+ *  An <em>Eulerian cycle</em> is a cycle (not necessarily simple) that
+ *  uses every edge in the graph exactly once.
+ *  <p>
+ *  This implementation uses a nonrecursive depth-first search.
+ *  The constructor takes &Theta;(<em>E</em> + <em>V</em>) time in the worst
+ *  case, where <em>E</em> is the number of edges and <em>V</em> is the
+ *  number of vertices
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>E</em> + <em>V</em>) extra space in the worst case
+ *  (not including the graph).
+ *  <p>
+ *  To compute Eulerian paths in graphs, see {@link EulerianPath}.
+ *  To compute Eulerian cycles and paths in digraphs, see
+ *  {@link DirectedEulerianCycle} and {@link DirectedEulerianPath}.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ * 
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *  @author Nate Liu
+ */
+public class EulerianCycle {
+    private Stack<Integer> cycle = new Stack<Integer>();  // Eulerian cycle; null if no such cycle
+
+    // an undirected edge, with a field to indicate whether the edge has already been used
+    private static class Edge {
+        private final int v;
+        private final int w;
+        private boolean isUsed;
+
+        public Edge(int v, int w) {
+            this.v = v;
+            this.w = w;
+            isUsed = false;
+        }
+
+        // returns the other vertex of the edge
+        public int other(int vertex) {
+            if      (vertex == v) return w;
+            else if (vertex == w) return v;
+            else throw new IllegalArgumentException("Illegal endpoint");
+        }
+    }
+
+    /**
+     * Computes an Eulerian cycle in the specified graph, if one exists.
+     * 
+     * @param G the graph
+     */
+    public EulerianCycle(Graph G) {
+
+        // must have at least one edge
+        if (G.E() == 0) return;
+
+        // necessary condition: all vertices have even degree
+        // (this test is needed or it might find an Eulerian path instead of cycle)
+        for (int v = 0; v < G.V(); v++) 
+            if (G.degree(v) % 2 != 0)
+                return;
+
+        // create local view of adjacency lists, to iterate one vertex at a time
+        // the helper Edge data type is used to avoid exploring both copies of an edge v-w
+        Queue<Edge>[] adj = (Queue<Edge>[]) new Queue[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            adj[v] = new Queue<Edge>();
+
+        for (int v = 0; v < G.V(); v++) {
+            int selfLoops = 0;
+            for (int w : G.adj(v)) {
+                // careful with self loops
+                if (v == w) {
+                    if (selfLoops % 2 == 0) {
+                        Edge e = new Edge(v, w);
+                        adj[v].enqueue(e);
+                        adj[w].enqueue(e);
+                    }
+                    selfLoops++;
+                }
+                else if (v < w) {
+                    Edge e = new Edge(v, w);
+                    adj[v].enqueue(e);
+                    adj[w].enqueue(e);
+                }
+            }
+        }
+
+        // initialize stack with any non-isolated vertex
+        int s = nonIsolatedVertex(G);
+        Stack<Integer> stack = new Stack<Integer>();
+        stack.push(s);
+
+        // greedily search through edges in iterative DFS style
+        cycle = new Stack<Integer>();
+        while (!stack.isEmpty()) {
+            int v = stack.pop();
+            while (!adj[v].isEmpty()) {
+                Edge edge = adj[v].dequeue();
+                if (edge.isUsed) continue;
+                edge.isUsed = true;
+                stack.push(v);
+                v = edge.other(v);
+            }
+            // push vertex with no more leaving edges to cycle
+            cycle.push(v);
+        }
+
+        // check if all edges are used
+        if (cycle.size() != G.E() + 1)
+            cycle = null;
+
+        assert certifySolution(G);
+    }
+
+    /**
+     * Returns the sequence of vertices on an Eulerian cycle.
+     * 
+     * @return the sequence of vertices on an Eulerian cycle;
+     *         {@code null} if no such cycle
+     */
+    public Iterable<Integer> cycle() {
+        return cycle;
+    }
+
+    /**
+     * Returns true if the graph has an Eulerian cycle.
+     * 
+     * @return {@code true} if the graph has an Eulerian cycle;
+     *         {@code false} otherwise
+     */
+    public boolean hasEulerianCycle() {
+        return cycle != null;
+    }
+
+    // returns any non-isolated vertex; -1 if no such vertex
+    private static int nonIsolatedVertex(Graph G) {
+        for (int v = 0; v < G.V(); v++)
+            if (G.degree(v) > 0)
+                return v;
+        return -1;
+    }
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // Determines whether a graph has an Eulerian cycle using necessary
+    // and sufficient conditions (without computing the cycle itself):
+    //    - at least one edge
+    //    - degree(v) is even for every vertex v
+    //    - the graph is connected (ignoring isolated vertices)
+    private static boolean satisfiesNecessaryAndSufficientConditions(Graph G) {
+
+        // Condition 0: at least 1 edge
+        if (G.E() == 0) return false;
+
+        // Condition 1: degree(v) is even for every vertex
+        for (int v = 0; v < G.V(); v++)
+            if (G.degree(v) % 2 != 0)
+                return false;
+
+        // Condition 2: graph is connected, ignoring isolated vertices
+        int s = nonIsolatedVertex(G);
+        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
+        for (int v = 0; v < G.V(); v++)
+            if (G.degree(v) > 0 && !bfs.hasPathTo(v))
+                return false;
+
+        return true;
+    }
+
+    // check that solution is correct
+    private boolean certifySolution(Graph G) {
+
+        // internal consistency check
+        if (hasEulerianCycle() == (cycle() == null)) return false;
+
+        // hashEulerianCycle() returns correct value
+        if (hasEulerianCycle() != satisfiesNecessaryAndSufficientConditions(G)) return false;
+
+        // nothing else to check if no Eulerian cycle
+        if (cycle == null) return true;
+
+        // check that cycle() uses correct number of edges
+        if (cycle.size() != G.E() + 1) return false;
+
+        // check that cycle() is a cycle of G
+        // TODO
+
+        // check that first and last vertices in cycle() are the same
+        int first = -1, last = -1;
+        for (int v : cycle()) {
+            if (first == -1) first = v;
+            last = v;
+        }
+        if (first != last) return false;
+
+        return true;
+    }
+
+    private static void unitTest(Graph G, String description) {
+        StdOut.println(description);
+        StdOut.println("-------------------------------------");
+        StdOut.print(G);
+
+        EulerianCycle euler = new EulerianCycle(G);
+
+        StdOut.print("Eulerian cycle: ");
+        if (euler.hasEulerianCycle()) {
+            for (int v : euler.cycle()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+        else {
+            StdOut.println("none");
+        }
+        StdOut.println();
+    }
+
+
+    /**
+     * Unit tests the {@code EulerianCycle} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+
+        // Eulerian cycle
+        Graph G1 = GraphGenerator.eulerianCycle(V, E);
+        unitTest(G1, "Eulerian cycle");
+
+        // Eulerian path
+        Graph G2 = GraphGenerator.eulerianPath(V, E);
+        unitTest(G2, "Eulerian path");
+
+        // empty graph
+        Graph G3 = new Graph(V);
+        unitTest(G3, "empty graph");
+
+        // self loop
+        Graph G4 = new Graph(V);
+        int v4 = StdRandom.uniform(V);
+        G4.addEdge(v4, v4);
+        unitTest(G4, "single self loop");
+
+        // union of two disjoint cycles
+        Graph H1 = GraphGenerator.eulerianCycle(V/2, E/2);
+        Graph H2 = GraphGenerator.eulerianCycle(V - V/2, E - E/2);
+        int[] perm = new int[V];
+        for (int i = 0; i < V; i++)
+            perm[i] = i;
+        StdRandom.shuffle(perm);
+        Graph G5 = new Graph(V);
+        for (int v = 0; v < H1.V(); v++)
+            for (int w : H1.adj(v))
+                G5.addEdge(perm[v], perm[w]);
+        for (int v = 0; v < H2.V(); v++)
+            for (int w : H2.adj(v))
+                G5.addEdge(perm[V/2 + v], perm[V/2 + w]);
+        unitTest(G5, "Union of two disjoint cycles");
+
+        // random digraph
+        Graph G6 = GraphGenerator.simple(V, E);
+        unitTest(G6, "simple graph");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/EulerianPath.java b/src/main/java/edu/princeton/cs/algs4/EulerianPath.java
new file mode 100644
index 0000000..7b782f9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/EulerianPath.java
@@ -0,0 +1,309 @@
+/******************************************************************************
+ *  Compilation:  javac EulerianPath.java
+ *  Execution:    java EulerianPath V E
+ *  Dependencies: Graph.java Stack.java StdOut.java
+ *
+ *  Find an Eulerian path in a graph, if one exists.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code EulerianPath} class represents a data type
+ *  for finding an Eulerian path in a graph.
+ *  An <em>Eulerian path</em> is a path (not necessarily simple) that
+ *  uses every edge in the graph exactly once.
+ *  <p>
+ *  This implementation uses a nonrecursive depth-first search.
+ *  The constructor takes &Theta;(<em>E</em> + <em>V</em>) time in the worst
+ *  case, where <em>E</em> is the number of edges and <em>V</em> is
+ *  the number of vertices.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>E</em> + <em>V</em>) extra space in the worst case
+ *  (not including the digraph).
+ *  <p>
+ *  To compute Eulerian cycles in graphs, see {@link EulerianCycle}.
+ *  To compute Eulerian cycles and paths in digraphs, see
+ *  {@link DirectedEulerianCycle} and {@link DirectedEulerianPath}.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ * 
+ * @author Robert Sedgewick
+ * @author Kevin Wayne
+ * @author Nate Liu
+ */
+public class EulerianPath {
+    private Stack<Integer> path = null;   // Eulerian path; null if no suh path
+
+    // an undirected edge, with a field to indicate whether the edge has already been used
+    private static class Edge {
+        private final int v;
+        private final int w;
+        private boolean isUsed;
+
+        public Edge(int v, int w) {
+            this.v = v;
+            this.w = w;
+            isUsed = false;
+        }
+
+        // returns the other vertex of the edge
+        public int other(int vertex) {
+            if      (vertex == v) return w;
+            else if (vertex == w) return v;
+            else throw new IllegalArgumentException("Illegal endpoint");
+        }
+    }
+
+    /**
+     * Computes an Eulerian path in the specified graph, if one exists.
+     * 
+     * @param G the graph
+     */
+    public EulerianPath(Graph G) {
+
+        // find vertex from which to start potential Eulerian path:
+        // a vertex v with odd degree(v) if it exits;
+        // otherwise a vertex with degree(v) > 0
+        int oddDegreeVertices = 0;
+        int s = nonIsolatedVertex(G);
+        for (int v = 0; v < G.V(); v++) {
+            if (G.degree(v) % 2 != 0) {
+                oddDegreeVertices++;
+                s = v;
+            }
+        }
+
+        // graph can't have an Eulerian path
+        // (this condition is needed for correctness)
+        if (oddDegreeVertices > 2) return;
+
+        // special case for graph with zero edges (has a degenerate Eulerian path)
+        if (s == -1) s = 0;
+
+        // create local view of adjacency lists, to iterate one vertex at a time
+        // the helper Edge data type is used to avoid exploring both copies of an edge v-w
+        Queue<Edge>[] adj = (Queue<Edge>[]) new Queue[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            adj[v] = new Queue<Edge>();
+
+        for (int v = 0; v < G.V(); v++) {
+            int selfLoops = 0;
+            for (int w : G.adj(v)) {
+                // careful with self loops
+                if (v == w) {
+                    if (selfLoops % 2 == 0) {
+                        Edge e = new Edge(v, w);
+                        adj[v].enqueue(e);
+                        adj[w].enqueue(e);
+                    }
+                    selfLoops++;
+                }
+                else if (v < w) {
+                    Edge e = new Edge(v, w);
+                    adj[v].enqueue(e);
+                    adj[w].enqueue(e);
+                }
+            }
+        }
+
+        // initialize stack with any non-isolated vertex
+        Stack<Integer> stack = new Stack<Integer>();
+        stack.push(s);
+
+        // greedily search through edges in iterative DFS style
+        path = new Stack<Integer>();
+        while (!stack.isEmpty()) {
+            int v = stack.pop();
+            while (!adj[v].isEmpty()) {
+                Edge edge = adj[v].dequeue();
+                if (edge.isUsed) continue;
+                edge.isUsed = true;
+                stack.push(v);
+                v = edge.other(v);
+            }
+            // push vertex with no more leaving edges to path
+            path.push(v);
+        }
+
+        // check if all edges are used
+        if (path.size() != G.E() + 1)
+            path = null;
+
+        assert certifySolution(G);
+    }
+
+    /**
+     * Returns the sequence of vertices on an Eulerian path.
+     * 
+     * @return the sequence of vertices on an Eulerian path;
+     *         {@code null} if no such path
+     */
+    public Iterable<Integer> path() {
+        return path;
+    }
+
+    /**
+     * Returns true if the graph has an Eulerian path.
+     * 
+     * @return {@code true} if the graph has an Eulerian path;
+     *         {@code false} otherwise
+     */
+    public boolean hasEulerianPath() {
+        return path != null;
+    }
+
+
+    // returns any non-isolated vertex; -1 if no such vertex
+    private static int nonIsolatedVertex(Graph G) {
+        for (int v = 0; v < G.V(); v++)
+            if (G.degree(v) > 0)
+                return v;
+        return -1;
+    }
+
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // Determines whether a graph has an Eulerian path using necessary
+    // and sufficient conditions (without computing the path itself):
+    //    - degree(v) is even for every vertex, except for possibly two
+    //    - the graph is connected (ignoring isolated vertices)
+    // This method is solely for unit testing.
+    private static boolean satisfiesNecessaryAndSufficientConditions(Graph G) {
+        if (G.E() == 0) return true;
+
+        // Condition 1: degree(v) is even except for possibly two
+        int oddDegreeVertices = 0;
+        for (int v = 0; v < G.V(); v++)
+            if (G.degree(v) % 2 != 0)
+                oddDegreeVertices++;
+        if (oddDegreeVertices > 2) return false;
+
+        // Condition 2: graph is connected, ignoring isolated vertices
+        int s = nonIsolatedVertex(G);
+        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
+        for (int v = 0; v < G.V(); v++)
+            if (G.degree(v) > 0 && !bfs.hasPathTo(v))
+                return false;
+
+        return true;
+    }
+
+    // check that solution is correct
+    private boolean certifySolution(Graph G) {
+
+        // internal consistency check
+        if (hasEulerianPath() == (path() == null)) return false;
+
+        // hashEulerianPath() returns correct value
+        if (hasEulerianPath() != satisfiesNecessaryAndSufficientConditions(G)) return false;
+
+        // nothing else to check if no Eulerian path
+        if (path == null) return true;
+
+        // check that path() uses correct number of edges
+        if (path.size() != G.E() + 1) return false;
+
+        // check that path() is a path in G
+        // TODO
+
+        return true;
+    }
+
+
+    private static void unitTest(Graph G, String description) {
+        StdOut.println(description);
+        StdOut.println("-------------------------------------");
+        StdOut.print(G);
+
+        EulerianPath euler = new EulerianPath(G);
+
+        StdOut.print("Eulerian path:  ");
+        if (euler.hasEulerianPath()) {
+            for (int v : euler.path()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+        else {
+            StdOut.println("none");
+        }
+        StdOut.println();
+    }
+
+
+    /**
+     * Unit tests the {@code EulerianPath} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+
+
+        // Eulerian cycle
+        Graph G1 = GraphGenerator.eulerianCycle(V, E);
+        unitTest(G1, "Eulerian cycle");
+
+        // Eulerian path
+        Graph G2 = GraphGenerator.eulerianPath(V, E);
+        unitTest(G2, "Eulerian path");
+
+        // add one random edge
+        Graph G3 = new Graph(G2);
+        G3.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
+        unitTest(G3, "one random edge added to Eulerian path");
+
+        // self loop
+        Graph G4 = new Graph(V);
+        int v4 = StdRandom.uniform(V);
+        G4.addEdge(v4, v4);
+        unitTest(G4, "single self loop");
+
+        // single edge
+        Graph G5 = new Graph(V);
+        G5.addEdge(StdRandom.uniform(V), StdRandom.uniform(V));
+        unitTest(G5, "single edge");
+
+        // empty graph
+        Graph G6 = new Graph(V);
+        unitTest(G6, "empty graph");
+
+        // random graph
+        Graph G7 = GraphGenerator.simple(V, E);
+        unitTest(G7, "simple graph");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FFT.java b/src/main/java/edu/princeton/cs/algs4/FFT.java
new file mode 100644
index 0000000..e984f31
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FFT.java
@@ -0,0 +1,304 @@
+/******************************************************************************
+ *  Compilation:  javac FFT.java
+ *  Execution:    java FFT n
+ *  Dependencies: Complex.java
+ *
+ *  Compute the FFT and inverse FFT of a length n complex sequence.
+ *  Bare bones implementation that runs in O(n log n) time. Our goal
+ *  is to optimize the clarity of the code, rather than performance.
+ *
+ *  Limitations
+ *  -----------
+ *   -  assumes n is a power of 2
+ *
+ *   -  not the most memory efficient algorithm (because it uses
+ *      an object type for representing complex numbers and because
+ *      it re-allocates memory for the subarray, instead of doing
+ *      in-place or reusing a single temporary array)
+ *  
+ *
+ *  % java FFT 4
+ *  x
+ *  -------------------
+ *  -0.03480425839330703
+ *  0.07910192950176387
+ *  0.7233322451735928
+ *  0.1659819820667019
+ *
+ *  y = fft(x)
+ *  -------------------
+ *  0.9336118983487516
+ *  -0.7581365035668999 + 0.08688005256493803i
+ *  0.44344407521182005
+ *  -0.7581365035668999 - 0.08688005256493803i
+ *
+ *  z = ifft(y)
+ *  -------------------
+ *  -0.03480425839330703
+ *  0.07910192950176387 + 2.6599344570851287E-18i
+ *  0.7233322451735928
+ *  0.1659819820667019 - 2.6599344570851287E-18i
+ *
+ *  c = cconvolve(x, x)
+ *  -------------------
+ *  0.5506798633981853
+ *  0.23461407150576394 - 4.033186818023279E-18i
+ *  -0.016542951108772352
+ *  0.10288019294318276 + 4.033186818023279E-18i
+ *
+ *  d = convolve(x, x)
+ *  -------------------
+ *  0.001211336402308083 - 3.122502256758253E-17i
+ *  -0.005506167987577068 - 5.058885073636224E-17i
+ *  -0.044092969479563274 + 2.1934338938072244E-18i
+ *  0.10288019294318276 - 3.6147323062478115E-17i
+ *  0.5494685269958772 + 3.122502256758253E-17i
+ *  0.240120239493341 + 4.655566391833896E-17i
+ *  0.02755001837079092 - 2.1934338938072244E-18i
+ *  4.01805098805014E-17i
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code FFT} class provides methods for computing the 
+ *  FFT (Fast-Fourier Transform), inverse FFT, linear convolution,
+ *  and circular convolution of a complex array.
+ *  <p>
+ *  It is a bare-bones implementation that runs in <em>n</em> log <em>n</em> time,
+ *  where <em>n</em> is the length of the complex array. For simplicity,
+ *  <em>n</em> must be a power of 2.
+ *  Our goal is to optimize the clarity of the code, rather than performance.
+ *  It is not the most memory efficient implementation because it uses
+ *  objects to represents complex numbers and it it re-allocates memory
+ *  for the subarray, instead of doing in-place or reusing a single temporary array.
+ *  <p>
+ *  This computes correct results if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.  
+ *  In practice, there will be floating-point rounding error.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/99scientific">Section 9.9</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FFT {
+
+    private static final Complex ZERO = new Complex(0, 0);
+
+    // Do not instantiate.
+    private FFT() { }
+
+    /**
+     * Returns the FFT of the specified complex array.
+     *
+     * @param  x the complex array
+     * @return the FFT of the complex array {@code x}
+     * @throws IllegalArgumentException if the length of {@code x} is not a power of 2
+     */
+    public static Complex[] fft(Complex[] x) {
+        int n = x.length;
+
+        // base case
+        if (n == 1) {
+            return new Complex[] { x[0] };
+        }
+
+        // radix 2 Cooley-Tukey FFT
+        if (n % 2 != 0) {
+            throw new IllegalArgumentException("n is not a power of 2");
+        }
+
+        // fft of even terms
+        Complex[] even = new Complex[n/2];
+        for (int k = 0; k < n/2; k++) {
+            even[k] = x[2*k];
+        }
+        Complex[] q = fft(even);
+
+        // fft of odd terms
+        Complex[] odd  = even;  // reuse the array
+        for (int k = 0; k < n/2; k++) {
+            odd[k] = x[2*k + 1];
+        }
+        Complex[] r = fft(odd);
+
+        // combine
+        Complex[] y = new Complex[n];
+        for (int k = 0; k < n/2; k++) {
+            double kth = -2 * k * Math.PI / n;
+            Complex wk = new Complex(Math.cos(kth), Math.sin(kth));
+            y[k]       = q[k].plus(wk.times(r[k]));
+            y[k + n/2] = q[k].minus(wk.times(r[k]));
+        }
+        return y;
+    }
+
+
+    /**
+     * Returns the inverse FFT of the specified complex array.
+     *
+     * @param  x the complex array
+     * @return the inverse FFT of the complex array {@code x}
+     * @throws IllegalArgumentException if the length of {@code x} is not a power of 2
+     */
+    public static Complex[] ifft(Complex[] x) {
+        int n = x.length;
+        Complex[] y = new Complex[n];
+
+        // take conjugate
+        for (int i = 0; i < n; i++) {
+            y[i] = x[i].conjugate();
+        }
+
+        // compute forward FFT
+        y = fft(y);
+
+        // take conjugate again
+        for (int i = 0; i < n; i++) {
+            y[i] = y[i].conjugate();
+        }
+
+        // divide by n
+        for (int i = 0; i < n; i++) {
+            y[i] = y[i].scale(1.0 / n);
+        }
+
+        return y;
+
+    }
+
+    /**
+     * Returns the circular convolution of the two specified complex arrays.
+     *
+     * @param  x one complex array
+     * @param  y the other complex array
+     * @return the circular convolution of {@code x} and {@code y}
+     * @throws IllegalArgumentException if the length of {@code x} does not equal
+     *         the length of {@code y} or if the length is not a power of 2
+     */
+    public static Complex[] cconvolve(Complex[] x, Complex[] y) {
+
+        // should probably pad x and y with 0s so that they have same length
+        // and are powers of 2
+        if (x.length != y.length) {
+            throw new IllegalArgumentException("Dimensions don't agree");
+        }
+
+        int n = x.length;
+
+        // compute FFT of each sequence
+        Complex[] a = fft(x);
+        Complex[] b = fft(y);
+
+        // point-wise multiply
+        Complex[] c = new Complex[n];
+        for (int i = 0; i < n; i++) {
+            c[i] = a[i].times(b[i]);
+        }
+
+        // compute inverse FFT
+        return ifft(c);
+    }
+
+    /**
+     * Returns the linear convolution of the two specified complex arrays.
+     *
+     * @param  x one complex array
+     * @param  y the other complex array
+     * @return the linear convolution of {@code x} and {@code y}
+     * @throws IllegalArgumentException if the length of {@code x} does not equal
+     *         the length of {@code y} or if the length is not a power of 2
+     */
+    public static Complex[] convolve(Complex[] x, Complex[] y) {
+        Complex[] a = new Complex[2*x.length];
+        for (int i = 0; i < x.length; i++)
+            a[i] = x[i];
+        for (int i = x.length; i < 2*x.length; i++)
+            a[i] = ZERO;
+
+        Complex[] b = new Complex[2*y.length];
+        for (int i = 0; i < y.length; i++)
+            b[i] = y[i];
+        for (int i = y.length; i < 2*y.length; i++)
+            b[i] = ZERO;
+
+        return cconvolve(a, b);
+    }
+
+    // display an array of Complex numbers to standard output
+    private static void show(Complex[] x, String title) {
+        StdOut.println(title);
+        StdOut.println("-------------------");
+        for (int i = 0; i < x.length; i++) {
+            StdOut.println(x[i]);
+        }
+        StdOut.println();
+    }
+
+
+   /***************************************************************************
+    *  Test client.
+    ***************************************************************************/
+
+    /**
+     * Unit tests the {@code FFT} class.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        int n = Integer.parseInt(args[0]);
+        Complex[] x = new Complex[n];
+
+        // original data
+        for (int i = 0; i < n; i++) {
+            x[i] = new Complex(i, 0);
+            x[i] = new Complex(StdRandom.uniform(-1.0, 1.0), 0);
+        }
+        show(x, "x");
+
+        // FFT of original data
+        Complex[] y = fft(x);
+        show(y, "y = fft(x)");
+
+        // take inverse FFT
+        Complex[] z = ifft(y);
+        show(z, "z = ifft(y)");
+
+        // circular convolution of x with itself
+        Complex[] c = cconvolve(x, x);
+        show(c, "c = cconvolve(x, x)");
+
+        // linear convolution of x with itself
+        Complex[] d = convolve(x, x);
+        show(d, "d = convolve(x, x)");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FarthestPair.java b/src/main/java/edu/princeton/cs/algs4/FarthestPair.java
new file mode 100644
index 0000000..12b866b
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FarthestPair.java
@@ -0,0 +1,193 @@
+/******************************************************************************
+ *  Compilation:  javac FarthestPair.java
+ *  Execution:    java FarthestPair < input.txt
+ *  Dependencies: GrahamScan.java Point2D.java
+ *  Data files:   https://algs4.cs.princeton.edu/99hull/rs1423.txt
+ *                https://algs4.cs.princeton.edu/99hull/kw1260.txt
+ *  
+ *  Given a set of n points in the plane, find the farthest pair
+ *  (equivalently, compute the diameter of the set of points).
+ *
+ *  Computes the convex hull of the set of points and using the
+ *  rotating calipers method to find all antipodal point pairs
+ *  and the farthest pair.
+ *
+ *  % java FarthestPair < input100.txt
+ *  42697.98170874122 from (32011.0, 3140.0) to (822.0, 32301.0)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code FarthestPair} data type computes the farthest pair of points
+ *  in a set of <em>n</em> points in the plane and provides accessor methods
+ *  for getting the farthest pair of points and the distance between them.
+ *  The distance between two points is their Euclidean distance.
+ *  <p>
+ *  This implementation computes the convex hull of the set of points and
+ *  uses the rotating calipers method to find all antipodal point pairs
+ *  and the farthest pair.
+ *  It runs in O(<em>n</em> log <em>n</em>) time in the worst case and uses
+ *  O(<em>N</em>) extra space.
+ *  See also {@link ClosestPair} and {@link GrahamScan}.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/99hull">Section 9.9</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FarthestPair {
+
+    // farthest pair of points and distance
+    private Point2D best1, best2;
+    private double bestDistanceSquared = Double.NEGATIVE_INFINITY;
+
+    /**
+     * Computes the farthest pair of points in the specified array of points.
+     *
+     * @param  points the array of points
+     * @throws IllegalArgumentException if {@code points} is {@code null} or if any
+     *         entry in {@code points[]} is {@code null}
+     */
+    public FarthestPair(Point2D[] points) {
+        if (points == null) throw new IllegalArgumentException("constructor argument is null");
+        for (int i = 0; i < points.length; i++) {
+            if (points[i] == null) throw new IllegalArgumentException("array element " + i + " is null");
+        }
+
+        GrahamScan graham = new GrahamScan(points);
+
+        // single point
+        if (points.length <= 1) return;
+
+        // number of points on the hull
+        int m = 0;
+        for (Point2D p : graham.hull())
+            m++;
+
+        // the hull, in counterclockwise order hull[1] to hull[m]
+        Point2D[] hull = new Point2D[m+1];
+        m = 1;
+        for (Point2D p : graham.hull()) {
+            hull[m++] = p;
+        }
+        m--;
+
+        // all points are equal
+        if (m == 1) return;
+
+        // points are collinear
+        if (m == 2) {
+            best1 = hull[1];
+            best2 = hull[2];
+            bestDistanceSquared = best1.distanceSquaredTo(best2);
+            return;
+        }
+
+        // k = farthest vertex from edge from hull[1] to hull[m]
+        int k = 2;
+        while (Point2D.area2(hull[m], hull[1], hull[k+1]) > Point2D.area2(hull[m], hull[1], hull[k])) {
+            k++;
+        }
+
+        int j = k;
+        for (int i = 1; i <= k && j <= m; i++) {
+            // StdOut.println("hull[i] + " and " + hull[j] + " are antipodal");
+            if (hull[i].distanceSquaredTo(hull[j]) > bestDistanceSquared) {
+                best1 = hull[i];
+                best2 = hull[j];
+                bestDistanceSquared = hull[i].distanceSquaredTo(hull[j]);
+            }
+            while ((j < m) && Point2D.area2(hull[i], hull[i+1], hull[j+1]) > Point2D.area2(hull[i], hull[i+1], hull[j])) {
+                j++;
+                // StdOut.println(hull[i] + " and " + hull[j] + " are antipodal");
+                double distanceSquared = hull[i].distanceSquaredTo(hull[j]);
+                if (distanceSquared > bestDistanceSquared) {
+                    best1 = hull[i];
+                    best2 = hull[j];
+                    bestDistanceSquared = hull[i].distanceSquaredTo(hull[j]);
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns one of the points in the farthest pair of points.
+     *
+     * @return one of the two points in the farthest pair of points;
+     *         {@code null} if no such point (because there are fewer than 2 points)
+     */
+    public Point2D either() {
+        return best1;
+    }
+
+    /**
+     * Returns the other point in the farthest pair of points.
+     *
+     * @return the other point in the farthest pair of points
+     *         {@code null} if no such point (because there are fewer than 2 points)
+     */
+    public Point2D other() {
+        return best2;
+    }
+
+    /**
+     * Returns the Eucliden distance between the farthest pair of points.
+     * This quantity is also known as the <em>diameter</em> of the set of points.
+     *
+     * @return the Euclidean distance between the farthest pair of points
+     *         {@code Double.POSITIVE_INFINITY} if no such pair of points
+     *         exist (because there are fewer than 2 points)
+     */
+    public double distance() {
+        return Math.sqrt(bestDistanceSquared);
+    }
+
+   /**
+     * Unit tests the {@code FarthestPair} data type.
+     * Reads in an integer {@code n} and {@code n} points (specified by
+     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
+     * computes a farthest pair of points; and prints the pair to standard
+     * output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        Point2D[] points = new Point2D[n];
+        for (int i = 0; i < n; i++) {
+            int x = StdIn.readInt();
+            int y = StdIn.readInt();
+            points[i] = new Point2D(x, y);
+        }
+        FarthestPair farthest = new FarthestPair(points);
+        StdOut.println(farthest.distance() + " from " + farthest.either() + " to " + farthest.other());
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FenwickTree.java b/src/main/java/edu/princeton/cs/algs4/FenwickTree.java
new file mode 100644
index 0000000..dc96911
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FenwickTree.java
@@ -0,0 +1,212 @@
+/******************************************************************************
+ *  Compilation:  javac FenwickTree.java
+ *  Execution:    java FenwickTree
+ *
+ *  A Fenwick tree.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+/**
+ * Created by ricardodpsx@gmail.com on 4/01/15.
+ * <p>
+ * In {@code Fenwick Tree} structure We arrange the array in an smart way to perform efficient <em>range queries and updates</em>.
+ * The key point is this: In a fenwick array, each position "responsible" for storing cumulative data of N previous positions (N could be 1)
+ * For example:
+ * array[40] stores: array[40] + array[39] ... + array[32] (8 positions)
+ * array[32] stores: array[32] + array[31] ... + array[1]  (32 positions)
+ * <p>
+ * <strong>But, how do you know how much positions a given index is "responsible" for?</strong>
+ * <p>
+ * To know the number of items that a given array position 'ind' is responsible for
+ * We should extract from 'ind' the portion up to the first significant one of the binary representation of 'ind'
+ * for example, given ind == 40 (101000 in binary), according to Fenwick algorithm
+ * what We want is to extract 1000(8 in decimal).
+ * <p>
+ * This means that array[40] has cumulative information of 8 array items.
+ * But We still need to know the cumulative data bellow array[40 - 8 = 32]
+ * 32 is  100000 in binnary, and the portion up to the least significant one is 32 itself!
+ * So array[32] has information of 32 items, and We are done!
+ * <p>
+ * So cummulative data of array[1...40] = array[40] + array[32]
+ * Because 40 has information of items from 40 to 32, and 32 has information of items from 32 to  1
+ * <p>
+ * Memory usage:  O(n)
+ *
+ * @author Ricardo Pacheco 
+ */
+public class FenwickTree {
+
+    int[] array; // 1-indexed array, In this array We save cumulative information to perform efficient range queries and updates
+
+    public FenwickTree(int size) {
+        array = new int[size + 1];
+    }
+
+    /**
+     * Range Sum query from 1 to ind
+     * ind is 1-indexed
+     * <p>
+     * Time-Complexity:    O(log(n))
+     *
+     * @param  ind index
+     * @return sum
+     */
+    public int rsq(int ind) {
+        assert ind > 0;
+        int sum = 0;
+        while (ind > 0) {
+            sum += array[ind];
+            //Extracting the portion up to the first significant one of the binary representation of 'ind' and decrementing ind by that number
+            ind -= ind & (-ind);
+        }
+
+        return sum;
+    }
+
+    /**
+     * Range Sum Query from a to b.
+     * Search for the sum from array index from a to b
+     * a and b are 1-indexed
+     * <p>
+     * Time-Complexity:    O(log(n))
+     *
+     * @param  a left index
+     * @param  b right index
+     * @return sum
+     */
+    public int rsq(int a, int b) {
+        assert b >= a && a > 0 && b > 0;
+
+        return rsq(b) - rsq(a - 1);
+    }
+
+    /**
+     * Update the array at ind and all the affected regions above ind.
+     * ind is 1-indexed
+     * <p>
+     * Time-Complexity:    O(log(n))
+     *
+     * @param  ind   index
+     * @param  value value
+     */
+    public void update(int ind, int value) {
+        assert ind > 0;
+        while (ind < array.length) {
+            array[ind] += value;
+            //Extracting the portion up to the first significant one of the binary representation of 'ind' and incrementing ind by that number
+            ind += ind & (-ind);
+        }
+    }
+
+    public int size() {
+        return array.length - 1;
+    }
+
+
+    /**
+     * Read the following commands:
+     * init n     Initializes the array of size n all zeroes
+     * set a b c    Initializes the array  with [a, b, c ...]
+     * rsq a b      Range Sum Query for the range [a,b]
+     * up  i v      Update the i position of the array with value v.
+     * exit
+     * <p>
+     * The array is 1-indexed
+     * Example:
+     * set 1 2 3 4 5 6
+     * rsq 1 3
+     * Sum from 1 to 3 = 6
+     * rmq 1 3
+     * Min from 1 to 3 = 1
+     * input up 1 3
+     * [3,2,3,4,5,6]
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+
+        FenwickTree ft = null;
+
+        String cmd = "cmp";
+        while (true) {
+            String[] line = StdIn.readLine().split(" ");
+
+            if (line[0].equals("exit")) break;
+
+            int arg1 = 0, arg2 = 0;
+
+            if (line.length > 1) {
+                arg1 = Integer.parseInt(line[1]);
+            }
+            if (line.length > 2) {
+                arg2 = Integer.parseInt(line[2]);
+            }
+
+            if ((!line[0].equals("set") && !line[0].equals("init")) && ft == null) {
+                StdOut.println("FenwickTree not initialized");
+                continue;
+            }
+
+            if (line[0].equals("init")) {
+                ft = new FenwickTree(arg1);
+                for (int i = 1; i <= ft.size(); i++) {
+                    StdOut.print(ft.rsq(i, i) + " ");
+                }
+                StdOut.println();
+            }
+            else if (line[0].equals("set")) {
+                ft = new FenwickTree(line.length - 1);
+                for (int i = 1; i <= line.length - 1; i++) {
+                    ft.update(i, Integer.parseInt(line[i]));
+                }
+            }
+
+            else if (line[0].equals("up")) {
+                ft.update(arg1, arg2);
+                for (int i = 1; i <= ft.size(); i++) {
+                    StdOut.print(ft.rsq(i, i) + " ");
+                }
+                StdOut.println();
+            }
+            else if (line[0].equals("rsq")) {
+                StdOut.printf("Sum from %d to %d = %d%n", arg1, arg2, ft.rsq(arg1, arg2));
+            }
+            else {
+                StdOut.println("Invalid command");
+            }
+
+        }
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FibonacciMinPQ.java b/src/main/java/edu/princeton/cs/algs4/FibonacciMinPQ.java
new file mode 100644
index 0000000..130fadb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FibonacciMinPQ.java
@@ -0,0 +1,354 @@
+/******************************************************************************
+ *  Compilation: javac FibonacciMinPQ.java
+ *  Execution:
+ *
+ *  A Fibonacci heap.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.HashMap;
+import java.util.NoSuchElementException;
+import java.util.Comparator;
+
+/*
+ *  The FibonacciMinPQ class represents a priority queue of generic keys.
+ *  It supports the usual insert and delete-the-minimum operations, 
+ *  along with the merging of two heaps together.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  It is possible to build the priority queue using a Comparator.
+ *  If not, the natural order relation between the keys will be used.
+ *  
+ *  This implementation uses a Fibonacci heap.
+ *  The delete-the-minimum operation takes amortized logarithmic time.
+ *  The insert, min-key, is-empty, size, union and constructor take constant time.
+ *
+ *   WARNING: THIS VERSION HAS AT LEAST ONE BUG.
+ *
+ *  @author Tristan Claverie
+ */
+public class FibonacciMinPQ<Key> implements Iterable<Key> {
+	private Node head;					//Head of the circular root list
+	private Node min;					//Minimum Node of the root list
+	private int size;					//Number of keys in the heap
+	private final Comparator<Key> comp;	//Comparator over the keys
+	private HashMap<Integer, Node> table = new HashMap<Integer, Node>(); //Used for the consolidate operation
+	
+	//Represents a Node of a tree
+	private class Node {
+		Key key;						//Key of this Node
+		int order;						//Order of the tree rooted by this Node
+		Node prev, next;				//Siblings of this Node
+		Node child;						//Child of this Node
+	}
+	
+	/**
+	 * Initializes an empty priority queue
+	 * Worst case is O(1)
+	 * @param C a Comparator over the Keys
+	 */
+	public FibonacciMinPQ(Comparator<Key> C) {
+		comp = C;
+	}
+	
+    /**
+     * Initializes an empty priority queue
+     * Worst case is O(1)
+     */
+	public FibonacciMinPQ() {
+		comp = new MyComparator();
+	}
+	
+	/**
+	 * Initializes a priority queue with given keys
+	 * Worst case is O(n)
+	 * @param a an array of keys
+	 */
+	public FibonacciMinPQ(Key[] a) {
+		comp = new MyComparator();
+		for (Key k : a) insert(k);
+	}
+	
+	/**
+	 * Initializes a priority queue with given keys
+	 * Worst case is O(n)
+	 * @param C a comparator over the keys
+	 * @param a an array of keys
+	 */
+	public FibonacciMinPQ(Comparator<Key> C, Key[] a) {
+		comp = C;
+		for (Key k : a) insert(k);
+	}
+
+	/**
+	 * Whether the priority queue is empty
+	 * Worst case is O(1)
+	 * @return true if the priority queue is empty, false if not
+	 */
+	public boolean isEmpty() {
+		return size == 0;
+	}
+
+	/**
+	 * Number of elements currently on the priority queue
+	 * Worst case is O(1)
+	 * @return the number of elements on the priority queue
+	 */
+	public int size() {
+		return size;
+	}
+
+	/**
+	 * Insert a key in the queue
+	 * Worst case is O(1)
+	 * @param key a Key
+	 */
+	public void insert(Key key) {
+		Node x = new Node();
+		x.key = key;
+		size++;
+		head = insert(x, head);
+		if (min == null) min = head;
+		else 			 min = (greater(min.key, key)) ? head : min;
+	}
+
+	/**
+	 * Gets the minimum key currently in the queue
+	 * Worst case is O(1)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key currently in the priority queue
+	 */
+	public Key minKey() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		return min.key;
+	}
+
+	/**
+	 * Deletes the minimum key
+	 * Worst case is O(log(n)) (amortized)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key
+	 */
+	public Key delMin() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		head = cut(min, head);
+		Node x = min.child;
+		Key key = min.key;
+		min.key = null;
+		if (x != null) {
+			head = meld(head, x);
+			min.child = null;
+		}
+		size--;
+		if (!isEmpty()) consolidate();
+		else 			min = null;
+		return key;
+	}
+	
+	/**
+	 * Merges two heaps together
+	 * This operation is destructive
+	 * Worst case is O(1)
+	 * @param that a Fibonacci heap
+	 * @return the union of the two heaps
+	 */
+	public FibonacciMinPQ<Key> union(FibonacciMinPQ<Key> that) {
+		this.head = meld(head, that.head);
+		this.min = (greater(this.min.key, that.min.key)) ? that.min : this.min;
+		this.size = this.size+that.size;
+		return this;
+	}
+	
+	/*************************************
+	 * General helper functions
+	 ************************************/
+	
+	//Compares two keys
+	private boolean greater(Key n, Key m) {
+		if (n == null) return false;
+		if (m == null) return true;
+		return comp.compare(n,m) > 0;
+	}
+	
+	//Assuming root1 holds a greater key than root2, root2 becomes the new root
+	private void link(Node root1, Node root2) {
+		root2.child = insert(root1, root2.child);
+		root2.order++;
+	}
+	
+	/*************************************
+	 * Function for consolidating all trees in the root list
+	 ************************************/
+	
+	//Coalesce the roots, thus reshapes the tree
+	private void consolidate() {
+		table.clear();
+		Node x = head;
+		int maxOrder = 0;
+		min = head;
+		Node y = null; Node z = null;
+		do {
+			y = x;
+			x = x.next;
+			z = table.get(y.order);
+			while (z != null) {
+				table.remove(y.order);
+				if (greater(y.key, z.key)) {
+					link(y, z);
+					y = z;
+				} else {
+					link(z, y);
+				}
+				z = table.get(y.order);
+			}
+			table.put(y.order, y);
+			if (y.order > maxOrder) maxOrder = y.order;
+		} while (x != head);
+		head = null;
+		for (Node n : table.values()) {
+			if (n != null) {
+				min = greater(min.key, n.key) ? n : min;
+				head = insert(n, head);
+			}
+		}
+	}
+	
+	/*************************************
+	 * General helper functions for manipulating circular lists
+	 ************************************/
+	
+	//Inserts a Node in a circular list containing head, returns a new head
+	private Node insert(Node x, Node head) {
+		if (head == null) {
+			x.prev = x;
+			x.next = x;
+		} else {
+			head.prev.next = x;
+			x.next = head;
+			x.prev = head.prev;
+			head.prev = x;
+		}
+		return x;
+	}
+	
+	//Removes a tree from the list defined by the head pointer
+	private Node cut(Node x, Node head) {
+		if (x.next == x) {
+			x.next = null;
+			x.prev = null;
+			return null;
+		} else {
+			x.next.prev = x.prev;
+			x.prev.next = x.next;
+			Node res = x.next;
+			x.next = null;
+			x.prev = null;
+			if (head == x)  return res;
+			else 			return head;
+		}
+	}
+	
+	//Merges two root lists together
+	private Node meld(Node x, Node y) {
+		if (x == null) return y;
+		if (y == null) return x;
+		x.prev.next = y.next;
+		y.next.prev = x.prev;
+		x.prev = y;
+		y.next = x;
+		return x;
+	}
+	
+	/*************************************
+	 * Iterator
+	 ************************************/
+	
+	/**
+	 * Gets an Iterator over the Keys in the priority queue in ascending order
+	 * The Iterator does not implement the remove() method
+	 * iterator() : Worst case is O(n)
+	 * next() : 	Worst case is O(log(n)) (amortized)
+	 * hasNext() : 	Worst case is O(1)
+	 * @return an Iterator over the Keys in the priority queue in ascending order
+	 */
+	
+	public Iterator<Key> iterator() {
+		return new MyIterator();
+	}
+	
+	private class MyIterator implements Iterator<Key> {
+		private FibonacciMinPQ<Key> copy;
+		
+		
+		//Constructor takes linear time
+		public MyIterator() {
+			copy = new FibonacciMinPQ<Key>(comp);
+			insertAll(head);
+		}
+		
+		private void insertAll(Node head) {
+			if (head == null) return;
+			Node x = head;
+			do {
+				copy.insert(x.key);
+				insertAll(x.child);
+				x = x.next;
+			} while (x != head);
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+		
+		public boolean hasNext() {
+			return !copy.isEmpty();
+		}
+		
+		//Takes amortized logarithmic time
+		public Key next() {
+			if (!hasNext()) throw new NoSuchElementException();
+			return copy.delMin();
+		}
+	}
+	
+	/*************************************
+	 * Comparator
+	 ************************************/
+	
+	//default Comparator
+	private class MyComparator implements Comparator<Key> {
+		@Override
+		public int compare(Key key1, Key key2) {
+			return ((Comparable<Key>) key1).compareTo(key2);
+		}
+	}
+	
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FileIndex.java b/src/main/java/edu/princeton/cs/algs4/FileIndex.java
new file mode 100644
index 0000000..9d7af1a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FileIndex.java
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *  Compilation:  javac FileIndex.java
+ *  Execution:    java FileIndex file1.txt file2.txt file3.txt ...
+ *  Dependencies: ST.java SET.java In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/ex1.txt
+ *                https://algs4.cs.princeton.edu/35applications/ex2.txt
+ *                https://algs4.cs.princeton.edu/35applications/ex3.txt
+ *                https://algs4.cs.princeton.edu/35applications/ex4.txt
+ *
+ *  % java FileIndex ex*.txt
+ *  age
+ *   ex3.txt
+ *   ex4.txt 
+ * best
+ *   ex1.txt 
+ * was
+ *   ex1.txt
+ *   ex2.txt
+ *   ex3.txt
+ *   ex4.txt 
+ *
+ *  % java FileIndex *.txt
+ *
+ *  % java FileIndex *.java
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.File;
+
+/**
+ *  The {@code FileIndex} class provides a client for indexing a set of files,
+ *  specified as command-line arguments. It takes queries from standard input
+ *  and prints each file that contains the given query.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FileIndex { 
+
+    // Do not instantiate.
+    private FileIndex() { }
+
+    public static void main(String[] args) {
+
+        // key = word, value = set of files containing that word
+        ST<String, SET<File>> st = new ST<String, SET<File>>();
+
+        // create inverted index of all files
+        StdOut.println("Indexing files");
+        for (String filename : args) {
+            StdOut.println("  " + filename);
+            File file = new File(filename);
+            In in = new In(file);
+            while (!in.isEmpty()) {
+                String word = in.readString();
+                if (!st.contains(word)) st.put(word, new SET<File>());
+                SET<File> set = st.get(word);
+                set.add(file);
+            }
+        }
+
+
+        // read queries from standard input, one per line
+        while (!StdIn.isEmpty()) {
+            String query = StdIn.readString();
+            if (st.contains(query)) {
+                SET<File> set = st.get(query);
+                for (File file : set) {
+                    StdOut.println("  " + file.getName());
+                }
+            }
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FlowEdge.java b/src/main/java/edu/princeton/cs/algs4/FlowEdge.java
new file mode 100644
index 0000000..5f1d1ba
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FlowEdge.java
@@ -0,0 +1,228 @@
+/******************************************************************************
+ *  Compilation:  javac FlowEdge.java
+ *  Execution:    java FlowEdge
+ *  Dependencies: StdOut.java
+ *
+ *  Capacitated edge with a flow in a flow network.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code FlowEdge} class represents a capacitated edge with a 
+  * flow in a {@link FlowNetwork}. Each edge consists of two integers
+ *  (naming the two vertices), a real-valued capacity, and a real-valued
+ *  flow. The data type provides methods for accessing the two endpoints
+ *  of the directed edge and the weight. It also provides methods for
+ *  changing the amount of flow on the edge and determining the residual
+ *  capacity of the edge.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/64maxflow">Section 6.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FlowEdge {
+    // to deal with floating-point roundoff errors
+    private static final double FLOATING_POINT_EPSILON = 1E-10;
+
+    private final int v;             // from
+    private final int w;             // to 
+    private final double capacity;   // capacity
+    private double flow;             // flow
+
+    /**
+     * Initializes an edge from vertex {@code v} to vertex {@code w} with
+     * the given {@code capacity} and zero flow.
+     * @param v the tail vertex
+     * @param w the head vertex
+     * @param capacity the capacity of the edge
+     * @throws IllegalArgumentException if either {@code v} or {@code w}
+     *    is a negative integer
+     * @throws IllegalArgumentException if {@code capacity < 0.0}
+     */
+    public FlowEdge(int v, int w, double capacity) {
+        if (v < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
+        if (w < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
+        if (!(capacity >= 0.0)) throw new IllegalArgumentException("Edge capacity must be non-negative");
+        this.v         = v;
+        this.w         = w;  
+        this.capacity  = capacity;
+        this.flow      = 0.0;
+    }
+
+    /**
+     * Initializes an edge from vertex {@code v} to vertex {@code w} with
+     * the given {@code capacity} and {@code flow}.
+     * @param v the tail vertex
+     * @param w the head vertex
+     * @param capacity the capacity of the edge
+     * @param flow the flow on the edge
+     * @throws IllegalArgumentException if either {@code v} or {@code w}
+     *    is a negative integer
+     * @throws IllegalArgumentException if {@code capacity} is negative
+     * @throws IllegalArgumentException unless {@code flow} is between 
+     *    {@code 0.0} and {@code capacity}.
+     */
+    public FlowEdge(int v, int w, double capacity, double flow) {
+        if (v < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
+        if (w < 0) throw new IllegalArgumentException("vertex index must be a non-negative integer");
+        if (!(capacity >= 0.0))  throw new IllegalArgumentException("edge capacity must be non-negative");
+        if (!(flow <= capacity)) throw new IllegalArgumentException("flow exceeds capacity");
+        if (!(flow >= 0.0))      throw new IllegalArgumentException("flow must be non-negative");
+        this.v         = v;
+        this.w         = w;  
+        this.capacity  = capacity;
+        this.flow      = flow;
+    }
+
+    /**
+     * Initializes a flow edge from another flow edge.
+     * @param e the edge to copy
+     */
+    public FlowEdge(FlowEdge e) {
+        this.v         = e.v;
+        this.w         = e.w;
+        this.capacity  = e.capacity;
+        this.flow      = e.flow;
+    }
+
+    /**
+     * Returns the tail vertex of the edge.
+     * @return the tail vertex of the edge
+     */
+    public int from() {
+        return v;
+    }  
+
+    /**
+     * Returns the head vertex of the edge.
+     * @return the head vertex of the edge
+     */
+    public int to() {
+        return w;
+    }  
+
+    /**
+     * Returns the capacity of the edge.
+     * @return the capacity of the edge
+     */
+    public double capacity() {
+        return capacity;
+    }
+
+    /**
+     * Returns the flow on the edge.
+     * @return the flow on the edge
+     */
+    public double flow() {
+        return flow;
+    }
+
+    /**
+     * Returns the endpoint of the edge that is different from the given vertex
+     * (unless the edge represents a self-loop in which case it returns the same vertex).
+     * @param vertex one endpoint of the edge
+     * @return the endpoint of the edge that is different from the given vertex
+     *   (unless the edge represents a self-loop in which case it returns the same vertex)
+     * @throws IllegalArgumentException if {@code vertex} is not one of the endpoints
+     *   of the edge
+     */
+    public int other(int vertex) {
+        if      (vertex == v) return w;
+        else if (vertex == w) return v;
+        else throw new IllegalArgumentException("invalid endpoint");
+    }
+
+    /**
+     * Returns the residual capacity of the edge in the direction
+     *  to the given {@code vertex}.
+     * @param vertex one endpoint of the edge
+     * @return the residual capacity of the edge in the direction to the given vertex
+     *   If {@code vertex} is the tail vertex, the residual capacity equals
+     *   {@code capacity() - flow()}; if {@code vertex} is the head vertex, the
+     *   residual capacity equals {@code flow()}.
+     * @throws IllegalArgumentException if {@code vertex} is not one of the endpoints of the edge
+     */
+    public double residualCapacityTo(int vertex) {
+        if      (vertex == v) return flow;              // backward edge
+        else if (vertex == w) return capacity - flow;   // forward edge
+        else throw new IllegalArgumentException("invalid endpoint");
+    }
+
+    /**
+     * Increases the flow on the edge in the direction to the given vertex.
+     *   If {@code vertex} is the tail vertex, this increases the flow on the edge by {@code delta};
+     *   if {@code vertex} is the head vertex, this decreases the flow on the edge by {@code delta}.
+     * @param vertex one endpoint of the edge
+     * @param delta amount by which to increase flow
+     * @throws IllegalArgumentException if {@code vertex} is not one of the endpoints
+     *   of the edge
+     * @throws IllegalArgumentException if {@code delta} makes the flow on
+     *   on the edge either negative or larger than its capacity
+     * @throws IllegalArgumentException if {@code delta} is {@code NaN}
+     */
+    public void addResidualFlowTo(int vertex, double delta) {
+        if (!(delta >= 0.0)) throw new IllegalArgumentException("Delta must be non-negative");
+
+        if      (vertex == v) flow -= delta;           // backward edge
+        else if (vertex == w) flow += delta;           // forward edge
+        else throw new IllegalArgumentException("invalid endpoint");
+
+        // round flow to 0 or capacity if within floating-point precision
+        if (Math.abs(flow) <= FLOATING_POINT_EPSILON)
+            flow = 0;
+        if (Math.abs(flow - capacity) <= FLOATING_POINT_EPSILON)
+            flow = capacity;
+
+        if (!(flow >= 0.0))      throw new IllegalArgumentException("Flow is negative");
+        if (!(flow <= capacity)) throw new IllegalArgumentException("Flow exceeds capacity");
+    }
+
+
+    /**
+     * Returns a string representation of the edge.
+     * @return a string representation of the edge
+     */
+    public String toString() {
+        return v + "->" + w + " " + flow + "/" + capacity;
+    }
+
+
+   /**
+     * Unit tests the {@code FlowEdge} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        FlowEdge e = new FlowEdge(12, 23, 4.56);
+        StdOut.println(e);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FlowNetwork.java b/src/main/java/edu/princeton/cs/algs4/FlowNetwork.java
new file mode 100644
index 0000000..ddb997e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FlowNetwork.java
@@ -0,0 +1,217 @@
+/******************************************************************************
+ *  Compilation:  javac FlowNetwork.java
+ *  Execution:    java FlowNetwork V E
+ *  Dependencies: Bag.java FlowEdge.java
+ *
+ *  A capacitated flow network, implemented using adjacency lists.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code FlowNetwork} class represents a capacitated network
+ *  with vertices named 0 through <em>V</em> - 1, where each directed
+ *  edge is of type {@link FlowEdge} and has a real-valued capacity
+ *  and flow.
+ *  It supports the following two primary operations: add an edge to the network,
+ *  iterate over all of the edges incident to or from a vertex. It also provides
+ *  methods for returning the number of vertices <em>V</em> and the number
+ *  of edges <em>E</em>. Parallel edges and self-loops are permitted.
+ *  <p>
+ *  This implementation uses an adjacency-lists representation, which 
+ *  is a vertex-indexed array of {@link Bag} objects.
+ *  All operations take constant time (in the worst case) except
+ *  iterating over the edges incident to a given vertex, which takes
+ *  time proportional to the number of such edges.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/64maxflow">Section 6.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FlowNetwork {
+    private static final String NEWLINE = System.getProperty("line.separator");
+
+    private final int V;
+    private int E;
+    private Bag<FlowEdge>[] adj;
+    
+    /**
+     * Initializes an empty flow network with {@code V} vertices and 0 edges.
+     * @param V the number of vertices
+     * @throws IllegalArgumentException if {@code V < 0}
+     */
+    public FlowNetwork(int V) {
+        if (V < 0) throw new IllegalArgumentException("Number of vertices in a Graph must be non-negative");
+        this.V = V;
+        this.E = 0;
+        adj = (Bag<FlowEdge>[]) new Bag[V];
+        for (int v = 0; v < V; v++)
+            adj[v] = new Bag<FlowEdge>();
+    }
+
+    /**
+     * Initializes a random flow network with {@code V} vertices and <em>E</em> edges.
+     * The capacities are integers between 0 and 99 and the flow values are zero.
+     * @param V the number of vertices
+     * @param E the number of edges
+     * @throws IllegalArgumentException if {@code V < 0}
+     * @throws IllegalArgumentException if {@code E < 0}
+     */
+    public FlowNetwork(int V, int E) {
+        this(V);
+        if (E < 0) throw new IllegalArgumentException("Number of edges must be non-negative");
+        for (int i = 0; i < E; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            double capacity = StdRandom.uniform(100);
+            addEdge(new FlowEdge(v, w, capacity));
+        }
+    }
+
+    /**  
+     * Initializes a flow network from an input stream.
+     * The format is the number of vertices <em>V</em>,
+     * followed by the number of edges <em>E</em>,
+     * followed by <em>E</em> pairs of vertices and edge capacities,
+     * with each entry separated by whitespace.
+     * @param in the input stream
+     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
+     * @throws IllegalArgumentException if the number of vertices or edges is negative
+     */
+    public FlowNetwork(In in) {
+        this(in.readInt());
+        int E = in.readInt();
+        if (E < 0) throw new IllegalArgumentException("number of edges must be non-negative");
+        for (int i = 0; i < E; i++) {
+            int v = in.readInt();
+            int w = in.readInt();
+            validateVertex(v);
+            validateVertex(w);
+            double capacity = in.readDouble();
+            addEdge(new FlowEdge(v, w, capacity));
+        }
+    }
+
+
+    /**
+     * Returns the number of vertices in the edge-weighted graph.
+     * @return the number of vertices in the edge-weighted graph
+     */
+    public int V() {
+        return V;
+    }
+
+    /**
+     * Returns the number of edges in the edge-weighted graph.
+     * @return the number of edges in the edge-weighted graph
+     */
+    public int E() {
+        return E;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Adds the edge {@code e} to the network.
+     * @param e the edge
+     * @throws IllegalArgumentException unless endpoints of edge are between
+     *         {@code 0} and {@code V-1}
+     */
+    public void addEdge(FlowEdge e) {
+        int v = e.from();
+        int w = e.to();
+        validateVertex(v);
+        validateVertex(w);
+        adj[v].add(e);
+        adj[w].add(e);
+        E++;
+    }
+
+    /**
+     * Returns the edges incident on vertex {@code v} (includes both edges pointing to
+     * and from {@code v}).
+     * @param v the vertex
+     * @return the edges incident on vertex {@code v} as an Iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<FlowEdge> adj(int v) {
+        validateVertex(v);
+        return adj[v];
+    }
+
+    // return list of all edges - excludes self loops
+    public Iterable<FlowEdge> edges() {
+        Bag<FlowEdge> list = new Bag<FlowEdge>();
+        for (int v = 0; v < V; v++)
+            for (FlowEdge e : adj(v)) {
+                if (e.to() != v)
+                    list.add(e);
+            }
+        return list;
+    }
+
+
+    /**
+     * Returns a string representation of the flow network.
+     * This method takes time proportional to <em>E</em> + <em>V</em>.
+     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,  
+     *    followed by the <em>V</em> adjacency lists
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(V + " " + E + NEWLINE);
+        for (int v = 0; v < V; v++) {
+            s.append(v + ":  ");
+            for (FlowEdge e : adj[v]) {
+                if (e.to() != v) s.append(e + "  ");
+            }
+            s.append(NEWLINE);
+        }
+        return s.toString();
+    }
+
+    /**
+     * Unit tests the {@code FlowNetwork} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        FlowNetwork G = new FlowNetwork(in);
+        StdOut.println(G);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FloydWarshall.java b/src/main/java/edu/princeton/cs/algs4/FloydWarshall.java
new file mode 100644
index 0000000..3f4a880
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FloydWarshall.java
@@ -0,0 +1,308 @@
+/******************************************************************************
+ *  Compilation:  javac FloydWarshall.java
+ *  Execution:    java FloydWarshall V E
+ *  Dependencies: AdjMatrixEdgeWeightedDigraph.java
+ *
+ *  Floyd-Warshall all-pairs shortest path algorithm.
+ *
+ *  % java FloydWarshall 100 500
+ *
+ *  Should check for negative cycles during triple loop; otherwise
+ *  intermediate numbers can get exponentially large.
+ *  Reference: "The Floyd-Warshall algorithm on graphs with negative cycles"
+ *  by Stefan Hougardy
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code FloydWarshall} class represents a data type for solving the
+ *  all-pairs shortest paths problem in edge-weighted digraphs with
+ *  no negative cycles.
+ *  The edge weights can be positive, negative, or zero.
+ *  This class finds either a shortest path between every pair of vertices
+ *  or a negative cycle.
+ *  <p>
+ *  This implementation uses the Floyd-Warshall algorithm.
+ *  The constructor takes &Theta;(<em>V</em><sup>3</sup>) time,
+ *  where <em>V</em> is the number of vertices.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em><sup>2</sup>) extra space
+ *  (not including the edge-weighted digraph).
+ *  <p>
+ *  This correctly computes shortest paths if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  This is the case if all edge weights are integers and if none of the
+ *  intermediate results exceeds 2<sup>52</sup>. Since all intermediate
+ *  results are sums of edge weights, they are bounded by <em>V C</em>,
+ *  where <em>V</em> is the number of vertices and <em>C</em> is the maximum
+ *  absolute value of any edge weight.
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of    
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FloydWarshall {
+    private boolean hasNegativeCycle;  // is there a negative cycle?
+    private double[][] distTo;         // distTo[v][w] = length of shortest v->w path
+    private DirectedEdge[][] edgeTo;   // edgeTo[v][w] = last edge on shortest v->w path
+
+    /**
+     * Computes a shortest paths tree from each vertex to to every other vertex in
+     * the edge-weighted digraph {@code G}. If no such shortest path exists for
+     * some pair of vertices, it computes a negative cycle.
+     * @param G the edge-weighted digraph
+     */
+    public FloydWarshall(AdjMatrixEdgeWeightedDigraph G) {
+        int V = G.V();
+        distTo = new double[V][V];
+        edgeTo = new DirectedEdge[V][V];
+
+        // initialize distances to infinity
+        for (int v = 0; v < V; v++) {
+            for (int w = 0; w < V; w++) {
+                distTo[v][w] = Double.POSITIVE_INFINITY;
+            }
+        }
+
+        // initialize distances using edge-weighted digraph's
+        for (int v = 0; v < G.V(); v++) {
+            for (DirectedEdge e : G.adj(v)) {
+                distTo[e.from()][e.to()] = e.weight();
+                edgeTo[e.from()][e.to()] = e;
+            }
+            // in case of self-loops
+            if (distTo[v][v] >= 0.0) {
+                distTo[v][v] = 0.0;
+                edgeTo[v][v] = null;
+            }
+        }
+
+        // Floyd-Warshall updates
+        for (int i = 0; i < V; i++) {
+            // compute shortest paths using only 0, 1, ..., i as intermediate vertices
+            for (int v = 0; v < V; v++) {
+                if (edgeTo[v][i] == null) continue;  // optimization
+                for (int w = 0; w < V; w++) {
+                    if (distTo[v][w] > distTo[v][i] + distTo[i][w]) {
+                        distTo[v][w] = distTo[v][i] + distTo[i][w];
+                        edgeTo[v][w] = edgeTo[i][w];
+                    }
+                }
+                // check for negative cycle
+                if (distTo[v][v] < 0.0) {
+                    hasNegativeCycle = true;
+                    return;
+                }
+            }
+        }
+        assert check(G);
+    }
+
+    /**
+     * Is there a negative cycle?
+     * @return {@code true} if there is a negative cycle, and {@code false} otherwise
+     */
+    public boolean hasNegativeCycle() {
+        return hasNegativeCycle;
+    }
+
+    /**
+     * Returns a negative cycle, or {@code null} if there is no such cycle.
+     * @return a negative cycle as an iterable of edges,
+     * or {@code null} if there is no such cycle
+     */
+    public Iterable<DirectedEdge> negativeCycle() {
+        for (int v = 0; v < distTo.length; v++) {
+            // negative cycle in v's predecessor graph
+            if (distTo[v][v] < 0.0) {
+                int V = edgeTo.length;
+                EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
+                for (int w = 0; w < V; w++)
+                    if (edgeTo[v][w] != null)
+                        spt.addEdge(edgeTo[v][w]);
+                EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt);
+                assert finder.hasCycle();
+                return finder.cycle();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Is there a path from the vertex {@code s} to vertex {@code t}?
+     * @param  s the source vertex
+     * @param  t the destination vertex
+     * @return {@code true} if there is a path from vertex {@code s}
+     *         to vertex {@code t}, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     * @throws IllegalArgumentException unless {@code 0 <= t < V}
+     */
+    public boolean hasPath(int s, int t) {
+        validateVertex(s);
+        validateVertex(t);
+        return distTo[s][t] < Double.POSITIVE_INFINITY;
+    }
+
+    /**
+     * Returns the length of a shortest path from vertex {@code s} to vertex {@code t}.
+     * @param  s the source vertex
+     * @param  t the destination vertex
+     * @return the length of a shortest path from vertex {@code s} to vertex {@code t};
+     *         {@code Double.POSITIVE_INFINITY} if no such path
+     * @throws UnsupportedOperationException if there is a negative cost cycle
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public double dist(int s, int t) {
+        validateVertex(s);
+        validateVertex(t);
+        if (hasNegativeCycle())
+            throw new UnsupportedOperationException("Negative cost cycle exists");
+        return distTo[s][t];
+    }
+
+    /**
+     * Returns a shortest path from vertex {@code s} to vertex {@code t}.
+     * @param  s the source vertex
+     * @param  t the destination vertex
+     * @return a shortest path from vertex {@code s} to vertex {@code t}
+     *         as an iterable of edges, and {@code null} if no such path
+     * @throws UnsupportedOperationException if there is a negative cost cycle
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<DirectedEdge> path(int s, int t) {
+        validateVertex(s);
+        validateVertex(t);
+        if (hasNegativeCycle())
+            throw new UnsupportedOperationException("Negative cost cycle exists");
+        if (!hasPath(s, t)) return null;
+        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
+        for (DirectedEdge e = edgeTo[s][t]; e != null; e = edgeTo[s][e.from()]) {
+            path.push(e);
+        }
+        return path;
+    }
+
+    // check optimality conditions
+    private boolean check(AdjMatrixEdgeWeightedDigraph G) {
+
+        // no negative cycle
+        if (!hasNegativeCycle()) {
+            for (int v = 0; v < G.V(); v++) {
+                for (DirectedEdge e : G.adj(v)) {
+                    int w = e.to();
+                    for (int i = 0; i < G.V(); i++) {
+                        if (distTo[i][w] > distTo[i][v] + e.weight()) {
+                            System.err.println("edge " + e + " is eligible");
+                            return false;
+                        }
+                    }
+                }
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = distTo.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code FloydWarshall} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // random graph with V vertices and E edges, parallel edges allowed
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        AdjMatrixEdgeWeightedDigraph G = new AdjMatrixEdgeWeightedDigraph(V);
+        for (int i = 0; i < E; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            double weight = Math.round(100 * (StdRandom.uniform() - 0.15)) / 100.0;
+            if (v == w) G.addEdge(new DirectedEdge(v, w, Math.abs(weight)));
+            else G.addEdge(new DirectedEdge(v, w, weight));
+        }
+
+        StdOut.println(G);
+
+        // run Floyd-Warshall algorithm
+        FloydWarshall spt = new FloydWarshall(G);
+
+        // print all-pairs shortest path distances
+        StdOut.printf("  ");
+        for (int v = 0; v < G.V(); v++) {
+            StdOut.printf("%6d ", v);
+        }
+        StdOut.println();
+        for (int v = 0; v < G.V(); v++) {
+            StdOut.printf("%3d: ", v);
+            for (int w = 0; w < G.V(); w++) {
+                if (spt.hasPath(v, w)) StdOut.printf("%6.2f ", spt.dist(v, w));
+                else StdOut.printf("  Inf ");
+            }
+            StdOut.println();
+        }
+
+        // print negative cycle
+        if (spt.hasNegativeCycle()) {
+            StdOut.println("Negative cost cycle:");
+            for (DirectedEdge e : spt.negativeCycle())
+                StdOut.println(e);
+            StdOut.println();
+        }
+
+        // print all-pairs shortest paths
+        else {
+            for (int v = 0; v < G.V(); v++) {
+                for (int w = 0; w < G.V(); w++) {
+                    if (spt.hasPath(v, w)) {
+                        StdOut.printf("%d to %d (%5.2f)  ", v, w, spt.dist(v, w));
+                        for (DirectedEdge e : spt.path(v, w))
+                            StdOut.print(e + "  ");
+                        StdOut.println();
+                    }
+                    else {
+                        StdOut.printf("%d to %d no path\n", v, w);
+                    }
+                }
+            }
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FordFulkerson.java b/src/main/java/edu/princeton/cs/algs4/FordFulkerson.java
new file mode 100644
index 0000000..9956bfb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FordFulkerson.java
@@ -0,0 +1,294 @@
+/******************************************************************************
+ *  Compilation:  javac FordFulkerson.java
+ *  Execution:    java FordFulkerson V E
+ *  Dependencies: FlowNetwork.java FlowEdge.java Queue.java
+ *  Data files:   https://algs4.cs.princeton.edu/65maxflow/tinyFN.txt
+ *
+ *  Ford-Fulkerson algorithm for computing a max flow and 
+ *  a min cut using shortest augmenting path rule.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code FordFulkerson} class represents a data type for computing a
+ *  <em>maximum st-flow</em> and <em>minimum st-cut</em> in a flow
+ *  network.
+ *  <p>
+ *  This implementation uses the <em>Ford-Fulkerson</em> algorithm with
+ *  the <em>shortest augmenting path</em> heuristic.
+ *  The constructor takes <em>O</em>(<em>E V</em> (<em>E</em> + <em>V</em>))
+ *  time, where <em>V</em> is the number of vertices and <em>E</em> is
+ *  the number of edges. In practice, the algorithm will run much faster.
+ *  The {@code inCut()} and {@code value()} methods take &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the network).
+ *  <p>
+ *  This correctly computes the maxflow and mincut if all arithmetic
+ *  performed is without floating-point rounding error or arithmetic
+ *  overflow. This is guaranteed to be the case if all edge capacities
+ *  and initial flow values are integers and the value of the maxflow
+ *  does not exceeds 2<sup>52</sup>.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/64maxflow">Section 6.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FordFulkerson {
+    private static final double FLOATING_POINT_EPSILON = 1E-11;
+
+    private final int V;          // number of vertices
+    private boolean[] marked;     // marked[v] = true iff s->v path in residual graph
+    private FlowEdge[] edgeTo;    // edgeTo[v] = last edge on shortest residual s->v path
+    private double value;         // current value of max flow
+  
+    /**
+     * Compute a maximum flow and minimum cut in the network {@code G}
+     * from vertex {@code s} to vertex {@code t}.
+     *
+     * @param  G the flow network
+     * @param  s the source vertex
+     * @param  t the sink vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     * @throws IllegalArgumentException unless {@code 0 <= t < V}
+     * @throws IllegalArgumentException if {@code s == t}
+     * @throws IllegalArgumentException if initial flow is infeasible
+     */
+    public FordFulkerson(FlowNetwork G, int s, int t) {
+        V = G.V();
+        validate(s);
+        validate(t);
+        if (s == t)               throw new IllegalArgumentException("Source equals sink");
+        if (!isFeasible(G, s, t)) throw new IllegalArgumentException("Initial flow is infeasible");
+
+        // while there exists an augmenting path, use it
+        value = excess(G, t);
+        while (hasAugmentingPath(G, s, t)) {
+
+            // compute bottleneck capacity
+            double bottle = Double.POSITIVE_INFINITY;
+            for (int v = t; v != s; v = edgeTo[v].other(v)) {
+                bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));
+            }
+
+            // augment flow
+            for (int v = t; v != s; v = edgeTo[v].other(v)) {
+                edgeTo[v].addResidualFlowTo(v, bottle); 
+            }
+
+            value += bottle;
+        }
+
+        // check optimality conditions
+        assert check(G, s, t);
+    }
+
+    /**
+     * Returns the value of the maximum flow.
+     *
+     * @return the value of the maximum flow
+     */
+    public double value()  {
+        return value;
+    }
+
+    /**
+     * Returns true if the specified vertex is on the {@code s} side of the mincut.
+     *
+     * @param  v vertex
+     * @return {@code true} if vertex {@code v} is on the {@code s} side of the micut;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean inCut(int v)  {
+        validate(v);
+        return marked[v];
+    }
+
+    // throw an IllegalArgumentException if v is outside prescibed range
+    private void validate(int v)  {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+
+    // is there an augmenting path? 
+    // if so, upon termination edgeTo[] will contain a parent-link representation of such a path
+    // this implementation finds a shortest augmenting path (fewest number of edges),
+    // which performs well both in theory and in practice
+    private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {
+        edgeTo = new FlowEdge[G.V()];
+        marked = new boolean[G.V()];
+
+        // breadth-first search
+        Queue<Integer> queue = new Queue<Integer>();
+        queue.enqueue(s);
+        marked[s] = true;
+        while (!queue.isEmpty() && !marked[t]) {
+            int v = queue.dequeue();
+
+            for (FlowEdge e : G.adj(v)) {
+                int w = e.other(v);
+
+                // if residual capacity from v to w
+                if (e.residualCapacityTo(w) > 0) {
+                    if (!marked[w]) {
+                        edgeTo[w] = e;
+                        marked[w] = true;
+                        queue.enqueue(w);
+                    }
+                }
+            }
+        }
+
+        // is there an augmenting path?
+        return marked[t];
+    }
+
+
+
+    // return excess flow at vertex v
+    private double excess(FlowNetwork G, int v) {
+        double excess = 0.0;
+        for (FlowEdge e : G.adj(v)) {
+            if (v == e.from()) excess -= e.flow();
+            else               excess += e.flow();
+        }
+        return excess;
+    }
+
+    // return excess flow at vertex v
+    private boolean isFeasible(FlowNetwork G, int s, int t) {
+
+        // check that capacity constraints are satisfied
+        for (int v = 0; v < G.V(); v++) {
+            for (FlowEdge e : G.adj(v)) {
+                if (e.flow() < -FLOATING_POINT_EPSILON || e.flow() > e.capacity() + FLOATING_POINT_EPSILON) {
+                    System.err.println("Edge does not satisfy capacity constraints: " + e);
+                    return false;
+                }
+            }
+        }
+
+        // check that net flow into a vertex equals zero, except at source and sink
+        if (Math.abs(value + excess(G, s)) > FLOATING_POINT_EPSILON) {
+            System.err.println("Excess at source = " + excess(G, s));
+            System.err.println("Max flow         = " + value);
+            return false;
+        }
+        if (Math.abs(value - excess(G, t)) > FLOATING_POINT_EPSILON) {
+            System.err.println("Excess at sink   = " + excess(G, t));
+            System.err.println("Max flow         = " + value);
+            return false;
+        }
+        for (int v = 0; v < G.V(); v++) {
+            if (v == s || v == t) continue;
+            else if (Math.abs(excess(G, v)) > FLOATING_POINT_EPSILON) {
+                System.err.println("Net flow out of " + v + " doesn't equal zero");
+                return false;
+            }
+        }
+        return true;
+    }
+
+
+
+    // check optimality conditions
+    private boolean check(FlowNetwork G, int s, int t) {
+
+        // check that flow is feasible
+        if (!isFeasible(G, s, t)) {
+            System.err.println("Flow is infeasible");
+            return false;
+        }
+
+        // check that s is on the source side of min cut and that t is not on source side
+        if (!inCut(s)) {
+            System.err.println("source " + s + " is not on source side of min cut");
+            return false;
+        }
+        if (inCut(t)) {
+            System.err.println("sink " + t + " is on source side of min cut");
+            return false;
+        }
+
+        // check that value of min cut = value of max flow
+        double mincutValue = 0.0;
+        for (int v = 0; v < G.V(); v++) {
+            for (FlowEdge e : G.adj(v)) {
+                if ((v == e.from()) && inCut(e.from()) && !inCut(e.to()))
+                    mincutValue += e.capacity();
+            }
+        }
+
+        if (Math.abs(mincutValue - value) > FLOATING_POINT_EPSILON) {
+            System.err.println("Max flow value = " + value + ", min cut value = " + mincutValue);
+            return false;
+        }
+
+        return true;
+    }
+
+
+    /**
+     * Unit tests the {@code FordFulkerson} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // create flow network with V vertices and E edges
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        int s = 0, t = V-1;
+        FlowNetwork G = new FlowNetwork(V, E);
+        StdOut.println(G);
+
+        // compute maximum flow and minimum cut
+        FordFulkerson maxflow = new FordFulkerson(G, s, t);
+        StdOut.println("Max flow from " + s + " to " + t);
+        for (int v = 0; v < G.V(); v++) {
+            for (FlowEdge e : G.adj(v)) {
+                if ((v == e.from()) && e.flow() > 0)
+                    StdOut.println("   " + e);
+            }
+        }
+
+        // print min-cut
+        StdOut.print("Min cut: ");
+        for (int v = 0; v < G.V(); v++) {
+            if (maxflow.inCut(v)) StdOut.print(v + " ");
+        }
+        StdOut.println();
+
+        StdOut.println("Max flow value = " +  maxflow.value());
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/FrequencyCounter.java b/src/main/java/edu/princeton/cs/algs4/FrequencyCounter.java
new file mode 100644
index 0000000..8db2a9f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/FrequencyCounter.java
@@ -0,0 +1,110 @@
+/******************************************************************************
+ *  Compilation:  javac FrequencyCounter.java
+ *  Execution:    java FrequencyCounter L < input.txt
+ *  Dependencies: ST.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/31elementary/tinyTale.txt
+ *                https://algs4.cs.princeton.edu/31elementary/tale.txt
+ *                https://algs4.cs.princeton.edu/31elementary/leipzig100K.txt
+ *                https://algs4.cs.princeton.edu/31elementary/leipzig300K.txt
+ *                https://algs4.cs.princeton.edu/31elementary/leipzig1M.txt
+ *
+ *  Read in a list of words from standard input and print out
+ *  the most frequently occurring word that has length greater than
+ *  a given threshold.
+ *
+ *  % java FrequencyCounter 1 < tinyTale.txt
+ *  it 10
+ *
+ *  % java FrequencyCounter 8 < tale.txt
+ *  business 122
+ *
+ *  % java FrequencyCounter 10 < leipzig1M.txt
+ *  government 24763
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code FrequencyCounter} class provides a client for 
+ *  reading in a sequence of words and printing a word (exceeding
+ *  a given length) that occurs most frequently. It is useful as
+ *  a test client for various symbol table implementations.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/31elementary">Section 3.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class FrequencyCounter {
+
+    // Do not instantiate.
+    private FrequencyCounter() { }
+
+    /**
+     * Reads in a command-line integer and sequence of words from
+     * standard input and prints out a word (whose length exceeds
+     * the threshold) that occurs most frequently to standard output.
+     * It also prints out the number of words whose length exceeds
+     * the threshold and the number of distinct such words.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int distinct = 0, words = 0;
+        int minlen = Integer.parseInt(args[0]);
+        ST<String, Integer> st = new ST<String, Integer>();
+
+        // compute frequency counts
+        while (!StdIn.isEmpty()) {
+            String key = StdIn.readString();
+            if (key.length() < minlen) continue;
+            words++;
+            if (st.contains(key)) {
+                st.put(key, st.get(key) + 1);
+            }
+            else {
+                st.put(key, 1);
+                distinct++;
+            }
+        }
+
+        // find a key with the highest frequency count
+        String max = "";
+        st.put(max, 0);
+        for (String word : st.keys()) {
+            if (st.get(word) > st.get(max))
+                max = word;
+        }
+
+        StdOut.println(max + " " + st.get(max));
+        StdOut.println("distinct = " + distinct);
+        StdOut.println("words    = " + words);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GREP.java b/src/main/java/edu/princeton/cs/algs4/GREP.java
new file mode 100644
index 0000000..3ce4017
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GREP.java
@@ -0,0 +1,89 @@
+/******************************************************************************
+ *  Compilation:  javac GREP.java
+ *  Execution:    java GREP regexp < input.txt
+ *  Dependencies: NFA.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/54regexp/tinyL.txt
+ *
+ *  This program takes an RE as a command-line argument and prints
+ *  the lines from standard input having some substring that
+ *  is in the language described by the RE. 
+ *
+ *  % more tinyL.txt
+ *  AC
+ *  AD
+ *  AAA
+ *  ABD
+ *  ADD
+ *  BCD
+ *  ABCCBD
+ *  BABAAA
+ *  BABBAAA
+ *
+ *  %  java GREP "(A*B|AC)D" < tinyL.txt
+ *  ABD
+ *  ABCCBD
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code GREP} class provides a client for reading in a sequence of
+ *  lines from standard input and printing to standard output those lines
+ *  that contain a substring matching a specified regular expression.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/31elementary">Section 3.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class GREP {
+
+    // do not instantiate
+    private GREP() { }
+
+    /**
+     * Interprets the command-line argument as a regular expression
+     * (supporting closure, binary or, parentheses, and wildcard)
+     * reads in lines from standard input; writes to standard output
+     * those lines that contain a substring matching the regular
+     * expression.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        String regexp = "(.*" + args[0] + ".*)";
+        NFA nfa = new NFA(regexp);
+        while (StdIn.hasNextLine()) { 
+            String line = StdIn.readLine();
+            if (nfa.recognizes(line)) {
+                StdOut.println(line);
+            }
+        }
+    } 
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GabowSCC.java b/src/main/java/edu/princeton/cs/algs4/GabowSCC.java
new file mode 100644
index 0000000..2f680d1
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GabowSCC.java
@@ -0,0 +1,222 @@
+/******************************************************************************
+ *  Compilation:  javac GabowSCC.java
+ *  Execution:    java GabowSCC V E
+ *  Dependencies: Digraph.java Stack.java TransitiveClosure.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Compute the strongly-connected components of a digraph using 
+ *  Gabow's algorithm (aka Cheriyan-Mehlhorn algorithm).
+ *
+ *  Runs in O(E + V) time.
+ *
+ *  % java GabowSCC tinyDG.txt
+ *  5 components
+ *  1 
+ *  0 2 3 4 5
+ *  9 10 11 12
+ *  6 8
+ *  7 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+/**
+ *  The {@code GabowSCC} class represents a data type for 
+ *  determining the strong components in a digraph.
+ *  The <em>id</em> operation determines in which strong component
+ *  a given vertex lies; the <em>areStronglyConnected</em> operation
+ *  determines whether two vertices are in the same strong component;
+ *  and the <em>count</em> operation determines the number of strong
+ *  components.
+
+ *  The <em>component identifier</em> of a component is one of the
+ *  vertices in the strong component: two vertices have the same component
+ *  identifier if and only if they are in the same strong component.
+
+ *  <p>
+ *  This implementation uses the Gabow's algorithm.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time,
+ *  where <em>V</em> is the number of vertices and <em>E</em> is
+ *  the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  For alternative implementations of the same API, see
+ *  {@link KosarajuSharirSCC} and {@link TarjanSCC}.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class GabowSCC {
+
+    private boolean[] marked;        // marked[v] = has v been visited?
+    private int[] id;                // id[v] = id of strong component containing v
+    private int[] preorder;          // preorder[v] = preorder of v
+    private int pre;                 // preorder number counter
+    private int count;               // number of strongly-connected components
+    private Stack<Integer> stack1;
+    private Stack<Integer> stack2;
+
+
+    /**
+     * Computes the strong components of the digraph {@code G}.
+     * @param G the digraph
+     */
+    public GabowSCC(Digraph G) {
+        marked = new boolean[G.V()];
+        stack1 = new Stack<Integer>();
+        stack2 = new Stack<Integer>();
+        id = new int[G.V()]; 
+        preorder = new int[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            id[v] = -1;
+
+        for (int v = 0; v < G.V(); v++) {
+            if (!marked[v]) dfs(G, v);
+        }
+
+        // check that id[] gives strong components
+        assert check(G);
+    }
+
+    private void dfs(Digraph G, int v) { 
+        marked[v] = true;
+        preorder[v] = pre++;
+        stack1.push(v);
+        stack2.push(v);
+        for (int w : G.adj(v)) {
+            if (!marked[w]) dfs(G, w);
+            else if (id[w] == -1) {
+                while (preorder[stack2.peek()] > preorder[w])
+                    stack2.pop();
+            }
+        }
+
+        // found strong component containing v
+        if (stack2.peek() == v) {
+            stack2.pop();
+            int w;
+            do {
+                w = stack1.pop();
+                id[w] = count;
+            } while (w != v);
+            count++;
+        }
+    }
+
+    /**
+     * Returns the number of strong components.
+     * @return the number of strong components
+     */
+    public int count() {
+        return count;
+    }
+
+    /**
+     * Are vertices {@code v} and {@code w} in the same strong component?
+     * @param  v one vertex
+     * @param  w the other vertex
+     * @return {@code true} if vertices {@code v} and {@code w} are in the same
+     *         strong component, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @throws IllegalArgumentException unless {@code 0 <= w < V}
+     */
+    public boolean stronglyConnected(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        return id[v] == id[w];
+    }
+
+    /**
+     * Returns the component id of the strong component containing vertex {@code v}.
+     * @param  v the vertex
+     * @return the component id of the strong component containing vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int id(int v) {
+        validateVertex(v);
+        return id[v];
+    }
+
+    // does the id[] array contain the strongly connected components?
+    private boolean check(Digraph G) {
+        TransitiveClosure tc = new TransitiveClosure(G);
+        for (int v = 0; v < G.V(); v++) {
+            for (int w = 0; w < G.V(); w++) {
+                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code GabowSCC} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        GabowSCC scc = new GabowSCC(G);
+
+        // number of connected components
+        int m = scc.count();
+        StdOut.println(m + " components");
+
+        // compute list of vertices in each strong component
+        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
+        for (int i = 0; i < m; i++) {
+            components[i] = new Queue<Integer>();
+        }
+        for (int v = 0; v < G.V(); v++) {
+            components[scc.id(v)].enqueue(v);
+        }
+
+        // print results
+        for (int i = 0; i < m; i++) {
+            for (int v : components[i]) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GaussJordanElimination.java b/src/main/java/edu/princeton/cs/algs4/GaussJordanElimination.java
new file mode 100644
index 0000000..f08fb4f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GaussJordanElimination.java
@@ -0,0 +1,435 @@
+/******************************************************************************
+ *  Compilation:  javac GaussJordanElimination.java
+ *  Execution:    java GaussJordanElimination n
+ *  Dependencies: StdOut.java
+ * 
+ *  Finds a solutions to Ax = b using Gauss-Jordan elimination with partial
+ *  pivoting. If no solution exists, find a solution to yA = 0, yb != 0,
+ *  which serves as a certificate of infeasibility.
+ *
+ *  % java GaussJordanElimination
+ *  -1.000000
+ *  2.000000
+ *  2.000000
+ *
+ *  3.000000
+ *  -1.000000
+ *  -2.000000
+ * 
+ *  System is infeasible
+ *
+ *  -6.250000
+ *  -4.500000
+ *  0.000000
+ *  0.000000
+ *  1.000000
+ *
+ *  System is infeasible
+ *
+ *  -1.375000
+ *  1.625000
+ *  0.000000
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code GaussJordanElimination} data type provides methods
+ *  to solve a linear system of equations <em>Ax</em> = <em>b</em>,
+ *  where <em>A</em> is an <em>n</em>-by-<em>n</em> matrix
+ *  and <em>b</em> is a length <em>n</em> vector.
+ *  If no solution exists, it finds a solution <em>y</em> to
+ *  <em>yA</em> = 0, <em>yb</em> &ne; 0, which
+ *  which serves as a certificate of infeasibility.
+ *  <p>
+ *  This implementation uses Gauss-Jordan elimination with partial pivoting.
+ *  See {@link GaussianElimination} for an implementation that uses
+ *  Gaussian elimination (but does not provide the certificate of infeasibility).
+ *  For an industrial-strength numerical linear algebra library,
+ *  see <a href = "http://math.nist.gov/javanumerics/jama/">JAMA</a>. 
+ *  <p>
+ *  This computes correct results if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.  
+ *  In practice, there will be floating-point rounding error;
+ *  partial pivoting helps prevent accumulated floating-point rounding
+ *  errors from growing out of control (though it does not
+ *  provide any guarantees).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/99scientific">Section 9.9</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class GaussJordanElimination {
+    private static final double EPSILON = 1e-8;
+
+    private final int n;      // n-by-n system
+    private double[][] a;     // n-by-(n+1) augmented matrix
+
+    // Gauss-Jordan elimination with partial pivoting
+    /**
+     * Solves the linear system of equations <em>Ax</em> = <em>b</em>,
+     * where <em>A</em> is an <em>n</em>-by-<em>n</em> matrix and <em>b</em>
+     * is a length <em>n</em> vector.
+     *
+     * @param  A the <em>n</em>-by-<em>n</em> constraint matrix
+     * @param  b the length <em>n</em> right-hand-side vector
+     */
+    public GaussJordanElimination(double[][] A, double[] b) {
+        n = b.length;
+
+        // build augmented matrix
+        a = new double[n][n+n+1];
+        for (int i = 0; i < n; i++)
+            for (int j = 0; j < n; j++)
+                a[i][j] = A[i][j];
+
+        // only needed if you want to find certificate of infeasibility (or compute inverse)
+        for (int i = 0; i < n; i++)
+            a[i][n+i] = 1.0;
+
+        for (int i = 0; i < n; i++)
+            a[i][n+n] = b[i];
+
+        solve();
+
+        assert certifySolution(A, b);
+    }
+
+    private void solve() {
+
+        // Gauss-Jordan elimination
+        for (int p = 0; p < n; p++) {
+            // show();
+
+            // find pivot row using partial pivoting
+            int max = p;
+            for (int i = p+1; i < n; i++) {
+                if (Math.abs(a[i][p]) > Math.abs(a[max][p])) {
+                    max = i;
+                }
+            }
+
+            // exchange row p with row max
+            swap(p, max);
+
+            // singular or nearly singular
+            if (Math.abs(a[p][p]) <= EPSILON) {
+                continue;
+                // throw new ArithmeticException("Matrix is singular or nearly singular");
+            }
+
+            // pivot
+            pivot(p, p);
+        }
+        // show();
+    }
+
+    // swap row1 and row2
+    private void swap(int row1, int row2) {
+        double[] temp = a[row1];
+        a[row1] = a[row2];
+        a[row2] = temp;
+    }
+
+
+    // pivot on entry (p, q) using Gauss-Jordan elimination
+    private void pivot(int p, int q) {
+
+        // everything but row p and column q
+        for (int i = 0; i < n; i++) {
+            double alpha = a[i][q] / a[p][q];
+            for (int j = 0; j <= n+n; j++) {
+                if (i != p && j != q) a[i][j] -= alpha * a[p][j];
+            }
+        }
+
+        // zero out column q
+        for (int i = 0; i < n; i++)
+            if (i != p) a[i][q] = 0.0;
+
+        // scale row p (ok to go from q+1 to n, but do this for consistency with simplex pivot)
+        for (int j = 0; j <= n+n; j++)
+            if (j != q) a[p][j] /= a[p][q];
+        a[p][q] = 1.0;
+    }
+
+    /**
+     * Returns a solution to the linear system of equations <em>Ax</em> = <em>b</em>.
+     *      
+     * @return a solution <em>x</em> to the linear system of equations
+     *         <em>Ax</em> = <em>b</em>; {@code null} if no such solution
+     */
+    public double[] primal() {
+        double[] x = new double[n];
+        for (int i = 0; i < n; i++) {
+            if (Math.abs(a[i][i]) > EPSILON)
+                x[i] = a[i][n+n] / a[i][i];
+            else if (Math.abs(a[i][n+n]) > EPSILON)
+                return null;
+        }
+        return x;
+    }
+
+    /**
+     * Returns a solution to the linear system of equations <em>yA</em> = 0,
+     * <em>yb</em> &ne; 0.
+     *      
+     * @return a solution <em>y</em> to the linear system of equations
+     *         <em>yA</em> = 0, <em>yb</em> &ne; 0; {@code null} if no such solution
+     */
+    public double[] dual() {
+        double[] y = new double[n];
+        for (int i = 0; i < n; i++) {
+            if ((Math.abs(a[i][i]) <= EPSILON) && (Math.abs(a[i][n+n]) > EPSILON)) {
+                for (int j = 0; j < n; j++)
+                    y[j] = a[i][n+j];
+                return y;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns true if there exists a solution to the linear system of
+     * equations <em>Ax</em> = <em>b</em>.
+     *      
+     * @return {@code true} if there exists a solution to the linear system
+     *         of equations <em>Ax</em> = <em>b</em>; {@code false} otherwise
+     */
+    public boolean isFeasible() {
+        return primal() != null;
+    }
+
+    // print the tableaux
+    private void show() {
+        for (int i = 0; i < n; i++) {
+            for (int j = 0; j < n; j++) {
+                StdOut.printf("%8.3f ", a[i][j]);
+            }
+            StdOut.printf("| ");
+            for (int j = n; j < n+n; j++) {
+                StdOut.printf("%8.3f ", a[i][j]);
+            }
+            StdOut.printf("| %8.3f\n", a[i][n+n]);
+        }
+        StdOut.println();
+    }
+
+
+    // check that Ax = b or yA = 0, yb != 0
+    private boolean certifySolution(double[][] A, double[] b) {
+
+        // check that Ax = b
+        if (isFeasible()) {
+            double[] x = primal();
+            for (int i = 0; i < n; i++) {
+                double sum = 0.0;
+                for (int j = 0; j < n; j++) {
+                    sum += A[i][j] * x[j];
+                }
+                if (Math.abs(sum - b[i]) > EPSILON) {
+                    StdOut.println("not feasible");
+                    StdOut.printf("b[%d] = %8.3f, sum = %8.3f\n", i, b[i], sum);
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        // or that yA = 0, yb != 0
+        else {
+            double[] y = dual();
+            for (int j = 0; j < n; j++) {
+                double sum = 0.0;
+                for (int i = 0; i < n; i++) {
+                    sum += A[i][j] * y[i];
+                }
+                if (Math.abs(sum) > EPSILON) {
+                    StdOut.println("invalid certificate of infeasibility");
+                    StdOut.printf("sum = %8.3f\n", sum);
+                    return false;
+                }
+            }
+            double sum = 0.0;
+            for (int i = 0; i < n; i++) {
+                sum += y[i] * b[i];
+            }
+            if (Math.abs(sum) < EPSILON) {
+                StdOut.println("invalid certificate of infeasibility");
+                StdOut.printf("yb  = %8.3f\n", sum);
+                return false;
+            }
+            return true;
+        }
+    }
+
+
+    private static void test(String name, double[][] A, double[] b) {
+        StdOut.println("----------------------------------------------------");
+        StdOut.println(name);
+        StdOut.println("----------------------------------------------------");
+        GaussJordanElimination gaussian = new GaussJordanElimination(A, b);
+        if (gaussian.isFeasible()) {
+            StdOut.println("Solution to Ax = b");
+            double[] x = gaussian.primal();
+            for (int i = 0; i < x.length; i++) {
+                StdOut.printf("%10.6f\n", x[i]);
+            }
+        }
+        else {
+            StdOut.println("Certificate of infeasibility");
+            double[] y = gaussian.dual();
+            for (int j = 0; j < y.length; j++) {
+                StdOut.printf("%10.6f\n", y[j]);
+            }
+        }
+        StdOut.println();
+        StdOut.println();
+    }
+
+
+    // 3-by-3 nonsingular system
+    private static void test1() {
+        double[][] A = {
+            { 0, 1,  1 },
+            { 2, 4, -2 },
+            { 0, 3, 15 }
+        };
+        double[] b = { 4, 2, 36 };
+        test("test 1", A, b);
+    }
+
+    // 3-by-3 nonsingular system
+    private static void test2() {
+        double[][] A = {
+            {  1, -3,   1 },
+            {  2, -8,   8 },
+            { -6,  3, -15 }
+        };
+        double[] b = { 4, -2, 9 };
+        test("test 2", A, b);
+    }
+
+    // 5-by-5 singular: no solutions
+    // y = [ -1, 0, 1, 1, 0 ]
+    private static void test3() {
+        double[][] A = {
+            {  2, -3, -1,  2,  3 },
+            {  4, -4, -1,  4, 11 },
+            {  2, -5, -2,  2, -1 },
+            {  0,  2,  1,  0,  4 },
+            { -4,  6,  0,  0,  7 },
+        };
+        double[] b = { 4, 4, 9, -6, 5 };
+        test("test 3", A, b);
+    }
+
+    // 5-by-5 singluar: infinitely many solutions
+    private static void test4() {
+        double[][] A = {
+            {  2, -3, -1,  2,  3 },
+            {  4, -4, -1,  4, 11 },
+            {  2, -5, -2,  2, -1 },
+            {  0,  2,  1,  0,  4 },
+            { -4,  6,  0,  0,  7 },
+        };
+        double[] b = { 4, 4, 9, -5, 5 };
+        test("test 4", A, b);
+    }
+
+    // 3-by-3 singular: no solutions
+    // y = [ 1, 0, 1/3 ]
+    private static void test5() {
+        double[][] A = {
+            {  2, -1,  1 },
+            {  3,  2, -4 },
+            { -6,  3, -3 },
+        };
+        double[] b = { 1, 4, 2 };
+        test("test 5", A, b);
+    }
+
+    // 3-by-3 singular: infinitely many solutions
+    private static void test6() {
+        double[][] A = {
+            {  1, -1,  2 },
+            {  4,  4, -2 },
+            { -2,  2, -4 },
+        };
+        double[] b = { -3, 1, 6 };
+        test("test 6 (infinitely many solutions)", A, b);
+    }
+
+    /**
+     * Unit tests the {@code GaussJordanElimination} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        test1();
+        test2();
+        test3();
+        test4();
+        test5();
+        test6();
+
+        // n-by-n random system (likely full rank)
+        int n = Integer.parseInt(args[0]);
+        double[][] A = new double[n][n];
+        for (int i = 0; i < n; i++)
+            for (int j = 0; j < n; j++)
+                A[i][j] = StdRandom.uniform(1000);
+        double[] b = new double[n];
+        for (int i = 0; i < n; i++)
+            b[i] = StdRandom.uniform(1000);
+        test("random " + n + "-by-" + n + " (likely full rank)", A, b);
+
+
+        // n-by-n random system (likely infeasible)
+        A = new double[n][n];
+        for (int i = 0; i < n-1; i++)
+            for (int j = 0; j < n; j++)
+                A[i][j] = StdRandom.uniform(1000);
+        for (int i = 0; i < n-1; i++) {
+            double alpha = StdRandom.uniform(11) - 5.0;
+            for (int j = 0; j < n; j++) {
+                A[n-1][j] += alpha * A[i][j];
+            }
+        }
+        b = new double[n];
+        for (int i = 0; i < n; i++)
+            b[i] = StdRandom.uniform(1000);
+        test("random " + n + "-by-" + n + " (likely infeasible)", A, b);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GaussianElimination.java b/src/main/java/edu/princeton/cs/algs4/GaussianElimination.java
new file mode 100644
index 0000000..83d6dc7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GaussianElimination.java
@@ -0,0 +1,386 @@
+/******************************************************************************
+ *  Compilation:  javac GaussianElimination.java
+ *  Execution:    java GaussianElimination m n
+ *  Dependencies: StdOut.java
+ * 
+ *  Gaussian elimination with partial pivoting for m-by-n system.
+ *
+ *  % java GaussianElimination m n
+ *  -1.000000
+ *  2.000000
+ *  2.000000
+ *
+ *  3.000000
+ *  -1.000000
+ *  -2.000000
+ * 
+ *  System is infeasible
+ *
+ *  -6.250000
+ *  -4.500000
+ *  0.000000
+ *  0.000000
+ *  1.000000
+ *
+ *  System is infeasible
+ *
+ *  -1.375000
+ *  1.625000
+ *  0.000000
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code GaussianElimination} data type provides methods
+ *  to solve a linear system of equations <em>Ax</em> = <em>b</em>,
+ *  where <em>A</em> is an <em>m</em>-by-<em>n</em> matrix
+ *  and <em>b</em> is a length <em>n</em> vector.
+ *  <p>
+ *  This is a bare-bones implementation that uses Gaussian elimination
+ *  with partial pivoting.
+ *  See <a href = "https://algs4.cs.princeton.edu/99scientific/GaussianEliminationLite.java.html">GaussianEliminationLite.java</a>
+ *  for a stripped-down version that assumes the matrix <em>A</em> is square
+ *  and nonsingular. See {@link GaussJordanElimination} for an alternate
+ *  implementation that uses Gauss-Jordan elimination.
+ *  For an industrial-strength numerical linear algebra library,
+ *  see <a href = "http://math.nist.gov/javanumerics/jama/">JAMA</a>.
+ *  <p>
+ *  This computes correct results if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  In practice, there will be floating-point rounding error;
+ *  partial pivoting helps prevent accumulated floating-point rounding
+ *  errors from growing out of control (though it does not
+ *  provide any guarantees).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/99scientific">Section 9.9</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class GaussianElimination {
+    private static final double EPSILON = 1e-8;
+
+    private final int m;      // number of rows
+    private final int n;      // number of columns
+    private double[][] a;     // m-by-(n+1) augmented matrix
+
+    /**
+     * Solves the linear system of equations <em>Ax</em> = <em>b</em>,
+     * where <em>A</em> is an <em>m</em>-by-<em>n</em> matrix and <em>b</em>
+     * is a length <em>m</em> vector.
+     *
+     * @param  A the <em>m</em>-by-<em>n</em> constraint matrix
+     * @param  b the length <em>m</em> right-hand-side vector
+     * @throws IllegalArgumentException if the dimensions disagree, i.e.,
+     *         the length of {@code b} does not equal {@code m}
+     */
+    public GaussianElimination(double[][] A, double[] b) {
+        m = A.length;
+        n = A[0].length;
+
+        if (b.length != m) throw new IllegalArgumentException("Dimensions disagree");
+
+        // build augmented matrix
+        a = new double[m][n+1];
+        for (int i = 0; i < m; i++)
+            for (int j = 0; j < n; j++)
+                a[i][j] = A[i][j];
+        for (int i = 0; i < m; i++)
+            a[i][n] = b[i];
+
+        forwardElimination();
+
+        assert certifySolution(A, b);
+    }
+
+    // forward elimination
+    private void forwardElimination() {
+        for (int p = 0; p < Math.min(m, n); p++) {
+
+            // find pivot row using partial pivoting
+            int max = p;
+            for (int i = p+1; i < m; i++) {
+                if (Math.abs(a[i][p]) > Math.abs(a[max][p])) {
+                    max = i;
+                }
+            }
+
+            // swap
+            swap(p, max);
+
+            // singular or nearly singular
+            if (Math.abs(a[p][p]) <= EPSILON) {
+                continue;
+            }
+
+            // pivot
+            pivot(p);
+        }
+    }
+
+    // swap row1 and row2
+    private void swap(int row1, int row2) {
+        double[] temp = a[row1];
+        a[row1] = a[row2];
+        a[row2] = temp;
+    }
+
+    // pivot on a[p][p]
+    private void pivot(int p) {
+        for (int i = p+1; i < m; i++) {
+            double alpha = a[i][p] / a[p][p];
+            for (int j = p; j <= n; j++) {
+                a[i][j] -= alpha * a[p][j];
+            }
+        }
+    }
+
+    /**
+     * Returns a solution to the linear system of equations <em>Ax</em> = <em>b</em>.
+     *      
+     * @return a solution <em>x</em> to the linear system of equations
+     *         <em>Ax</em> = <em>b</em>; {@code null} if no such solution
+     */
+    public double[] primal() {
+        // back substitution
+        double[] x = new double[n];
+        for (int i = Math.min(n-1, m-1); i >= 0; i--) {
+            double sum = 0.0;
+            for (int j = i+1; j < n; j++) {
+                sum += a[i][j] * x[j];
+            }
+
+            if (Math.abs(a[i][i]) > EPSILON)
+                x[i] = (a[i][n] - sum) / a[i][i];
+            else if (Math.abs(a[i][n] - sum) > EPSILON)
+                return null;
+        }
+
+        // redundant rows
+        for (int i = n; i < m; i++) {
+            double sum = 0.0;
+            for (int j = 0; j < n; j++) {
+                sum += a[i][j] * x[j];
+            }
+            if (Math.abs(a[i][n] - sum) > EPSILON)
+                return null;
+        }
+        return x;
+    }
+
+    /**
+     * Returns true if there exists a solution to the linear system of
+     * equations <em>Ax</em> = <em>b</em>.
+     *      
+     * @return {@code true} if there exists a solution to the linear system
+     *         of equations <em>Ax</em> = <em>b</em>; {@code false} otherwise
+     */
+    public boolean isFeasible() {
+        return primal() != null;
+    }
+
+
+    // check that Ax = b
+    private boolean certifySolution(double[][] A, double[] b) {
+        if (!isFeasible()) return true;
+        double[] x = primal();
+        for (int i = 0; i < m; i++) {
+            double sum = 0.0;
+            for (int j = 0; j < n; j++) {
+                sum += A[i][j] * x[j];
+            }
+            if (Math.abs(sum - b[i]) > EPSILON) {
+                StdOut.println("not feasible");
+                StdOut.println("b[" + i + "] = " + b[i] + ", sum = " + sum);
+                return false;
+            }
+        }
+        return true;
+    }
+
+
+    /**
+     * Unit tests the {@code GaussianElimination} data type.
+     */
+    private static void test(String name, double[][] A, double[] b) {
+        StdOut.println("----------------------------------------------------");
+        StdOut.println(name);
+        StdOut.println("----------------------------------------------------");
+        GaussianElimination gaussian = new GaussianElimination(A, b);
+        double[] x = gaussian.primal();
+        if (gaussian.isFeasible()) {
+            for (int i = 0; i < x.length; i++) {
+                StdOut.printf("%.6f\n", x[i]);
+            }
+        }
+        else {
+            StdOut.println("System is infeasible");
+        }
+        StdOut.println();
+        StdOut.println();
+    }
+
+
+    // 3-by-3 nonsingular system
+    private static void test1() {
+        double[][] A = {
+            { 0, 1,  1 },
+            { 2, 4, -2 },
+            { 0, 3, 15 }
+        };
+        double[] b = { 4, 2, 36 };
+        test("test 1 (3-by-3 system, nonsingular)", A, b);
+    }
+
+    // 3-by-3 nonsingular system
+    private static void test2() {
+        double[][] A = {
+            {  1, -3,   1 },
+            {  2, -8,   8 },
+            { -6,  3, -15 }
+        };
+        double[] b = { 4, -2, 9 };
+        test("test 2 (3-by-3 system, nonsingular)", A, b);
+    }
+
+    // 5-by-5 singular: no solutions
+    private static void test3() {
+        double[][] A = {
+            {  2, -3, -1,  2,  3 },
+            {  4, -4, -1,  4, 11 },
+            {  2, -5, -2,  2, -1 },
+            {  0,  2,  1,  0,  4 },
+            { -4,  6,  0,  0,  7 },
+        };
+        double[] b = { 4, 4, 9, -6, 5 };
+        test("test 3 (5-by-5 system, no solutions)", A, b);
+    }
+
+    // 5-by-5 singular: infinitely many solutions
+    private static void test4() {
+        double[][] A = {
+            {  2, -3, -1,  2,  3 },
+            {  4, -4, -1,  4, 11 },
+            {  2, -5, -2,  2, -1 },
+            {  0,  2,  1,  0,  4 },
+            { -4,  6,  0,  0,  7 },
+        };
+        double[] b = { 4, 4, 9, -5, 5 };
+        test("test 4 (5-by-5 system, infinitely many solutions)", A, b);
+    }
+
+    // 3-by-3 singular: no solutions
+    private static void test5() {
+        double[][] A = {
+            {  2, -1,  1 },
+            {  3,  2, -4 },
+            { -6,  3, -3 },
+        };
+        double[] b = { 1, 4, 2 };
+        test("test 5 (3-by-3 system, no solutions)", A, b);
+    }
+
+    // 3-by-3 singular: infinitely many solutions
+    private static void test6() {
+        double[][] A = {
+            {  1, -1,  2 },
+            {  4,  4, -2 },
+            { -2,  2, -4 },
+        };
+        double[] b = { -3, 1, 6 };
+        test("test 6 (3-by-3 system, infinitely many solutions)", A, b);
+    }
+
+    // 4-by-3 full rank and feasible system
+    private static void test7() {
+        double[][] A = {
+            { 0, 1,  1 },
+            { 2, 4, -2 },
+            { 0, 3, 15 },
+            { 2, 8, 14 }
+        };
+        double[] b = { 4, 2, 36, 42 };
+        test("test 7 (4-by-3 system, full rank)", A, b);
+    }
+
+    // 4-by-3 full rank and infeasible system
+    private static void test8() {
+        double[][] A = {
+            { 0, 1,  1 },
+            { 2, 4, -2 },
+            { 0, 3, 15 },
+            { 2, 8, 14 }
+        };
+        double[] b = { 4, 2, 36, 40 };
+        test("test 8 (4-by-3 system, no solution)", A, b);
+    }
+
+    // 3-by-4 full rank system
+    private static void test9() {
+        double[][] A = {
+            {  1, -3,   1,  1 },
+            {  2, -8,   8,  2 },
+            { -6,  3, -15,  3 }
+        };
+        double[] b = { 4, -2, 9 };
+        test("test 9 (3-by-4 system, full rank)", A, b);
+    }
+
+    /**
+     * Unit tests the {@code GaussianElimination} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        test1();
+        test2();
+        test3();
+        test4();
+        test5();
+        test6();
+        test7();
+        test8();
+        test9();
+
+        // n-by-n random system
+        int n = Integer.parseInt(args[0]);
+        double[][] A = new double[n][n];
+        for (int i = 0; i < n; i++)
+            for (int j = 0; j < n; j++)
+                A[i][j] = StdRandom.uniform(1000);
+        double[] b = new double[n];
+        for (int i = 0; i < n; i++)
+            b[i] = StdRandom.uniform(1000);
+
+        test(n + "-by-" + n + " (probably nonsingular)", A, b);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Genome.java b/src/main/java/edu/princeton/cs/algs4/Genome.java
new file mode 100644
index 0000000..4e0ba51
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Genome.java
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *  Compilation:  javac Genome.java
+ *  Execution:    java Genome - < input.txt   (compress)
+ *  Execution:    java Genome + < input.txt   (expand)
+ *  Dependencies: BinaryIn.java BinaryOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/55compression/genomeTiny.txt
+ *
+ *  Compress or expand a genomic sequence using a 2-bit code.
+ *
+ *  % more genomeTiny.txt
+ *  ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
+ *
+ *  % java Genome - < genomeTiny.txt | java Genome +
+ *  ATAGATGCATAGCGCATAGCTAGATGTGCTAGC
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Genome} class provides static methods for compressing
+ *  and expanding a genomic sequence using a 2-bit code.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Genome {
+
+    // Do not instantiate.
+    private Genome() { }
+
+    /**
+     * Reads a sequence of 8-bit extended ASCII characters over the alphabet
+     * { A, C, T, G } from standard input; compresses them using two bits per
+     * character; and writes the results to standard output.
+     */
+    public static void compress() { 
+        Alphabet DNA = Alphabet.DNA;
+        String s = BinaryStdIn.readString();
+        int n = s.length();
+        BinaryStdOut.write(n);
+
+        // Write two-bit code for char. 
+        for (int i = 0; i < n; i++) {
+            int d = DNA.toIndex(s.charAt(i));
+            BinaryStdOut.write(d, 2);
+        }
+        BinaryStdOut.close();
+    } 
+
+    /**
+     * Reads a binary sequence from standard input; converts each two bits
+     * to an 8-bit extended ASCII character over the alphabet { A, C, T, G };
+     * and writes the results to standard output.
+     */
+    public static void expand() {
+        Alphabet DNA = Alphabet.DNA;
+        int n = BinaryStdIn.readInt();
+        // Read two bits; write char. 
+        for (int i = 0; i < n; i++) {
+            char c = BinaryStdIn.readChar(2);
+            BinaryStdOut.write(DNA.toChar(c), 8);
+        }
+        BinaryStdOut.close();
+    }
+
+
+    /**
+     * Sample client that calls {@code compress()} if the command-line
+     * argument is "-" an {@code expand()} if it is "+".
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        if      (args[0].equals("-")) compress();
+        else if (args[0].equals("+")) expand();
+        else throw new IllegalArgumentException("Illegal command line argument");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GlobalMincut.java b/src/main/java/edu/princeton/cs/algs4/GlobalMincut.java
new file mode 100644
index 0000000..3f10d55
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GlobalMincut.java
@@ -0,0 +1,314 @@
+/******************************************************************************
+ *  Compilation:  javac GlobalMincut.java
+ *  Execution:    java  GlobalMincut filename.txt
+ *  Dependencies: EdgeWeightedGraph.java Edge.java UF.java 
+ *                IndexMaxPQ.java FlowNetwork.java FlowEdge.java 
+ *                FordFulkerson.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *
+ *  Computes a minimum cut using Stoer-Wagner's algorithm.
+ *
+ *  % java GlobalMincut tinyEWG.txt 
+ *    Min cut: 5 
+ *    Min cut weight = 0.9500000000000001
+ *    
+ *  % java GlobalMincut mediumEWG.txt 
+ *    Min cut: 25 60 63 96 199 237 
+ *    Min cut weight = 0.14021
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code GlobalMincut} class represents a data type for computing a
+ *  <em>global minimum cut</em> in a graph with non-negative edge weights.
+ *  A <em>cut</em> is a partition of the vertices into two nonempty subsets.
+ *  An edge that has one
+ *  endpoint in each subset of a cut is a <em>crossing edge</em>. The weight
+ *  of a cut is the sum of the weights of its crossing edges.
+ *  A <em>global minimum cut</em> whose weight is no larger than the weight
+ *  of any other cut.
+ *  <p>
+ *  This is an implementation of <em>Stoer-Wagner's algorithm</em>.
+ *  The constructor takes
+ *  <em>O</em>(<em>V</em> (<em>V</em> + <em>E</em>) log <em>V</em>) time,
+ *  where <em>V</em> is the number of vertices and <em>E</em> is the
+ *  number of edges. 
+ *  The <em>weight</em> and <em>isCut</em> methods take &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph).
+ *  <p>
+ *  For additional documentation, see
+ *  <ul>
+ *  <li>M. Stoer and F. Wagner (1997). A simple min-cut algorithm. <em>Journal of
+ *  the ACM </em>, 44(4):585-591.
+ *  </ul>
+ * 
+ * @author Marcelo Silva
+ */
+public class GlobalMincut {
+    private static final double FLOATING_POINT_EPSILON = 1E-11;
+
+    // the weight of the minimum cut
+    private double weight = Double.POSITIVE_INFINITY;
+
+    // cut[v] = true if v is on the first subset of vertices of the minimum cut;
+    // or false if v is on the second subset
+    private boolean[] cut;
+
+    // number of vertices
+    private int V;
+
+    /**
+     * This helper class represents the <em>cut-of-the-phase</em>. The
+     * cut-of-the-phase is a <em>minimum s-t-cut</em> in the current graph,
+     * where {@code s} and {@code t} are the two vertices added last in the
+     * phase.
+     */
+    private class CutPhase {
+        private double weight; // the weight of the minimum s-t cut
+        private int s;         // the vertex s
+        private int t;         // the vertex t
+
+        public CutPhase(double weight, int s, int t) {
+            this.weight = weight;
+            this.s = s;
+            this.t = t;
+        }
+    }
+
+    /**
+     * Computes a minimum cut in an edge-weighted graph.
+     * 
+     * @param G the edge-weighted graph
+     * @throws IllegalArgumentException if the number of vertices of {@code G}
+     *             is less than {@code 2}.
+     * @throws IllegalArgumentException if any edge weight is negative
+     */
+    public GlobalMincut(EdgeWeightedGraph G) {
+        V = G.V();
+        validate(G);
+        minCut(G, 0);
+        assert check(G);
+    }
+
+    /**
+     * Validates the edge-weighted graph.
+     * 
+     * @param G the edge-weighted graph
+     * @throws IllegalArgumentException if the number of vertices of {@code G}
+     *             is less than {@code 2} or if any edge weight is negative
+     */
+    private void validate(EdgeWeightedGraph G) {
+        if (G.V() < 2) throw new IllegalArgumentException("number of vertices of G is less than 2");
+        for (Edge e : G.edges()) {
+            if (e.weight() < 0) throw new IllegalArgumentException("edge " + e + " has negative weight");
+        }
+    }
+
+    /**
+     * Returns the weight of the minimum cut.
+     * 
+     * @return the weight of the minimum cut
+     */
+    public double weight() {
+        return weight;
+    }
+
+    /**
+     * Returns {@code true} if the vertex {@code v} is one side of the
+     * mincut and {@code false} otherwise. An edge <em>v</em>-<em>w</em>
+     * crosses the mincut if and only if <em>v</em> and <em>w</em> have
+     * opposite parity.
+     * 
+     * @param v the vertex to check
+     * @return {@code true} if the vertex {@code v} is on the first subset of
+     *         vertices of the minimum cut; or {@code false} if the vertex
+     *         {@code v} is on the second subset.
+     * @throws IllegalArgumentException unless vertex {@code v} is between
+     *             {@code 0 <= v < V}
+     */
+    public boolean cut(int v) {
+        validateVertex(v);
+        return cut[v];
+    }
+
+    /**
+     * Makes a cut for the current edge-weighted graph by partitioning its
+     * vertices into two nonempty subsets. The vertices connected to the
+     * vertex {@code t} belong to the first subset. Other vertices not connected
+     * to {@code t} belong to the second subset.
+     * 
+     * @param t the vertex {@code t}
+     * @param uf the union-find data type
+     */
+    private void makeCut(int t, UF uf) {
+        for (int v = 0; v < cut.length; v++) {
+            cut[v] = (uf.find(v) == uf.find(t));
+        }
+    }
+
+    /**
+     * Computes a minimum cut of the edge-weighted graph. Precisely, it computes
+     * the lightest of the cuts-of-the-phase which yields the desired minimum
+     * cut.
+     * 
+     * @param G the edge-weighted graph
+     * @param a the starting vertex
+     */
+    private void minCut(EdgeWeightedGraph G, int a) {
+        UF uf = new UF(G.V());
+        boolean[] marked = new boolean[G.V()];
+        cut = new boolean[G.V()];
+        CutPhase cp = new CutPhase(0.0, a, a);
+        for (int v = G.V(); v > 1; v--) {
+            cp = minCutPhase(G, marked, cp);
+            if (cp.weight < weight) {
+                weight = cp.weight;
+                makeCut(cp.t, uf);
+            }
+            G = contractEdge(G, cp.s, cp.t);
+            marked[cp.t] = true;
+            uf.union(cp.s, cp.t);
+        }
+    }
+
+    /**
+     * Returns the cut-of-the-phase. The cut-of-the-phase is a minimum s-t-cut
+     * in the current graph, where {@code s} and {@code t} are the two vertices
+     * added last in the phase. This algorithm is known in the literature as
+     * <em>maximum adjacency search</em> or <em>maximum cardinality search</em>.
+     * 
+     * @param G the edge-weighted graph
+     * @param marked the array of contracted vertices, where {@code marked[v]}
+     *            is {@code true} if the vertex {@code v} was already
+     *            contracted; or {@code false} otherwise
+     * @param cp the previous cut-of-the-phase
+     * @return the cut-of-the-phase
+     */
+    private CutPhase minCutPhase(EdgeWeightedGraph G, boolean[] marked, CutPhase cp) {
+        IndexMaxPQ<Double> pq = new IndexMaxPQ<Double>(G.V());
+        for (int v = 0; v < G.V(); v++) {
+            if (v != cp.s && !marked[v]) pq.insert(v, 0.0);
+        }
+        pq.insert(cp.s, Double.POSITIVE_INFINITY);
+        while (!pq.isEmpty()) {
+            int v = pq.delMax();
+            cp.s = cp.t;
+            cp.t = v;
+            for (Edge e : G.adj(v)) {
+                int w = e.other(v);
+                if (pq.contains(w)) pq.increaseKey(w, pq.keyOf(w) + e.weight());
+            }
+        }
+        cp.weight = 0.0;
+        for (Edge e : G.adj(cp.t)) {
+            cp.weight += e.weight();
+        }
+        return cp;
+    }
+
+    /**
+     * Contracts the edges incidents on the vertices {@code s} and {@code t} of
+     * the given edge-weighted graph.
+     * 
+     * @param G the edge-weighted graph
+     * @param s the vertex {@code s}
+     * @param t the vertex {@code t}
+     * @return a new edge-weighted graph for which the edges incidents on the
+     *         vertices {@code s} and {@code t} were contracted
+     */
+    private EdgeWeightedGraph contractEdge(EdgeWeightedGraph G, int s, int t) {
+        EdgeWeightedGraph H = new EdgeWeightedGraph(G.V());
+        for (int v = 0; v < G.V(); v++) {
+            for (Edge e : G.adj(v)) {
+                int w = e.other(v);
+                if (v == s && w == t || v == t && w == s) continue;
+                if (v < w) {
+                    if (w == t)      H.addEdge(new Edge(v, s, e.weight()));
+                    else if (v == t) H.addEdge(new Edge(w, s, e.weight()));
+                    else             H.addEdge(new Edge(v, w, e.weight()));
+                }
+            }
+        }
+        return H;
+    }
+
+    /**
+     * Checks optimality conditions.
+     * 
+     * @param G the edge-weighted graph
+     * @return {@code true} if optimality conditions are fine
+     */
+    private boolean check(EdgeWeightedGraph G) {
+
+        // compute min st-cut for all pairs s and t
+        // shortcut: s must appear on one side of global mincut,
+        // so it suffices to try all pairs s-v for some fixed s
+        double value = Double.POSITIVE_INFINITY;
+        for (int s = 0, t = 1; t < G.V(); t++) {
+            FlowNetwork F = new FlowNetwork(G.V());
+            for (Edge e : G.edges()) {
+                int v = e.either(), w = e.other(v);
+                F.addEdge(new FlowEdge(v, w, e.weight()));
+                F.addEdge(new FlowEdge(w, v, e.weight()));
+            }
+            FordFulkerson maxflow = new FordFulkerson(F, s, t);
+            value = Math.min(value, maxflow.value());
+        }
+        if (Math.abs(weight - value) > FLOATING_POINT_EPSILON) {
+            System.err.println("Min cut weight = " + weight + " , max flow value = " + value);
+            return false;
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+
+    /**
+     * Unit tests the {@code GlobalMincut} data type.
+     * 
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        GlobalMincut mc = new GlobalMincut(G);
+        StdOut.print("Min cut: ");
+        for (int v = 0; v < G.V(); v++) {
+            if (mc.cut(v)) StdOut.print(v + " ");
+        }
+        StdOut.println();
+        StdOut.println("Min cut weight = " + mc.weight());
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GrahamScan.java b/src/main/java/edu/princeton/cs/algs4/GrahamScan.java
new file mode 100644
index 0000000..205ccf6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GrahamScan.java
@@ -0,0 +1,182 @@
+/******************************************************************************
+ *  Compilation:  javac GrahamaScan.java
+ *  Execution:    java GrahamScan < input.txt
+ *  Dependencies: Point2D.java
+ *  Data files:   https://algs4.cs.princeton.edu/99hull/rs1423.txt
+ *                https://algs4.cs.princeton.edu/99hull/kw1260.txt
+ * 
+ *  Create points from standard input and compute the convex hull using
+ *  Graham scan algorithm.
+ *
+ *  May be floating-point issues if x- and y-coordinates are not integers.
+ *
+ *  % java GrahamScan < input100.txt 
+ *  (7486.0, 422.0)
+ *  (29413.0, 596.0)
+ *  (32011.0, 3140.0)
+ *  (30875.0, 28560.0)
+ *  (28462.0, 32343.0)
+ *  (15731.0, 32661.0)
+ *  (822.0, 32301.0)
+ *  (823.0, 15895.0)
+ *  (1444.0, 10362.0)
+ *  (4718.0, 4451.0)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+
+/**
+ *  The {@code GrahamScan} data type provides methods for computing the 
+ *  convex hull of a set of <em>n</em> points in the plane.
+ *  <p>
+ *  The implementation uses the Graham-Scan convex hull algorithm.
+ *  It runs in O(<em>n</em> log <em>n</em>) time in the worst case
+ *  and uses O(<em>n</em>) extra memory.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/99scientific">Section 9.9</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class GrahamScan {
+    private Stack<Point2D> hull = new Stack<Point2D>();
+
+    /**
+     * Computes the convex hull of the specified array of points.
+     *
+     * @param  points the array of points
+     * @throws IllegalArgumentException if {@code points} is {@code null}
+     * @throws IllegalArgumentException if any entry in {@code points[]} is {@code null}
+     * @throws IllegalArgumentException if {@code points.length} is {@code 0}
+     */
+    public GrahamScan(Point2D[] points) {
+        if (points == null) throw new IllegalArgumentException("argument is null");
+        if (points.length == 0) throw new IllegalArgumentException("array is of length 0");
+
+        // defensive copy
+        int n = points.length;
+        Point2D[] a = new Point2D[n];
+        for (int i = 0; i < n; i++) {
+            if (points[i] == null)
+                throw new IllegalArgumentException("points[" + i + "] is null");
+            a[i] = points[i];
+        }
+
+        // preprocess so that a[0] has lowest y-coordinate; break ties by x-coordinate
+        // a[0] is an extreme point of the convex hull
+        // (alternatively, could do easily in linear time)
+        Arrays.sort(a);
+
+        // sort by polar angle with respect to base point a[0],
+        // breaking ties by distance to a[0]
+        Arrays.sort(a, 1, n, a[0].polarOrder());
+
+        hull.push(a[0]);       // a[0] is first extreme point
+
+        // find index k1 of first point not equal to a[0]
+        int k1;
+        for (k1 = 1; k1 < n; k1++)
+            if (!a[0].equals(a[k1])) break;
+        if (k1 == n) return;        // all points equal
+
+        // find index k2 of first point not collinear with a[0] and a[k1]
+        int k2;
+        for (k2 = k1+1; k2 < n; k2++)
+            if (Point2D.ccw(a[0], a[k1], a[k2]) != 0) break;
+        hull.push(a[k2-1]);    // a[k2-1] is second extreme point
+
+        // Graham scan; note that a[n-1] is extreme point different from a[0]
+        for (int i = k2; i < n; i++) {
+            Point2D top = hull.pop();
+            while (Point2D.ccw(hull.peek(), top, a[i]) <= 0) {
+                top = hull.pop();
+            }
+            hull.push(top);
+            hull.push(a[i]);
+        }
+
+        assert isConvex();
+    }
+
+    /**
+     * Returns the extreme points on the convex hull in counterclockwise order.
+     *
+     * @return the extreme points on the convex hull in counterclockwise order
+     */
+    public Iterable<Point2D> hull() {
+        Stack<Point2D> s = new Stack<Point2D>();
+        for (Point2D p : hull) s.push(p);
+        return s;
+    }
+
+    // check that boundary of hull is strictly convex
+    private boolean isConvex() {
+        int n = hull.size();
+        if (n <= 2) return true;
+
+        Point2D[] points = new Point2D[n];
+        int k = 0;
+        for (Point2D p : hull()) {
+            points[k++] = p;
+        }
+
+        for (int i = 0; i < n; i++) {
+            if (Point2D.ccw(points[i], points[(i+1) % n], points[(i+2) % n]) <= 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+   /**
+     * Unit tests the {@code GrahamScan} data type.
+     * Reads in an integer {@code n} and {@code n} points (specified by
+     * their <em>x</em>- and <em>y</em>-coordinates) from standard input;
+     * computes their convex hull; and prints out the points on the
+     * convex hull to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        Point2D[] points = new Point2D[n];
+        for (int i = 0; i < n; i++) {
+            int x = StdIn.readInt();
+            int y = StdIn.readInt();
+            points[i] = new Point2D(x, y);
+        }
+        GrahamScan graham = new GrahamScan(points);
+        for (Point2D p : graham.hull())
+            StdOut.println(p);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Graph.java b/src/main/java/edu/princeton/cs/algs4/Graph.java
new file mode 100644
index 0000000..47da9b9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Graph.java
@@ -0,0 +1,281 @@
+/******************************************************************************
+ *  Compilation:  javac Graph.java        
+ *  Execution:    java Graph input.txt
+ *  Dependencies: Bag.java Stack.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *                https://algs4.cs.princeton.edu/41graph/largeG.txt
+ *
+ *  A graph, implemented using an array of sets.
+ *  Parallel edges and self-loops allowed.
+ *
+ *  % java Graph tinyG.txt
+ *  13 vertices, 13 edges 
+ *  0: 6 2 1 5 
+ *  1: 0 
+ *  2: 0 
+ *  3: 5 4 
+ *  4: 5 6 3 
+ *  5: 3 4 0 
+ *  6: 0 4 
+ *  7: 8 
+ *  8: 7 
+ *  9: 11 10 12 
+ *  10: 9 
+ *  11: 9 12 
+ *  12: 11 9 
+ *
+ *  % java Graph mediumG.txt
+ *  250 vertices, 1273 edges 
+ *  0: 225 222 211 209 204 202 191 176 163 160 149 114 97 80 68 59 58 49 44 24 15 
+ *  1: 220 203 200 194 189 164 150 130 107 72 
+ *  2: 141 110 108 86 79 51 42 18 14 
+ *  ...
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code Graph} class represents an undirected graph of vertices
+ *  named 0 through <em>V</em> ‚Äì 1.
+ *  It supports the following two primary operations: add an edge to the graph,
+ *  iterate over all of the vertices adjacent to a vertex. It also provides
+ *  methods for returning the degree of a vertex, the number of vertices
+ *  <em>V</em> in the graph, and the number of edges <em>E</em> in the graph.
+ *  Parallel edges and self-loops are permitted.
+ *  By convention, a self-loop <em>v</em>-<em>v</em> appears in the
+ *  adjacency list of <em>v</em> twice and contributes two to the degree
+ *  of <em>v</em>.
+ *  <p>
+ *  This implementation uses an <em>adjacency-lists representation</em>, which
+ *  is a vertex-indexed array of {@link Bag} objects.
+ *  It uses &Theta;(<em>E</em> + <em>V</em>) space, where <em>E</em> is
+ *  the number of edges and <em>V</em> is the number of vertices.
+ *  All instance methods take &Theta;(1) time. (Though, iterating over
+ *  the vertices returned by {@link #adj(int)} takes time proportional
+ *  to the degree of the vertex.)
+ *  Constructing an empty graph with <em>V</em> vertices takes
+ *  &Theta;(<em>V</em>) time; constructing a graph with <em>E</em> edges
+ *  and <em>V</em> vertices takes &Theta;(<em>E</em> + <em>V</em>) time. 
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Graph {
+    private static final String NEWLINE = System.getProperty("line.separator");
+
+    private final int V;
+    private int E;
+    private Bag<Integer>[] adj;
+    
+    /**
+     * Initializes an empty graph with {@code V} vertices and 0 edges.
+     * param V the number of vertices
+     *
+     * @param  V number of vertices
+     * @throws IllegalArgumentException if {@code V < 0}
+     */
+    public Graph(int V) {
+        if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");
+        this.V = V;
+        this.E = 0;
+        adj = (Bag<Integer>[]) new Bag[V];
+        for (int v = 0; v < V; v++) {
+            adj[v] = new Bag<Integer>();
+        }
+    }
+
+    /**  
+     * Initializes a graph from the specified input stream.
+     * The format is the number of vertices <em>V</em>,
+     * followed by the number of edges <em>E</em>,
+     * followed by <em>E</em> pairs of vertices, with each entry separated by whitespace.
+     *
+     * @param  in the input stream
+     * @throws IllegalArgumentException if {@code in} is {@code null}
+     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
+     * @throws IllegalArgumentException if the number of vertices or edges is negative
+     * @throws IllegalArgumentException if the input stream is in the wrong format
+     */
+    public Graph(In in) {
+        if (in == null) throw new IllegalArgumentException("argument is null");
+        try {
+            this.V = in.readInt();
+            if (V < 0) throw new IllegalArgumentException("number of vertices in a Graph must be non-negative");
+            adj = (Bag<Integer>[]) new Bag[V];
+            for (int v = 0; v < V; v++) {
+                adj[v] = new Bag<Integer>();
+            }
+            int E = in.readInt();
+            if (E < 0) throw new IllegalArgumentException("number of edges in a Graph must be non-negative");
+            for (int i = 0; i < E; i++) {
+                int v = in.readInt();
+                int w = in.readInt();
+                validateVertex(v);
+                validateVertex(w);
+                addEdge(v, w); 
+            }
+        }
+        catch (NoSuchElementException e) {
+            throw new IllegalArgumentException("invalid input format in Graph constructor", e);
+        }
+    }
+
+
+    /**
+     * Initializes a new graph that is a deep copy of {@code G}.
+     *
+     * @param  G the graph to copy
+     * @throws IllegalArgumentException if {@code G} is {@code null}
+     */
+    public Graph(Graph G) {
+        this.V = G.V();
+        this.E = G.E();
+        if (V < 0) throw new IllegalArgumentException("Number of vertices must be non-negative");
+
+        // update adjacency lists
+        adj = (Bag<Integer>[]) new Bag[V];
+        for (int v = 0; v < V; v++) {
+            adj[v] = new Bag<Integer>();
+        }
+
+        for (int v = 0; v < G.V(); v++) {
+            // reverse so that adjacency list is in same order as original
+            Stack<Integer> reverse = new Stack<Integer>();
+            for (int w : G.adj[v]) {
+                reverse.push(w);
+            }
+            for (int w : reverse) {
+                adj[v].add(w);
+            }
+        }
+    }
+
+    /**
+     * Returns the number of vertices in this graph.
+     *
+     * @return the number of vertices in this graph
+     */
+    public int V() {
+        return V;
+    }
+
+    /**
+     * Returns the number of edges in this graph.
+     *
+     * @return the number of edges in this graph
+     */
+    public int E() {
+        return E;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Adds the undirected edge v-w to this graph.
+     *
+     * @param  v one vertex in the edge
+     * @param  w the other vertex in the edge
+     * @throws IllegalArgumentException unless both {@code 0 <= v < V} and {@code 0 <= w < V}
+     */
+    public void addEdge(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        E++;
+        adj[v].add(w);
+        adj[w].add(v);
+    }
+
+
+    /**
+     * Returns the vertices adjacent to vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the vertices adjacent to vertex {@code v}, as an iterable
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public Iterable<Integer> adj(int v) {
+        validateVertex(v);
+        return adj[v];
+    }
+
+    /**
+     * Returns the degree of vertex {@code v}.
+     *
+     * @param  v the vertex
+     * @return the degree of vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int degree(int v) {
+        validateVertex(v);
+        return adj[v].size();
+    }
+
+
+    /**
+     * Returns a string representation of this graph.
+     *
+     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
+     *         followed by the <em>V</em> adjacency lists
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(V + " vertices, " + E + " edges " + NEWLINE);
+        for (int v = 0; v < V; v++) {
+            s.append(v + ": ");
+            for (int w : adj[v]) {
+                s.append(w + " ");
+            }
+            s.append(NEWLINE);
+        }
+        return s.toString();
+    }
+
+
+    /**
+     * Unit tests the {@code Graph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        StdOut.println(G);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GraphGenerator.java b/src/main/java/edu/princeton/cs/algs4/GraphGenerator.java
new file mode 100644
index 0000000..637fbe7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GraphGenerator.java
@@ -0,0 +1,494 @@
+/******************************************************************************
+ *  Compilation:  javac GraphGenerator.java
+ *  Execution:    java GraphGenerator V E
+ *  Dependencies: Graph.java
+ *
+ *  A graph generator.
+ *
+ *  For many more graph generators, see
+ *  http://networkx.github.io/documentation/latest/reference/generators.html
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code GraphGenerator} class provides static methods for creating
+ *  various graphs, including Erdos-Renyi random graphs, random bipartite
+ *  graphs, random k-regular graphs, and random rooted trees.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class GraphGenerator {
+    private static final class Edge implements Comparable<Edge> {
+        private int v;
+        private int w;
+
+        private Edge(int v, int w) {
+            if (v < w) {
+                this.v = v;
+                this.w = w;
+            }
+            else {
+                this.v = w;
+                this.w = v;
+            }
+        }
+
+        public int compareTo(Edge that) {
+            if (this.v < that.v) return -1;
+            if (this.v > that.v) return +1;
+            if (this.w < that.w) return -1;
+            if (this.w > that.w) return +1;
+            return 0;
+        }
+    }
+
+    // this class cannot be instantiated
+    private GraphGenerator() { }
+
+    /**
+     * Returns a random simple graph containing {@code V} vertices and {@code E} edges.
+     * @param V the number of vertices
+     * @param E the number of vertices
+     * @return a random simple graph on {@code V} vertices, containing a total
+     *     of {@code E} edges
+     * @throws IllegalArgumentException if no such simple graph exists
+     */
+    public static Graph simple(int V, int E) {
+        if (E > (long) V*(V-1)/2) throw new IllegalArgumentException("Too many edges");
+        if (E < 0)                throw new IllegalArgumentException("Too few edges");
+        Graph G = new Graph(V);
+        SET<Edge> set = new SET<Edge>();
+        while (G.E() < E) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            Edge e = new Edge(v, w);
+            if ((v != w) && !set.contains(e)) {
+                set.add(e);
+                G.addEdge(v, w);
+            }
+        }
+        return G;
+    }
+
+    /**
+     * Returns a random simple graph on {@code V} vertices, with an 
+     * edge between any two vertices with probability {@code p}. This is sometimes
+     * referred to as the Erdos-Renyi random graph model.
+     * @param V the number of vertices
+     * @param p the probability of choosing an edge
+     * @return a random simple graph on {@code V} vertices, with an edge between
+     *     any two vertices with probability {@code p}
+     * @throws IllegalArgumentException if probability is not between 0 and 1
+     */
+    public static Graph simple(int V, double p) {
+        if (p < 0.0 || p > 1.0)
+            throw new IllegalArgumentException("Probability must be between 0 and 1");
+        Graph G = new Graph(V);
+        for (int v = 0; v < V; v++)
+            for (int w = v+1; w < V; w++)
+                if (StdRandom.bernoulli(p))
+                    G.addEdge(v, w);
+        return G;
+    }
+
+    /**
+     * Returns the complete graph on {@code V} vertices.
+     * @param V the number of vertices
+     * @return the complete graph on {@code V} vertices
+     */
+    public static Graph complete(int V) {
+        return simple(V, 1.0);
+    }
+
+    /**
+     * Returns a complete bipartite graph on {@code V1} and {@code V2} vertices.
+     * @param V1 the number of vertices in one partition
+     * @param V2 the number of vertices in the other partition
+     * @return a complete bipartite graph on {@code V1} and {@code V2} vertices
+     * @throws IllegalArgumentException if probability is not between 0 and 1
+     */
+    public static Graph completeBipartite(int V1, int V2) {
+        return bipartite(V1, V2, V1*V2);
+    }
+
+    /**
+     * Returns a random simple bipartite graph on {@code V1} and {@code V2} vertices
+     * with {@code E} edges.
+     * @param V1 the number of vertices in one partition
+     * @param V2 the number of vertices in the other partition
+     * @param E the number of edges
+     * @return a random simple bipartite graph on {@code V1} and {@code V2} vertices,
+     *    containing a total of {@code E} edges
+     * @throws IllegalArgumentException if no such simple bipartite graph exists
+     */
+    public static Graph bipartite(int V1, int V2, int E) {
+        if (E > (long) V1*V2) throw new IllegalArgumentException("Too many edges");
+        if (E < 0)            throw new IllegalArgumentException("Too few edges");
+        Graph G = new Graph(V1 + V2);
+
+        int[] vertices = new int[V1 + V2];
+        for (int i = 0; i < V1 + V2; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+
+        SET<Edge> set = new SET<Edge>();
+        while (G.E() < E) {
+            int i = StdRandom.uniform(V1);
+            int j = V1 + StdRandom.uniform(V2);
+            Edge e = new Edge(vertices[i], vertices[j]);
+            if (!set.contains(e)) {
+                set.add(e);
+                G.addEdge(vertices[i], vertices[j]);
+            }
+        }
+        return G;
+    }
+
+    /**
+     * Returns a random simple bipartite graph on {@code V1} and {@code V2} vertices,
+     * containing each possible edge with probability {@code p}.
+     * @param V1 the number of vertices in one partition
+     * @param V2 the number of vertices in the other partition
+     * @param p the probability that the graph contains an edge with one endpoint in either side
+     * @return a random simple bipartite graph on {@code V1} and {@code V2} vertices,
+     *    containing each possible edge with probability {@code p}
+     * @throws IllegalArgumentException if probability is not between 0 and 1
+     */
+    public static Graph bipartite(int V1, int V2, double p) {
+        if (p < 0.0 || p > 1.0)
+            throw new IllegalArgumentException("Probability must be between 0 and 1");
+        int[] vertices = new int[V1 + V2];
+        for (int i = 0; i < V1 + V2; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        Graph G = new Graph(V1 + V2);
+        for (int i = 0; i < V1; i++)
+            for (int j = 0; j < V2; j++)
+                if (StdRandom.bernoulli(p))
+                    G.addEdge(vertices[i], vertices[V1+j]);
+        return G;
+    }
+
+    /**
+     * Returns a path graph on {@code V} vertices.
+     * @param V the number of vertices in the path
+     * @return a path graph on {@code V} vertices
+     */
+    public static Graph path(int V) {
+        Graph G = new Graph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        return G;
+    }
+
+    /**
+     * Returns a complete binary tree graph on {@code V} vertices.
+     * @param V the number of vertices in the binary tree
+     * @return a complete binary tree graph on {@code V} vertices
+     */
+    public static Graph binaryTree(int V) {
+        Graph G = new Graph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 1; i < V; i++) {
+            G.addEdge(vertices[i], vertices[(i-1)/2]);
+        }
+        return G;
+    }
+
+    /**
+     * Returns a cycle graph on {@code V} vertices.
+     * @param V the number of vertices in the cycle
+     * @return a cycle graph on {@code V} vertices
+     */
+    public static Graph cycle(int V) {
+        Graph G = new Graph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        G.addEdge(vertices[V-1], vertices[0]);
+        return G;
+    }
+
+    /**
+     * Returns an Eulerian cycle graph on {@code V} vertices.
+     *
+     * @param  V the number of vertices in the cycle
+     * @param  E the number of edges in the cycle
+     * @return a graph that is an Eulerian cycle on {@code V} vertices
+     *         and {@code E} edges
+     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E <= 0}
+     */
+    public static Graph eulerianCycle(int V, int E) {
+        if (E <= 0)
+            throw new IllegalArgumentException("An Eulerian cycle must have at least one edge");
+        if (V <= 0)
+            throw new IllegalArgumentException("An Eulerian cycle must have at least one vertex");
+        Graph G = new Graph(V);
+        int[] vertices = new int[E];
+        for (int i = 0; i < E; i++)
+            vertices[i] = StdRandom.uniform(V);
+        for (int i = 0; i < E-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        G.addEdge(vertices[E-1], vertices[0]);
+        return G;
+    }
+
+    /**
+     * Returns an Eulerian path graph on {@code V} vertices.
+     *
+     * @param  V the number of vertices in the path
+     * @param  E the number of edges in the path
+     * @return a graph that is an Eulerian path on {@code V} vertices
+     *         and {@code E} edges
+     * @throws IllegalArgumentException if either {@code V <= 0} or {@code E < 0}
+     */
+    public static Graph eulerianPath(int V, int E) {
+        if (E < 0)
+            throw new IllegalArgumentException("negative number of edges");
+        if (V <= 0)
+            throw new IllegalArgumentException("An Eulerian path must have at least one vertex");
+        Graph G = new Graph(V);
+        int[] vertices = new int[E+1];
+        for (int i = 0; i < E+1; i++)
+            vertices[i] = StdRandom.uniform(V);
+        for (int i = 0; i < E; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        return G;
+    }
+
+    /**
+     * Returns a wheel graph on {@code V} vertices.
+     * @param V the number of vertices in the wheel
+     * @return a wheel graph on {@code V} vertices: a single vertex connected to
+     *     every vertex in a cycle on {@code V-1} vertices
+     */
+    public static Graph wheel(int V) {
+        if (V <= 1) throw new IllegalArgumentException("Number of vertices must be at least 2");
+        Graph G = new Graph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+
+        // simple cycle on V-1 vertices
+        for (int i = 1; i < V-1; i++) {
+            G.addEdge(vertices[i], vertices[i+1]);
+        }
+        G.addEdge(vertices[V-1], vertices[1]);
+
+        // connect vertices[0] to every vertex on cycle
+        for (int i = 1; i < V; i++) {
+            G.addEdge(vertices[0], vertices[i]);
+        }
+
+        return G;
+    }
+
+    /**
+     * Returns a star graph on {@code V} vertices.
+     * @param V the number of vertices in the star
+     * @return a star graph on {@code V} vertices: a single vertex connected to
+     *     every other vertex
+     */
+    public static Graph star(int V) {
+        if (V <= 0) throw new IllegalArgumentException("Number of vertices must be at least 1");
+        Graph G = new Graph(V);
+        int[] vertices = new int[V];
+        for (int i = 0; i < V; i++)
+            vertices[i] = i;
+        StdRandom.shuffle(vertices);
+
+        // connect vertices[0] to every other vertex
+        for (int i = 1; i < V; i++) {
+            G.addEdge(vertices[0], vertices[i]);
+        }
+
+        return G;
+    }
+
+    /**
+     * Returns a uniformly random {@code k}-regular graph on {@code V} vertices
+     * (not necessarily simple). The graph is simple with probability only about e^(-k^2/4),
+     * which is tiny when k = 14.
+     *
+     * @param V the number of vertices in the graph
+     * @param k degree of each vertex
+     * @return a uniformly random {@code k}-regular graph on {@code V} vertices.
+     */
+    public static Graph regular(int V, int k) {
+        if (V*k % 2 != 0) throw new IllegalArgumentException("Number of vertices * k must be even");
+        Graph G = new Graph(V);
+
+        // create k copies of each vertex
+        int[] vertices = new int[V*k];
+        for (int v = 0; v < V; v++) {
+            for (int j = 0; j < k; j++) {
+                vertices[v + V*j] = v;
+            }
+        }
+
+        // pick a random perfect matching
+        StdRandom.shuffle(vertices);
+        for (int i = 0; i < V*k/2; i++) {
+            G.addEdge(vertices[2*i], vertices[2*i + 1]);
+        }
+        return G;
+    }
+
+    // http://www.proofwiki.org/wiki/Labeled_Tree_from_Pr√ºfer_Sequence
+    // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.6484&rep=rep1&type=pdf
+    /**
+     * Returns a uniformly random tree on {@code V} vertices.
+     * This algorithm uses a Prufer sequence and takes time proportional to <em>V log V</em>.
+     * @param V the number of vertices in the tree
+     * @return a uniformly random tree on {@code V} vertices
+     */
+    public static Graph tree(int V) {
+        Graph G = new Graph(V);
+
+        // special case
+        if (V == 1) return G;
+
+        // Cayley's theorem: there are V^(V-2) labeled trees on V vertices
+        // Prufer sequence: sequence of V-2 values between 0 and V-1
+        // Prufer's proof of Cayley's theorem: Prufer sequences are in 1-1
+        // with labeled trees on V vertices
+        int[] prufer = new int[V-2];
+        for (int i = 0; i < V-2; i++)
+            prufer[i] = StdRandom.uniform(V);
+
+        // degree of vertex v = 1 + number of times it appers in Prufer sequence
+        int[] degree = new int[V];
+        for (int v = 0; v < V; v++)
+            degree[v] = 1;
+        for (int i = 0; i < V-2; i++)
+            degree[prufer[i]]++;
+
+        // pq contains all vertices of degree 1
+        MinPQ<Integer> pq = new MinPQ<Integer>();
+        for (int v = 0; v < V; v++)
+            if (degree[v] == 1) pq.insert(v);
+
+        // repeatedly delMin() degree 1 vertex that has the minimum index
+        for (int i = 0; i < V-2; i++) {
+            int v = pq.delMin();
+            G.addEdge(v, prufer[i]);
+            degree[v]--;
+            degree[prufer[i]]--;
+            if (degree[prufer[i]] == 1) pq.insert(prufer[i]);
+        }
+        G.addEdge(pq.delMin(), pq.delMin());
+        return G;
+    }
+
+    /**
+     * Unit tests the {@code GraphGenerator} library.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        int V1 = V/2;
+        int V2 = V - V1;
+
+        StdOut.println("complete graph");
+        StdOut.println(complete(V));
+        StdOut.println();
+
+        StdOut.println("simple");
+        StdOut.println(simple(V, E));
+        StdOut.println();
+
+        StdOut.println("Erdos-Renyi");
+        double p = (double) E / (V*(V-1)/2.0);
+        StdOut.println(simple(V, p));
+        StdOut.println();
+
+        StdOut.println("complete bipartite");
+        StdOut.println(completeBipartite(V1, V2));
+        StdOut.println();
+
+        StdOut.println("bipartite");
+        StdOut.println(bipartite(V1, V2, E));
+        StdOut.println();
+
+        StdOut.println("Erdos Renyi bipartite");
+        double q = (double) E / (V1*V2);
+        StdOut.println(bipartite(V1, V2, q));
+        StdOut.println();
+
+        StdOut.println("path");
+        StdOut.println(path(V));
+        StdOut.println();
+
+        StdOut.println("cycle");
+        StdOut.println(cycle(V));
+        StdOut.println();
+
+        StdOut.println("binary tree");
+        StdOut.println(binaryTree(V));
+        StdOut.println();
+
+        StdOut.println("tree");
+        StdOut.println(tree(V));
+        StdOut.println();
+
+        StdOut.println("4-regular");
+        StdOut.println(regular(V, 4));
+        StdOut.println();
+
+        StdOut.println("star");
+        StdOut.println(star(V));
+        StdOut.println();
+
+        StdOut.println("wheel");
+        StdOut.println(wheel(V));
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/GrayscalePicture.java b/src/main/java/edu/princeton/cs/algs4/GrayscalePicture.java
new file mode 100644
index 0000000..6b3bdef
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/GrayscalePicture.java
@@ -0,0 +1,500 @@
+/******************************************************************************
+ *  Compilation:  javac GrayscalePicture.java
+ *  Execution:    java GrayscalePicture imagename
+ *  Dependencies: none
+ *
+ *  Data type for manipulating individual pixels of a grayscale image. The
+ *  original image can be read from a file in JPEG, GIF, or PNG format, or the
+ *  user can create a blank image of a given dimension. Includes methods for
+ *  displaying the image in a window on the screen or saving to a file.
+ *
+ *  % java GrayscalePicture mandrill.jpg
+ *
+ *  Remarks
+ *  -------
+ *   - pixel (x, y) is column x and row y, where (0, 0) is upper left
+ *
+ *   - uses BufferedImage.TYPE_INT_RGB because BufferedImage.TYPE_BYTE_GRAY
+ *     seems to do some undesirable olor correction when calling getRGB() and
+ *     setRGB()
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.Color;
+import java.awt.FileDialog;
+import java.awt.Toolkit;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.KeyEvent;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import javax.imageio.ImageIO;
+import javax.swing.ImageIcon;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.JPanel;
+import javax.swing.KeyStroke;
+
+
+/**
+ *  This class provides methods for manipulating individual pixels of
+ *  a grayscale image.
+ *  The original image can be read from a {@code PNG}, {@code GIF},
+ *  or {@code JPEG} file or the user can create a blank image of a given dimension.
+ *  This class includes methods for displaying the image in a window on
+ *  the screen or saving it to a file.
+ *  <p>
+ *  Pixel (<em>col</em>, <em>row</em>) is column <em>col</em> and row <em>row</em>.
+ *  By default, the origin (0, 0) is the pixel in the top-left corner,
+ *  which is a common convention in image processing.
+ *  The method {@link #setOriginLowerLeft()} change the origin to the lower left.
+ *  <p>
+ *  The {@code get()} and {@code set()} methods use {@link Color} objects to get
+ *  or set the color of the specified pixel. The {@link Color} objects are converted
+ *  to grayscale if they have different values for the R, G, and B channels.
+ *  The {@code getGrayscale()} and {@code setGrayscale()} methods use an
+ *  8-bit {@code int} to encode the grayscale value, thereby avoiding the need to
+ *  create temporary {@code Color} objects.
+ *  <p>
+ *  A <em>W</em>-by-<em>H</em> picture uses ~ 4 <em>W H</em> bytes of memory,
+ *  since the color of each pixel is encoded as a 32-bit <code>int</code>
+ *  (even though, in principle, only ~ <em>W H</em> bytes are needed).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *  See {@link Picture} for a version that supports 32-bit RGB color images.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class GrayscalePicture implements ActionListener {
+    private BufferedImage image;               // the rasterized image
+    private JFrame frame;                      // on-screen view
+    private String filename;                   // name of file
+    private boolean isOriginUpperLeft = true;  // location of origin
+    private final int width, height;           // width and height
+
+   /**
+     * Creates a {@code width}-by-{@code height} picture, with {@code width} columns
+     * and {@code height} rows, where each pixel is black.
+     *
+     * @param width the width of the picture
+     * @param height the height of the picture
+     * @throws IllegalArgumentException if {@code width} is negative
+     * @throws IllegalArgumentException if {@code height} is negative
+     */
+    public GrayscalePicture(int width, int height) {
+        if (width  < 0) throw new IllegalArgumentException("width must be non-negative");
+        if (height < 0) throw new IllegalArgumentException("height must be non-negative");
+        this.width  = width;
+        this.height = height;
+        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+    }
+
+   /**
+     * Creates a new grayscale picture that is a deep copy of the argument picture.
+     *
+     * @param  picture the picture to copy
+     * @throws IllegalArgumentException if {@code picture} is {@code null}
+     */
+    public GrayscalePicture(GrayscalePicture picture) {
+        if (picture == null) throw new IllegalArgumentException("constructor argument is null");
+
+        width  = picture.width();
+        height = picture.height();
+        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+        filename = picture.filename;
+        isOriginUpperLeft = picture.isOriginUpperLeft;
+        for (int col = 0; col < width(); col++)
+            for (int row = 0; row < height(); row++)
+                image.setRGB(col, row, picture.image.getRGB(col, row));
+    }
+
+   /**
+     * Creates a grayscale picture by reading an image from a file or URL.
+     *
+     * @param  name the name of the file (.png, .gif, or .jpg) or URL.
+     * @throws IllegalArgumentException if cannot read image
+     * @throws IllegalArgumentException if {@code name} is {@code null}
+     */
+    public GrayscalePicture(String name) {
+        if (name == null) throw new IllegalArgumentException("constructor argument is null");
+        this.filename = name;
+        try {
+            // try to read from file in working directory
+            File file = new File(name);
+            if (file.isFile()) {
+                image = ImageIO.read(file);
+            }
+
+            else {
+
+                // resource relative to .class file
+                URL url = getClass().getResource(name);
+
+                // resource relative to classloader root
+                if (url == null) {
+                    url = getClass().getClassLoader().getResource(name);
+                }
+     
+                // or URL from web
+                if (url == null) {
+                    url = new URL(name);
+                }
+        
+                image = ImageIO.read(url);
+            }
+
+            if (image == null) {
+                throw new IllegalArgumentException("could not read image: " + name);
+            }
+
+            width  = image.getWidth(null);
+            height = image.getHeight(null);
+
+            // convert to grayscale inplace
+            for (int col = 0; col < width; col++) {
+                for (int row = 0; row < height; row++) {
+                    Color color = new Color(image.getRGB(col, row));
+                    Color gray = toGray(color);
+                    image.setRGB(col, row, gray.getRGB());
+                }
+            }
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("could not open image: " + name, ioe);
+        }
+    }
+
+     // Returns a grayscale version of the given color as a Color object.
+    private static Color toGray(Color color) {
+        int r = color.getRed();
+        int g = color.getGreen();
+        int b = color.getBlue();
+        int y = (int) (Math.round(0.299*r + 0.587*g + 0.114*b));
+        return new Color(y, y, y);
+    }
+
+   /**
+     * Returns a {@link JLabel} containing this picture, for embedding in a {@link JPanel},
+     * {@link JFrame} or other GUI widget.
+     *
+     * @return the {@code JLabel}
+     */
+    public JLabel getJLabel() {
+        if (image == null) return null;         // no image available
+        ImageIcon icon = new ImageIcon(image);
+        return new JLabel(icon);
+    }
+
+   /**
+     * Sets the origin to be the upper left pixel. This is the default.
+     */
+    public void setOriginUpperLeft() {
+        isOriginUpperLeft = true;
+    }
+
+   /**
+     * Sets the origin to be the lower left pixel.
+     */
+    public void setOriginLowerLeft() {
+        isOriginUpperLeft = false;
+    }
+
+   /**
+     * Displays the picture in a window on the screen.
+     */
+    public void show() {
+
+        // create the GUI for viewing the image if needed
+        if (frame == null) {
+            frame = new JFrame();
+
+            JMenuBar menuBar = new JMenuBar();
+            JMenu menu = new JMenu("File");
+            menuBar.add(menu);
+            JMenuItem menuItem1 = new JMenuItem(" Save...   ");
+            menuItem1.addActionListener(this);
+            // use getMenuShortcutKeyMaskEx() in Java 10 (getMenuShortcutKeyMask() deprecated)
+            menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,
+                                     Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
+            menu.add(menuItem1);
+            frame.setJMenuBar(menuBar);
+
+
+
+            frame.setContentPane(getJLabel());
+            // f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
+            if (filename == null) frame.setTitle(width + "-by-" + height);
+            else                  frame.setTitle(filename);
+            frame.setResizable(false);
+            frame.pack();
+            frame.setVisible(true);
+        }
+
+        // draw
+        frame.repaint();
+    }
+
+   /**
+     * Returns the height of the picture.
+     *
+     * @return the height of the picture (in pixels)
+     */
+    public int height() {
+        return height;
+    }
+
+   /**
+     * Returns the width of the picture.
+     *
+     * @return the width of the picture (in pixels)
+     */
+    public int width() {
+        return width;
+    }
+
+    private void validateRowIndex(int row) {
+        if (row < 0 || row >= height())
+            throw new IllegalArgumentException("row index must be between 0 and " + (height() - 1) + ": " + row);
+    }
+
+    private void validateColumnIndex(int col) {
+        if (col < 0 || col >= width())
+            throw new IllegalArgumentException("column index must be between 0 and " + (width() - 1) + ": " + col);
+    }
+
+    private void validateGrayscaleValue(int gray) {
+        if (gray < 0 || gray >= 256)
+            throw new IllegalArgumentException("grayscale value must be between 0 and 255");
+    }
+
+   /**
+     * Returns the grayscale value of pixel ({@code col}, {@code row}) as a {@link java.awt.Color}.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @return the grayscale value of pixel ({@code col}, {@code row})
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     */
+    public Color get(int col, int row) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        Color color = new Color(image.getRGB(col, row));
+        return toGray(color);
+    }
+
+   /**
+     * Returns the grayscale value of pixel ({@code col}, {@code row}) as an {@code int}
+     * between 0 and 255.
+     * Using this method can be more efficient than {@link #get(int, int)} because
+     * it does not create a {@code Color} object.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @return the 8-bit integer representation of the grayscale value of pixel ({@code col}, {@code row})
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     */
+    public int getGrayscale(int col, int row) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        if (isOriginUpperLeft) return image.getRGB(col, row) & 0xFF;
+        else                   return image.getRGB(col, height - row - 1) & 0xFF;
+    }
+
+   /**
+     * Sets the color of pixel ({@code col}, {@code row}) to the given grayscale value.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @param color the color (converts to grayscale if color is not a shade of gray)
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     * @throws IllegalArgumentException if {@code color} is {@code null}
+     */
+    public void set(int col, int row, Color color) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        if (color == null) throw new IllegalArgumentException("color argument is null");
+        Color gray = toGray(color);
+        image.setRGB(col, row, gray.getRGB());
+    }
+
+   /**
+     * Sets the color of pixel ({@code col}, {@code row}) to the given grayscale value
+     * between 0 and 255.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @param gray the 8-bit integer representation of the grayscale value
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     */
+    public void setGrayscale(int col, int row, int gray) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        validateGrayscaleValue(gray);
+        int rgb = gray | (gray << 8) | (gray << 16);
+        if (isOriginUpperLeft) image.setRGB(col, row, rgb);
+        else                   image.setRGB(col, height - row - 1, rgb);
+    }
+
+   /**
+     * Returns true if this picture is equal to the argument picture.
+     *
+     * @param other the other picture
+     * @return {@code true} if this picture is the same dimension as {@code other}
+     *         and if all pixels have the same color; {@code false} otherwise
+     */
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        GrayscalePicture that = (GrayscalePicture) other;
+        if (this.width()  != that.width())  return false;
+        if (this.height() != that.height()) return false;
+        for (int col = 0; col < width(); col++)
+            for (int row = 0; row < height(); row++)
+                if (this.getGrayscale(col, row) != that.getGrayscale(col, row)) return false;
+        return true;
+    }
+
+   /**
+     * Returns a string representation of this picture.
+     * The result is a <code>width</code>-by-<code>height</code> matrix of pixels,
+     * where the grayscale value of a pixel is an integer between 0 and 255.
+     *
+     * @return a string representation of this picture
+     */
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(width +"-by-" + height + " grayscale picture (grayscale values given in hex)\n");
+        for (int row = 0; row < height; row++) {
+            for (int col = 0; col < width; col++) {
+                int gray = 0;
+                if (isOriginUpperLeft) gray = 0xFF & image.getRGB(col, row);
+                else                   gray = 0xFF & image.getRGB(col, height - row - 1);
+                sb.append(String.format("%3d ", gray));
+            }
+            sb.append("\n");
+        }
+        return sb.toString().trim();
+    }
+
+    /**
+     * This operation is not supported because pictures are mutable.
+     *
+     * @return does not return a value
+     * @throws UnsupportedOperationException if called
+     */
+    public int hashCode() {
+        throw new UnsupportedOperationException("hashCode() is not supported because pictures are mutable");
+    }
+
+   /**
+     * Saves the picture to a file in either PNG or JPEG format.
+     * The filetype extension must be either .png or .jpg.
+     *
+     * @param name the name of the file
+     * @throws IllegalArgumentException if {@code name} is {@code null}
+     */
+    public void save(String name) {
+        if (name == null) throw new IllegalArgumentException("argument to save() is null");
+        save(new File(name));
+        filename = name;
+    }
+
+   /**
+     * Saves the picture to a file in a PNG or JPEG image format.
+     *
+     * @param  file the file
+     * @throws IllegalArgumentException if {@code file} is {@code null}
+     */
+    public void save(File file) {
+        if (file == null) throw new IllegalArgumentException("argument to save() is null");
+        filename = file.getName();
+        if (frame != null) frame.setTitle(filename);
+        String suffix = filename.substring(filename.lastIndexOf('.') + 1);
+        if ("jpg".equalsIgnoreCase(suffix) || "png".equalsIgnoreCase(suffix)) {
+            try {
+                ImageIO.write(image, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        else {
+            System.out.println("Error: filename must end in .jpg or .png");
+        }
+    }
+
+   /**
+     * Opens a save dialog box when the user selects "Save As" from the menu.
+     */
+    @Override
+    public void actionPerformed(ActionEvent e) {
+        FileDialog chooser = new FileDialog(frame,
+                             "Use a .png or .jpg extension", FileDialog.SAVE);
+        chooser.setVisible(true);
+        if (chooser.getFile() != null) {
+            save(chooser.getDirectory() + File.separator + chooser.getFile());
+        }
+    }
+
+   /**
+     * Unit tests this {@code Picture} data type.
+     * Reads a picture specified by the command-line argument,
+     * and shows it in a window on the screen.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        GrayscalePicture picture = new GrayscalePicture(args[0]);
+        StdOut.printf("%d-by-%d\n", picture.width(), picture.height());
+        GrayscalePicture copy = new GrayscalePicture(picture);
+        picture.show();
+        copy.show();
+        while (!StdIn.isEmpty()) {
+            int row = StdIn.readInt();
+            int col = StdIn.readInt();
+            int gray = StdIn.readInt();
+            picture.setGrayscale(row, col, gray);
+            StdOut.println(picture.get(row, col));
+            StdOut.println(picture.getGrayscale(row, col));
+        }
+    }
+
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Heap.java b/src/main/java/edu/princeton/cs/algs4/Heap.java
new file mode 100644
index 0000000..fa92032
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Heap.java
@@ -0,0 +1,139 @@
+/******************************************************************************
+ *  Compilation:  javac Heap.java
+ *  Execution:    java Heap < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/24pq/tiny.txt
+ *                https://algs4.cs.princeton.edu/24pq/words3.txt
+ *  
+ *  Sorts a sequence of strings from standard input using heapsort.
+ *
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Heap < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *
+ *  % java Heap < words3.txt
+ *  all bad bed bug dad ... yes yet zoo   [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Heap} class provides a static method to sort an array
+ *  using <em>heapsort</em>.
+ *  <p>
+ *  This implementation takes &Theta;(<em>n</em> log <em>n</em>) time
+ *  to sort any array of length <em>n</em> (assuming comparisons
+ *  take constant time). It makes at most 
+ *  2 <em>n</em> log<sub>2</sub> <em>n</em> compares.
+ *  <p>
+ *  This sorting algorithm is not stable.
+ *  It uses &Theta;(1) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Heap {
+
+    // This class should not be instantiated.
+    private Heap() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param pq the array to be sorted
+     */
+    public static void sort(Comparable[] pq) {
+        int n = pq.length;
+
+        // heapify phase
+        for (int k = n/2; k >= 1; k--)
+            sink(pq, k, n);
+
+        // sortdown phase
+        int k = n;
+        while (k > 1) {
+            exch(pq, 1, k--);
+            sink(pq, 1, k);
+        }
+    }
+
+   /***************************************************************************
+    * Helper functions to restore the heap invariant.
+    ***************************************************************************/
+
+    private static void sink(Comparable[] pq, int k, int n) {
+        while (2*k <= n) {
+            int j = 2*k;
+            if (j < n && less(pq, j, j+1)) j++;
+            if (!less(pq, k, j)) break;
+            exch(pq, k, j);
+            k = j;
+        }
+    }
+
+   /***************************************************************************
+    * Helper functions for comparisons and swaps.
+    * Indices are "off-by-one" to support 1-based indexing.
+    ***************************************************************************/
+    private static boolean less(Comparable[] pq, int i, int j) {
+        return pq[i-1].compareTo(pq[j-1]) < 0;
+    }
+
+    private static void exch(Object[] pq, int i, int j) {
+        Object swap = pq[i-1];
+        pq[i-1] = pq[j-1];
+        pq[j-1] = swap;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; heapsorts them; 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Heap.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/HexDump.java b/src/main/java/edu/princeton/cs/algs4/HexDump.java
new file mode 100644
index 0000000..690b6a6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/HexDump.java
@@ -0,0 +1,104 @@
+/******************************************************************************
+ *  Compilation:  javac HexDump.java
+ *  Execution:    java HexDump < file
+ *  Dependencies: BinaryStdIn.java StdOut.java
+ *  Data file:    https://algs4.cs.princeton.edu/55compression/abra.txt
+ *  
+ *  Reads in a binary file and writes out the bytes in hex, 16 per line.
+ *
+ *  % more abra.txt
+ *  ABRACADABRA!
+ *
+ *  % java HexDump 16 < abra.txt
+ *  41 42 52 41 43 41 44 41 42 52 41 21
+ *  96 bits
+ *
+ *
+ *  Remark
+ *  --------------------------
+ *   - Similar to the Unix utilities od (octal dump) or hexdump (hexadecimal dump).
+ *
+ *  % od -t x1 < abra.txt 
+ *  0000000 41 42 52 41 43 41 44 41 42 52 41 21
+ *  0000014
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code HexDump} class provides a client for displaying the contents
+ *  of a binary file in hexadecimal.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  <p>
+ *  See also {@link BinaryDump} and {@link PictureDump}.
+ *  For more full-featured versions, see the Unix utilities
+ *  {@code od} (octal dump) and {@code hexdump} (hexadecimal dump).
+ *  <p>
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class HexDump {
+
+    // Do not instantiate.
+    private HexDump() { }
+
+    /**
+     * Reads in a sequence of bytes from standard input and writes
+     * them to standard output using hexademical notation, k hex digits
+     * per line, where k is given as a command-line integer (defaults
+     * to 16 if no integer is specified); also writes the number
+     * of bits.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int bytesPerLine = 16;
+        if (args.length == 1) {
+            bytesPerLine = Integer.parseInt(args[0]);
+        }
+
+        int i;
+        for (i = 0; !BinaryStdIn.isEmpty(); i++) {
+            if (bytesPerLine == 0) {
+                BinaryStdIn.readChar();
+                continue;
+            }
+            if (i == 0) StdOut.printf("");
+            else if (i % bytesPerLine == 0) StdOut.printf("\n", i);
+            else StdOut.print(" ");
+            char c = BinaryStdIn.readChar();
+            StdOut.printf("%02x", c & 0xff);
+        }
+        if (bytesPerLine != 0) StdOut.println();
+        StdOut.println((i*8) + " bits");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/HopcroftKarp.java b/src/main/java/edu/princeton/cs/algs4/HopcroftKarp.java
new file mode 100644
index 0000000..0110a21
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/HopcroftKarp.java
@@ -0,0 +1,419 @@
+/******************************************************************************
+ *  Compilation:  javac HopcroftKarp.java
+ *  Execution:    java HopcroftKarp V1 V2 E
+ *  Dependencies: FordFulkerson.java FlowNetwork.java FlowEdge.java
+ *                BipartiteX.java
+ *
+ *  Find a maximum cardinality matching (and minimum cardinality vertex cover)
+ *  in a bipartite graph using Hopcroft-Karp algorithm.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code HopcroftKarp} class represents a data type for computing a
+ *  <em>maximum (cardinality) matching</em> and a
+ *  <em>minimum (cardinality) vertex cover</em> in a bipartite graph.
+ *  A <em>bipartite graph</em> in a graph whose vertices can be partitioned
+ *  into two disjoint sets such that every edge has one endpoint in either set.
+ *  A <em>matching</em> in a graph is a subset of its edges with no common
+ *  vertices. A <em>maximum matching</em> is a matching with the maximum number
+ *  of edges.
+ *  A <em>perfect matching</em> is a matching which matches all vertices in the graph.
+ *  A <em>vertex cover</em> in a graph is a subset of its vertices such that
+ *  every edge is incident to at least one vertex. A <em>minimum vertex cover</em>
+ *  is a vertex cover with the minimum number of vertices.
+ *  By Konig's theorem, in any biparite
+ *  graph, the maximum number of edges in matching equals the minimum number
+ *  of vertices in a vertex cover.
+ *  The maximum matching problem in <em>nonbipartite</em> graphs is
+ *  also important, but all known algorithms for this more general problem
+ *  are substantially more complicated.
+ *  <p>
+ *  This implementation uses the <em>Hopcroft-Karp algorithm</em>.
+ *  The order of growth of the running time in the worst case is
+ *  (<em>E</em> + <em>V</em>) sqrt(<em>V</em>),
+ *  where <em>E</em> is the number of edges and <em>V</em> is the number
+ *  of vertices in the graph. It uses extra space (not including the graph)
+ *  proportional to <em>V</em>.
+ *  <p>
+ *  See also {@link BipartiteMatching}, which solves the problem in
+ *  O(<em>E V</em>) time using the <em>alternating path algorithm</em>
+ *  and <a href = "https://algs4.cs.princeton.edu/65reductions/BipartiteMatchingToMaxflow.java.html">BipartiteMatchingToMaxflow</a>,
+ *  which solves the problem in O(<em>E V</em>) time via a reduction
+ *  to the maxflow problem.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/65reductions">Section 6.5</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class HopcroftKarp {
+    private static final int UNMATCHED = -1;
+
+    private final int V;                 // number of vertices in the graph
+    private BipartiteX bipartition;      // the bipartition
+    private int cardinality;             // cardinality of current matching
+    private int[] mate;                  // mate[v] =  w if v-w is an edge in current matching
+                                         //         = -1 if v is not in current matching
+    private boolean[] inMinVertexCover;  // inMinVertexCover[v] = true iff v is in min vertex cover
+    private boolean[] marked;            // marked[v] = true iff v is reachable via alternating path
+    private int[] distTo;                // distTo[v] = number of edges on shortest path to v
+
+    /**
+     * Determines a maximum matching (and a minimum vertex cover)
+     * in a bipartite graph.
+     *
+     * @param  G the bipartite graph
+     * @throws IllegalArgumentException if {@code G} is not bipartite
+     */
+    public HopcroftKarp(Graph G) {
+        bipartition = new BipartiteX(G);
+        if (!bipartition.isBipartite()) {
+            throw new IllegalArgumentException("graph is not bipartite");
+        }
+
+        // initialize empty matching
+        this.V = G.V();
+        mate = new int[V];
+        for (int v = 0; v < V; v++)
+            mate[v] = UNMATCHED;
+
+        // the call to hasAugmentingPath() provides enough info to reconstruct level graph
+        while (hasAugmentingPath(G)) {
+
+            // to be able to iterate over each adjacency list, keeping track of which
+            // vertex in each adjacency list needs to be explored next
+            Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
+            for (int v = 0; v < G.V(); v++)
+                adj[v] = G.adj(v).iterator();
+
+            // for each unmatched vertex s on one side of bipartition
+            for (int s = 0; s < V; s++) {
+                if (isMatched(s) || !bipartition.color(s)) continue;   // or use distTo[s] == 0
+
+                // find augmenting path from s using nonrecursive DFS
+                Stack<Integer> path = new Stack<Integer>();
+                path.push(s);
+                while (!path.isEmpty()) {
+                    int v = path.peek();
+
+                    // retreat, no more edges in level graph leaving v
+                    if (!adj[v].hasNext())
+                        path.pop();
+
+                    // advance
+                    else {
+                        // process edge v-w only if it is an edge in level graph
+                        int w = adj[v].next();
+                        if (!isLevelGraphEdge(v, w)) continue;
+
+                        // add w to augmenting path
+                        path.push(w);
+
+                        // augmenting path found: update the matching
+                        if (!isMatched(w)) {
+                            // StdOut.println("augmenting path: " + toString(path));
+
+                            while (!path.isEmpty()) {
+                                int x = path.pop();
+                                int y = path.pop();
+                                mate[x] = y;
+                                mate[y] = x;
+                            }
+                            cardinality++;
+                        }
+                    }
+                }
+            }
+        }
+
+        // also find a min vertex cover
+        inMinVertexCover = new boolean[V];
+        for (int v = 0; v < V; v++) {
+            if (bipartition.color(v) && !marked[v]) inMinVertexCover[v] = true;
+            if (!bipartition.color(v) && marked[v]) inMinVertexCover[v] = true;
+        }
+
+        assert certifySolution(G);
+    }
+
+    // string representation of augmenting path (chop off last vertex)
+    private static String toString(Iterable<Integer> path) {
+        StringBuilder sb = new StringBuilder();
+        for (int v : path)
+            sb.append(v + "-");
+        String s = sb.toString();
+        s = s.substring(0, s.lastIndexOf('-'));
+        return s;
+    }
+
+   // is the edge v-w in the level graph?
+    private boolean isLevelGraphEdge(int v, int w) {
+        return (distTo[w] == distTo[v] + 1) && isResidualGraphEdge(v, w);
+    }
+
+   // is the edge v-w a forward edge not in the matching or a reverse edge in the matching?
+    private boolean isResidualGraphEdge(int v, int w) {
+        if ((mate[v] != w) &&  bipartition.color(v)) return true;
+        if ((mate[v] == w) && !bipartition.color(v)) return true;
+        return false;
+    }
+
+    /*
+     * is there an augmenting path?
+     *   - if so, upon termination adj[] contains the level graph;
+     *   - if not, upon termination marked[] specifies those vertices reachable via an alternating
+     *     path from one side of the bipartition
+     *
+     * an alternating path is a path whose edges belong alternately to the matching and not
+     * to the matching
+     *
+     * an augmenting path is an alternating path that starts and ends at unmatched vertices
+     */
+    private boolean hasAugmentingPath(Graph G) {
+
+        // shortest path distances
+        marked = new boolean[V];
+        distTo = new int[V];
+        for (int v = 0; v < V; v++)
+            distTo[v] = Integer.MAX_VALUE;
+
+        // breadth-first search (starting from all unmatched vertices on one side of bipartition)
+        Queue<Integer> queue = new Queue<Integer>();
+        for (int v = 0; v < V; v++) {
+            if (bipartition.color(v) && !isMatched(v)) {
+                queue.enqueue(v);
+                marked[v] = true;
+                distTo[v] = 0;
+            }
+        }
+
+        // run BFS until an augmenting path is found
+        // (and keep going until all vertices at that distance are explored)
+        boolean hasAugmentingPath = false;
+        while (!queue.isEmpty()) {
+            int v = queue.dequeue();
+            for (int w : G.adj(v)) {
+
+                // forward edge not in matching or backwards edge in matching
+                if (isResidualGraphEdge(v, w)) {
+                    if (!marked[w]) {
+                        distTo[w] = distTo[v] + 1;
+                        marked[w] = true;
+                        if (!isMatched(w))
+                            hasAugmentingPath = true;
+
+                        // stop enqueuing vertices once an alternating path has been discovered
+                        // (no vertex on same side will be marked if its shortest path distance longer)
+                        if (!hasAugmentingPath) queue.enqueue(w);
+                    }
+                }
+            }
+        }
+
+        return hasAugmentingPath;
+    }
+
+    /**
+     * Returns the vertex to which the specified vertex is matched in
+     * the maximum matching computed by the algorithm.
+     *
+     * @param  v the vertex
+     * @return the vertex to which vertex {@code v} is matched in the
+     *         maximum matching; {@code -1} if the vertex is not matched
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     *
+     */
+    public int mate(int v) {
+        validate(v);
+        return mate[v];
+    }
+
+    /**
+     * Returns true if the specified vertex is matched in the maximum matching
+     * computed by the algorithm.
+     *
+     * @param  v the vertex
+     * @return {@code true} if vertex {@code v} is matched in maximum matching;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     *
+     */
+    public boolean isMatched(int v) {
+        validate(v);
+        return mate[v] != UNMATCHED;
+    }
+
+    /**
+     * Returns the number of edges in any maximum matching.
+     *
+     * @return the number of edges in any maximum matching
+     */
+    public int size() {
+        return cardinality;
+    }
+
+    /**
+     * Returns true if the graph contains a perfect matching.
+     * That is, the number of edges in a maximum matching is equal to one half
+     * of the number of vertices in the graph (so that every vertex is matched).
+     *
+     * @return {@code true} if the graph contains a perfect matching;
+     *         {@code false} otherwise
+     */
+    public boolean isPerfect() {
+        return cardinality * 2 == V;
+    }
+
+    /**
+     * Returns true if the specified vertex is in the minimum vertex cover
+     * computed by the algorithm.
+     *
+     * @param  v the vertex
+     * @return {@code true} if vertex {@code v} is in the minimum vertex cover;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean inMinVertexCover(int v) {
+        validate(v);
+        return inMinVertexCover[v];
+    }
+
+    // throw an exception if vertex is invalid
+    private void validate(int v) {
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**************************************************************************
+     *   
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // check that mate[] and inVertexCover[] define a max matching and min vertex cover, respectively
+    private boolean certifySolution(Graph G) {
+
+        // check that mate(v) = w iff mate(w) = v
+        for (int v = 0; v < V; v++) {
+            if (mate(v) == -1) continue;
+            if (mate(mate(v)) != v) return false;
+        }
+
+        // check that size() is consistent with mate()
+        int matchedVertices = 0;
+        for (int v = 0; v < V; v++) {
+            if (mate(v) != -1) matchedVertices++;
+        }
+        if (2*size() != matchedVertices) return false;
+
+        // check that size() is consistent with minVertexCover()
+        int sizeOfMinVertexCover = 0;
+        for (int v = 0; v < V; v++)
+            if (inMinVertexCover(v)) sizeOfMinVertexCover++;
+        if (size() != sizeOfMinVertexCover) return false;
+
+        // check that mate() uses each vertex at most once
+        boolean[] isMatched = new boolean[V];
+        for (int v = 0; v < V; v++) {
+            int w = mate[v];
+            if (w == -1) continue;
+            if (v == w) return false;
+            if (v >= w) continue;
+            if (isMatched[v] || isMatched[w]) return false;
+            isMatched[v] = true;
+            isMatched[w] = true;
+        }
+
+        // check that mate() uses only edges that appear in the graph
+        for (int v = 0; v < V; v++) {
+            if (mate(v) == -1) continue;
+            boolean isEdge = false;
+            for (int w : G.adj(v)) {
+                if (mate(v) == w) isEdge = true;
+            }
+            if (!isEdge) return false;
+        }
+
+        // check that inMinVertexCover() is a vertex cover
+        for (int v = 0; v < V; v++)
+            for (int w : G.adj(v))
+                if (!inMinVertexCover(v) && !inMinVertexCover(w)) return false;
+
+        return true;
+    }
+
+    /** 
+     * Unit tests the {@code HopcroftKarp} data type.   
+     * Takes three command-line arguments {@code V1}, {@code V2}, and {@code E};
+     * creates a random bipartite graph with {@code V1} + {@code V2} vertices
+     * and {@code E} edges; computes a maximum matching and minimum vertex cover;
+     * and prints the results.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        int V1 = Integer.parseInt(args[0]);
+        int V2 = Integer.parseInt(args[1]);
+        int E  = Integer.parseInt(args[2]);
+        Graph G = GraphGenerator.bipartite(V1, V2, E);
+        if (G.V() < 1000) StdOut.println(G);
+
+        HopcroftKarp matching = new HopcroftKarp(G);
+
+        // print maximum matching
+        StdOut.printf("Number of edges in max matching        = %d\n", matching.size());
+        StdOut.printf("Number of vertices in min vertex cover = %d\n", matching.size());
+        StdOut.printf("Graph has a perfect matching           = %b\n", matching.isPerfect());
+        StdOut.println();
+
+        if (G.V() >= 1000) return;
+
+        StdOut.print("Max matching: ");
+        for (int v = 0; v < G.V(); v++) {
+            int w = matching.mate(v);
+            if (matching.isMatched(v) && v < w)  // print each edge only once
+                StdOut.print(v + "-" + w + " ");
+        }
+        StdOut.println();
+
+        // print minimum vertex cover
+        StdOut.print("Min vertex cover: ");
+        for (int v = 0; v < G.V(); v++)
+            if (matching.inMinVertexCover(v))
+                StdOut.print(v + " ");
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Huffman.java b/src/main/java/edu/princeton/cs/algs4/Huffman.java
new file mode 100644
index 0000000..796eb27
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Huffman.java
@@ -0,0 +1,231 @@
+/******************************************************************************
+ *  Compilation:  javac Huffman.java
+ *  Execution:    java Huffman - < input.txt   (compress)
+ *  Execution:    java Huffman + < input.txt   (expand)
+ *  Dependencies: BinaryIn.java BinaryOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/55compression/abra.txt
+ *                https://algs4.cs.princeton.edu/55compression/tinytinyTale.txt
+ *                https://algs4.cs.princeton.edu/55compression/medTale.txt
+ *                https://algs4.cs.princeton.edu/55compression/tale.txt
+ *
+ *  Compress or expand a binary input stream using the Huffman algorithm.
+ *
+ *  % java Huffman - < abra.txt | java BinaryDump 60
+ *  010100000100101000100010010000110100001101010100101010000100
+ *  000000000000000000000000000110001111100101101000111110010100
+ *  120 bits
+ *
+ *  % java Huffman - < abra.txt | java Huffman +
+ *  ABRACADABRA!
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Huffman} class provides static methods for compressing
+ *  and expanding a binary input using Huffman codes over the 8-bit extended
+ *  ASCII alphabet.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Huffman {
+
+    // alphabet size of extended ASCII
+    private static final int R = 256;
+
+    // Do not instantiate.
+    private Huffman() { }
+
+    // Huffman trie node
+    private static class Node implements Comparable<Node> {
+        private final char ch;
+        private final int freq;
+        private final Node left, right;
+
+        Node(char ch, int freq, Node left, Node right) {
+            this.ch    = ch;
+            this.freq  = freq;
+            this.left  = left;
+            this.right = right;
+        }
+
+        // is the node a leaf node?
+        private boolean isLeaf() {
+            assert ((left == null) && (right == null)) || ((left != null) && (right != null));
+            return (left == null) && (right == null);
+        }
+
+        // compare, based on frequency
+        public int compareTo(Node that) {
+            return this.freq - that.freq;
+        }
+    }
+
+    /**
+     * Reads a sequence of 8-bit bytes from standard input; compresses them
+     * using Huffman codes with an 8-bit alphabet; and writes the results
+     * to standard output.
+     */
+    public static void compress() {
+        // read the input
+        String s = BinaryStdIn.readString();
+        char[] input = s.toCharArray();
+
+        // tabulate frequency counts
+        int[] freq = new int[R];
+        for (int i = 0; i < input.length; i++)
+            freq[input[i]]++;
+
+        // build Huffman trie
+        Node root = buildTrie(freq);
+
+        // build code table
+        String[] st = new String[R];
+        buildCode(st, root, "");
+
+        // print trie for decoder
+        writeTrie(root);
+
+        // print number of bytes in original uncompressed message
+        BinaryStdOut.write(input.length);
+
+        // use Huffman code to encode input
+        for (int i = 0; i < input.length; i++) {
+            String code = st[input[i]];
+            for (int j = 0; j < code.length(); j++) {
+                if (code.charAt(j) == '0') {
+                    BinaryStdOut.write(false);
+                }
+                else if (code.charAt(j) == '1') {
+                    BinaryStdOut.write(true);
+                }
+                else throw new IllegalStateException("Illegal state");
+            }
+        }
+
+        // close output stream
+        BinaryStdOut.close();
+    }
+
+    // build the Huffman trie given frequencies
+    private static Node buildTrie(int[] freq) {
+
+        // initialze priority queue with singleton trees
+        MinPQ<Node> pq = new MinPQ<Node>();
+        for (char c = 0; c < R; c++)
+            if (freq[c] > 0)
+                pq.insert(new Node(c, freq[c], null, null));
+
+        // merge two smallest trees
+        while (pq.size() > 1) {
+            Node left  = pq.delMin();
+            Node right = pq.delMin();
+            Node parent = new Node('\0', left.freq + right.freq, left, right);
+            pq.insert(parent);
+        }
+        return pq.delMin();
+    }
+
+
+    // write bitstring-encoded trie to standard output
+    private static void writeTrie(Node x) {
+        if (x.isLeaf()) {
+            BinaryStdOut.write(true);
+            BinaryStdOut.write(x.ch, 8);
+            return;
+        }
+        BinaryStdOut.write(false);
+        writeTrie(x.left);
+        writeTrie(x.right);
+    }
+
+    // make a lookup table from symbols and their encodings
+    private static void buildCode(String[] st, Node x, String s) {
+        if (!x.isLeaf()) {
+            buildCode(st, x.left,  s + '0');
+            buildCode(st, x.right, s + '1');
+        }
+        else {
+            st[x.ch] = s;
+        }
+    }
+
+    /**
+     * Reads a sequence of bits that represents a Huffman-compressed message from
+     * standard input; expands them; and writes the results to standard output.
+     */
+    public static void expand() {
+
+        // read in Huffman trie from input stream
+        Node root = readTrie(); 
+
+        // number of bytes to write
+        int length = BinaryStdIn.readInt();
+
+        // decode using the Huffman trie
+        for (int i = 0; i < length; i++) {
+            Node x = root;
+            while (!x.isLeaf()) {
+                boolean bit = BinaryStdIn.readBoolean();
+                if (bit) x = x.right;
+                else     x = x.left;
+            }
+            BinaryStdOut.write(x.ch, 8);
+        }
+        BinaryStdOut.close();
+    }
+
+
+    private static Node readTrie() {
+        boolean isLeaf = BinaryStdIn.readBoolean();
+        if (isLeaf) {
+            return new Node(BinaryStdIn.readChar(), -1, null, null);
+        }
+        else {
+            return new Node('\0', -1, readTrie(), readTrie());
+        }
+    }
+
+    /**
+     * Sample client that calls {@code compress()} if the command-line
+     * argument is "-" an {@code expand()} if it is "+".
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        if      (args[0].equals("-")) compress();
+        else if (args[0].equals("+")) expand();
+        else throw new IllegalArgumentException("Illegal command line argument");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/In.java b/src/main/java/edu/princeton/cs/algs4/In.java
new file mode 100644
index 0000000..c7ff75c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/In.java
@@ -0,0 +1,820 @@
+/******************************************************************************
+ *  Compilation:  javac In.java
+ *  Execution:    java In   (basic test --- see source for required files)
+ *  Dependencies: none
+ *
+ *  Reads in data of various types from standard input, files, and URLs.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.Socket;
+// import java.net.HttpURLConnection;
+import java.net.URLConnection;
+import java.util.ArrayList;
+import java.util.InputMismatchException;
+import java.util.Locale;
+import java.util.NoSuchElementException;
+import java.util.Scanner;
+import java.util.regex.Pattern;
+
+/**
+ *  <i>Input</i>. This class provides methods for reading strings
+ *  and numbers from standard input, file input, URLs, and sockets. 
+ *  <p>
+ *  The Locale used is: language = English, country = US. This is consistent
+ *  with the formatting conventions with Java floating-point literals,
+ *  command-line arguments (via {@link Double#parseDouble(String)})
+ *  and standard output. 
+ *  <p>
+ *  For additional documentation, see 
+ *  <a href="https://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i> 
+ *  by Robert Sedgewick and Kevin Wayne.
+ *  <p>
+ *  Like {@link Scanner}, reading a token also consumes preceding Java
+ *  whitespace, reading a full line consumes
+ *  the following end-of-line delimeter, while reading a character consumes
+ *  nothing extra. 
+ *  <p>
+ *  Whitespace is defined in {@link Character#isWhitespace(char)}. Newlines
+ *  consist of \n, \r, \r\n, and Unicode hex code points 0x2028, 0x2029, 0x0085;
+ *  see <a href="http://www.docjar.com/html/api/java/util/Scanner.java.html">
+ *  Scanner.java</a> (NB: Java 6u23 and earlier uses only \r, \r, \r\n).
+ *
+ *  @author David Pritchard
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class In {
+    
+    ///// begin: section (1 of 2) of code duplicated from In to StdIn.
+    
+    // assume Unicode UTF-8 encoding
+    private static final String CHARSET_NAME = "UTF-8";
+
+    // assume language = English, country = US for consistency with System.out.
+    private static final Locale LOCALE = Locale.US;
+
+    // the default token separator; we maintain the invariant that this value 
+    // is held by the scanner's delimiter between calls
+    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");
+
+    // makes whitespace characters significant 
+    private static final Pattern EMPTY_PATTERN = Pattern.compile("");
+
+    // used to read the entire input. source:
+    // http://weblogs.java.net/blog/pat/archive/2004/10/stupid_scanner_1.html
+    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");
+
+    //// end: section (1 of 2) of code duplicated from In to StdIn.
+
+    private Scanner scanner;
+
+   /**
+     * Initializes an input stream from standard input.
+     */
+    public In() {
+        scanner = new Scanner(new BufferedInputStream(System.in), CHARSET_NAME);
+        scanner.useLocale(LOCALE);
+    }
+
+   /**
+     * Initializes an input stream from a socket.
+     *
+     * @param  socket the socket
+     * @throws IllegalArgumentException if cannot open {@code socket}
+     * @throws IllegalArgumentException if {@code socket} is {@code null}
+     */
+    public In(Socket socket) {
+        if (socket == null) throw new IllegalArgumentException("socket argument is null");
+        try {
+            InputStream is = socket.getInputStream();
+            scanner = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
+            scanner.useLocale(LOCALE);
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("Could not open " + socket, ioe);
+        }
+    }
+
+   /**
+     * Initializes an input stream from a URL.
+     *
+     * @param  url the URL
+     * @throws IllegalArgumentException if cannot open {@code url}
+     * @throws IllegalArgumentException if {@code url} is {@code null}
+     */
+    public In(URL url) {
+        if (url == null) throw new IllegalArgumentException("url argument is null");
+        try {
+            URLConnection site = url.openConnection();
+            InputStream is     = site.getInputStream();
+            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
+            scanner.useLocale(LOCALE);
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("Could not open " + url, ioe);
+        }
+    }
+
+   /**
+     * Initializes an input stream from a file.
+     *
+     * @param  file the file
+     * @throws IllegalArgumentException if cannot open {@code file}
+     * @throws IllegalArgumentException if {@code file} is {@code null}
+     */
+    public In(File file) {
+        if (file == null) throw new IllegalArgumentException("file argument is null");
+        try {
+            // for consistency with StdIn, wrap with BufferedInputStream instead of use
+            // file as argument to Scanner
+            FileInputStream fis = new FileInputStream(file);
+            scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
+            scanner.useLocale(LOCALE);
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("Could not open " + file, ioe);
+        }
+    }
+
+
+   /**
+     * Initializes an input stream from a filename or web page name.
+     *
+     * @param  name the filename or web page name
+     * @throws IllegalArgumentException if cannot open {@code name} as
+     *         a file or URL
+     * @throws IllegalArgumentException if {@code name} is {@code null}
+     */
+    public In(String name) {
+        if (name == null) throw new IllegalArgumentException("argument is null");
+        if (name.length() == 0) throw new IllegalArgumentException("argument is the empty string");
+        try {
+            // first try to read file from local file system
+            File file = new File(name);
+            if (file.exists()) {
+                // for consistency with StdIn, wrap with BufferedInputStream instead of use
+                // file as argument to Scanner
+                FileInputStream fis = new FileInputStream(file);
+                scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
+                scanner.useLocale(LOCALE);
+                return;
+            }
+
+            // resource relative to .class file
+            URL url = getClass().getResource(name);
+
+            // resource relative to classloader root
+            if (url == null) {
+                url = getClass().getClassLoader().getResource(name);
+            }
+
+            // or URL from web
+            if (url == null) {
+                url = new URL(name);
+            }
+
+            URLConnection site = url.openConnection();
+
+            // in order to set User-Agent, replace above line with these two
+            // HttpURLConnection site = (HttpURLConnection) url.openConnection();
+            // site.addRequestProperty("User-Agent", "Mozilla/4.76");
+
+            InputStream is     = site.getInputStream();
+            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
+            scanner.useLocale(LOCALE);
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("Could not open " + name, ioe);
+        }
+    }
+
+    /**
+     * Initializes an input stream from a given {@link Scanner} source; use with 
+     * {@code new Scanner(String)} to read from a string.
+     * <p>
+     * Note that this does not create a defensive copy, so the
+     * scanner will be mutated as you read on. 
+     *
+     * @param  scanner the scanner
+     * @throws IllegalArgumentException if {@code scanner} is {@code null}
+     */
+    public In(Scanner scanner) {
+        if (scanner == null) throw new IllegalArgumentException("scanner argument is null");
+        this.scanner = scanner;
+    }
+
+    /**
+     * Returns true if this input stream exists.
+     *
+     * @return {@code true} if this input stream exists; {@code false} otherwise
+     */
+    public boolean exists()  {
+        return scanner != null;
+    }
+    
+    ////  begin: section (2 of 2) of code duplicated from In to StdIn,
+    ////  with all methods changed from "public" to "public static".
+
+   /**
+     * Returns true if input stream is empty (except possibly whitespace).
+     * Use this to know whether the next call to {@link #readString()}, 
+     * {@link #readDouble()}, etc will succeed.
+     *
+     * @return {@code true} if this input stream is empty (except possibly whitespace);
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return !scanner.hasNext();
+    }
+
+   /** 
+     * Returns true if this input stream has a next line.
+     * Use this method to know whether the
+     * next call to {@link #readLine()} will succeed.
+     * This method is functionally equivalent to {@link #hasNextChar()}.
+     *
+     * @return {@code true} if this input stream has more input (including whitespace);
+     *         {@code false} otherwise
+     */
+    public boolean hasNextLine() {
+        return scanner.hasNextLine();
+    }
+
+    /**
+     * Returns true if this input stream has more input (including whitespace).
+     * Use this method to know whether the next call to {@link #readChar()} will succeed.
+     * This method is functionally equivalent to {@link #hasNextLine()}.
+     * 
+     * @return {@code true} if this input stream has more input (including whitespace);
+     *         {@code false} otherwise   
+     */
+    public boolean hasNextChar() {
+        scanner.useDelimiter(EMPTY_PATTERN);
+        boolean result = scanner.hasNext();
+        scanner.useDelimiter(WHITESPACE_PATTERN);
+        return result;
+    }
+
+
+   /**
+     * Reads and returns the next line in this input stream.
+     *
+     * @return the next line in this input stream; {@code null} if no such line
+     */
+    public String readLine() {
+        String line;
+        try {
+            line = scanner.nextLine();
+        }
+        catch (NoSuchElementException e) {
+            line = null;
+        }
+        return line;
+    }
+
+    /**
+     * Reads and returns the next character in this input stream.
+     *
+     * @return the next {@code char} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     */
+    public char readChar() {
+        scanner.useDelimiter(EMPTY_PATTERN);
+        try {
+            String ch = scanner.next();
+            assert ch.length() == 1 : "Internal (Std)In.readChar() error!"
+                + " Please contact the authors.";
+            scanner.useDelimiter(WHITESPACE_PATTERN);
+            return ch.charAt(0);
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'char' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }  
+
+
+   /**
+     * Reads and returns the remainder of this input stream, as a string.
+     *
+     * @return the remainder of this input stream, as a string
+     */
+    public String readAll() {
+        if (!scanner.hasNextLine())
+            return "";
+
+        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
+        // not that important to reset delimeter, since now scanner is empty
+        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
+        return result;
+    }
+
+
+   /**
+     * Reads the next token from this input stream and returns it as a {@code String}.
+     *
+     * @return the next {@code String} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     */
+    public String readString() {
+        try {
+            return scanner.next();
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'String' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from this input stream, parses it as a {@code int},
+     * and returns the {@code int}.
+     *
+     * @return the next {@code int} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
+     */
+    public int readInt() {
+        try {
+            return scanner.nextInt();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read an 'int' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read an 'int' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from this input stream, parses it as a {@code double},
+     * and returns the {@code double}.
+     *
+     * @return the next {@code double} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
+     */
+    public double readDouble() {
+        try {
+            return scanner.nextDouble();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'double' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read a 'double' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from this input stream, parses it as a {@code float},
+     * and returns the {@code float}.
+     *
+     * @return the next {@code float} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
+     */
+    public float readFloat() {
+        try {
+            return scanner.nextFloat();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'float' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read a 'float' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from this input stream, parses it as a {@code long},
+     * and returns the {@code long}.
+     *
+     * @return the next {@code long} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
+     */
+    public long readLong() {
+        try {
+            return scanner.nextLong();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'long' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read a 'long' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from this input stream, parses it as a {@code short},
+     * and returns the {@code short}.
+     *
+     * @return the next {@code short} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
+     */
+    public short readShort() {
+        try {
+            return scanner.nextShort();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'short' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read a 'short' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from this input stream, parses it as a {@code byte},
+     * and returns the {@code byte}.
+     * <p>
+     * To read binary data, use {@link BinaryIn}.
+     *
+     * @return the next {@code byte} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
+     */
+    public byte readByte() {
+        try {
+            return scanner.nextByte();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'byte' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read a 'byte' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+    /**
+     * Reads the next token from this input stream, parses it as a {@code boolean}
+     * (interpreting either {@code "true"} or {@code "1"} as {@code true},
+     * and either {@code "false"} or {@code "0"} as {@code false}).
+     *
+     * @return the next {@code boolean} in this input stream
+     * @throws NoSuchElementException if the input stream is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}
+     */
+    public boolean readBoolean() {
+        try {
+            String token = readString();
+            if ("true".equalsIgnoreCase(token))  return true;
+            if ("false".equalsIgnoreCase(token)) return false;
+            if ("1".equals(token))               return true;
+            if ("0".equals(token))               return false;
+            throw new InputMismatchException("attempts to read a 'boolean' value from the input stream, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'boolean' value from the input stream, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+    /**
+     * Reads all remaining tokens from this input stream and returns them as
+     * an array of strings.
+     *
+     * @return all remaining tokens in this input stream, as an array of strings
+     */
+    public String[] readAllStrings() {
+        // we could use readAll.trim().split(), but that's not consistent
+        // since trim() uses characters 0x00..0x20 as whitespace
+        String[] tokens = WHITESPACE_PATTERN.split(readAll());
+        if (tokens.length == 0 || tokens[0].length() > 0)
+            return tokens;
+        String[] decapitokens = new String[tokens.length-1];
+        for (int i = 0; i < tokens.length-1; i++)
+            decapitokens[i] = tokens[i+1];
+        return decapitokens;
+    }
+
+    /**
+     * Reads all remaining lines from this input stream and returns them as
+     * an array of strings.
+     *
+     * @return all remaining lines in this input stream, as an array of strings
+     */
+    public String[] readAllLines() {
+        ArrayList<String> lines = new ArrayList<String>();
+        while (hasNextLine()) {
+            lines.add(readLine());
+        }
+        return lines.toArray(new String[lines.size()]);
+    }
+
+
+    /**
+     * Reads all remaining tokens from this input stream, parses them as integers,
+     * and returns them as an array of integers.
+     *
+     * @return all remaining lines in this input stream, as an array of integers
+     */
+    public int[] readAllInts() {
+        String[] fields = readAllStrings();
+        int[] vals = new int[fields.length];
+        for (int i = 0; i < fields.length; i++)
+            vals[i] = Integer.parseInt(fields[i]);
+        return vals;
+    }
+
+    /**
+     * Reads all remaining tokens from this input stream, parses them as longs,
+     * and returns them as an array of longs.
+     *
+     * @return all remaining lines in this input stream, as an array of longs
+     */
+    public long[] readAllLongs() {
+        String[] fields = readAllStrings();
+        long[] vals = new long[fields.length];
+        for (int i = 0; i < fields.length; i++)
+            vals[i] = Long.parseLong(fields[i]);
+        return vals;
+    }
+
+    /**
+     * Reads all remaining tokens from this input stream, parses them as doubles,
+     * and returns them as an array of doubles.
+     *
+     * @return all remaining lines in this input stream, as an array of doubles
+     */
+    public double[] readAllDoubles() {
+        String[] fields = readAllStrings();
+        double[] vals = new double[fields.length];
+        for (int i = 0; i < fields.length; i++)
+            vals[i] = Double.parseDouble(fields[i]);
+        return vals;
+    }
+    
+    ///// end: section (2 of 2) of code duplicated from In to StdIn */
+
+   /**
+     * Closes this input stream.
+     */
+    public void close() {
+        scanner.close();  
+    }
+
+    /**
+     * Reads all integers from a file and returns them as
+     * an array of integers.
+     *
+     * @param      filename the name of the file
+     * @return     the integers in the file
+     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllInts()}.
+     */
+    @Deprecated
+    public static int[] readInts(String filename) {
+        return new In(filename).readAllInts();
+    }
+
+   /**
+     * Reads all doubles from a file and returns them as
+     * an array of doubles.
+     *
+     * @param      filename the name of the file
+     * @return     the doubles in the file
+     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllDoubles()}.
+     */
+    @Deprecated
+    public static double[] readDoubles(String filename) {
+        return new In(filename).readAllDoubles();
+    }
+
+   /**
+     * Reads all strings from a file and returns them as
+     * an array of strings.
+     *
+     * @param      filename the name of the file
+     * @return     the strings in the file
+     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllStrings()}.
+     */
+    @Deprecated
+    public static String[] readStrings(String filename) {
+        return new In(filename).readAllStrings();
+    }
+
+    /**
+     * Reads all integers from standard input and returns them
+     * an array of integers.
+     *
+     * @return     the integers on standard input
+     * @deprecated Replaced by {@link StdIn#readAllInts()}.
+     */
+    @Deprecated
+    public static int[] readInts() {
+        return new In().readAllInts();
+    }
+
+   /**
+     * Reads all doubles from standard input and returns them as
+     * an array of doubles.
+     *
+     * @return     the doubles on standard input
+     * @deprecated Replaced by {@link StdIn#readAllDoubles()}.
+     */
+    @Deprecated
+    public static double[] readDoubles() {
+        return new In().readAllDoubles();
+    }
+
+   /**
+     * Reads all strings from standard input and returns them as
+     *  an array of strings.
+     *
+     * @return     the strings on standard input
+     * @deprecated Replaced by {@link StdIn#readAllStrings()}.
+     */
+    @Deprecated
+    public static String[] readStrings() {
+        return new In().readAllStrings();
+    }
+    
+   /**
+     * Unit tests the {@code In} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in;
+        String urlName = "https://introcs.cs.princeton.edu/java/stdlib/InTest.txt";
+
+        // read from a URL
+        System.out.println("readAll() from URL " + urlName);
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In(urlName);
+            System.out.println(in.readAll());
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+        // read one line at a time from URL
+        System.out.println("readLine() from URL " + urlName);
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In(urlName);
+            while (!in.isEmpty()) {
+                String s = in.readLine();
+                System.out.println(s);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+        // read one string at a time from URL
+        System.out.println("readString() from URL " + urlName);
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In(urlName);
+            while (!in.isEmpty()) {
+                String s = in.readString();
+                System.out.println(s);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+
+        // read one line at a time from file in current directory
+        System.out.println("readLine() from current directory");
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In("./InTest.txt");
+            while (!in.isEmpty()) {
+                String s = in.readLine();
+                System.out.println(s);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+
+        // read one line at a time from file using relative path
+        System.out.println("readLine() from relative path");
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In("../stdlib/InTest.txt");
+            while (!in.isEmpty()) {
+                String s = in.readLine();
+                System.out.println(s);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+        // read one char at a time
+        System.out.println("readChar() from file");
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In("InTest.txt");
+            while (!in.isEmpty()) {
+                char c = in.readChar();
+                System.out.print(c);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+        System.out.println();
+
+        // read one line at a time from absolute OS X / Linux path
+        System.out.println("readLine() from absolute OS X / Linux path");
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In("/n/fs/introcs/www/java/stdlib/InTest.txt");
+            while (!in.isEmpty()) {
+                String s = in.readLine();
+                System.out.println(s);
+            }
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+
+        // read one line at a time from absolute Windows path
+        System.out.println("readLine() from absolute Windows path");
+        System.out.println("---------------------------------------------------------------------------");
+        try {
+            in = new In("G:\\www\\introcs\\stdlib\\InTest.txt");
+            while (!in.isEmpty()) {
+                String s = in.readLine();
+                System.out.println(s);
+            }
+            System.out.println();
+        }
+        catch (IllegalArgumentException e) {
+            System.out.println(e);
+        }
+        System.out.println();
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/InTest.txt b/src/main/java/edu/princeton/cs/algs4/InTest.txt
new file mode 100644
index 0000000..753b42d
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/InTest.txt
@@ -0,0 +1,2 @@
+This is a test file.
+Here    is line 2.
diff --git a/src/main/java/edu/princeton/cs/algs4/IndexBinomialMinPQ.java b/src/main/java/edu/princeton/cs/algs4/IndexBinomialMinPQ.java
new file mode 100644
index 0000000..03edae8
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/IndexBinomialMinPQ.java
@@ -0,0 +1,526 @@
+/******************************************************************************
+ *  Compilation: javac IndexBinomialMinPQ.java
+ *  Execution:
+ *  
+ *  An index binomial heap.
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The IndexBinomialMinPQ class represents an indexed priority queue of generic keys.
+ *  It supports the usual insert and delete-the-minimum operations,
+ *  along with delete and change-the-key methods. 
+ *  In order to let the client refer to keys on the priority queue,
+ *  an integer between 0 and N-1 is associated with each key ; the client
+ *  uses this integer to specify which key to delete or change.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  
+ *  This implementation uses a binomial heap along with an array to associate
+ *  keys with integers in the given range.
+ *  The insert, delete-the-minimum, delete, change-key, decrease-key,
+ *  increase-key and size operations take logarithmic time.
+ *  The is-empty, min-index, min-key, and key-of operations take constant time.
+ *  Construction takes time proportional to the specified capacity.
+ *
+ *  @author Tristan Claverie
+ */
+public class IndexBinomialMinPQ<Key> implements Iterable<Integer> {
+	private Node<Key> head;    			//Head of the list of roots
+	private Node<Key>[] nodes; 			//Array of indexed Nodes of the heap
+	private int n;			   		//Maximum size of the tree
+	private final Comparator<Key> comparator;	//Comparator over the keys
+	
+	//Represents a node of a Binomial Tree
+	private class Node<Key> {
+		Key key;				//Key contained by the Node
+		int order;				//The order of the Binomial Tree rooted by this Node
+		int index;				//Index associated with the Key
+		Node<Key> parent;			//parent of this Node
+		Node<Key> child, sibling;		//child and sibling of this Node
+	}
+	
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0} to {@code N-1}
+     * Worst case is O(n)
+     * @param N number of keys in the priority queue, index from {@code 0} to {@code N-1}
+     * @throws java.lang.IllegalArgumentException if {@code N < 0}
+     */
+	public IndexBinomialMinPQ(int N) {
+		if (N < 0) throw new IllegalArgumentException("Cannot create a priority queue of negative size");
+		comparator = new MyComparator();
+		nodes = (Node<Key>[]) new Node[N];
+		this.n = N;
+	}
+	
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0} to {@code N-1}
+     * Worst case is O(n)
+     * @param N number of keys in the priority queue, index from {@code 0} to {@code N-1}
+     * @param comparator a Comparator over the keys
+     * @throws java.lang.IllegalArgumentException if {@code N < 0}
+     */
+	public IndexBinomialMinPQ(int N, Comparator<Key> comparator) {
+		if (N < 0) throw new IllegalArgumentException("Cannot create a priority queue of negative size");
+		this.comparator = comparator;
+		nodes = (Node<Key>[]) new Node[N];
+		this.n = N;
+	}
+
+	/**
+	 * Whether the priority queue is empty
+	 * Worst case is O(1)
+	 * @return true if the priority queue is empty, false if not
+	 */
+	public boolean isEmpty() {
+		return head == null;
+	}
+
+	/**
+	 * Does the priority queue contains the index i ?
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @return true if i is on the priority queue, false if not
+	 */
+	public boolean contains(int i) {
+		if (i < 0 || i >= n) throw new IllegalArgumentException();
+		else return nodes[i] != null;
+	}
+
+	/**
+	 * Number of elements currently on the priority queue
+	 * Worst case is O(log(n))
+	 * @return the number of elements on the priority queue
+	 */
+	public int size() {
+		int result = 0, tmp;
+		for (Node<Key> node = head; node != null; node = node.sibling) {
+			if (node.order > 30) { throw new ArithmeticException("The number of elements cannot be evaluated, but the priority queue is still valid."); }
+			tmp =  1 << node.order;
+			result |= tmp;
+		}
+		return result;
+	}
+
+	/**
+	 * Associates a key with an index
+	 * Worst case is O(log(n))
+	 * @param i an index
+	 * @param key a Key associated with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index is already in the queue
+	 */
+	public void insert(int i, Key key) {
+		if (i < 0 || i >= n) throw new IllegalArgumentException();
+		if (contains(i)) throw new IllegalArgumentException("Specified index is already in the queue");
+		Node<Key> x = new Node<Key>();
+		x.key = key;
+		x.index = i;
+		x.order = 0;
+		nodes[i] = x;
+		IndexBinomialMinPQ<Key> H = new IndexBinomialMinPQ<Key>();
+		H.head = x;
+		head = union(H).head;
+	}
+
+	/**
+	 * Gets the index associated with the minimum key
+	 * Worst case is O(log(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the index associated with the minimum key
+	 */
+	
+	public int minIndex() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		Node<Key> min = head;
+		Node<Key> current = head;
+		while (current.sibling != null) {
+			min = (greater(min.key, current.sibling.key)) ? current.sibling : min;
+			current = current.sibling;
+		}
+		return min.index;
+	}
+
+	/**
+	 * Gets the minimum key currently in the queue
+	 * Worst case is O(log(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key currently in the priority queue
+	 */
+	
+	public Key minKey() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		Node<Key> min = head;
+		Node<Key> current = head;
+		while (current.sibling != null) {
+			min = (greater(min.key, current.sibling.key)) ? current.sibling : min;
+			current = current.sibling;
+		}
+		return min.key;
+	}
+
+	/**
+	 * Deletes the minimum key
+	 * Worst case is O(log(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the index associated with the minimum key
+	 */
+	
+	public int delMin() {
+		if(isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		Node<Key> min = eraseMin();
+		Node<Key> x = (min.child == null) ? min : min.child;
+		if (min.child != null) {
+			min.child = null;
+			Node<Key> prevx = null, nextx = x.sibling;
+			while (nextx != null) {
+				x.parent = null; // for garbage collection
+				x.sibling = prevx;
+				prevx = x;
+				x = nextx;nextx = nextx.sibling;
+			}
+			x.parent = null;
+			x.sibling = prevx;
+			IndexBinomialMinPQ<Key> H = new IndexBinomialMinPQ<Key>();
+			H.head = x;
+			head = union(H).head;
+		}
+		return min.index;
+	}
+
+	/**
+	 * Gets the key associated with index i
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index is not in the queue
+	 * @return the key associated with index i
+	 */
+	
+	public Key keyOf(int i) {
+		if (i < 0 || i >= n) throw new IllegalArgumentException();
+		if (!contains(i)) throw new IllegalArgumentException("Specified index is not in the queue");
+		return nodes[i].key;
+	}
+
+	/**
+	 * Changes the key associated with index i to the given key
+	 * Worst case is O(log(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index has no key associated with
+	 */
+	
+	public void changeKey(int i, Key key) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new IllegalArgumentException("Specified index is not in the queue");
+		if (greater(nodes[i].key, key))  decreaseKey(i, key);
+		else 							 increaseKey(i, key);
+	}
+
+	/**
+	 * Decreases the key associated with index i to the given key
+	 * Worst case is O(log(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 * @throws java.lang.IllegalArgumentException if the given key is greater than the current key
+	 */
+	
+	public void decreaseKey(int i, Key key) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		if (greater(key, nodes[i].key))  throw new IllegalArgumentException("Calling with this argument would not decrease the key");
+		Node<Key> x = nodes[i];
+		x.key = key;
+		swim(i);
+	}
+
+	/**
+	 * Increases the key associated with index i to the given key
+	 * Worst case is O(log(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 * @throws java.lang.IllegalArgumentException if the given key is lower than the current key
+	 */
+	
+	public void increaseKey(int i, Key key) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		if (greater(nodes[i].key, key))  throw new IllegalArgumentException("Calling with this argument would not increase the key");
+		delete(i);
+		insert(i, key);
+	}
+
+	/**
+	 * Deletes the key associated the given index
+	 * Worst case is O(log(n))
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the given index has no key associated with
+	 */
+	
+	public void delete(int i) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		toTheRoot(i);
+		Node<Key> x = erase(i);
+		if (x.child != null) {
+			Node<Key> y = x;
+			x = x.child;
+			y.child = null;
+			Node<Key> prevx = null, nextx = x.sibling;
+			while (nextx != null) {
+				x.parent = null;
+				x.sibling = prevx;
+				prevx = x;
+				x = nextx; nextx = nextx.sibling;
+			}
+			x.parent = null;
+			x.sibling = prevx;
+			IndexBinomialMinPQ<Key> H = new IndexBinomialMinPQ<Key>();
+			H.head = x;
+			head = union(H).head;
+		}
+	}
+	
+	/*************************************************
+	 * General helper functions
+	 ************************************************/
+	
+	//Compares two keys
+	private boolean greater(Key n, Key m) {
+		if (n == null) return false;
+		if (m == null) return true;
+		return comparator.compare(n, m) > 0;
+	}
+	
+	//Exchanges the positions of two nodes
+	private void exchange(Node<Key> x, Node<Key> y) {
+		Key tempKey = x.key; x.key = y.key; y.key = tempKey;
+		int tempInt = x.index; x.index = y.index; y.index = tempInt;
+		nodes[x.index] = x;
+		nodes[y.index] = y;
+	}
+	
+	//Assuming root1 holds a greater key than root2, root2 becomes the new root
+	private void link(Node<Key> root1, Node<Key> root2) {
+		root1.sibling = root2.child;
+		root1.parent = root2;
+		root2.child = root1;
+		root2.order++;
+	}
+	
+	/*************************************************
+	 * Functions for moving upward
+	 ************************************************/
+	
+	//Moves a Node upward
+	private void swim(int i) {
+		Node<Key> x = nodes[i];
+		Node<Key> parent = x.parent;
+		if (parent != null && greater(parent.key, x.key)) {
+			exchange(x, parent);
+			swim(i);
+		}
+	}
+	
+	//The key associated with i becomes the root of its Binomial Tree,
+	//regardless of the order relation defined for the keys
+	private void toTheRoot(int i) {
+		Node<Key> x = nodes[i];
+		Node<Key> parent = x.parent;
+		if (parent != null) {
+			exchange(x, parent);
+			toTheRoot(i);
+		}
+	}
+	
+	/**************************************************
+	 * Functions for deleting a key
+	 *************************************************/
+	
+	//Assuming the key associated with i is in the root list,
+	//deletes and return the node of index i
+	private Node<Key> erase(int i) {
+		Node<Key> reference = nodes[i];
+		Node<Key> x = head;
+		Node<Key> previous = null;
+		while (x != reference) {
+			previous = x;
+			x = x.sibling;
+		}
+		previous.sibling = x.sibling;
+		if (x == head) head = head.sibling;
+		nodes[i] = null;
+		return x;
+	}
+	
+	//Deletes and return the node containing the minimum key
+	private Node<Key> eraseMin() {
+		Node<Key> min = head;
+		Node<Key> previous = null;
+		Node<Key> current = head;
+		while (current.sibling != null) {
+			if (greater(min.key, current.sibling.key)) {
+				previous = current;
+				min = current.sibling;
+			}
+			current = current.sibling;
+		}
+		previous.sibling = min.sibling;
+		if (min == head) head = min.sibling;
+		nodes[min.index] = null;
+		return min;
+	}
+	
+	/**************************************************
+	 * Functions for inserting a key in the heap
+	 *************************************************/
+	
+	//Merges two root lists into one, there can be up to 2 Binomial Trees of same order
+	private Node<Key> merge(Node<Key> h, Node<Key> x, Node<Key> y) {
+		if (x == null && y == null) return h;
+		else if (x == null) 		h.sibling = merge(y, null, y.sibling);
+		else if (y == null) 		h.sibling = merge(x, x.sibling, null);
+		else if (x.order < y.order) h.sibling = merge(x, x.sibling, y);
+		else 						h.sibling = merge(y, x, y.sibling);
+		return h;
+	}
+	
+	//Merges two Binomial Heaps together and returns the resulting Binomial Heap
+	//It destroys the two Heaps in parameter, which should not be used any after.
+	//To guarantee logarithmic time, this function assumes the arrays are up-to-date
+	private IndexBinomialMinPQ<Key> union(IndexBinomialMinPQ<Key> heap) {
+		this.head = merge(new Node<Key>(), this.head, heap.head).sibling;
+		Node<Key> x = this.head;
+		Node<Key> prevx = null, nextx = x.sibling;
+		while (nextx != null) {
+			if (x.order < nextx.order ||
+			   (nextx.sibling != null && nextx.sibling.order == x.order)) {
+				prevx = x; x = nextx;
+			} else if (greater(nextx.key, x.key)) {
+				x.sibling = nextx.sibling;
+				link(nextx, x);
+			} else {
+				if (prevx == null) { this.head = nextx; }
+				else { prevx.sibling = nextx; }
+				link(x, nextx);
+				x = nextx;
+			}
+			nextx = x.sibling;
+		}
+		return this;
+	}
+	
+	/******************************************************************
+	 * Constructor
+	 *****************************************************************/
+	
+	//Creates an empty heap
+	//The comparator is instanciated because it needs to,
+	//but won't be used by any heap created by this constructor
+	private IndexBinomialMinPQ() { comparator = null; }
+	
+	/******************************************************************
+	 * Iterator
+	 *****************************************************************/
+	
+	/**
+	 * Gets an Iterator over the indexes in the priority queue in ascending order
+	 * The Iterator does not implement the remove() method
+	 * iterator() : Worst case is O(n)
+	 * next() : 	Worst case is O(log(n))
+	 * hasNext() : 	Worst case is O(1)
+	 * @return an Iterator over the indexes in the priority queue in ascending order
+	 */
+	
+	public Iterator<Integer> iterator() {
+		return new MyIterator();
+	}
+	
+	private class MyIterator implements Iterator<Integer> {
+		IndexBinomialMinPQ<Key> data;
+		
+		//Constructor clones recursively the elements in the queue
+		//It takes linear time
+		public MyIterator() {
+			data = new IndexBinomialMinPQ<Key>(n, comparator);
+			data.head = clone(head, null);
+		}
+		
+		private Node<Key> clone(Node<Key> x, Node<Key> parent) {
+			if (x == null) return null;
+			Node<Key> node = new Node<Key>();
+			node.index = x.index;
+			node.key = x.key;
+			data.nodes[node.index] = node;
+			node.parent = parent;
+			node.sibling = clone(x.sibling, parent);
+			node.child = clone(x.child, node);
+			return node;
+		}
+		
+		public boolean hasNext() {
+			return !data.isEmpty();
+		}
+		
+		public Integer next() {
+                        if (!hasNext()) throw new NoSuchElementException();
+			return data.delMin();
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
+	
+	/***************************
+	 * Comparator
+	 **************************/
+	
+	//default Comparator
+	private class MyComparator implements Comparator<Key> {
+		@Override
+		public int compare(Key key1, Key key2) {
+			return ((Comparable<Key>) key1).compareTo(key2);
+		}
+	}
+	
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/IndexFibonacciMinPQ.java b/src/main/java/edu/princeton/cs/algs4/IndexFibonacciMinPQ.java
new file mode 100644
index 0000000..1291306
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/IndexFibonacciMinPQ.java
@@ -0,0 +1,495 @@
+/******************************************************************************
+ *  Compilation: javac IndexFibonacciMinPQ.java
+ *  Execution:
+ *  
+ *  An index Fibonacci heap.
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.HashMap;
+import java.util.NoSuchElementException;
+
+/*
+ *  The IndexFibonacciMinPQ class represents an indexed priority queue of generic keys.
+ *  It supports the usual insert and delete-the-minimum operations,
+ *  along with delete and change-the-key methods. 
+ *  In order to let the client refer to keys on the priority queue,
+ *  an integer between 0 and N-1 is associated with each key ; the client
+ *  uses this integer to specify which key to delete or change.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  
+ *  This implementation uses a Fibonacci heap along with an array to associate
+ *  keys with integers in the given range.
+ *  The insert, size, is-empty, contains, minimum-index, minimum-key
+ *  and key-of take constant time.
+ *  The decrease-key operation takes amortized constant time.
+ *  The delete, increase-key, delete-the-minimum, change-key take amortized logarithmic time.
+ *  Construction takes time proportional to the specified capacity
+ *
+ *   WARNING: THIS VERSION HAS AT LEAST ONE BUG.
+ *
+ *  @author Tristan Claverie
+ */
+public class IndexFibonacciMinPQ<Key> implements Iterable<Integer> {
+	private Node<Key>[] nodes;			//Array of Nodes in the heap
+	private Node<Key> head;				//Head of the circular root list
+	private Node<Key> min;				//Minimum Node in the heap
+	private int size;					//Number of keys in the heap
+	private int n;						//Maximum number of elements in the heap
+	private final Comparator<Key> comp; //Comparator over the keys
+	private HashMap<Integer, Node<Key>> table = new HashMap<Integer, Node<Key>>(); //Used for the consolidate operation
+	
+	//Represents a Node of a tree
+	private class Node<Key> {
+		Key key;						//Key of the Node
+		int order;						//The order of the tree rooted by this Node
+		int index;						//Index associated with the key
+		Node<Key> prev, next;			//siblings of the Node
+		Node<Key> parent, child;		//parent and child of this Node
+		boolean mark;					//Indicates if this Node already lost a child
+	}
+	
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0} and {@code N-1}
+     * Worst case is O(n)
+     * @param N number of keys in the priority queue, index from {@code 0} to {@code N-1}
+     * @throws java.lang.IllegalArgumentException if {@code N < 0}
+     */
+	public IndexFibonacciMinPQ(int N) {
+		if (N < 0) throw new IllegalArgumentException("Cannot create a priority queue of negative size");
+		n = N;
+		nodes = (Node<Key>[]) new Node[n];
+		comp = new MyComparator();
+	}
+	
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0} and {@code N-1}
+     * Worst case is O(n)
+     * @param N number of keys in the priority queue, index from {@code 0} to {@code N-1}
+     * @param C a Comparator over the keys
+     * @throws java.lang.IllegalArgumentException if {@code N < 0}
+     */
+	public IndexFibonacciMinPQ(Comparator<Key> C, int N) {
+		if (N < 0) throw new IllegalArgumentException("Cannot create a priority queue of negative size");
+		n = N;
+		nodes = (Node<Key>[]) new Node[n];
+		comp = C;
+	}
+
+	/**
+	 * Whether the priority queue is empty
+	 * Worst case is O(1)
+	 * @return true if the priority queue is empty, false if not
+	 */
+	
+	public boolean isEmpty() {
+		return size == 0;
+	}
+
+	/**
+	 * Does the priority queue contains the index i ?
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @return true if i is on the priority queue, false if not
+	 */
+	
+	public boolean contains(int i) {
+		if (i < 0 || i >= n) throw new IllegalArgumentException();
+		else 				 return nodes[i] != null;
+	}
+
+	/**
+	 * Number of elements currently on the priority queue
+	 * Worst case is O(1)
+	 * @return the number of elements on the priority queue
+	 */
+	
+	public int size() {
+		return size;
+	}
+
+	/**
+	 * Associates a key with an index
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @param key a Key associated with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index is already in the queue
+	 */
+	
+	public void insert(int i, Key key) {
+		if (i < 0 || i >= n) throw new IllegalArgumentException();
+		if (contains(i)) throw new IllegalArgumentException("Specified index is already in the queue");
+		Node<Key> x = new Node<Key>();
+		x.key = key;
+		x.index = i;
+		nodes[i] = x;
+		size++;
+		head = insert(x, head);
+		if (min == null) min = head;
+		else 			 min = (greater(min.key, key)) ? head : min;
+	}
+
+	/**
+	 * Get the index associated with the minimum key
+	 * Worst case is O(1)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the index associated with the minimum key
+	 */
+	
+	public int minIndex() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		return min.index;
+	}
+
+	/**
+	 * Get the minimum key currently in the queue
+	 * Worst case is O(1)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key currently in the priority queue
+	 */
+	
+	public Key minKey() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		return min.key;
+	}
+
+	/**
+	 * Delete the minimum key
+	 * Worst case is O(log(n)) (amortized)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the index associated with the minimum key
+	 */
+	
+	public int delMin() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		head = cut(min, head);
+		Node<Key> x = min.child;
+		int index = min.index;
+		min.key = null;					//For garbage collection
+		if (x != null) {
+			do {
+				x.parent = null;
+				x = x.next;
+			} while (x != min.child);
+			head = meld(head, x);
+			min.child = null;			//For garbage collection
+		}
+		size--;
+		if (!isEmpty()) consolidate();
+		else 			min = null;
+		nodes[index] = null;
+		return index;
+	}
+
+	/**
+	 * Get the key associated with index i
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index is not in the queue
+	 * @return the key associated with index i
+	 */
+	
+	public Key keyOf(int i) {
+		if (i < 0 || i >= n) throw new IllegalArgumentException();
+		if (!contains(i)) throw new NoSuchElementException("Specified index is not in the queue");
+		return nodes[i].key;
+	}
+
+	/**
+	 * Changes the key associated with index i to the given key
+	 * If the given key is greater, Worst case is O(log(n))
+	 * If the given key is lower, Worst case is O(1) (amortized)
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 */
+	
+	public void changeKey(int i, Key key) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		if (greater(key, nodes[i].key))  increaseKey(i, key);
+		else 							 decreaseKey(i, key);
+	}
+
+	/**
+	 * Decreases the key associated with index i to the given key
+	 * Worst case is O(1) (amortized).
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 * @throws java.lang.IllegalArgumentException if the given key is greater than the current key
+	 */
+	
+	public void decreaseKey(int i, Key key) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		if (greater(key, nodes[i].key))  throw new IllegalArgumentException("Calling with this argument would not decrease the key");
+		Node<Key> x = nodes[i];
+		x.key = key;
+		if (greater(min.key, key)) min = x;
+		if (x.parent != null && greater(x.parent.key, key)) {
+			cut(i);
+		}
+	}
+
+	/**
+	 * Increases the key associated with index i to the given key
+	 * Worst case is O(log(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 * @throws java.lang.IllegalArgumentException if the given key is lower than the current key
+	 */
+	
+	public void increaseKey(int i, Key key) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		if (greater(nodes[i].key, key))  throw new IllegalArgumentException("Calling with this argument would not increase the key");
+		delete(i);
+		insert(i, key);
+	}
+
+	/**
+	 * Deletes the key associated the given index
+	 * Worst case is O(log(n)) (amortized)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the given index has no key associated with
+	 */
+	
+	public void delete(int i) {
+		if (i < 0 || i >= n) 		throw new IllegalArgumentException();
+		if (!contains(i))			throw new NoSuchElementException("Specified index is not in the queue");
+		Node<Key> x = nodes[i];
+		x.key = null;				//For garbage collection
+		if (x.parent != null) {
+			cut(i);
+		}
+		head = cut(x, head);
+		if (x.child != null) {
+			Node<Key> child = x.child;
+			x.child = null;			//For garbage collection
+			x = child;
+			do {
+				child.parent = null;
+				child = child.next;
+			} while (child != x);
+			head = meld(head, child);
+		}
+		if (!isEmpty()) consolidate();
+		else 			min = null;
+		nodes[i] = null;
+		size--;
+	}
+	
+	/*************************************
+	 * General helper functions
+	 ************************************/
+	
+	//Compares two keys
+	private boolean greater(Key n, Key m) {
+		if (n == null) return false;
+		if (m == null) return true;
+		return comp.compare(n,  m) > 0;
+	}
+	
+	//Assuming root1 holds a greater key than root2, root2 becomes the new root
+	private void link(Node<Key> root1, Node<Key> root2) {
+		root1.parent = root2;
+		root2.child = insert(root1, root2.child);
+		root2.order++;
+	}
+	
+	/*************************************
+	 * Function for decreasing a key
+	 ************************************/
+	
+	//Removes a Node from its parent's child list and insert it in the root list
+	//If the parent Node already lost a child, reshapes the heap accordingly
+	private void cut(int i) {
+		Node<Key> x = nodes[i];
+		Node<Key> parent = x.parent;
+		parent.child = cut(x, parent.child);
+		x.parent = null;
+		parent.order--;
+		head = insert(x, head);
+		parent.mark = !parent.mark;
+		if (!parent.mark && parent.parent != null) {
+			cut(parent.index);}
+	}
+	
+	/*************************************
+	 * Function for consolidating all trees in the root list
+	 ************************************/
+	
+	//Coalesces the roots, thus reshapes the heap
+	//Caching a HashMap improves greatly performances
+	private void consolidate() {
+		table.clear();
+		Node<Key> x = head;
+		int maxOrder = 0;
+		min = head;
+		Node<Key> y = null, z = null;
+		do {
+			y = x;
+			x = x.next;
+			z = table.get(y.order);
+			while (z != null) {
+				table.remove(y.order);
+				if (greater(y.key, z.key)) {
+					link(y, z);
+					y = z;
+				} else {
+					link(z, y);
+				}
+				z = table.get(y.order);
+			}
+			table.put(y.order, y);
+			if (y.order > maxOrder) maxOrder = y.order;
+		} while (x != head);
+		head = null;
+		for (Node<Key> n : table.values()) {
+			min = greater(min.key, n.key) ? n : min;
+			head = insert(n, head);
+		}
+	}
+	
+	/*************************************
+	 * General helper functions for manipulating circular lists
+	 ************************************/
+	
+	//Inserts a Node in a circular list containing head, returns a new head
+	private Node<Key> insert(Node<Key> x, Node<Key> head) {
+		if (head == null) {
+			x.prev = x;
+			x.next = x;
+		} else {
+			head.prev.next = x;
+			x.next = head;
+			x.prev = head.prev;
+			head.prev = x;
+		}
+		return x;
+	}
+	
+	//Removes a tree from the list defined by the head pointer
+	private Node<Key> cut(Node<Key> x, Node<Key> head) {
+		if (x.next == x) {
+			x.next = null;
+			x.prev = null;
+			return null;
+		} else {
+			x.next.prev = x.prev;
+			x.prev.next = x.next;
+			Node<Key> res = x.next;
+			x.next = null;
+			x.prev = null;
+			if (head == x)  return res;
+			else 			return head;
+		}
+	}
+	
+	//Merges two lists together.
+	private Node<Key> meld(Node<Key> x, Node<Key> y) {
+		if (x == null) return y;
+		if (y == null) return x;
+		x.prev.next = y.next;
+		y.next.prev = x.prev;
+		x.prev = y;
+		y.next = x;
+		return x;
+	}
+	
+	/*************************************
+	 * Iterator
+	 ************************************/
+	
+	/**
+	 * Get an Iterator over the indexes in the priority queue in ascending order
+	 * The Iterator does not implement the remove() method
+	 * iterator() : Worst case is O(n)
+	 * next() : 	Worst case is O(log(n)) (amortized)
+	 * hasNext() : 	Worst case is O(1)
+	 * @return an Iterator over the indexes in the priority queue in ascending order
+	 */
+	
+	public Iterator<Integer> iterator() {
+		return new MyIterator();
+	}
+	
+	private class MyIterator implements Iterator<Integer> {
+		private IndexFibonacciMinPQ<Key> copy;
+		
+		
+		//Constructor takes linear time
+		public MyIterator() {
+			copy = new IndexFibonacciMinPQ<Key>(comp, n);
+			for (Node<Key> x : nodes) {
+				if (x != null) copy.insert(x.index, x.key);
+			}
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+		
+		public boolean hasNext() {
+			return !copy.isEmpty();
+		}
+		
+		//Takes amortized logarithmic time
+		public Integer next() {
+			if (!hasNext()) throw new NoSuchElementException();
+			return copy.delMin();
+		}
+	}
+	
+	/***************************
+	 * Comparator
+	 **************************/
+	
+	//default Comparator
+	private class MyComparator implements Comparator<Key> {
+		@Override
+		public int compare(Key key1, Key key2) {
+			return ((Comparable<Key>) key1).compareTo(key2);
+		}
+	}
+	
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/IndexMaxPQ.java b/src/main/java/edu/princeton/cs/algs4/IndexMaxPQ.java
new file mode 100644
index 0000000..948eec6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/IndexMaxPQ.java
@@ -0,0 +1,416 @@
+/******************************************************************************
+ *  Compilation:  javac IndexMaxPQ.java
+ *  Execution:    java IndexMaxPQ
+ *  Dependencies: StdOut.java
+ *
+ *  Maximum-oriented indexed PQ implementation using a binary heap.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code IndexMaxPQ} class represents an indexed priority queue of generic keys.
+ *  It supports the usual <em>insert</em> and <em>delete-the-maximum</em>
+ *  operations, along with <em>delete</em> and <em>change-the-key</em> 
+ *  methods. In order to let the client refer to items on the priority queue,
+ *  an integer between {@code 0} and {@code maxN - 1}
+ *  is associated with each key‚Äîthe client
+ *  uses this integer to specify which key to delete or change.
+ *  It also supports methods for peeking at a maximum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  <p>
+ *  This implementation uses a <em>binary heap</em> along with an
+ *  array to associate keys with integers in the given range.
+ *  The <em>insert</em>, <em>delete-the-maximum</em>, <em>delete</em>,
+ *  <em>change-key</em>, <em>decrease-key</em>, and <em>increase-key</em>
+ *  operations take &Theta;(log <em>n</em>) time in the worst case,
+ *  where <em>n</em> is the number of elements in the priority queue.
+ *  Construction takes time proportional to the specified capacity.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Key> the generic type of key on this priority queue
+ */
+public class IndexMaxPQ<Key extends Comparable<Key>> implements Iterable<Integer> {
+    private int maxN;        // maximum number of elements on PQ
+    private int n;           // number of elements on PQ
+    private int[] pq;        // binary heap using 1-based indexing
+    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i
+    private Key[] keys;      // keys[i] = priority of i
+
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0}
+     * and {@code maxN - 1}.
+     *
+     * @param  maxN the keys on this priority queue are index from {@code 0} to {@code maxN - 1}
+     * @throws IllegalArgumentException if {@code maxN < 0}
+     */
+    public IndexMaxPQ(int maxN) {
+        if (maxN < 0) throw new IllegalArgumentException();
+        this.maxN = maxN;
+        n = 0;
+        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??
+        pq   = new int[maxN + 1];
+        qp   = new int[maxN + 1];                   // make this of length maxN??
+        for (int i = 0; i <= maxN; i++)
+            qp[i] = -1;
+    }
+
+    /**
+     * Returns true if this priority queue is empty.
+     *
+     * @return {@code true} if this priority queue is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Is {@code i} an index on this priority queue?
+     *
+     * @param  i an index
+     * @return {@code true} if {@code i} is an index on this priority queue;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     */
+    public boolean contains(int i) {
+        validateIndex(i);
+        return qp[i] != -1;
+    }
+
+    /**
+     * Returns the number of keys on this priority queue.
+     *
+     * @return the number of keys on this priority queue 
+     */
+    public int size() {
+        return n;
+    }
+
+   /**
+     * Associate key with index i.
+     *
+     * @param  i an index
+     * @param  key the key to associate with index {@code i}
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws IllegalArgumentException if there already is an item
+     *         associated with index {@code i}
+     */
+    public void insert(int i, Key key) {
+        validateIndex(i);
+        if (contains(i)) throw new IllegalArgumentException("index is already in the priority queue");
+        n++;
+        qp[i] = n;
+        pq[n] = i;
+        keys[i] = key;
+        swim(n);
+    }
+
+    /**
+     * Returns an index associated with a maximum key.
+     *
+     * @return an index associated with a maximum key
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public int maxIndex() {
+        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
+        return pq[1];
+    }
+
+    /**
+     * Returns a maximum key.
+     *
+     * @return a maximum key
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public Key maxKey() {
+        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
+        return keys[pq[1]];
+    }
+
+    /**
+     * Removes a maximum key and returns its associated index.
+     *
+     * @return an index associated with a maximum key
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public int delMax() {
+        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
+        int max = pq[1];
+        exch(1, n--);
+        sink(1);
+
+        assert pq[n+1] == max;
+        qp[max] = -1;        // delete
+        keys[max] = null;    // to help with garbage collection
+        pq[n+1] = -1;        // not needed
+        return max;
+    }
+
+    /**
+     * Returns the key associated with index {@code i}.
+     *
+     * @param  i the index of the key to return
+     * @return the key associated with index {@code i}
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public Key keyOf(int i) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        else return keys[i];
+    }
+
+    /**
+     * Change the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to change
+     * @param  key change the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     */
+    public void changeKey(int i, Key key) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        keys[i] = key;
+        swim(qp[i]);
+        sink(qp[i]);
+    }
+
+   /**
+     * Change the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to change
+     * @param  key change the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @deprecated Replaced by {@code changeKey(int, Key)}.
+     */
+    @Deprecated
+    public void change(int i, Key key) {
+        validateIndex(i);
+        changeKey(i, key);
+    }
+
+    /**
+     * Increase the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to increase
+     * @param  key increase the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws IllegalArgumentException if {@code key <= keyOf(i)}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void increaseKey(int i, Key key) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        if (keys[i].compareTo(key) == 0)
+            throw new IllegalArgumentException("Calling increaseKey() with a key equal to the key in the priority queue");
+        if (keys[i].compareTo(key) > 0)
+            throw new IllegalArgumentException("Calling increaseKey() with a key that is strictly less than the key in the priority queue");
+
+        keys[i] = key;
+        swim(qp[i]);
+    }
+
+    /**
+     * Decrease the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to decrease
+     * @param  key decrease the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws IllegalArgumentException if {@code key >= keyOf(i)}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void decreaseKey(int i, Key key) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        if (keys[i].compareTo(key) == 0)
+            throw new IllegalArgumentException("Calling decreaseKey() with a key equal to the key in the priority queue");
+        if (keys[i].compareTo(key) < 0)
+            throw new IllegalArgumentException("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");
+        keys[i] = key;
+        sink(qp[i]);
+    }
+
+    /**
+     * Remove the key on the priority queue associated with index {@code i}.
+     *
+     * @param  i the index of the key to remove
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void delete(int i) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        int index = qp[i];
+        exch(index, n--);
+        swim(index);
+        sink(index);
+        keys[i] = null;
+        qp[i] = -1;
+    }
+
+    // throw an IllegalArgumentException if i is an invalid index
+    private void validateIndex(int i) {
+        if (i < 0) throw new IllegalArgumentException("index is negative: " + i);
+        if (i >= maxN) throw new IllegalArgumentException("index >= capacity: " + i);
+    }
+
+   /***************************************************************************
+    * General helper functions.
+    ***************************************************************************/
+    private boolean less(int i, int j) {
+        return keys[pq[i]].compareTo(keys[pq[j]]) < 0;
+    }
+
+    private void exch(int i, int j) {
+        int swap = pq[i];
+        pq[i] = pq[j];
+        pq[j] = swap;
+        qp[pq[i]] = i;
+        qp[pq[j]] = j;
+    }
+
+
+   /***************************************************************************
+    * Heap helper functions.
+    ***************************************************************************/
+    private void swim(int k) {
+        while (k > 1 && less(k/2, k)) {
+            exch(k, k/2);
+            k = k/2;
+        }
+    }
+
+    private void sink(int k) {
+        while (2*k <= n) {
+            int j = 2*k;
+            if (j < n && less(j, j+1)) j++;
+            if (!less(k, j)) break;
+            exch(k, j);
+            k = j;
+        }
+    }
+
+
+    /**
+     * Returns an iterator that iterates over the keys on the
+     * priority queue in descending order.
+     * The iterator doesn't implement {@code remove()} since it's optional.
+     *
+     * @return an iterator that iterates over the keys in descending order
+     */
+    public Iterator<Integer> iterator() {
+        return new HeapIterator();
+    }
+
+    private class HeapIterator implements Iterator<Integer> {
+        // create a new pq
+        private IndexMaxPQ<Key> copy;
+
+        // add all elements to copy of heap
+        // takes linear time since already in heap order so no keys move
+        public HeapIterator() {
+            copy = new IndexMaxPQ<Key>(pq.length - 1);
+            for (int i = 1; i <= n; i++)
+                copy.insert(pq[i], keys[pq[i]]);
+        }
+
+        public boolean hasNext()  { return !copy.isEmpty();                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Integer next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            return copy.delMax();
+        }
+    }
+
+    /**
+     * Unit tests the {@code IndexMaxPQ} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        // insert a bunch of strings
+        String[] strings = { "it", "was", "the", "best", "of", "times", "it", "was", "the", "worst" };
+
+        IndexMaxPQ<String> pq = new IndexMaxPQ<String>(strings.length);
+        for (int i = 0; i < strings.length; i++) {
+            pq.insert(i, strings[i]);
+        }
+
+        // print each key using the iterator
+        for (int i : pq) {
+            StdOut.println(i + " " + strings[i]);
+        }
+
+        StdOut.println();
+
+        // increase or decrease the key
+        for (int i = 0; i < strings.length; i++) {
+            if (StdRandom.uniform() < 0.5)
+                pq.increaseKey(i, strings[i] + strings[i]);
+            else
+                pq.decreaseKey(i, strings[i].substring(0, 1));
+        }
+
+        // delete and print each key
+        while (!pq.isEmpty()) {
+            String key = pq.maxKey();
+            int i = pq.delMax();
+            StdOut.println(i + " " + key);
+        }
+        StdOut.println();
+
+        // reinsert the same strings
+        for (int i = 0; i < strings.length; i++) {
+            pq.insert(i, strings[i]);
+        }
+
+        // delete them in random order
+        int[] perm = new int[strings.length];
+        for (int i = 0; i < strings.length; i++)
+            perm[i] = i;
+        StdRandom.shuffle(perm);
+        for (int i = 0; i < perm.length; i++) {
+            String key = pq.keyOf(perm[i]);
+            pq.delete(perm[i]);
+            StdOut.println(perm[i] + " " + key);
+        }
+
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/IndexMinPQ.java b/src/main/java/edu/princeton/cs/algs4/IndexMinPQ.java
new file mode 100644
index 0000000..66fcace
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/IndexMinPQ.java
@@ -0,0 +1,397 @@
+/******************************************************************************
+ *  Compilation:  javac IndexMinPQ.java
+ *  Execution:    java IndexMinPQ
+ *  Dependencies: StdOut.java
+ *
+ *  Minimum-oriented indexed PQ implementation using a binary heap.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code IndexMinPQ} class represents an indexed priority queue of generic keys.
+ *  It supports the usual <em>insert</em> and <em>delete-the-minimum</em>
+ *  operations, along with <em>delete</em> and <em>change-the-key</em> 
+ *  methods. In order to let the client refer to keys on the priority queue,
+ *  an integer between {@code 0} and {@code maxN - 1}
+ *  is associated with each key‚Äîthe client uses this integer to specify
+ *  which key to delete or change.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  <p>
+ *  This implementation uses a binary heap along with an array to associate
+ *  keys with integers in the given range.
+ *  The <em>insert</em>, <em>delete-the-minimum</em>, <em>delete</em>,
+ *  <em>change-key</em>, <em>decrease-key</em>, and <em>increase-key</em>
+ *  operations take &Theta;(log <em>n</em>) time in the worst case,
+ *  where <em>n</em> is the number of elements in the priority queue.
+ *  Construction takes time proportional to the specified capacity.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Key> the generic type of key on this priority queue
+ */
+public class IndexMinPQ<Key extends Comparable<Key>> implements Iterable<Integer> {
+    private int maxN;        // maximum number of elements on PQ
+    private int n;           // number of elements on PQ
+    private int[] pq;        // binary heap using 1-based indexing
+    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i
+    private Key[] keys;      // keys[i] = priority of i
+
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0}
+     * and {@code maxN - 1}.
+     * @param  maxN the keys on this priority queue are index from {@code 0}
+     *         {@code maxN - 1}
+     * @throws IllegalArgumentException if {@code maxN < 0}
+     */
+    public IndexMinPQ(int maxN) {
+        if (maxN < 0) throw new IllegalArgumentException();
+        this.maxN = maxN;
+        n = 0;
+        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??
+        pq   = new int[maxN + 1];
+        qp   = new int[maxN + 1];                   // make this of length maxN??
+        for (int i = 0; i <= maxN; i++)
+            qp[i] = -1;
+    }
+
+    /**
+     * Returns true if this priority queue is empty.
+     *
+     * @return {@code true} if this priority queue is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Is {@code i} an index on this priority queue?
+     *
+     * @param  i an index
+     * @return {@code true} if {@code i} is an index on this priority queue;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     */
+    public boolean contains(int i) {
+        validateIndex(i);
+        return qp[i] != -1;
+    }
+
+    /**
+     * Returns the number of keys on this priority queue.
+     *
+     * @return the number of keys on this priority queue
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Associates key with index {@code i}.
+     *
+     * @param  i an index
+     * @param  key the key to associate with index {@code i}
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws IllegalArgumentException if there already is an item associated
+     *         with index {@code i}
+     */
+    public void insert(int i, Key key) {
+        validateIndex(i);
+        if (contains(i)) throw new IllegalArgumentException("index is already in the priority queue");
+        n++;
+        qp[i] = n;
+        pq[n] = i;
+        keys[i] = key;
+        swim(n);
+    }
+
+    /**
+     * Returns an index associated with a minimum key.
+     *
+     * @return an index associated with a minimum key
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public int minIndex() {
+        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
+        return pq[1];
+    }
+
+    /**
+     * Returns a minimum key.
+     *
+     * @return a minimum key
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public Key minKey() {
+        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
+        return keys[pq[1]];
+    }
+
+    /**
+     * Removes a minimum key and returns its associated index.
+     * @return an index associated with a minimum key
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public int delMin() {
+        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
+        int min = pq[1];
+        exch(1, n--);
+        sink(1);
+        assert min == pq[n+1];
+        qp[min] = -1;        // delete
+        keys[min] = null;    // to help with garbage collection
+        pq[n+1] = -1;        // not needed
+        return min;
+    }
+
+    /**
+     * Returns the key associated with index {@code i}.
+     *
+     * @param  i the index of the key to return
+     * @return the key associated with index {@code i}
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public Key keyOf(int i) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        else return keys[i];
+    }
+
+    /**
+     * Change the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to change
+     * @param  key change the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void changeKey(int i, Key key) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        keys[i] = key;
+        swim(qp[i]);
+        sink(qp[i]);
+    }
+
+    /**
+     * Change the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to change
+     * @param  key change the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @deprecated Replaced by {@code changeKey(int, Key)}.
+     */
+    @Deprecated
+    public void change(int i, Key key) {
+        changeKey(i, key);
+    }
+
+    /**
+     * Decrease the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to decrease
+     * @param  key decrease the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws IllegalArgumentException if {@code key >= keyOf(i)}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void decreaseKey(int i, Key key) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        if (keys[i].compareTo(key) == 0)
+            throw new IllegalArgumentException("Calling decreaseKey() with a key equal to the key in the priority queue");
+        if (keys[i].compareTo(key) < 0)
+            throw new IllegalArgumentException("Calling decreaseKey() with a key strictly greater than the key in the priority queue");
+        keys[i] = key;
+        swim(qp[i]);
+    }
+
+    /**
+     * Increase the key associated with index {@code i} to the specified value.
+     *
+     * @param  i the index of the key to increase
+     * @param  key increase the key associated with index {@code i} to this key
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws IllegalArgumentException if {@code key <= keyOf(i)}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void increaseKey(int i, Key key) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        if (keys[i].compareTo(key) == 0)
+            throw new IllegalArgumentException("Calling increaseKey() with a key equal to the key in the priority queue");
+        if (keys[i].compareTo(key) > 0)
+            throw new IllegalArgumentException("Calling increaseKey() with a key strictly less than the key in the priority queue");
+        keys[i] = key;
+        sink(qp[i]);
+    }
+
+    /**
+     * Remove the key associated with index {@code i}.
+     *
+     * @param  i the index of the key to remove
+     * @throws IllegalArgumentException unless {@code 0 <= i < maxN}
+     * @throws NoSuchElementException no key is associated with index {@code i}
+     */
+    public void delete(int i) {
+        validateIndex(i);
+        if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
+        int index = qp[i];
+        exch(index, n--);
+        swim(index);
+        sink(index);
+        keys[i] = null;
+        qp[i] = -1;
+    }
+
+    // throw an IllegalArgumentException if i is an invalid index
+    private void validateIndex(int i) {
+        if (i < 0) throw new IllegalArgumentException("index is negative: " + i);
+        if (i >= maxN) throw new IllegalArgumentException("index >= capacity: " + i);
+    }
+
+   /***************************************************************************
+    * General helper functions.
+    ***************************************************************************/
+    private boolean greater(int i, int j) {
+        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;
+    }
+
+    private void exch(int i, int j) {
+        int swap = pq[i];
+        pq[i] = pq[j];
+        pq[j] = swap;
+        qp[pq[i]] = i;
+        qp[pq[j]] = j;
+    }
+
+
+   /***************************************************************************
+    * Heap helper functions.
+    ***************************************************************************/
+    private void swim(int k) {
+        while (k > 1 && greater(k/2, k)) {
+            exch(k, k/2);
+            k = k/2;
+        }
+    }
+
+    private void sink(int k) {
+        while (2*k <= n) {
+            int j = 2*k;
+            if (j < n && greater(j, j+1)) j++;
+            if (!greater(k, j)) break;
+            exch(k, j);
+            k = j;
+        }
+    }
+
+
+   /***************************************************************************
+    * Iterators.
+    ***************************************************************************/
+
+    /**
+     * Returns an iterator that iterates over the keys on the
+     * priority queue in ascending order.
+     * The iterator doesn't implement {@code remove()} since it's optional.
+     *
+     * @return an iterator that iterates over the keys in ascending order
+     */
+    public Iterator<Integer> iterator() { return new HeapIterator(); }
+
+    private class HeapIterator implements Iterator<Integer> {
+        // create a new pq
+        private IndexMinPQ<Key> copy;
+
+        // add all elements to copy of heap
+        // takes linear time since already in heap order so no keys move
+        public HeapIterator() {
+            copy = new IndexMinPQ<Key>(pq.length - 1);
+            for (int i = 1; i <= n; i++)
+                copy.insert(pq[i], keys[pq[i]]);
+        }
+
+        public boolean hasNext()  { return !copy.isEmpty();                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Integer next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            return copy.delMin();
+        }
+    }
+
+
+    /**
+     * Unit tests the {@code IndexMinPQ} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        // insert a bunch of strings
+        String[] strings = { "it", "was", "the", "best", "of", "times", "it", "was", "the", "worst" };
+
+        IndexMinPQ<String> pq = new IndexMinPQ<String>(strings.length);
+        for (int i = 0; i < strings.length; i++) {
+            pq.insert(i, strings[i]);
+        }
+
+        // delete and print each key
+        while (!pq.isEmpty()) {
+            int i = pq.delMin();
+            StdOut.println(i + " " + strings[i]);
+        }
+        StdOut.println();
+
+        // reinsert the same strings
+        for (int i = 0; i < strings.length; i++) {
+            pq.insert(i, strings[i]);
+        }
+
+        // print each key using the iterator
+        for (int i : pq) {
+            StdOut.println(i + " " + strings[i]);
+        }
+        while (!pq.isEmpty()) {
+            pq.delMin();
+        }
+
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/IndexMultiwayMinPQ.java b/src/main/java/edu/princeton/cs/algs4/IndexMultiwayMinPQ.java
new file mode 100644
index 0000000..dbd8400
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/IndexMultiwayMinPQ.java
@@ -0,0 +1,395 @@
+/******************************************************************************
+ *  Compilation: javac IndexMultiwayMinPQ.java
+ *  Execution:
+ *
+ *  An inde  multiway heap.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The IndexMultiwayMinPQ class represents an indexed priority queue of generic keys.
+ *  It supports the usual insert and delete-the-minimum operations,
+ *  along with delete and change-the-key methods. 
+ *  In order to let the client refer to keys on the priority queue,
+ *  an integer between 0 and N-1 is associated with each key ; the client
+ *  uses this integer to specify which key to delete or change.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  
+ *  This implementation uses a multiway heap along with an array to associate
+ *  keys with integers in the given range.
+ *  For simplified notations, logarithm in base d will be referred as log-d
+ *  The delete-the-minimum, delete, change-key and increase-key operations
+ *  take time proportional to d*log-d(n)
+ *  The insert and decrease-key take time proportional to log-d(n)
+ *  The is-empty, min-index, min-key, size, contains and key-of operations take constant time.
+ *  Construction takes time proportional to the specified capacity.
+ *  
+ *  The arrays used in this structure have the first d indices empty,
+ *  it apparently helps with caching effects.
+ *
+ *  @author Tristan Claverie
+ */
+public class IndexMultiwayMinPQ<Key> implements Iterable<Integer> {
+	private final int d;				//Dimension of the heap
+	private int n;						//Number of keys currently in the queue
+	private int nmax;					//Maximum number of items in the queue
+	private int[] pq;					//Multiway heap
+	private int[] qp;					//Inverse of pq : qp[pq[i]] = pq[qp[i]] = i
+	private Key[] keys;					//keys[i] = priority of i
+	private final Comparator<Key> comp; //Comparator over the keys
+	
+	
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0} to {@code N-1}
+     * Worst case is O(n)
+     * @param N number of keys in the priority queue, index from {@code 0} to {@code N-1}
+     * @param D dimension of the heap
+     * @throws java.lang.IllegalArgumentException if {@code N < 0}
+     * @throws java.lang.IllegalArgumentException if {@code D < 2}
+     */
+	public IndexMultiwayMinPQ(int N, int D) {
+		if (N < 0) throw new IllegalArgumentException("Maximum number of elements cannot be negative");
+		if (D < 2) throw new IllegalArgumentException("Dimension should be 2 or over");
+		this.d = D;
+		nmax = N;
+		pq = new int[nmax+D];
+		qp = new int[nmax+D];
+		keys = (Key[]) new Comparable[nmax+D];
+		for (int i = 0; i < nmax+D; qp[i++] = -1);
+		comp = new MyComparator();
+	}
+	
+    /**
+     * Initializes an empty indexed priority queue with indices between {@code 0} to {@code N-1}
+     * Worst case is O(n)
+     * @param N number of keys in the priority queue, index from {@code 0} to {@code N-1}
+     * @param D dimension of the heap
+     * @param C a Comparator over the keys
+     * @throws java.lang.IllegalArgumentException if {@code N < 0}
+     * @throws java.lang.IllegalArgumentException if {@code D < 2}
+     */
+	public IndexMultiwayMinPQ(int N, Comparator<Key> C, int D) {
+		if (N < 0) throw new IllegalArgumentException("Maximum number of elements cannot be negative");
+		if (D < 2) throw new IllegalArgumentException("Dimension should be 2 or over");
+		this.d = D;
+		nmax = N;
+		pq = new int[nmax+D];
+		qp = new int[nmax+D];
+		keys = (Key[]) new Comparable[nmax+D];
+		for (int i = 0; i < nmax+D; qp[i++] = -1);
+		comp = C;
+	}
+
+	/**
+	 * Whether the priority queue is empty
+	 * Worst case is O(1)
+	 * @return true if the priority queue is empty, false if not
+	 */
+	public boolean isEmpty() {
+		return n == 0;
+	}
+
+	/**
+	 * Does the priority queue contains the index i ?
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @return true if i is on the priority queue, false if not
+	 */
+	public boolean contains(int i) {
+		if (i < 0 ||i >= nmax) throw new IllegalArgumentException();
+		return qp[i+d] != -1;
+	}
+
+	/**
+	 * Number of elements currently on the priority queue
+	 * Worst case is O(1)
+	 * @return the number of elements on the priority queue
+	 */
+	public int size() {
+		return n;
+	}
+
+	/**
+	 * Associates a key with an index
+	 * Worst case is O(log-d(n))
+	 * @param i an index
+	 * @param key a Key associated with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index is already in the queue
+	 */
+	public void insert(int i, Key key) {
+		if (i < 0 || i >= nmax) throw new IllegalArgumentException();
+		if (contains(i)) throw new IllegalArgumentException("Index already there");
+		keys[i+d] = key;
+		pq[n+d] = i;
+		qp[i+d] = n;
+		swim(n++);
+	}
+
+	/**
+	 * Gets the index associated with the minimum key
+	 * Worst case is O(1)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the index associated with the minimum key
+	 */
+	public int minIndex() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		return pq[d];
+	}
+
+	/**
+	 * Gets the minimum key currently in the queue
+	 * Worst case is O(1)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key currently in the priority queue
+	 */
+	public Key minKey() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		return keys[pq[d]+d];
+	}
+
+	/**
+	 * Deletes the minimum key
+	 * Worst case is O(d*log-d(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the index associated with the minimum key
+	 */
+	public int delMin() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		int min = pq[d];
+		exch(0, --n);
+		sink(0);
+		qp[min+d] = -1;
+		keys[pq[n+d]+d] = null;
+		pq[n+d] = -1;
+		return min;
+	}
+
+	/**
+	 * Gets the key associated with index i
+	 * Worst case is O(1)
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index is not in the queue
+	 * @return the key associated with index i
+	 */
+	public Key keyOf(int i) {
+		if (i < 0 || i >= nmax) throw new IllegalArgumentException();
+		if (! contains(i)) throw new NoSuchElementException("Specified index is not in the queue");
+		return keys[i+d];
+	}
+
+	/**
+	 * Changes the key associated with index i to the given key
+	 * If the given key is greater, Worst case is O(d*log-d(n))
+	 * If the given key is lower,   Worst case is O(log-d(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.lang.IllegalArgumentException if the index has no key associated with
+	 */
+	public void changeKey(int i, Key key) {
+		if (i < 0 || i >= nmax) throw new IllegalArgumentException();
+		if (! contains(i)) throw new NoSuchElementException("Specified index is not in the queue");
+		Key tmp = keys[i+d];
+		keys[i+d] = key;
+		if (comp.compare(key, tmp) <= 0) { swim(qp[i+d]);}
+		else 							 { sink(qp[i+d]);}
+	}
+
+	/**
+	 * Decreases the key associated with index i to the given key
+	 * Worst case is O(log-d(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 * @throws java.lang.IllegalArgumentException if the given key is greater than the current key
+	 */
+	public void decreaseKey(int i, Key key) {
+		if (i < 0 || i >=nmax) throw new IllegalArgumentException();
+		if (! contains(i)) throw new NoSuchElementException("Specified index is not in the queue");
+		if (comp.compare(keys[i+d], key) <= 0) throw new IllegalArgumentException("Calling with this argument would not decrease the Key");
+		keys[i+d] = key;
+		swim(qp[i+d]);
+	}
+
+	/**
+	 * Increases the key associated with index i to the given key
+	 * Worst case is O(d*log-d(n))
+	 * @param i an index
+	 * @param key the key to associate with i
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the index has no key associated with
+	 * @throws java.lang.IllegalArgumentException if the given key is lower than the current key
+	 */
+	public void increaseKey(int i, Key key) {
+		if (i < 0 || i >=nmax) throw new IllegalArgumentException();
+		if (! contains(i)) throw new NoSuchElementException("Specified index is not in the queue");
+		if (comp.compare(keys[i+d], key) >= 0) throw new IllegalArgumentException("Calling with this argument would not increase the Key");
+		keys[i+d] = key;
+		sink(qp[i+d]);
+	}
+
+	/**
+	 * Deletes the key associated to the given index
+	 * Worst case is O(d*log-d(n))
+	 * @param i an index
+	 * @throws java.lang.IllegalArgumentException if the specified index is invalid
+	 * @throws java.util.NoSuchElementException if the given index has no key associated with
+	 */
+	public void delete(int i) {
+		if (i < 0 || i >= nmax) throw new IllegalArgumentException();
+		if (! contains(i)) throw new NoSuchElementException("Specified index is not in the queue");
+		int idx = qp[i+d];
+		exch(idx, --n);
+		swim(idx);
+		sink(idx);
+		keys[i+d] = null;
+		qp[i+d] = -1;
+	}
+	
+	/***************************
+	 * General helper functions
+	 **************************/
+	
+	//Compares two keys
+	private boolean greater(int i, int j) {
+		return comp.compare(keys[pq[i+d]+d], keys[pq[j+d]+d]) > 0;
+	}
+	
+	//Exchanges two keys
+	private void exch(int x, int y) {
+		int i = x+d, j = y+d;
+		int swap = pq[i];
+		pq[i] = pq[j];
+		pq[j] = swap;
+		qp[pq[i]+d] = x;
+		qp[pq[j]+d] = y;
+	}
+	
+	/***************************
+	 * Functions for moving upward or downward
+	 **************************/
+	
+	//Moves upward
+	private void swim(int i) {
+		if (i > 0 && greater((i-1)/d, i)) {
+			exch(i, (i-1)/d);
+			swim((i-1)/d);
+		}
+	}
+	
+	//Moves downward
+	private void sink(int i) {
+		if (d*i+1 >= n) return;
+		int min = minChild(i);
+		while (min < n && greater(i, min)) {
+			exch(i, min);
+			i = min;
+			min = minChild(i);
+		}
+	}
+	
+	/***************************
+	 * Deletes the minimum child
+	 **************************/
+	
+	//Return the minimum child of i
+	private int minChild(int i) {
+		int loBound = d*i+1, hiBound = d*i+d;
+		int min = loBound;
+		for (int cur = loBound; cur <= hiBound; cur++) {
+			if (cur < n && greater(min, cur)) min = cur;
+		}
+		return min;
+	}
+	
+	/***************************
+	 * Iterator
+	 **************************/
+	
+	/**
+	 * Gets an Iterator over the indexes in the priority queue in ascending order
+	 * The Iterator does not implement the remove() method
+	 * iterator() : Worst case is O(n)
+	 * next() : 	Worst case is O(d*log-d(n))
+	 * hasNext() : 	Worst case is O(1)
+	 * @return an Iterator over the indexes in the priority queue in ascending order
+	 */
+	
+	public Iterator<Integer> iterator() {
+		return new MyIterator();
+	}
+	
+	//Constructs an Iterator over the indices in linear time
+	private class MyIterator implements Iterator<Integer> {
+		IndexMultiwayMinPQ<Key> clone;
+		
+		public MyIterator() {
+			clone = new IndexMultiwayMinPQ<Key>(nmax, comp, d);
+			for (int i = 0; i < n; i++) {
+				clone.insert(pq[i+d], keys[pq[i+d]+d]);
+			}
+		}
+
+		public boolean hasNext() {
+			return !clone.isEmpty();
+		}
+		
+		public Integer next() {
+                        if (!hasNext()) throw new NoSuchElementException();
+			return clone.delMin();
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
+	
+	/***************************
+	 * Comparator
+	 **************************/
+	
+	//default Comparator
+	private class MyComparator implements Comparator<Key> {
+		@Override
+		public int compare(Key key1, Key key2) {
+			return ((Comparable<Key>) key1).compareTo(key2);
+		}
+	}
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/InplaceMSD.java b/src/main/java/edu/princeton/cs/algs4/InplaceMSD.java
new file mode 100644
index 0000000..0257d71
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/InplaceMSD.java
@@ -0,0 +1,171 @@
+/******************************************************************************
+ *  Compilation: javac InplaceMSD.java
+ *  Execution:   java InplaceMSD < input.txt
+ *  Dependencies: StdIn.java StdOut.java 
+ *  Data files:   https://algs4.cs.princeton.edu/51radix/words3.txt
+ *                https://algs4.cs.princeton.edu/51radix/shells.txt
+ *
+ *  Sort an array of strings or integers using in-place MSD radix sort.
+ *
+ *  % java InplaceMSD < shells.txt 
+ *  are
+ *  by
+ *  sea
+ *  seashells
+ *  seashells
+ *  sells
+ *  sells
+ *  she
+ *  she
+ *  shells
+ *  shore
+ *  surely
+ *  the
+ *  the
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code InplaceMSD} class provides static methods for sorting an
+ *  array of extended ASCII strings using in-place MSD radix sort.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/51radix">Section 5.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Ivan Pesin
+ */
+
+public class InplaceMSD {
+    private static final int R             = 256;   // extended ASCII alphabet size
+    private static final int CUTOFF        =  15;   // cutoff to insertion sort
+
+    // do not instantiate
+    private InplaceMSD() { } 
+
+   /**
+     * Rearranges the array of extended ASCII strings in ascending order.
+     * This is an unstable sorting algorithm.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(String[] a) {
+        int n = a.length;
+        sort(a, 0, n-1, 0);
+    }
+
+    // return dth character of s, -1 if d = length of string
+    private static int charAt(String s, int d) {
+        assert d >= 0 && d <= s.length();
+        if (d == s.length()) return -1;
+        return s.charAt(d);
+    }
+
+    // sort from a[lo] to a[hi], starting at the dth character
+    private static void sort(String[] a, int lo, int hi, int d) {
+
+        // cutoff to insertion sort for small subarrays
+        if (hi <= lo + CUTOFF) {
+            insertion(a, lo, hi, d);
+            return;
+        }
+
+        // compute frequency counts
+        int[] heads = new int[R+2];
+        int[] tails = new int[R+1];
+        for (int i = lo; i <= hi; i++) {
+            int c = charAt(a[i], d);
+            heads[c+2]++;
+        }
+
+        // transform counts to indices
+        heads[0] = lo;
+        for (int r = 0; r < R+1; r++) {
+            heads[r+1] += heads[r];
+            tails[r] = heads[r+1];
+        }
+
+        // sort by d-th character in-place
+        for (int r = 0; r < R+1; r++) {
+            while (heads[r] < tails[r]) {
+                int c = charAt(a[heads[r]], d);
+                while (c + 1 != r) {
+                    exch(a, heads[r], heads[c+1]++);
+                    c = charAt(a[heads[r]], d);
+                }
+                heads[r]++;
+            }
+        }
+              
+        // recursively sort for each character (excludes sentinel -1)
+        for (int r = 0; r < R; r++)
+            sort(a, tails[r], tails[r+1] - 1, d+1);
+    }
+
+
+    // insertion sort a[lo..hi], starting at dth character
+    private static void insertion(String[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(String[] a, int i, int j) {
+        String temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+    // is v less than w, starting at character d
+    private static boolean less(String v, String w, int d) {
+        // assert v.substring(0, d).equals(w.substring(0, d));
+        for (int i = d; i < Math.min(v.length(), w.length()); i++) {
+            if (v.charAt(i) < w.charAt(i)) return true;
+            if (v.charAt(i) > w.charAt(i)) return false;
+        }
+        return v.length() < w.length();
+    }
+
+
+    /**
+     * Reads in a sequence of extended ASCII strings from standard input;
+     * in-place MSD radix sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        int n = a.length;
+        sort(a);
+        for (int i = 0; i < n; i++)
+            StdOut.println(a[i]);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Insertion.java b/src/main/java/edu/princeton/cs/algs4/Insertion.java
new file mode 100644
index 0000000..f0d5925
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Insertion.java
@@ -0,0 +1,235 @@
+/******************************************************************************
+ *  Compilation:  javac Insertion.java
+ *  Execution:    java Insertion < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/21elementary/tiny.txt
+ *                https://algs4.cs.princeton.edu/21elementary/words3.txt
+ *  
+ *  Sorts a sequence of strings from standard input using insertion sort.
+ *
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Insertion < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *
+ *  % java Insertion < words3.txt
+ *  all bad bed bug dad ... yes yet zoo   [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+
+/**
+ *  The {@code Insertion} class provides static methods for sorting an
+ *  array using insertion sort.
+ *  <p>
+ *  In the worst case, this implementation makes ~ &frac12; <em>n</em><sup>2</sup>
+ *  compares and ~ &frac12; <em>n</em><sup>2</sup> exchanges to sort an array
+ *  of length <em>n</em>. So, it is not suitable for sorting large arbitrary
+ *  arrays. More precisely, the number of exchanges is exactly equal to the
+ *  number of inversions. So, for example, it sorts a partially-sorted array
+ *  in linear time.
+ *  <p>
+ *  This sorting algorithm is stable.
+ *  It uses &Theta;(1) extra memory (not including the input array).
+ *  <p>
+ *  See <a href="https://algs4.cs.princeton.edu/21elementary/InsertionPedantic.java.html">InsertionPedantic.java</a>
+ *  for a version that eliminates the compiler warning.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/21elementary">Section 2.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Insertion {
+
+    // This class should not be instantiated.
+    private Insertion() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        int n = a.length;
+        for (int i = 1; i < n; i++) {
+            for (int j = i; j > 0 && less(a[j], a[j-1]); j--) {
+                exch(a, j, j-1);
+            }
+            assert isSorted(a, 0, i);
+        }
+        assert isSorted(a);
+    }
+
+    /**
+     * Rearranges the subarray a[lo..hi) in ascending order, using the natural order.
+     * @param a the array to be sorted
+     * @param lo left endpoint (inclusive)
+     * @param hi right endpoint (exclusive)
+     */
+    public static void sort(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i < hi; i++) {
+            for (int j = i; j > lo && less(a[j], a[j-1]); j--) {
+                exch(a, j, j-1);
+            }
+        }
+        assert isSorted(a, lo, hi);
+    }
+
+    /**
+     * Rearranges the array in ascending order, using a comparator.
+     * @param a the array
+     * @param comparator the comparator specifying the order
+     */
+    public static void sort(Object[] a, Comparator comparator) {
+        int n = a.length;
+        for (int i = 1; i < n; i++) {
+            for (int j = i; j > 0 && less(a[j], a[j-1], comparator); j--) {
+                exch(a, j, j-1);
+            }
+            assert isSorted(a, 0, i, comparator);
+        }
+        assert isSorted(a, comparator);
+    }
+
+    /**
+     * Rearranges the subarray a[lo..hi) in ascending order, using a comparator.
+     * @param a the array
+     * @param lo left endpoint (inclusive)
+     * @param hi right endpoint (exclusive)
+     * @param comparator the comparator specifying the order
+     */
+    public static void sort(Object[] a, int lo, int hi, Comparator comparator) {
+        for (int i = lo + 1; i < hi; i++) {
+            for (int j = i; j > lo && less(a[j], a[j-1], comparator); j--) {
+                exch(a, j, j-1);
+            }
+        }
+        assert isSorted(a, lo, hi, comparator);
+    }
+
+
+    // return a permutation that gives the elements in a[] in ascending order
+    // do not change the original array a[]
+    /**
+     * Returns a permutation that gives the elements in the array in ascending order.
+     * @param a the array
+     * @return a permutation {@code p[]} such that {@code a[p[0]]}, {@code a[p[1]]},
+     *    ..., {@code a[p[n-1]]} are in ascending order
+     */
+    public static int[] indexSort(Comparable[] a) {
+        int n = a.length;
+        int[] index = new int[n];
+        for (int i = 0; i < n; i++)
+            index[i] = i;
+
+        for (int i = 1; i < n; i++)
+            for (int j = i; j > 0 && less(a[index[j]], a[index[j-1]]); j--)
+                exch(index, j, j-1);
+
+        return index;
+    }
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+
+    // is v < w ?
+    private static boolean less(Object v, Object w, Comparator comparator) {
+        return comparator.compare(v, w) < 0;
+    }
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+    // exchange a[i] and a[j]  (for indirect sort)
+    private static void exch(int[] a, int i, int j) {
+        int swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length);
+    }
+
+    // is the array a[lo..hi) sorted
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i < hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    private static boolean isSorted(Object[] a, Comparator comparator) {
+        return isSorted(a, 0, a.length, comparator);
+    }
+
+    // is the array a[lo..hi) sorted
+    private static boolean isSorted(Object[] a, int lo, int hi, Comparator comparator) {
+        for (int i = lo + 1; i < hi; i++)
+            if (less(a[i], a[i-1], comparator)) return false;
+        return true;
+    }
+
+   // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; insertion sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Insertion.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/InsertionX.java b/src/main/java/edu/princeton/cs/algs4/InsertionX.java
new file mode 100644
index 0000000..ec68da4
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/InsertionX.java
@@ -0,0 +1,155 @@
+/******************************************************************************
+ *  Compilation:  javac InsertionX.java
+ *  Execution:    java InsertionX < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/21elementary/tiny.txt
+ *                https://algs4.cs.princeton.edu/21elementary/words3.txt
+ *  
+ *  Sorts a sequence of strings from standard input using an optimized
+ *  version of insertion sort that uses half exchanges instead of 
+ *  full exchanges to reduce data movement..
+ *
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java InsertionX < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *
+ *  % java InsertionX < words3.txt
+ *  all bad bed bug dad ... yes yet zoo   [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+/**
+ *  The {@code InsertionX} class provides static methods for sorting
+ *  an array using an optimized version of insertion sort (with half exchanges
+ *  and a sentinel).
+ *  <p>
+ *  In the worst case, this implementation makes ~ 1/2 <em>n</em><sup>2</sup>
+ *  compares to sort an array of length <em>n</em>.
+ *  So, it is not suitable for sorting large arrays
+ *  (unless the number of inversions is small).
+ *  <p>
+ *  This sorting algorithm is stable.
+ *  It uses &Theta;(1) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/21elementary">Section 2.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class InsertionX {
+
+    // This class should not be instantiated.
+    private InsertionX() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        int n = a.length;
+
+        // put smallest element in position to serve as sentinel
+        int exchanges = 0;
+        for (int i = n-1; i > 0; i--) {
+            if (less(a[i], a[i-1])) {
+                exch(a, i, i-1);
+                exchanges++;
+            }
+        }
+        if (exchanges == 0) return;
+
+
+        // insertion sort with half-exchanges
+        for (int i = 2; i < n; i++) {
+            Comparable v = a[i];
+            int j = i;
+            while (less(v, a[j-1])) {
+                a[j] = a[j-1];
+                j--;
+            }
+            a[j] = v;
+        }
+
+        assert isSorted(a);
+    }
+
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; insertion sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        InsertionX.sort(a);
+        show(a);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Interval1D.java b/src/main/java/edu/princeton/cs/algs4/Interval1D.java
new file mode 100644
index 0000000..578400e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Interval1D.java
@@ -0,0 +1,279 @@
+/******************************************************************************
+ *  Compilation:  javac Interval1D.java
+ *  Execution:    java Interval1D
+ *  Dependencies: StdOut.java
+ *  
+ *  1-dimensional interval data type.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+import java.util.Comparator;
+
+/**
+ *  The {@code Interval1D} class represents a one-dimensional interval.
+ *  The interval is <em>closed</em>‚Äîit contains both endpoints.
+ *  Intervals are immutable: their values cannot be changed after they are created.
+ *  The class {@code Interval1D} includes methods for checking whether
+ *  an interval contains a point and determining whether two intervals intersect.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Interval1D {
+
+    /**
+     * Compares two intervals by min endpoint.
+     */
+    public static final Comparator<Interval1D> MIN_ENDPOINT_ORDER  = new MinEndpointComparator();
+
+    /**
+     * Compares two intervals by max endpoint.
+     */
+    public static final Comparator<Interval1D> MAX_ENDPOINT_ORDER = new MaxEndpointComparator();
+
+    /**
+     * Compares two intervals by length.
+     */
+    public static final Comparator<Interval1D> LENGTH_ORDER = new LengthComparator();
+
+    private final double min;
+    private final double max;
+
+    /**
+     * Initializes a closed interval [min, max].
+     *
+     * @param  min the smaller endpoint
+     * @param  max the larger endpoint
+     * @throws IllegalArgumentException if the min endpoint is greater than the max endpoint
+     * @throws IllegalArgumentException if either {@code min} or {@code max}
+     *         is {@code Double.NaN}, {@code Double.POSITIVE_INFINITY} or
+     *         {@code Double.NEGATIVE_INFINITY}
+
+     */
+    public Interval1D(double min, double max) {
+        if (Double.isInfinite(min) || Double.isInfinite(max))
+            throw new IllegalArgumentException("Endpoints must be finite");
+        if (Double.isNaN(min) || Double.isNaN(max))
+            throw new IllegalArgumentException("Endpoints cannot be NaN");
+
+        // convert -0.0 to +0.0
+        if (min == 0.0) min = 0.0;
+        if (max == 0.0) max = 0.0;
+
+        if (min <= max) {
+            this.min = min;
+            this.max = max;
+        }
+        else throw new IllegalArgumentException("Illegal interval");
+    }
+
+    /**
+     * Returns the left endpoint of this interval.
+     *
+     * @return the left endpoint of this interval
+     * @deprecated Replaced by {@link #min()}.
+     */
+    @Deprecated
+    public double left() { 
+        return min;
+    }
+
+    /**
+     * Returns the right endpoint of this interval.
+     * @return the right endpoint of this interval
+     * @deprecated Replaced by {@link #max()}.
+     */
+    @Deprecated
+    public double right() { 
+        return max;
+    }
+
+    /**
+     * Returns the min endpoint of this interval.
+     *
+     * @return the min endpoint of this interval
+     */
+    public double min() { 
+        return min;
+    }
+
+    /**
+     * Returns the max endpoint of this interval.
+     *
+     * @return the max endpoint of this interval
+     */
+    public double max() { 
+        return max;
+    }
+
+    /**
+     * Returns true if this interval intersects the specified interval.
+     *
+     * @param  that the other interval
+     * @return {@code true} if this interval intersects the argument interval;
+     *         {@code false} otherwise
+     */
+    public boolean intersects(Interval1D that) {
+        if (this.max < that.min) return false;
+        if (that.max < this.min) return false;
+        return true;
+    }
+
+    /**
+     * Returns true if this interval contains the specified value.
+     *
+     * @param x the value
+     * @return {@code true} if this interval contains the value {@code x};
+     *         {@code false} otherwise
+     */
+    public boolean contains(double x) {
+        return (min <= x) && (x <= max);
+    }
+
+    /**
+     * Returns the length of this interval.
+     *
+     * @return the length of this interval (max - min)
+     */
+    public double length() {
+        return max - min;
+    }
+
+    /**
+     * Returns a string representation of this interval.
+     *
+     * @return a string representation of this interval in the form [min, max]
+     */
+    public String toString() {
+        return "[" + min + ", " + max + "]";
+    }
+
+    /**
+     * Compares this transaction to the specified object.
+     *
+     * @param  other the other interval
+     * @return {@code true} if this interval equals the other interval;
+     *         {@code false} otherwise
+     */
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Interval1D that = (Interval1D) other;
+        return this.min == that.min && this.max == that.max;
+    }
+
+    /**
+     * Returns an integer hash code for this interval.
+     *
+     * @return an integer hash code for this interval
+     */
+    public int hashCode() {
+        int hash1 = ((Double) min).hashCode();
+        int hash2 = ((Double) max).hashCode();
+        return 31*hash1 + hash2;
+    }
+
+    // ascending order of min endpoint, breaking ties by max endpoint
+    private static class MinEndpointComparator implements Comparator<Interval1D> {
+        public int compare(Interval1D a, Interval1D b) {
+            if      (a.min < b.min) return -1;
+            else if (a.min > b.min) return +1;
+            else if (a.max < b.max) return -1;
+            else if (a.max > b.max) return +1;
+            else                    return  0;
+        }
+    }
+
+    // ascending order of max endpoint, breaking ties by min endpoint
+    private static class MaxEndpointComparator implements Comparator<Interval1D> {
+        public int compare(Interval1D a, Interval1D b) {
+            if      (a.max < b.max) return -1;
+            else if (a.max > b.max) return +1;
+            else if (a.min < b.min) return -1;
+            else if (a.min > b.min) return +1;
+            else                    return  0;
+        }
+    }
+
+    // ascending order of length
+    private static class LengthComparator implements Comparator<Interval1D> {
+        public int compare(Interval1D a, Interval1D b) {
+            double alen = a.length();
+            double blen = b.length();
+            if      (alen < blen) return -1;
+            else if (alen > blen) return +1;
+            else                  return  0;
+        }
+    }
+
+
+
+
+    /**
+     * Unit tests the {@code Interval1D} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Interval1D[] intervals = new Interval1D[4];
+        intervals[0] = new Interval1D(15.0, 33.0);
+        intervals[1] = new Interval1D(45.0, 60.0);
+        intervals[2] = new Interval1D(20.0, 70.0);
+        intervals[3] = new Interval1D(46.0, 55.0);
+
+        StdOut.println("Unsorted");
+        for (int i = 0; i < intervals.length; i++)
+            StdOut.println(intervals[i]);
+        StdOut.println();
+        
+        StdOut.println("Sort by min endpoint");
+        Arrays.sort(intervals, Interval1D.MIN_ENDPOINT_ORDER);
+        for (int i = 0; i < intervals.length; i++)
+            StdOut.println(intervals[i]);
+        StdOut.println();
+
+        StdOut.println("Sort by max endpoint");
+        Arrays.sort(intervals, Interval1D.MAX_ENDPOINT_ORDER);
+        for (int i = 0; i < intervals.length; i++)
+            StdOut.println(intervals[i]);
+        StdOut.println();
+
+        StdOut.println("Sort by length");
+        Arrays.sort(intervals, Interval1D.LENGTH_ORDER);
+        for (int i = 0; i < intervals.length; i++)
+            StdOut.println(intervals[i]);
+        StdOut.println();
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Interval2D.java b/src/main/java/edu/princeton/cs/algs4/Interval2D.java
new file mode 100644
index 0000000..0d1c864
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Interval2D.java
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *  Compilation:  javac Interval2D.java
+ *  Execution:    java Interval2D
+ *  Dependencies: StdOut.java Interval1D.java StdDraw.java
+ *  
+ *  2-dimensional interval data type.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Interval2D} class represents a closed two-dimensional interval,
+ *  which represents all points (x, y) with both {@code xmin <= x <= xmax} and
+ *  {@code ymin <= y <= ymax}.
+ *  Two-dimensional intervals are immutable: their values cannot be changed
+ *  after they are created.
+ *  The class {@code Interval2D} includes methods for checking whether
+ *  a two-dimensional interval contains a point and determining whether
+ *  two two-dimensional intervals intersect.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Interval2D {
+    private final Interval1D x;
+    private final Interval1D y;
+
+    /**
+     * Initializes a two-dimensional interval.
+     * @param x the one-dimensional interval of x-coordinates
+     * @param y the one-dimensional interval of y-coordinates
+     */
+    public Interval2D(Interval1D x, Interval1D y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    /**
+     * Does this two-dimensional interval intersect that two-dimensional interval?
+     * @param that the other two-dimensional interval
+     * @return true if this two-dimensional interval intersects
+     *    that two-dimensional interval; false otherwise
+     */
+    public boolean intersects(Interval2D that) {
+        if (!this.x.intersects(that.x)) return false;
+        if (!this.y.intersects(that.y)) return false;
+        return true;
+    }
+
+    /**
+     * Does this two-dimensional interval contain the point p?
+     * @param p the two-dimensional point
+     * @return true if this two-dimensional interval contains the point p; false otherwise
+     */
+    public boolean contains(Point2D p) {
+        return x.contains(p.x())  && y.contains(p.y());
+    }
+
+    /**
+     * Returns the area of this two-dimensional interval.
+     * @return the area of this two-dimensional interval
+     */
+    public double area() {
+        return x.length() * y.length();
+    }
+        
+    /**
+     * Returns a string representation of this two-dimensional interval.
+     * @return a string representation of this two-dimensional interval
+     *    in the form [xmin, xmax] x [ymin, ymax]
+     */
+    public String toString() {
+        return x + " x " + y;
+    }
+
+    /**
+     * Does this interval equal the other interval?
+     * @param other the other interval
+     * @return true if this interval equals the other interval; false otherwise
+     */
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Interval2D that = (Interval2D) other;
+        return this.x.equals(that.x) && this.y.equals(that.y);
+    }
+
+ 
+    /**
+     * Returns an integer hash code for this interval.  
+     * @return an integer hash code for this interval 
+     */
+    public int hashCode() {
+        int hash1 = x.hashCode();
+        int hash2 = y.hashCode();
+        return 31*hash1 + hash2;
+    }
+
+    /**
+     * Draws this two-dimensional interval to standard draw.
+     */
+    public void draw() {
+        double xc = (x.min() + x.max()) / 2.0;
+        double yc = (y.min() + y.max()) / 2.0;
+        StdDraw.rectangle(xc, yc, x.length() / 2.0, y.length() / 2.0);
+    }
+
+    /**
+     * Unit tests the {@code Interval2D} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        double xmin = Double.parseDouble(args[0]);
+        double xmax = Double.parseDouble(args[1]);
+        double ymin = Double.parseDouble(args[2]);
+        double ymax = Double.parseDouble(args[3]);
+        int trials = Integer.parseInt(args[4]);
+
+        Interval1D xInterval = new Interval1D(xmin, xmax);
+        Interval1D yInterval = new Interval1D(ymin, ymax);
+        Interval2D box = new Interval2D(xInterval, yInterval);
+        box.draw();
+
+        Counter counter = new Counter("hits");
+        for (int t = 0; t < trials; t++) {
+            double x = StdRandom.uniform(0.0, 1.0);
+            double y = StdRandom.uniform(0.0, 1.0);
+            Point2D point = new Point2D(x, y);
+
+            if (box.contains(point)) counter.increment();
+            else                     point.draw();
+        }
+
+        StdOut.println(counter);
+        StdOut.printf("box area = %.2f\n", box.area());
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Inversions.java b/src/main/java/edu/princeton/cs/algs4/Inversions.java
new file mode 100644
index 0000000..68939cb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Inversions.java
@@ -0,0 +1,201 @@
+/******************************************************************************
+ *  Compilation:  javac Inversions.java
+ *  Execution:    java Inversions < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  
+ *  Read array of n integers and count number of inversions in n log n time.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Inversions} class provides static methods to count the 
+ *  number of <em>inversions</em> in either an array of integers or comparables.
+ *  An inversion in an array {@code a[]} is a pair of indicies {@code i} and
+ *  {@code j} such that {@code i < j} and {@code a[i] > a[j]}.
+ *  <p>
+ *  This implementation uses a generalization of mergesort. The <em>count</em>
+ *  operation takes &Theta;(<em>n</em> log <em>n</em>) time to count the
+ *  number of inversions in any array of length <em>n</em> (assuming
+ *  comparisons take constant time).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/22mergesort">Section 2.2</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Inversions {
+
+    // do not instantiate
+    private Inversions() { }
+
+    // merge and count
+    private static long merge(int[] a, int[] aux, int lo, int mid, int hi) {
+        long inversions = 0;
+
+        // copy to aux[]
+        for (int k = lo; k <= hi; k++) {
+            aux[k] = a[k]; 
+        }
+
+        // merge back to a[]
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)           a[k] = aux[j++];
+            else if (j > hi)            a[k] = aux[i++];
+            else if (aux[j] < aux[i]) { a[k] = aux[j++]; inversions += (mid - i + 1); }
+            else                        a[k] = aux[i++];
+        }
+        return inversions;
+    }
+
+    // return the number of inversions in the subarray b[lo..hi]
+    // side effect b[lo..hi] is rearranged in ascending order
+    private static long count(int[] a, int[] b, int[] aux, int lo, int hi) {
+        long inversions = 0;
+        if (hi <= lo) return 0;
+        int mid = lo + (hi - lo) / 2;
+        inversions += count(a, b, aux, lo, mid);  
+        inversions += count(a, b, aux, mid+1, hi);
+        inversions += merge(b, aux, lo, mid, hi);
+        assert inversions == brute(a, lo, hi);
+        return inversions;
+    }
+
+
+    /**
+     * Returns the number of inversions in the integer array.
+     * The argument array is not modified.
+     * @param  a the array
+     * @return the number of inversions in the array. An inversion is a pair of 
+     *         indicies {@code i} and {@code j} such that {@code i < j}
+     *         and {@code a[i] > a[j]}.
+     */
+    public static long count(int[] a) {
+        int[] b   = new int[a.length];
+        int[] aux = new int[a.length];
+        for (int i = 0; i < a.length; i++)
+            b[i] = a[i];
+        long inversions = count(a, b, aux, 0, a.length - 1);
+        return inversions;
+    }
+
+
+
+    // merge and count (Comparable version)
+    private static <Key extends Comparable<Key>> long merge(Key[] a, Key[] aux, int lo, int mid, int hi) {
+        long inversions = 0;
+
+        // copy to aux[]
+        for (int k = lo; k <= hi; k++) {
+            aux[k] = a[k]; 
+        }
+
+        // merge back to a[]
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)                a[k] = aux[j++];
+            else if (j > hi)                 a[k] = aux[i++];
+            else if (less(aux[j], aux[i])) { a[k] = aux[j++]; inversions += (mid - i + 1); }
+            else                             a[k] = aux[i++];
+        }
+        return inversions;
+    }
+
+    // return the number of inversions in the subarray b[lo..hi]
+    // side effect b[lo..hi] is rearranged in ascending order
+    private static <Key extends Comparable<Key>> long count(Key[] a, Key[] b, Key[] aux, int lo, int hi) {
+        long inversions = 0;
+        if (hi <= lo) return 0;
+        int mid = lo + (hi - lo) / 2;
+        inversions += count(a, b, aux, lo, mid);  
+        inversions += count(a, b, aux, mid+1, hi);
+        inversions += merge(b, aux, lo, mid, hi);
+        assert inversions == brute(a, lo, hi);
+        return inversions;
+    }
+
+
+    /**
+     * Returns the number of inversions in the comparable array.
+     * The argument array is not modified.
+     * @param  a the array
+     * @param <Key> the inferred type of the elements in the array
+     * @return the number of inversions in the array. An inversion is a pair of 
+     *         indicies {@code i} and {@code j} such that {@code i < j}
+     *         and {@code a[i].compareTo(a[j]) > 0}.
+     */
+    public static <Key extends Comparable<Key>> long count(Key[] a) {
+        Key[] b   = a.clone();
+        Key[] aux = a.clone();
+        long inversions = count(a, b, aux, 0, a.length - 1);
+        return inversions;
+    }
+
+
+    // is v < w ?
+    private static <Key extends Comparable<Key>> boolean less(Key v, Key w) {
+        return (v.compareTo(w) < 0);
+    }
+
+    // count number of inversions in a[lo..hi] via brute force (for debugging only)
+    private static <Key extends Comparable<Key>> long brute(Key[] a, int lo, int hi) {
+        long inversions = 0;
+        for (int i = lo; i <= hi; i++)
+            for (int j = i + 1; j <= hi; j++)
+                if (less(a[j], a[i])) inversions++;
+        return inversions;
+    }
+
+    // count number of inversions in a[lo..hi] via brute force (for debugging only)
+    private static long brute(int[] a, int lo, int hi) {
+        long inversions = 0;
+        for (int i = lo; i <= hi; i++)
+            for (int j = i + 1; j <= hi; j++)
+                if (a[j] < a[i]) inversions++;
+        return inversions;
+    }
+
+    /**
+     * Reads a sequence of integers from standard input and
+     * prints the number of inversions to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int[] a = StdIn.readAllInts();
+        int n = a.length;
+        Integer[] b = new Integer[n];
+        for (int i = 0; i < n; i++)
+            b[i] = a[i];
+        StdOut.println(Inversions.count(a));
+        StdOut.println(Inversions.count(b));
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/KMP.java b/src/main/java/edu/princeton/cs/algs4/KMP.java
new file mode 100644
index 0000000..d5bdce3
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/KMP.java
@@ -0,0 +1,192 @@
+/******************************************************************************
+ *  Compilation:  javac KMP.java
+ *  Execution:    java KMP pattern text
+ *  Dependencies: StdOut.java
+ *
+ *  Reads in two strings, the pattern and the input text, and
+ *  searches for the pattern in the input text using the
+ *  KMP algorithm.
+ *
+ *  % java KMP abracadabra abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  pattern:               abracadabra          
+ *
+ *  % java KMP rab abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  pattern:         rab
+ *
+ *  % java KMP bcara abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  pattern:                                   bcara
+ *
+ *  % java KMP rabrabracad abacadabrabracabracadabrabrabracad 
+ *  text:    abacadabrabracabracadabrabrabracad
+ *  pattern:                        rabrabracad
+ *
+ *  % java KMP abacad abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad
+ *  pattern: abacad
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code KMP} class finds the first occurrence of a pattern string
+ *  in a text string.
+ *  <p>
+ *  This implementation uses a version of the Knuth-Morris-Pratt substring search
+ *  algorithm. The version takes time proportional to <em>n</em> + <em>m R</em>
+ *  in the worst case, where <em>n</em> is the length of the text string,
+ *  <em>m</em> is the length of the pattern, and <em>R</em> is the alphabet size.
+ *  It uses extra space proportional to <em>m R</em>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/53substring">Section 5.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class KMP {
+    private final int R;       // the radix
+    private final int m;       // length of pattern
+    private int[][] dfa;       // the KMP automoton
+
+    /**
+     * Preprocesses the pattern string.
+     *
+     * @param pat the pattern string
+     */
+    public KMP(String pat) {
+        this.R = 256;
+        this.m = pat.length();
+
+        // build DFA from pattern
+        dfa = new int[R][m]; 
+        dfa[pat.charAt(0)][0] = 1; 
+        for (int x = 0, j = 1; j < m; j++) {
+            for (int c = 0; c < R; c++) 
+                dfa[c][j] = dfa[c][x];     // Copy mismatch cases. 
+            dfa[pat.charAt(j)][j] = j+1;   // Set match case. 
+            x = dfa[pat.charAt(j)][x];     // Update restart state. 
+        } 
+    } 
+
+    /**
+     * Preprocesses the pattern string.
+     *
+     * @param pattern the pattern string
+     * @param R the alphabet size
+     */
+    public KMP(char[] pattern, int R) {
+        this.R = R;
+        this.m = pattern.length;
+
+        // build DFA from pattern
+        int m = pattern.length;
+        dfa = new int[R][m]; 
+        dfa[pattern[0]][0] = 1; 
+        for (int x = 0, j = 1; j < m; j++) {
+            for (int c = 0; c < R; c++) 
+                dfa[c][j] = dfa[c][x];     // Copy mismatch cases. 
+            dfa[pattern[j]][j] = j+1;      // Set match case. 
+            x = dfa[pattern[j]][x];        // Update restart state. 
+        } 
+    } 
+
+    /**
+     * Returns the index of the first occurrrence of the pattern string
+     * in the text string.
+     *
+     * @param  txt the text string
+     * @return the index of the first occurrence of the pattern string
+     *         in the text string; N if no such match
+     */
+    public int search(String txt) {
+
+        // simulate operation of DFA on text
+        int n = txt.length();
+        int i, j;
+        for (i = 0, j = 0; i < n && j < m; i++) {
+            j = dfa[txt.charAt(i)][j];
+        }
+        if (j == m) return i - m;    // found
+        return n;                    // not found
+    }
+
+    /**
+     * Returns the index of the first occurrrence of the pattern string
+     * in the text string.
+     *
+     * @param  text the text string
+     * @return the index of the first occurrence of the pattern string
+     *         in the text string; N if no such match
+     */
+    public int search(char[] text) {
+
+        // simulate operation of DFA on text
+        int n = text.length;
+        int i, j;
+        for (i = 0, j = 0; i < n && j < m; i++) {
+            j = dfa[text[i]][j];
+        }
+        if (j == m) return i - m;    // found
+        return n;                    // not found
+    }
+
+
+    /** 
+     * Takes a pattern string and an input string as command-line arguments;
+     * searches for the pattern string in the text string; and prints
+     * the first occurrence of the pattern string in the text string.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String pat = args[0];
+        String txt = args[1];
+        char[] pattern = pat.toCharArray();
+        char[] text    = txt.toCharArray();
+
+        KMP kmp1 = new KMP(pat);
+        int offset1 = kmp1.search(txt);
+
+        KMP kmp2 = new KMP(pattern, 256);
+        int offset2 = kmp2.search(text);
+
+        // print results
+        StdOut.println("text:    " + txt);
+
+        StdOut.print("pattern: ");
+        for (int i = 0; i < offset1; i++)
+            StdOut.print(" ");
+        StdOut.println(pat);
+
+        StdOut.print("pattern: ");
+        for (int i = 0; i < offset2; i++)
+            StdOut.print(" ");
+        StdOut.println(pat);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/KWIK.java b/src/main/java/edu/princeton/cs/algs4/KWIK.java
new file mode 100644
index 0000000..f3624cb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/KWIK.java
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *  Compilation:  javac KWIK.java
+ *  Execution:    java KWIK file.txt
+ *  Dependencies: StdIn.java StdOut.java In.java SuffixArray.java
+ *  Data files:   https://algs4.cs.princeton.edu/63suffix/tale.txt
+ *                https://algs4.cs.princeton.edu/63suffix/mobydick.txt 
+ *
+ *  Keyword-in-context search.
+ *
+ *  %  java KWIK tale.txt 15
+ *  majesty
+ *   most gracious majesty king george th
+ *  rnkeys and the majesty of the law fir
+ *  on against the majesty of the people 
+ *  se them to his majestys chief secreta
+ *  h lists of his majestys forces and of
+ *
+ *  the worst
+ *  w the best and the worst are known to y
+ *  f them give me the worst first there th
+ *  for in case of the worst is a friend in
+ *  e roomdoor and the worst is over then a
+ *  pect mr darnay the worst its the wisest
+ *  is his brother the worst of a bad race 
+ *  ss in them for the worst of health for 
+ *   you have seen the worst of her agitati
+ *  cumwented into the worst of luck buuust
+ *  n your brother the worst of the bad rac
+ *   full share in the worst of the day pla
+ *  mes to himself the worst of the strife 
+ *  f times it was the worst of times it wa
+ *  ould hope that the worst was over well 
+ *  urage business the worst will be over i
+ *  clesiastics of the worst world worldly 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code KWIK} class provides a {@link SuffixArray} client for computing
+ *  all occurrences of a keyword in a given string, with surrounding context.
+ *  This is known as <em>keyword-in-context search</em>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/63suffix">Section 6.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class KWIK {
+
+    // Do not instantiate.
+    private KWIK() { }
+
+    /**
+     * Reads a string from a file specified as the first
+     * command-line argument; read an integer k specified as the
+     * second command line argument; then repeatedly processes
+     * use queries, printing all occurrences of the given query
+     * string in the text string with k characters of surrounding
+     * context on either side.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        int context = Integer.parseInt(args[1]);
+
+        // read in text
+        String text = in.readAll().replaceAll("\\s+", " ");
+        int n = text.length();
+
+        // build suffix array
+        SuffixArray sa = new SuffixArray(text);
+
+        // find all occurrences of queries and give context
+        while (StdIn.hasNextLine()) {
+            String query = StdIn.readLine();
+            for (int i = sa.rank(query); i < n; i++) {
+                int from1 = sa.index(i);
+                int to1   = Math.min(n, from1 + query.length());
+                if (!query.equals(text.substring(from1, to1))) break;
+                int from2 = Math.max(0, sa.index(i) - context);
+                int to2   = Math.min(n, sa.index(i) + context + query.length());
+                StdOut.println(text.substring(from2, to2));
+            }
+            StdOut.println();
+        }
+    } 
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Knuth.java b/src/main/java/edu/princeton/cs/algs4/Knuth.java
new file mode 100644
index 0000000..f55dbf0
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Knuth.java
@@ -0,0 +1,146 @@
+/******************************************************************************
+ *  Compilation:  javac Knuth.java
+ *  Execution:    java Knuth < list.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/11model/cards.txt
+ *                https://algs4.cs.princeton.edu/11model/cardsUnicode.txt
+ *  
+ *  Reads in a list of strings and prints them in random order.
+ *  The Knuth (or Fisher-Yates) shuffling algorithm guarantees
+ *  to rearrange the elements in uniformly random order, under
+ *  the assumption that Math.random() generates independent and
+ *  uniformly distributed numbers between 0 and 1.
+ *
+ *  % more cards.txt
+ *  2C 3C 4C 5C 6C 7C 8C 9C 10C JC QC KC AC
+ *  2D 3D 4D 5D 6D 7D 8D 9D 10D JD QD KD AD
+ *  2H 3H 4H 5H 6H 7H 8H 9H 10H JH QH KH AH
+ *  2S 3S 4S 5S 6S 7S 8S 9S 10S JS QS KS AS
+ *
+ *  % java Knuth < cards.txt
+ *  6H
+ *  9C
+ *  8H
+ *  7C
+ *  JS
+ *  ...
+ *  KH
+ *
+ *  % more cardsUnicode.txt
+ *  2‚ô£ 3‚ô£ 4‚ô£ 5‚ô£ 6‚ô£ 7‚ô£ 8‚ô£ 9‚ô£ 10‚ô£ J‚ô£ Q‚ô£ K‚ô£ A‚ô£ 
+ *  2‚ô¶ 3‚ô¶ 4‚ô¶ 5‚ô¶ 6‚ô¶ 7‚ô¶ 8‚ô¶ 9‚ô¶ 10‚ô¶ J‚ô¶ Q‚ô¶ K‚ô¶ A‚ô¶ 
+ *  2‚ô• 3‚ô• 4‚ô• 5‚ô• 6‚ô• 7‚ô• 8‚ô• 9‚ô• 10‚ô• J‚ô• Q‚ô• K‚ô• A‚ô• 
+ *  2‚ô† 3‚ô† 4‚ô† 5‚ô† 6‚ô† 7‚ô† 8‚ô† 9‚ô† 10‚ô† J‚ô† Q‚ô† K‚ô† A‚ô† 
+ * 
+ *  % java Knuth < cardsUnicode.txt
+ *  2‚ô†
+ *  K‚ô•
+ *  6‚ô•
+ *  5‚ô£
+ *  J‚ô£
+ *  ...
+ *  A‚ô¶
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Knuth} class provides a client for reading in a 
+ *  sequence of strings and <em>shuffling</em> them using the Knuth (or Fisher-Yates)
+ *  shuffling algorithm. This algorithm guarantees to rearrange the
+ *  elements in uniformly random order, under
+ *  the assumption that Math.random() generates independent and
+ *  uniformly distributed numbers between 0 and 1.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/11model">Section 1.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  See {@link StdRandom} for versions that shuffle arrays and
+ *  subarrays of objects, doubles, and ints.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Knuth { 
+
+    // this class should not be instantiated
+    private Knuth() { }
+
+    /**
+     * Rearranges an array of objects in uniformly random order
+     * (under the assumption that {@code Math.random()} generates independent
+     * and uniformly distributed numbers between 0 and 1).
+     * @param a the array to be shuffled
+     */
+    public static void shuffle(Object[] a) {
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            // choose index uniformly in [0, i]
+            int r = (int) (Math.random() * (i + 1));
+            Object swap = a[r];
+            a[r] = a[i];
+            a[i] = swap;
+        }
+    }
+
+    /**
+     * Rearranges an array of objects in uniformly random order
+     * (under the assumption that {@code Math.random()} generates independent
+     * and uniformly distributed numbers between 0 and 1).
+     * @param a the array to be shuffled
+     */
+    public static void shuffleAlternate(Object[] a) {
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            // choose index uniformly in [i, n-1]
+            int r = i + (int) (Math.random() * (n - i));
+            Object swap = a[r];
+            a[r] = a[i];
+            a[i] = swap;
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input, shuffles
+     * them, and prints out the results.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read in the data
+        String[] a = StdIn.readAllStrings();
+
+        // shuffle the array
+        Knuth.shuffle(a);
+
+        // print results.
+        for (int i = 0; i < a.length; i++)
+            StdOut.println(a[i]);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/KosarajuSharirSCC.java b/src/main/java/edu/princeton/cs/algs4/KosarajuSharirSCC.java
new file mode 100644
index 0000000..4313c2d
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/KosarajuSharirSCC.java
@@ -0,0 +1,243 @@
+/******************************************************************************
+ *  Compilation:  javac KosarajuSharirSCC.java
+ *  Execution:    java KosarajuSharirSCC filename.txt
+ *  Dependencies: Digraph.java TransitiveClosure.java StdOut.java In.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Compute the strongly-connected components of a digraph using the
+ *  Kosaraju-Sharir algorithm.
+ *
+ *  Runs in O(E + V) time.
+ *
+ *  % java KosarajuSharirSCC tinyDG.txt
+ *  5 strong components
+ *  1 
+ *  0 2 3 4 5 
+ *  9 10 11 12 
+ *  6 8 
+ *  7
+ *
+ *  % java KosarajuSharirSCC mediumDG.txt 
+ *  10 strong components
+ *  21 
+ *  2 5 6 8 9 11 12 13 15 16 18 19 22 23 25 26 28 29 30 31 32 33 34 35 37 38 39 40 42 43 44 46 47 48 49 
+ *  14 
+ *  3 4 17 20 24 27 36 
+ *  41 
+ *  7 
+ *  45 
+ *  1 
+ *  0 
+ *  10 
+ *
+ *  % java -Xss50m KosarajuSharirSCC mediumDG.txt 
+ *  25 strong components
+ *  7 11 32 36 61 84 95 116 121 128 230   ...
+ *  28 73 80 104 115 143 149 164 184 185  ...
+ *  38 40 200 201 207 218 286 387 418 422 ...
+ *  12 14 56 78 87 103 216 269 271 272    ...
+ *  42 48 112 135 160 217 243 246 273 346 ...
+ *  46 76 96 97 224 237 297 303 308 309   ...
+ *  9 15 21 22 27 90 167 214 220 225 227  ...
+ *  74 99 133 146 161 166 202 205 245 262 ...
+ *  43 83 94 120 125 183 195 206 244 254  ...
+ *  1 13 54 91 92 93 106 140 156 194 208  ...
+ *  10 39 67 69 131 144 145 154 168 258   ...
+ *  6 52 66 113 118 122 139 147 212 213   ...
+ *  8 127 150 182 203 204 249 367 400 432 ...
+ *  63 65 101 107 108 136 169 170 171 173 ...
+ *  55 71 102 155 159 198 228 252 325 419 ...
+ *  4 25 34 58 70 152 172 196 199 210 226 ...
+ *  2 44 50 88 109 138 141 178 197 211    ...
+ *  57 89 129 162 174 179 188 209 238 276 ...
+ *  33 41 49 119 126 132 148 181 215 221  ...
+ *  3 18 23 26 35 64 105 124 157 186 251  ...
+ *  5 16 17 20 31 47 81 98 158 180 187    ...
+ *  24 29 51 59 75 82 100 114 117 134 151 ...
+ *  30 45 53 60 72 85 111 130 137 142 163 ...
+ *  19 37 62 77 79 110 153 352 353 361    ...
+ *  0 68 86 123 165 176 193 239 289 336   ...
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code KosarajuSharirSCC} class represents a data type for 
+ *  determining the strong components in a digraph.
+ *  The <em>id</em> operation determines in which strong component
+ *  a given vertex lies; the <em>areStronglyConnected</em> operation
+ *  determines whether two vertices are in the same strong component;
+ *  and the <em>count</em> operation determines the number of strong
+ *  components.
+ *  <p>
+ *  The <em>component identifier</em> of a component is one of the
+ *  vertices in the strong component: two vertices have the same component
+ *  identifier if and only if they are in the same strong component.
+ *  <p>
+ *  This implementation uses the Kosaraju-Sharir algorithm.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time,
+ *  where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  For alternative implementations of the same API, see
+ *  {@link TarjanSCC} and {@link GabowSCC}.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class KosarajuSharirSCC {
+    private boolean[] marked;     // marked[v] = has vertex v been visited?
+    private int[] id;             // id[v] = id of strong component containing v
+    private int count;            // number of strongly-connected components
+
+    /**
+     * Computes the strong components of the digraph {@code G}.
+     * @param G the digraph
+     */
+    public KosarajuSharirSCC(Digraph G) {
+
+        // compute reverse postorder of reverse graph
+        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());
+
+        // run DFS on G, using reverse postorder to guide calculation
+        marked = new boolean[G.V()];
+        id = new int[G.V()];
+        for (int v : dfs.reversePost()) {
+            if (!marked[v]) {
+                dfs(G, v);
+                count++;
+            }
+        }
+
+        // check that id[] gives strong components
+        assert check(G);
+    }
+
+    // DFS on graph G
+    private void dfs(Digraph G, int v) { 
+        marked[v] = true;
+        id[v] = count;
+        for (int w : G.adj(v)) {
+            if (!marked[w]) dfs(G, w);
+        }
+    }
+
+    /**
+     * Returns the number of strong components.
+     * @return the number of strong components
+     */
+    public int count() {
+        return count;
+    }
+
+    /**
+     * Are vertices {@code v} and {@code w} in the same strong component?
+     * @param  v one vertex
+     * @param  w the other vertex
+     * @return {@code true} if vertices {@code v} and {@code w} are in the same
+     *         strong component, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @throws IllegalArgumentException unless {@code 0 <= w < V}
+     */
+    public boolean stronglyConnected(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        return id[v] == id[w];
+    }
+
+    /**
+     * Returns the component id of the strong component containing vertex {@code v}.
+     * @param  v the vertex
+     * @return the component id of the strong component containing vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public int id(int v) {
+        validateVertex(v);
+        return id[v];
+    }
+
+    // does the id[] array contain the strongly connected components?
+    private boolean check(Digraph G) {
+        TransitiveClosure tc = new TransitiveClosure(G);
+        for (int v = 0; v < G.V(); v++) {
+            for (int w = 0; w < G.V(); w++) {
+                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code KosarajuSharirSCC} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        KosarajuSharirSCC scc = new KosarajuSharirSCC(G);
+
+        // number of connected components
+        int m = scc.count();
+        StdOut.println(m + " strong components");
+
+        // compute list of vertices in each strong component
+        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
+        for (int i = 0; i < m; i++) {
+            components[i] = new Queue<Integer>();
+        }
+        for (int v = 0; v < G.V(); v++) {
+            components[scc.id(v)].enqueue(v);
+        }
+
+        // print results
+        for (int i = 0; i < m; i++) {
+            for (int v : components[i]) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/KruskalMST.java b/src/main/java/edu/princeton/cs/algs4/KruskalMST.java
new file mode 100644
index 0000000..b1a5438
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/KruskalMST.java
@@ -0,0 +1,229 @@
+/******************************************************************************
+ *  Compilation:  javac KruskalMST.java
+ *  Execution:    java  KruskalMST filename.txt
+ *  Dependencies: EdgeWeightedGraph.java Edge.java Queue.java MinPQ.java
+ *                UF.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/largeEWG.txt
+ *
+ *  Compute a minimum spanning forest using Kruskal's algorithm.
+ *
+ *  %  java KruskalMST tinyEWG.txt 
+ *  0-7 0.16000
+ *  2-3 0.17000
+ *  1-7 0.19000
+ *  0-2 0.26000
+ *  5-7 0.28000
+ *  4-5 0.35000
+ *  6-2 0.40000
+ *  1.81000
+ *
+ *  % java KruskalMST mediumEWG.txt
+ *  168-231 0.00268
+ *  151-208 0.00391
+ *  7-157   0.00516
+ *  122-205 0.00647
+ *  8-152   0.00702
+ *  156-219 0.00745
+ *  28-198  0.00775
+ *  38-126  0.00845
+ *  10-123  0.00886
+ *  ...
+ *  10.46351
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ *  The {@code KruskalMST} class represents a data type for computing a
+ *  <em>minimum spanning tree</em> in an edge-weighted graph.
+ *  The edge weights can be positive, zero, or negative and need not
+ *  be distinct. If the graph is not connected, it computes a <em>minimum
+ *  spanning forest</em>, which is the union of minimum spanning trees
+ *  in each connected component. The {@code weight()} method returns the 
+ *  weight of a minimum spanning tree and the {@code edges()} method
+ *  returns its edges.
+ *  <p>
+ *  This implementation uses <em>Krusal's algorithm</em> and the
+ *  union-find data type.
+ *  The constructor takes &Theta;(<em>E</em> log <em>E</em>) time in
+ *  the worst case.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>E</em>) extra space (not including the graph).
+ *  <p>
+ *  This {@code weight()} method correctly computes the weight of the MST
+ *  if all arithmetic performed is without floating-point rounding error
+ *  or arithmetic overflow.
+ *  This is the case if all edge weights are non-negative integers
+ *  and the weight of the MST does not exceed 2<sup>52</sup>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For alternate implementations, see {@link LazyPrimMST}, {@link PrimMST},
+ *  and {@link BoruvkaMST}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class KruskalMST {
+    private static final double FLOATING_POINT_EPSILON = 1E-12;
+
+    private double weight;                        // weight of MST
+    private Queue<Edge> mst = new Queue<Edge>();  // edges in MST
+
+    /**
+     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
+     * @param G the edge-weighted graph
+     */
+    public KruskalMST(EdgeWeightedGraph G) {
+
+        // create array of edges, sorted by weight
+        Edge[] edges = new Edge[G.E()];
+        int t = 0;
+        for (Edge e: G.edges()) {
+            edges[t++] = e;
+        }
+        Arrays.sort(edges);
+
+        // run greedy algorithm
+        UF uf = new UF(G.V());
+        for (int i = 0; i < G.E() && mst.size() < G.V() - 1; i++) {
+            Edge e = edges[i];
+            int v = e.either();
+            int w = e.other(v);
+
+            // v-w does not create a cycle
+            if (uf.find(v) != uf.find(w)) {
+                uf.union(v, w);     // merge v and w components
+                mst.enqueue(e);     // add edge e to mst
+                weight += e.weight();
+            }
+        }
+
+        // check optimality conditions
+        assert check(G);
+    }
+
+    /**
+     * Returns the edges in a minimum spanning tree (or forest).
+     * @return the edges in a minimum spanning tree (or forest) as
+     *    an iterable of edges
+     */
+    public Iterable<Edge> edges() {
+        return mst;
+    }
+
+    /**
+     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
+     * @return the sum of the edge weights in a minimum spanning tree (or forest)
+     */
+    public double weight() {
+        return weight;
+    }
+    
+    // check optimality conditions (takes time proportional to E V lg* V)
+    private boolean check(EdgeWeightedGraph G) {
+
+        // check total weight
+        double total = 0.0;
+        for (Edge e : edges()) {
+            total += e.weight();
+        }
+        if (Math.abs(total - weight()) > FLOATING_POINT_EPSILON) {
+            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", total, weight());
+            return false;
+        }
+
+        // check that it is acyclic
+        UF uf = new UF(G.V());
+        for (Edge e : edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) == uf.find(w)) {
+                System.err.println("Not a forest");
+                return false;
+            }
+            uf.union(v, w);
+        }
+
+        // check that it is a spanning forest
+        for (Edge e : G.edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) != uf.find(w)) {
+                System.err.println("Not a spanning forest");
+                return false;
+            }
+        }
+
+        // check that it is a minimal spanning forest (cut optimality conditions)
+        for (Edge e : edges()) {
+
+            // all edges in MST except e
+            uf = new UF(G.V());
+            for (Edge f : mst) {
+                int x = f.either(), y = f.other(x);
+                if (f != e) uf.union(x, y);
+            }
+            
+            // check that e is min weight edge in crossing cut
+            for (Edge f : G.edges()) {
+                int x = f.either(), y = f.other(x);
+                if (uf.find(x) != uf.find(y)) {
+                    if (f.weight() < e.weight()) {
+                        System.err.println("Edge " + f + " violates cut optimality conditions");
+                        return false;
+                    }
+                }
+            }
+
+        }
+
+        return true;
+    }
+
+
+    /**
+     * Unit tests the {@code KruskalMST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        KruskalMST mst = new KruskalMST(G);
+        for (Edge e : mst.edges()) {
+            StdOut.println(e);
+        }
+        StdOut.printf("%.5f\n", mst.weight());
+    }
+
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LSD.java b/src/main/java/edu/princeton/cs/algs4/LSD.java
new file mode 100644
index 0000000..c382a21
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LSD.java
@@ -0,0 +1,179 @@
+/******************************************************************************
+ *  Compilation:  javac LSD.java
+ *  Execution:    java LSD < input.txt
+ *  Dependencies: StdIn.java StdOut.java 
+ *  Data files:   https://algs4.cs.princeton.edu/51radix/words3.txt
+ *
+ *  LSD radix sort
+ *
+ *    - Sort a String[] array of n extended ASCII strings (R = 256), each of length w.
+ *
+ *    - Sort an int[] array of n 32-bit integers, treating each integer as 
+ *      a sequence of w = 4 bytes (R = 256).
+ *
+ *  Uses extra space proportional to n + R.
+ *
+ *
+ *  % java LSD < words3.txt
+ *  all
+ *  bad
+ *  bed
+ *  bug
+ *  dad
+ *  ...
+ *  yes
+ *  yet
+ *  zoo
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LSD} class provides static methods for sorting an
+ *  array of <em>w</em>-character strings or 32-bit integers using LSD radix sort.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/51radix">Section 5.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LSD {
+    private static final int BITS_PER_BYTE = 8;
+
+    // do not instantiate
+    private LSD() { }
+
+   /**  
+     * Rearranges the array of w-character strings in ascending order.
+     *
+     * @param a the array to be sorted
+     * @param w the number of characters per string
+     */
+    public static void sort(String[] a, int w) {
+        int n = a.length;
+        int R = 256;   // extend ASCII alphabet size
+        String[] aux = new String[n];
+
+        for (int d = w-1; d >= 0; d--) {
+            // sort by key-indexed counting on dth character
+
+            // compute frequency counts
+            int[] count = new int[R+1];
+            for (int i = 0; i < n; i++)
+                count[a[i].charAt(d) + 1]++;
+
+            // compute cumulates
+            for (int r = 0; r < R; r++)
+                count[r+1] += count[r];
+
+            // move data
+            for (int i = 0; i < n; i++)
+                aux[count[a[i].charAt(d)]++] = a[i];
+
+            // copy back
+            for (int i = 0; i < n; i++)
+                a[i] = aux[i];
+        }
+    }
+
+   /**
+     * Rearranges the array of 32-bit integers in ascending order.
+     * This is about 2-3x faster than Arrays.sort().
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(int[] a) {
+        final int BITS = 32;                 // each int is 32 bits 
+        final int R = 1 << BITS_PER_BYTE;    // each bytes is between 0 and 255
+        final int MASK = R - 1;              // 0xFF
+        final int w = BITS / BITS_PER_BYTE;  // each int is 4 bytes
+
+        int n = a.length;
+        int[] aux = new int[n];
+
+        for (int d = 0; d < w; d++) {         
+
+            // compute frequency counts
+            int[] count = new int[R+1];
+            for (int i = 0; i < n; i++) {           
+                int c = (a[i] >> BITS_PER_BYTE*d) & MASK;
+                count[c + 1]++;
+            }
+
+            // compute cumulates
+            for (int r = 0; r < R; r++)
+                count[r+1] += count[r];
+
+            // for most significant byte, 0x80-0xFF comes before 0x00-0x7F
+            if (d == w-1) {
+                int shift1 = count[R] - count[R/2];
+                int shift2 = count[R/2];
+                for (int r = 0; r < R/2; r++)
+                    count[r] += shift1;
+                for (int r = R/2; r < R; r++)
+                    count[r] -= shift2;
+            }
+
+            // move data
+            for (int i = 0; i < n; i++) {
+                int c = (a[i] >> BITS_PER_BYTE*d) & MASK;
+                aux[count[c]++] = a[i];
+            }
+
+            // copy back
+            for (int i = 0; i < n; i++)
+                a[i] = aux[i];
+        }
+    }
+
+    /**
+     * Reads in a sequence of fixed-length strings from standard input;
+     * LSD radix sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        int n = a.length;
+
+        // check that strings have fixed length
+        int w = a[0].length();
+        for (int i = 0; i < n; i++)
+            assert a[i].length() == w : "Strings must have fixed length";
+
+        // sort the strings
+        sort(a, w);
+
+        // print results
+        for (int i = 0; i < n; i++)
+            StdOut.println(a[i]);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LZW.java b/src/main/java/edu/princeton/cs/algs4/LZW.java
new file mode 100644
index 0000000..cae42b7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LZW.java
@@ -0,0 +1,136 @@
+/******************************************************************************
+ *  Compilation:  javac LZW.java
+ *  Execution:    java LZW - < input.txt   (compress)
+ *  Execution:    java LZW + < input.txt   (expand)
+ *  Dependencies: BinaryIn.java BinaryOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/55compression/abraLZW.txt
+ *                https://algs4.cs.princeton.edu/55compression/ababLZW.txt
+ *
+ *  Compress or expand binary input from standard input using LZW.
+ *
+
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LZW} class provides static methods for compressing
+ *  and expanding a binary input using LZW compression over the 8-bit extended
+ *  ASCII alphabet with 12-bit codewords.
+ *  <p>
+ *  WARNING: Starting with Oracle Java 7u6, the substring method takes time and
+ *  space linear in the length of the extracted substring (instead of constant
+ *  time an space as in earlier versions). As a result, compression takes
+ *  quadratic time. TODO: fix.
+ *  See <a href = "http://java-performance.info/changes-to-string-java-1-7-0_06/">this article</a>
+ *  for more details.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick  
+ *  @author Kevin Wayne
+ */
+public class LZW {
+    private static final int R = 256;        // number of input chars
+    private static final int L = 4096;       // number of codewords = 2^W
+    private static final int W = 12;         // codeword width
+
+    // Do not instantiate.
+    private LZW() { }
+
+    /**
+     * Reads a sequence of 8-bit bytes from standard input; compresses
+     * them using LZW compression with 12-bit codewords; and writes the results
+     * to standard output.
+     */
+    public static void compress() { 
+        String input = BinaryStdIn.readString();
+        TST<Integer> st = new TST<Integer>();
+
+        // since TST is not balanced, it would be better to insert in a different order
+        for (int i = 0; i < R; i++)
+            st.put("" + (char) i, i);
+
+        int code = R+1;  // R is codeword for EOF
+
+        while (input.length() > 0) {
+            String s = st.longestPrefixOf(input);  // Find max prefix match s.
+            BinaryStdOut.write(st.get(s), W);      // Print s's encoding.
+            int t = s.length();
+            if (t < input.length() && code < L)    // Add s to symbol table.
+                st.put(input.substring(0, t + 1), code++);
+            input = input.substring(t);            // Scan past s in input.
+        }
+        BinaryStdOut.write(R, W);
+        BinaryStdOut.close();
+    } 
+
+    /**
+     * Reads a sequence of bit encoded using LZW compression with
+     * 12-bit codewords from standard input; expands them; and writes
+     * the results to standard output.
+     */
+    public static void expand() {
+        String[] st = new String[L];
+        int i; // next available codeword value
+
+        // initialize symbol table with all 1-character strings
+        for (i = 0; i < R; i++)
+            st[i] = "" + (char) i;
+        st[i++] = "";                        // (unused) lookahead for EOF
+
+        int codeword = BinaryStdIn.readInt(W);
+        if (codeword == R) return;           // expanded message is empty string
+        String val = st[codeword];
+
+        while (true) {
+            BinaryStdOut.write(val);
+            codeword = BinaryStdIn.readInt(W);
+            if (codeword == R) break;
+            String s = st[codeword];
+            if (i == codeword) s = val + val.charAt(0);   // special case hack
+            if (i < L) st[i++] = val + s.charAt(0);
+            val = s;
+        }
+        BinaryStdOut.close();
+    }
+
+    /**
+     * Sample client that calls {@code compress()} if the command-line
+     * argument is "-" an {@code expand()} if it is "+".
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        if      (args[0].equals("-")) compress();
+        else if (args[0].equals("+")) expand();
+        else throw new IllegalArgumentException("Illegal command line argument");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LazyPrimMST.java b/src/main/java/edu/princeton/cs/algs4/LazyPrimMST.java
new file mode 100644
index 0000000..9ad3822
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LazyPrimMST.java
@@ -0,0 +1,234 @@
+/******************************************************************************
+ *  Compilation:  javac LazyPrimMST.java
+ *  Execution:    java LazyPrimMST filename.txt
+ *  Dependencies: EdgeWeightedGraph.java Edge.java Queue.java
+ *                MinPQ.java UF.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/largeEWG.txt
+ *
+ *  Compute a minimum spanning forest using a lazy version of Prim's 
+ *  algorithm.
+ *
+ *  %  java LazyPrimMST tinyEWG.txt 
+ *  0-7 0.16000
+ *  1-7 0.19000
+ *  0-2 0.26000
+ *  2-3 0.17000
+ *  5-7 0.28000
+ *  4-5 0.35000
+ *  6-2 0.40000
+ *  1.81000
+ *
+ *  % java LazyPrimMST mediumEWG.txt
+ *  0-225   0.02383
+ *  49-225  0.03314
+ *  44-49   0.02107
+ *  44-204  0.01774
+ *  49-97   0.03121
+ *  202-204 0.04207
+ *  176-202 0.04299
+ *  176-191 0.02089
+ *  68-176  0.04396
+ *  58-68   0.04795
+ *  10.46351
+ *
+ *  % java LazyPrimMST largeEWG.txt
+ *  ...
+ *  647.66307
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LazyPrimMST} class represents a data type for computing a
+ *  <em>minimum spanning tree</em> in an edge-weighted graph.
+ *  The edge weights can be positive, zero, or negative and need not
+ *  be distinct. If the graph is not connected, it computes a <em>minimum
+ *  spanning forest</em>, which is the union of minimum spanning trees
+ *  in each connected component. The {@code weight()} method returns the 
+ *  weight of a minimum spanning tree and the {@code edges()} method
+ *  returns its edges.
+ *  <p>
+ *  This implementation uses a lazy version of <em>Prim's algorithm</em>
+ *  with a binary heap of edges.
+ *  The constructor takes &Theta;(<em>E</em> log <em>E</em>) time in
+ *  the worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>E</em>) extra space in the worst case
+ *  (not including the edge-weighted graph).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For alternate implementations, see {@link PrimMST}, {@link KruskalMST},
+ *  and {@link BoruvkaMST}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LazyPrimMST {
+    private static final double FLOATING_POINT_EPSILON = 1E-12;
+
+    private double weight;       // total weight of MST
+    private Queue<Edge> mst;     // edges in the MST
+    private boolean[] marked;    // marked[v] = true iff v on tree
+    private MinPQ<Edge> pq;      // edges with one endpoint in tree
+
+    /**
+     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
+     * @param G the edge-weighted graph
+     */
+    public LazyPrimMST(EdgeWeightedGraph G) {
+        mst = new Queue<Edge>();
+        pq = new MinPQ<Edge>();
+        marked = new boolean[G.V()];
+        for (int v = 0; v < G.V(); v++)     // run Prim from all vertices to
+            if (!marked[v]) prim(G, v);     // get a minimum spanning forest
+
+        // check optimality conditions
+        assert check(G);
+    }
+
+    // run Prim's algorithm
+    private void prim(EdgeWeightedGraph G, int s) {
+        scan(G, s);
+        while (!pq.isEmpty()) {                        // better to stop when mst has V-1 edges
+            Edge e = pq.delMin();                      // smallest edge on pq
+            int v = e.either(), w = e.other(v);        // two endpoints
+            assert marked[v] || marked[w];
+            if (marked[v] && marked[w]) continue;      // lazy, both v and w already scanned
+            mst.enqueue(e);                            // add e to MST
+            weight += e.weight();
+            if (!marked[v]) scan(G, v);               // v becomes part of tree
+            if (!marked[w]) scan(G, w);               // w becomes part of tree
+        }
+    }
+
+    // add all edges e incident to v onto pq if the other endpoint has not yet been scanned
+    private void scan(EdgeWeightedGraph G, int v) {
+        assert !marked[v];
+        marked[v] = true;
+        for (Edge e : G.adj(v))
+            if (!marked[e.other(v)]) pq.insert(e);
+    }
+        
+    /**
+     * Returns the edges in a minimum spanning tree (or forest).
+     * @return the edges in a minimum spanning tree (or forest) as
+     *    an iterable of edges
+     */
+    public Iterable<Edge> edges() {
+        return mst;
+    }
+
+    /**
+     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
+     * @return the sum of the edge weights in a minimum spanning tree (or forest)
+     */
+    public double weight() {
+        return weight;
+    }
+
+    // check optimality conditions (takes time proportional to E V lg* V)
+    private boolean check(EdgeWeightedGraph G) {
+
+        // check weight
+        double totalWeight = 0.0;
+        for (Edge e : edges()) {
+            totalWeight += e.weight();
+        }
+        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
+            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
+            return false;
+        }
+
+        // check that it is acyclic
+        UF uf = new UF(G.V());
+        for (Edge e : edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) == uf.find(w)) {
+                System.err.println("Not a forest");
+                return false;
+            }
+            uf.union(v, w);
+        }
+
+        // check that it is a spanning forest
+        for (Edge e : G.edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) != uf.find(w)) {
+                System.err.println("Not a spanning forest");
+                return false;
+            }
+        }
+
+        // check that it is a minimal spanning forest (cut optimality conditions)
+        for (Edge e : edges()) {
+
+            // all edges in MST except e
+            uf = new UF(G.V());
+            for (Edge f : mst) {
+                int x = f.either(), y = f.other(x);
+                if (f != e) uf.union(x, y);
+            }
+
+            // check that e is min weight edge in crossing cut
+            for (Edge f : G.edges()) {
+                int x = f.either(), y = f.other(x);
+                if (uf.find(x) != uf.find(y)) {
+                    if (f.weight() < e.weight()) {
+                        System.err.println("Edge " + f + " violates cut optimality conditions");
+                        return false;
+                    }
+                }
+            }
+
+        }
+
+        return true;
+    }
+    
+    
+    /**
+     * Unit tests the {@code LazyPrimMST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        LazyPrimMST mst = new LazyPrimMST(G);
+        for (Edge e : mst.edges()) {
+            StdOut.println(e);
+        }
+        StdOut.printf("%.5f\n", mst.weight());
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LinearProbingHashST.java b/src/main/java/edu/princeton/cs/algs4/LinearProbingHashST.java
new file mode 100644
index 0000000..6e4ee53
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LinearProbingHashST.java
@@ -0,0 +1,297 @@
+/******************************************************************************
+ *  Compilation:  javac LinearProbingHashST.java
+ *  Execution:    java LinearProbingHashST < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/34hash/tinyST.txt
+ *  
+ *  Symbol-table implementation with linear-probing hash table.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LinearProbingHashST} class represents a symbol table of generic
+ *  key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  This implementation uses a linear probing hash table. It requires that
+ *  the key type overrides the {@code equals()} and {@code hashCode()} methods.
+ *  The expected time per <em>put</em>, <em>contains</em>, or <em>remove</em>
+ *  operation is constant, subject to the uniform hashing assumption.
+ *  The <em>size</em>, and <em>is-empty</em> operations take constant time.
+ *  Construction takes constant time.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/34hash">Section 3.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For other implementations, see {@link ST}, {@link BinarySearchST},
+ *  {@link SequentialSearchST}, {@link BST}, {@link RedBlackBST}, and
+ *  {@link SeparateChainingHashST},
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LinearProbingHashST<Key, Value> {
+
+    // must be a power of 2
+    private static final int INIT_CAPACITY = 4;
+
+    private int n;           // number of key-value pairs in the symbol table
+    private int m;           // size of linear probing table
+    private Key[] keys;      // the keys
+    private Value[] vals;    // the values
+
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public LinearProbingHashST() {
+        this(INIT_CAPACITY);
+    }
+
+    /**
+     * Initializes an empty symbol table with the specified initial capacity.
+     *
+     * @param capacity the initial capacity
+     */
+    public LinearProbingHashST(int capacity) {
+        m = capacity;
+        n = 0;
+        keys = (Key[])   new Object[m];
+        vals = (Value[]) new Object[m];
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     *
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns true if this symbol table is empty.
+     *
+     * @return {@code true} if this symbol table is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns true if this symbol table contains the specified key.
+     *
+     * @param  key the key
+     * @return {@code true} if this symbol table contains {@code key};
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        return get(key) != null;
+    }
+
+    // hash function for keys - returns value between 0 and m-1
+    private int hashTextbook(Key key) {
+        return (key.hashCode() & 0x7fffffff) % m;
+    }
+
+    // hash function for keys - returns value between 0 and m-1 (assumes m is a power of 2)
+    // (from Java 7 implementation, protects against poor quality hashCode() implementations)
+    private int hash(Key key) {
+        int h = key.hashCode();
+        h ^= (h >>> 20) ^ (h >>> 12) ^ (h >>> 7) ^ (h >>> 4);
+        return h & (m-1);
+    }
+
+    // resizes the hash table to the given capacity by re-hashing all of the keys
+    private void resize(int capacity) {
+        LinearProbingHashST<Key, Value> temp = new LinearProbingHashST<Key, Value>(capacity);
+        for (int i = 0; i < m; i++) {
+            if (keys[i] != null) {
+                temp.put(keys[i], vals[i]);
+            }
+        }
+        keys = temp.keys;
+        vals = temp.vals;
+        m    = temp.m;
+    }
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
+
+        if (val == null) {
+            delete(key);
+            return;
+        }
+
+        // double table size if 50% full
+        if (n >= m/2) resize(2*m);
+
+        int i;
+        for (i = hash(key); keys[i] != null; i = (i + 1) % m) {
+            if (keys[i].equals(key)) {
+                vals[i] = val;
+                return;
+            }
+        }
+        keys[i] = key;
+        vals[i] = val;
+        n++;
+    }
+
+    /**
+     * Returns the value associated with the specified key.
+     * @param key the key
+     * @return the value associated with {@code key};
+     *         {@code null} if no such value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null");
+        for (int i = hash(key); keys[i] != null; i = (i + 1) % m)
+            if (keys[i].equals(key))
+                return vals[i];
+        return null;
+    }
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).    
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
+        if (!contains(key)) return;
+
+        // find position i of key
+        int i = hash(key);
+        while (!key.equals(keys[i])) {
+            i = (i + 1) % m;
+        }
+
+        // delete key and associated value
+        keys[i] = null;
+        vals[i] = null;
+
+        // rehash all keys in same cluster
+        i = (i + 1) % m;
+        while (keys[i] != null) {
+            // delete keys[i] an vals[i] and reinsert
+            Key   keyToRehash = keys[i];
+            Value valToRehash = vals[i];
+            keys[i] = null;
+            vals[i] = null;
+            n--;
+            put(keyToRehash, valToRehash);
+            i = (i + 1) % m;
+        }
+
+        n--;
+
+        // halves size of array if it's 12.5% full or less
+        if (n > 0 && n <= m/8) resize(m/2);
+
+        assert check();
+    }
+
+    /**
+     * Returns all keys in this symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     *
+     * @return all keys in this symbol table
+     */
+    public Iterable<Key> keys() {
+        Queue<Key> queue = new Queue<Key>();
+        for (int i = 0; i < m; i++)
+            if (keys[i] != null) queue.enqueue(keys[i]);
+        return queue;
+    }
+
+    // integrity check - don't check after each put() because
+    // integrity not maintained during a delete()
+    private boolean check() {
+
+        // check that hash table is at most 50% full
+        if (m < 2*n) {
+            System.err.println("Hash table size m = " + m + "; array size n = " + n);
+            return false;
+        }
+
+        // check that each key in table can be found by get()
+        for (int i = 0; i < m; i++) {
+            if (keys[i] == null) continue;
+            else if (get(keys[i]) != vals[i]) {
+                System.err.println("get[" + keys[i] + "] = " + get(keys[i]) + "; vals[i] = " + vals[i]);
+                return false;
+            }
+        }
+        return true;
+    }
+
+
+    /**
+     * Unit tests the {@code LinearProbingHashST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        LinearProbingHashST<String, Integer> st = new LinearProbingHashST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+
+        // print keys
+        for (String s : st.keys()) 
+            StdOut.println(s + " " + st.get(s)); 
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LinearProgramming.java b/src/main/java/edu/princeton/cs/algs4/LinearProgramming.java
new file mode 100644
index 0000000..36128c0
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LinearProgramming.java
@@ -0,0 +1,425 @@
+/******************************************************************************
+ *  Compilation:  javac LinearProgramming.java
+ *  Execution:    java LinearProgramming m n
+ *  Dependencies: StdOut.java
+ *
+ *  Given an m-by-n matrix A, an m-length vector b, and an
+ *  n-length vector c, solve the  LP { max cx : Ax <= b, x >= 0 }.
+ *  Assumes that b >= 0 so that x = 0 is a basic feasible solution.
+ *
+ *  Creates an (m+1)-by-(n+m+1) simplex tableaux with the 
+ *  RHS in column m+n, the objective function in row m, and
+ *  slack variables in columns m through m+n-1.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LinearProgramming} class represents a data type for solving a
+ *  linear program of the form { max cx : Ax &le; b, x &ge; 0 }, where A is a m-by-n
+ *  matrix, b is an m-length vector, and c is an n-length vector. For simplicity,
+ *  we assume that A is of full rank and that b &ge; 0 so that x = 0 is a basic
+ *  feasible soution.
+ *  <p>
+ *  The data type supplies methods for determining the optimal primal and
+ *  dual solutions.
+ *  <p>
+ *  This is a bare-bones implementation of the <em>simplex algorithm</em>.
+ *  It uses Bland's rule to determing the entering and leaving variables.
+ *  It is not suitable for use on large inputs. 
+ *  <p>
+ *  This computes correct results if all arithmetic performed is
+ *  without floating-point rounding error or arithmetic overflow.
+ *  In practice, there will be floating-point rounding error
+ *  and this implementation is not robust in the presence of 
+ *  such errors.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/65reductions">Section 6.5</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LinearProgramming {
+    private static final double EPSILON = 1.0E-10;
+    private double[][] a;   // tableaux
+    private int m;          // number of constraints
+    private int n;          // number of original variables
+
+    private int[] basis;    // basis[i] = basic variable corresponding to row i
+                            // only needed to print out solution, not book
+
+    /**
+     * Determines an optimal solution to the linear program
+     * { max cx : Ax &le; b, x &ge; 0 }, where A is a m-by-n
+     * matrix, b is an m-length vector, and c is an n-length vector.
+     *
+     * @param  A the <em>m</em>-by-<em>b</em> matrix
+     * @param  b the <em>m</em>-length RHS vector
+     * @param  c the <em>n</em>-length cost vector
+     * @throws IllegalArgumentException unless {@code b[i] >= 0} for each {@code i}
+     * @throws ArithmeticException if the linear program is unbounded
+     */ 
+    public LinearProgramming(double[][] A, double[] b, double[] c) {
+        m = b.length;
+        n = c.length;
+        for (int i = 0; i < m; i++)
+            if (!(b[i] >= 0)) throw new IllegalArgumentException("RHS must be nonnegative");
+
+        a = new double[m+1][n+m+1];
+        for (int i = 0; i < m; i++)
+            for (int j = 0; j < n; j++)
+                a[i][j] = A[i][j];
+        for (int i = 0; i < m; i++)
+            a[i][n+i] = 1.0;
+        for (int j = 0; j < n; j++)
+            a[m][j] = c[j];
+        for (int i = 0; i < m; i++)
+            a[i][m+n] = b[i];
+
+        basis = new int[m];
+        for (int i = 0; i < m; i++)
+            basis[i] = n + i;
+
+        solve();
+
+        // check optimality conditions
+        assert check(A, b, c);
+    }
+
+    // run simplex algorithm starting from initial BFS
+    private void solve() {
+        while (true) {
+
+            // find entering column q
+            int q = bland();
+            if (q == -1) break;  // optimal
+
+            // find leaving row p
+            int p = minRatioRule(q);
+            if (p == -1) throw new ArithmeticException("Linear program is unbounded");
+
+            // pivot
+            pivot(p, q);
+
+            // update basis
+            basis[p] = q;
+        }
+    }
+
+    // lowest index of a non-basic column with a positive cost
+    private int bland() {
+        for (int j = 0; j < m+n; j++)
+            if (a[m][j] > 0) return j;
+        return -1;  // optimal
+    }
+
+   // index of a non-basic column with most positive cost
+    private int dantzig() {
+        int q = 0;
+        for (int j = 1; j < m+n; j++)
+            if (a[m][j] > a[m][q]) q = j;
+
+        if (a[m][q] <= 0) return -1;  // optimal
+        else return q;
+    }
+
+    // find row p using min ratio rule (-1 if no such row)
+    // (smallest such index if there is a tie)
+    private int minRatioRule(int q) {
+        int p = -1;
+        for (int i = 0; i < m; i++) {
+            // if (a[i][q] <= 0) continue;
+            if (a[i][q] <= EPSILON) continue;
+            else if (p == -1) p = i;
+            else if ((a[i][m+n] / a[i][q]) < (a[p][m+n] / a[p][q])) p = i;
+        }
+        return p;
+    }
+
+    // pivot on entry (p, q) using Gauss-Jordan elimination
+    private void pivot(int p, int q) {
+
+        // everything but row p and column q
+        for (int i = 0; i <= m; i++)
+            for (int j = 0; j <= m+n; j++)
+                if (i != p && j != q) a[i][j] -= a[p][j] * a[i][q] / a[p][q];
+
+        // zero out column q
+        for (int i = 0; i <= m; i++)
+            if (i != p) a[i][q] = 0.0;
+
+        // scale row p
+        for (int j = 0; j <= m+n; j++)
+            if (j != q) a[p][j] /= a[p][q];
+        a[p][q] = 1.0;
+    }
+
+    /**
+     * Returns the optimal value of this linear program.
+     *
+     * @return the optimal value of this linear program
+     *
+     */
+    public double value() {
+        return -a[m][m+n];
+    }
+
+    /**
+     * Returns the optimal primal solution to this linear program.
+     *
+     * @return the optimal primal solution to this linear program
+     */
+    public double[] primal() {
+        double[] x = new double[n];
+        for (int i = 0; i < m; i++)
+            if (basis[i] < n) x[basis[i]] = a[i][m+n];
+        return x;
+    }
+
+    /**
+     * Returns the optimal dual solution to this linear program
+     *
+     * @return the optimal dual solution to this linear program
+     */
+    public double[] dual() {
+        double[] y = new double[m];
+        for (int i = 0; i < m; i++)
+            y[i] = -a[m][n+i];
+        return y;
+    }
+
+
+    // is the solution primal feasible?
+    private boolean isPrimalFeasible(double[][] A, double[] b) {
+        double[] x = primal();
+
+        // check that x >= 0
+        for (int j = 0; j < x.length; j++) {
+            if (x[j] < 0.0) {
+                StdOut.println("x[" + j + "] = " + x[j] + " is negative");
+                return false;
+            }
+        }
+
+        // check that Ax <= b
+        for (int i = 0; i < m; i++) {
+            double sum = 0.0;
+            for (int j = 0; j < n; j++) {
+                sum += A[i][j] * x[j];
+            }
+            if (sum > b[i] + EPSILON) {
+                StdOut.println("not primal feasible");
+                StdOut.println("b[" + i + "] = " + b[i] + ", sum = " + sum);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // is the solution dual feasible?
+    private boolean isDualFeasible(double[][] A, double[] c) {
+        double[] y = dual();
+
+        // check that y >= 0
+        for (int i = 0; i < y.length; i++) {
+            if (y[i] < 0.0) {
+                StdOut.println("y[" + i + "] = " + y[i] + " is negative");
+                return false;
+            }
+        }
+
+        // check that yA >= c
+        for (int j = 0; j < n; j++) {
+            double sum = 0.0;
+            for (int i = 0; i < m; i++) {
+                sum += A[i][j] * y[i];
+            }
+            if (sum < c[j] - EPSILON) {
+                StdOut.println("not dual feasible");
+                StdOut.println("c[" + j + "] = " + c[j] + ", sum = " + sum);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // check that optimal value = cx = yb
+    private boolean isOptimal(double[] b, double[] c) {
+        double[] x = primal();
+        double[] y = dual();
+        double value = value();
+
+        // check that value = cx = yb
+        double value1 = 0.0;
+        for (int j = 0; j < x.length; j++)
+            value1 += c[j] * x[j];
+        double value2 = 0.0;
+        for (int i = 0; i < y.length; i++)
+            value2 += y[i] * b[i];
+        if (Math.abs(value - value1) > EPSILON || Math.abs(value - value2) > EPSILON) {
+            StdOut.println("value = " + value + ", cx = " + value1 + ", yb = " + value2);
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean check(double[][]A, double[] b, double[] c) {
+        return isPrimalFeasible(A, b) && isDualFeasible(A, c) && isOptimal(b, c);
+    }
+
+    // print tableaux
+    private void show() {
+        StdOut.println("m = " + m);
+        StdOut.println("n = " + n);
+        for (int i = 0; i <= m; i++) {
+            for (int j = 0; j <= m+n; j++) {
+                StdOut.printf("%7.2f ", a[i][j]);
+                // StdOut.printf("%10.7f ", a[i][j]);
+            }
+            StdOut.println();
+        }
+        StdOut.println("value = " + value());
+        for (int i = 0; i < m; i++)
+            if (basis[i] < n) StdOut.println("x_" + basis[i] + " = " + a[i][m+n]);
+        StdOut.println();
+    }
+
+
+    private static void test(double[][] A, double[] b, double[] c) {
+        LinearProgramming lp;
+        try {
+            lp = new LinearProgramming(A, b, c);
+        }
+        catch (ArithmeticException e) {
+            System.out.println(e);
+            return;
+        }
+
+        StdOut.println("value = " + lp.value());
+        double[] x = lp.primal();
+        for (int i = 0; i < x.length; i++)
+            StdOut.println("x[" + i + "] = " + x[i]);
+        double[] y = lp.dual();
+        for (int j = 0; j < y.length; j++)
+            StdOut.println("y[" + j + "] = " + y[j]);
+    }
+
+    private static void test1() {
+        double[][] A = {
+            { -1,  1,  0 },
+            {  1,  4,  0 },
+            {  2,  1,  0 },
+            {  3, -4,  0 },
+            {  0,  0,  1 },
+        };
+        double[] c = { 1, 1, 1 };
+        double[] b = { 5, 45, 27, 24, 4 };
+        test(A, b, c);
+    }
+
+
+    // x0 = 12, x1 = 28, opt = 800
+    private static void test2() {
+        double[] c = {  13.0,  23.0 };
+        double[] b = { 480.0, 160.0, 1190.0 };
+        double[][] A = {
+            {  5.0, 15.0 },
+            {  4.0,  4.0 },
+            { 35.0, 20.0 },
+        };
+        test(A, b, c);
+    }
+
+    // unbounded
+    private static void test3() {
+        double[] c = { 2.0, 3.0, -1.0, -12.0 };
+        double[] b = {  3.0,   2.0 };
+        double[][] A = {
+            { -2.0, -9.0,  1.0,  9.0 },
+            {  1.0,  1.0, -1.0, -2.0 },
+        };
+        test(A, b, c);
+    }
+
+    // degenerate - cycles if you choose most positive objective function coefficient
+    private static void test4() {
+        double[] c = { 10.0, -57.0, -9.0, -24.0 };
+        double[] b = {  0.0,   0.0,  1.0 };
+        double[][] A = {
+            { 0.5, -5.5, -2.5, 9.0 },
+            { 0.5, -1.5, -0.5, 1.0 },
+            { 1.0,  0.0,  0.0, 0.0 },
+        };
+        test(A, b, c);
+    }
+
+
+    /**
+     * Unit tests the {@code LinearProgramming} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        StdOut.println("----- test 1 --------------------");
+        test1();
+        StdOut.println();
+
+        StdOut.println("----- test 2 --------------------");
+        test2();
+        StdOut.println();
+
+        StdOut.println("----- test 3 --------------------");
+        test3();
+        StdOut.println();
+
+        StdOut.println("----- test 4 --------------------");
+        test4();
+        StdOut.println();
+
+        StdOut.println("----- test random ---------------");
+        int m = Integer.parseInt(args[0]);
+        int n = Integer.parseInt(args[1]);
+        double[] c = new double[n];
+        double[] b = new double[m];
+        double[][] A = new double[m][n];
+        for (int j = 0; j < n; j++)
+            c[j] = StdRandom.uniform(1000);
+        for (int i = 0; i < m; i++)
+            b[i] = StdRandom.uniform(1000);
+        for (int i = 0; i < m; i++)
+            for (int j = 0; j < n; j++)
+                A[i][j] = StdRandom.uniform(100);
+        LinearProgramming lp = new LinearProgramming(A, b, c);
+        test(A, b, c);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LinearRegression.java b/src/main/java/edu/princeton/cs/algs4/LinearRegression.java
new file mode 100644
index 0000000..0e25bde
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LinearRegression.java
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *  Compilation:  javac LinearRegression.java
+ *  Execution:    java  LinearRegression
+ *  Dependencies: none
+ *  
+ *  Compute least squares solution to y = beta * x + alpha.
+ *  Simple linear regression.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code LinearRegression} class performs a simple linear regression
+ *  on an set of <em>n</em> data points (<em>y<sub>i</sub></em>, <em>x<sub>i</sub></em>).
+ *  That is, it fits a straight line <em>y</em> = &alpha; + &beta; <em>x</em>,
+ *  (where <em>y</em> is the response variable, <em>x</em> is the predictor variable,
+ *  &alpha; is the <em>y-intercept</em>, and &beta; is the <em>slope</em>)
+ *  that minimizes the sum of squared residuals of the linear regression model.
+ *  It also computes associated statistics, including the coefficient of
+ *  determination <em>R</em><sup>2</sup> and the standard deviation of the
+ *  estimates for the slope and <em>y</em>-intercept.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LinearRegression {
+    private final double intercept, slope;
+    private final double r2;
+    private final double svar0, svar1;
+
+   /**
+     * Performs a linear regression on the data points {@code (y[i], x[i])}.
+     *
+     * @param  x the values of the predictor variable
+     * @param  y the corresponding values of the response variable
+     * @throws IllegalArgumentException if the lengths of the two arrays are not equal
+     */
+    public LinearRegression(double[] x, double[] y) {
+        if (x.length != y.length) {
+            throw new IllegalArgumentException("array lengths are not equal");
+        }
+        int n = x.length;
+
+        // first pass
+        double sumx = 0.0, sumy = 0.0, sumx2 = 0.0;
+        for (int i = 0; i < n; i++) {
+            sumx  += x[i];
+            sumx2 += x[i]*x[i];
+            sumy  += y[i];
+        }
+        double xbar = sumx / n;
+        double ybar = sumy / n;
+
+        // second pass: compute summary statistics
+        double xxbar = 0.0, yybar = 0.0, xybar = 0.0;
+        for (int i = 0; i < n; i++) {
+            xxbar += (x[i] - xbar) * (x[i] - xbar);
+            yybar += (y[i] - ybar) * (y[i] - ybar);
+            xybar += (x[i] - xbar) * (y[i] - ybar);
+        }
+        slope  = xybar / xxbar;
+        intercept = ybar - slope * xbar;
+
+        // more statistical analysis
+        double rss = 0.0;      // residual sum of squares
+        double ssr = 0.0;      // regression sum of squares
+        for (int i = 0; i < n; i++) {
+            double fit = slope*x[i] + intercept;
+            rss += (fit - y[i]) * (fit - y[i]);
+            ssr += (fit - ybar) * (fit - ybar);
+        }
+
+        int degreesOfFreedom = n-2;
+        r2    = ssr / yybar;
+        double svar  = rss / degreesOfFreedom;
+        svar1 = svar / xxbar;
+        svar0 = svar/n + xbar*xbar*svar1;
+    }
+
+   /**
+     * Returns the <em>y</em>-intercept &alpha; of the best of the best-fit line <em>y</em> = &alpha; + &beta; <em>x</em>.
+     *
+     * @return the <em>y</em>-intercept &alpha; of the best-fit line <em>y = &alpha; + &beta; x</em>
+     */
+    public double intercept() {
+        return intercept;
+    }
+
+   /**
+     * Returns the slope &beta; of the best of the best-fit line <em>y</em> = &alpha; + &beta; <em>x</em>.
+     *
+     * @return the slope &beta; of the best-fit line <em>y</em> = &alpha; + &beta; <em>x</em>
+     */
+    public double slope() {
+        return slope;
+    }
+
+   /**
+     * Returns the coefficient of determination <em>R</em><sup>2</sup>.
+     *
+     * @return the coefficient of determination <em>R</em><sup>2</sup>,
+     *         which is a real number between 0 and 1
+     */
+    public double R2() {
+        return r2;
+    }
+
+   /**
+     * Returns the standard error of the estimate for the intercept.
+     *
+     * @return the standard error of the estimate for the intercept
+     */
+    public double interceptStdErr() {
+        return Math.sqrt(svar0);
+    }
+
+   /**
+     * Returns the standard error of the estimate for the slope.
+     *
+     * @return the standard error of the estimate for the slope
+     */
+    public double slopeStdErr() {
+        return Math.sqrt(svar1);
+    }
+
+   /**
+     * Returns the expected response {@code y} given the value of the predictor
+     * variable {@code x}.
+     *
+     * @param  x the value of the predictor variable
+     * @return the expected response {@code y} given the value of the predictor
+     *         variable {@code x}
+     */
+    public double predict(double x) {
+        return slope*x + intercept;
+    }
+
+   /**
+     * Returns a string representation of the simple linear regression model.
+     *
+     * @return a string representation of the simple linear regression model,
+     *         including the best-fit line and the coefficient of determination
+     *         <em>R</em><sup>2</sup>
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        s.append(String.format("%.2f n + %.2f", slope(), intercept()));
+        s.append("  (R^2 = " + String.format("%.3f", R2()) + ")");
+        return s.toString();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LinkedBag.java b/src/main/java/edu/princeton/cs/algs4/LinkedBag.java
new file mode 100644
index 0000000..9facf88
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LinkedBag.java
@@ -0,0 +1,176 @@
+/******************************************************************************
+ *  Compilation:  javac LinkedBag.java
+ *  Execution:    java LinkedBag < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *
+ *  A generic bag or multiset, implemented using a singly linked list.
+ *
+ *  % more tobe.txt 
+ *  to be or not to - be - - that - - - is
+ *
+ *  % java LinkedBag < tobe.txt
+ *  size of bag = 14
+ *  is
+ *  -
+ *  -
+ *  -
+ *  that
+ *  -
+ *  -
+ *  be
+ *  -
+ *  to
+ *  not
+ *  or
+ *  be
+ *  to
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code LinkedBag} class represents a bag (or multiset) of 
+ *  generic items. It supports insertion and iterating over the 
+ *  items in arbitrary order.
+ *  <p>
+ *  This implementation uses a singly linked list with a non-static nested class Node.
+ *  See {@link Bag} for a version that uses a static nested class.
+ *  The <em>add</em>, <em>isEmpty</em>, and <em>size</em> operations
+ *  take constant time. Iteration takes time proportional to the number of items.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LinkedBag<Item> implements Iterable<Item> {
+    private Node first;    // beginning of bag
+    private int n;         // number of elements in bag
+
+    // helper linked list class
+    private class Node {
+        private Item item;
+        private Node next;
+    }
+
+    /**
+     * Initializes an empty bag.
+     */
+    public LinkedBag() {
+        first = null;
+        n = 0;
+    }
+
+    /**
+     * Is this bag empty?
+     * @return true if this bag is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return first == null;
+    }
+
+    /**
+     * Returns the number of items in this bag.
+     * @return the number of items in this bag
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Adds the item to this bag.
+     * @param item the item to add to this bag
+     */
+    public void add(Item item) {
+        Node oldfirst = first;
+        first = new Node();
+        first.item = item;
+        first.next = oldfirst;
+        n++;
+    }
+
+
+    /**
+     * Returns an iterator that iterates over the items in the bag.
+     */
+    public Iterator<Item> iterator()  {
+        return new LinkedIterator();  
+    }
+
+    // an iterator over a linked list
+    private class LinkedIterator implements Iterator<Item> {
+        private Node current;
+
+        // creates a new iterator
+        public LinkedIterator() {
+            current = first;
+        }
+
+        // is there a next item in the iterator?
+        public boolean hasNext() {
+            return current != null;
+        }
+
+        // this method is optional in Iterator interface
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        // returns the next item in the iterator (and advances the iterator)
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = current.item;
+            current = current.next; 
+            return item;
+        }
+    }
+
+    /**
+     * Unit tests the {@code LinkedBag} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        LinkedBag<String> bag = new LinkedBag<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            bag.add(item);
+        }
+
+        StdOut.println("size of bag = " + bag.size());
+        for (String s : bag) {
+            StdOut.println(s);
+        }
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LinkedQueue.java b/src/main/java/edu/princeton/cs/algs4/LinkedQueue.java
new file mode 100644
index 0000000..96041fa
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LinkedQueue.java
@@ -0,0 +1,229 @@
+/******************************************************************************
+ *  Compilation:  javac LinkedQueue.java
+ *  Execution:    java LinkedQueue < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/13stacks/tobe.txt  
+ *
+ *  A generic queue, implemented using a singly linked list.
+ *
+ *  % java Queue < tobe.txt 
+ *  to be or not to be (2 left on queue)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code LinkedQueue} class represents a first-in-first-out (FIFO)
+ *  queue of generic items.
+ *  It supports the usual <em>enqueue</em> and <em>dequeue</em>
+ *  operations, along with methods for peeking at the first item,
+ *  testing if the queue is empty, and iterating through
+ *  the items in FIFO order.
+ *  <p>
+ *  This implementation uses a singly linked list with a non-static nested class 
+ *  for linked-list nodes.  See {@link Queue} for a version that uses a static nested class.
+ *  The <em>enqueue</em>, <em>dequeue</em>, <em>peek</em>, <em>size</em>, and <em>is-empty</em>
+ *  operations all take constant time in the worst case.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LinkedQueue<Item> implements Iterable<Item> {
+    private int n;         // number of elements on queue
+    private Node first;    // beginning of queue
+    private Node last;     // end of queue
+
+    // helper linked list class
+    private class Node {
+        private Item item;
+        private Node next;
+    }
+
+    /**
+     * Initializes an empty queue.
+     */
+    public LinkedQueue() {
+        first = null;
+        last  = null;
+        n = 0;
+        assert check();
+    }
+
+    /**
+     * Is this queue empty?
+     * @return true if this queue is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return first == null;
+    }
+
+    /**
+     * Returns the number of items in this queue.
+     * @return the number of items in this queue
+     */
+    public int size() {
+        return n;     
+    }
+
+    /**
+     * Returns the item least recently added to this queue.
+     * @return the item least recently added to this queue
+     * @throws java.util.NoSuchElementException if this queue is empty
+     */
+    public Item peek() {
+        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
+        return first.item;
+    }
+
+    /**
+     * Adds the item to this queue.
+     * @param item the item to add
+     */
+    public void enqueue(Item item) {
+        Node oldlast = last;
+        last = new Node();
+        last.item = item;
+        last.next = null;
+        if (isEmpty()) first = last;
+        else           oldlast.next = last;
+        n++;
+        assert check();
+    }
+
+    /**
+     * Removes and returns the item on this queue that was least recently added.
+     * @return the item on this queue that was least recently added
+     * @throws java.util.NoSuchElementException if this queue is empty
+     */
+    public Item dequeue() {
+        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
+        Item item = first.item;
+        first = first.next;
+        n--;
+        if (isEmpty()) last = null;   // to avoid loitering
+        assert check();
+        return item;
+    }
+
+    /**
+     * Returns a string representation of this queue.
+     * @return the sequence of items in FIFO order, separated by spaces
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (Item item : this)
+            s.append(item + " ");
+        return s.toString();
+    } 
+
+    // check internal invariants
+    private boolean check() {
+        if (n < 0) {
+            return false;
+        }
+        else if (n == 0) {
+            if (first != null) return false;
+            if (last  != null) return false;
+        }
+        else if (n == 1) {
+            if (first == null || last == null) return false;
+            if (first != last)                 return false;
+            if (first.next != null)            return false;
+        }
+        else {
+            if (first == null || last == null) return false;
+            if (first == last)      return false;
+            if (first.next == null) return false;
+            if (last.next  != null) return false;
+
+            // check internal consistency of instance variable n
+            int numberOfNodes = 0;
+            for (Node x = first; x != null && numberOfNodes <= n; x = x.next) {
+                numberOfNodes++;
+            }
+            if (numberOfNodes != n) return false;
+
+            // check internal consistency of instance variable last
+            Node lastNode = first;
+            while (lastNode.next != null) {
+                lastNode = lastNode.next;
+            }
+            if (last != lastNode) return false;
+        }
+
+        return true;
+    } 
+ 
+
+    /**
+     * Returns an iterator that iterates over the items in this queue in FIFO order.
+     * @return an iterator that iterates over the items in this queue in FIFO order
+     */
+    public Iterator<Item> iterator()  {
+        return new LinkedIterator();  
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class LinkedIterator implements Iterator<Item> {
+        private Node current = first;
+
+        public boolean hasNext()  { return current != null;                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = current.item;
+            current = current.next; 
+            return item;
+        }
+    }
+
+
+    /**
+     * Unit tests the {@code LinkedQueue} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        LinkedQueue<String> queue = new LinkedQueue<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-"))
+                queue.enqueue(item);
+            else if (!queue.isEmpty())
+                StdOut.print(queue.dequeue() + " ");
+        }
+        StdOut.println("(" + queue.size() + " left on queue)");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LinkedStack.java b/src/main/java/edu/princeton/cs/algs4/LinkedStack.java
new file mode 100644
index 0000000..7f7a61a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LinkedStack.java
@@ -0,0 +1,220 @@
+/******************************************************************************
+ *  Compilation:  javac LinkedStack.java
+ *  Execution:    java LinkedStack < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/13stacks/tobe.txt
+ *
+ *  A generic stack, implemented using a linked list. Each stack
+ *  element is of type Item.
+ *  
+ *  % more tobe.txt 
+ *  to be or not to - be - - that - - - is
+ *
+ *  % java LinkedStack < tobe.txt
+ *  to be not that or be (2 left on stack)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+
+/**
+ *  The {@code LinkedStack} class represents a last-in-first-out (LIFO) stack of
+ *  generic items.
+ *  It supports the usual <em>push</em> and <em>pop</em> operations, along with methods
+ *  for peeking at the top item, testing if the stack is empty, and iterating through
+ *  the items in LIFO order.
+ *  <p>
+ *  This implementation uses a singly linked list with a non-static nested class for 
+ *  linked-list nodes. See {@link Stack} for a version that uses a static nested class.
+ *  The <em>push</em>, <em>pop</em>, <em>peek</em>, <em>size</em>, and <em>is-empty</em>
+ *  operations all take constant time in the worst case.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LinkedStack<Item> implements Iterable<Item> {
+    private int n;          // size of the stack
+    private Node first;     // top of stack
+
+    // helper linked list class
+    private class Node {
+        private Item item;
+        private Node next;
+    }
+
+    /**
+     * Initializes an empty stack.
+     */
+    public LinkedStack() {
+        first = null;
+        n = 0;
+        assert check();
+    }
+
+    /**
+     * Is this stack empty?
+     * @return true if this stack is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return first == null;
+    }
+
+    /**
+     * Returns the number of items in the stack.
+     * @return the number of items in the stack
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Adds the item to this stack.
+     * @param item the item to add
+     */
+    public void push(Item item) {
+        Node oldfirst = first;
+        first = new Node();
+        first.item = item;
+        first.next = oldfirst;
+        n++;
+        assert check();
+    }
+
+    /**
+     * Removes and returns the item most recently added to this stack.
+     * @return the item most recently added
+     * @throws java.util.NoSuchElementException if this stack is empty
+     */
+    public Item pop() {
+        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
+        Item item = first.item;        // save item to return
+        first = first.next;            // delete first node
+        n--;
+        assert check();
+        return item;                   // return the saved item
+    }
+
+
+    /**
+     * Returns (but does not remove) the item most recently added to this stack.
+     * @return the item most recently added to this stack
+     * @throws java.util.NoSuchElementException if this stack is empty
+     */
+    public Item peek() {
+        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
+        return first.item;
+    }
+
+    /**
+     * Returns a string representation of this stack.
+     * @return the sequence of items in the stack in LIFO order, separated by spaces
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (Item item : this)
+            s.append(item + " ");
+        return s.toString();
+    }
+       
+    /**
+     * Returns an iterator to this stack that iterates through the items in LIFO order.
+     * @return an iterator to this stack that iterates through the items in LIFO order.
+     */
+    public Iterator<Item> iterator() {
+        return new LinkedIterator();
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class LinkedIterator implements Iterator<Item> {
+        private Node current = first;
+        public boolean hasNext()  { return current != null;                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = current.item;
+            current = current.next; 
+            return item;
+        }
+    }
+
+
+    // check internal invariants
+    private boolean check() {
+
+        // check a few properties of instance variable 'first'
+        if (n < 0) {
+            return false;
+        }
+        if (n == 0) {
+            if (first != null) return false;
+        }
+        else if (n == 1) {
+            if (first == null)      return false;
+            if (first.next != null) return false;
+        }
+        else {
+            if (first == null)      return false;
+            if (first.next == null) return false;
+        }
+
+        // check internal consistency of instance variable n
+        int numberOfNodes = 0;
+        for (Node x = first; x != null && numberOfNodes <= n; x = x.next) {
+            numberOfNodes++;
+        }
+        if (numberOfNodes != n) return false;
+
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code LinkedStack} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        LinkedStack<String> stack = new LinkedStack<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-"))
+                stack.push(item);
+            else if (!stack.isEmpty())
+                StdOut.print(stack.pop() + " ");
+        }
+        StdOut.println("(" + stack.size() + " left on stack)");
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LongestCommonSubstring.java b/src/main/java/edu/princeton/cs/algs4/LongestCommonSubstring.java
new file mode 100644
index 0000000..113de9e
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LongestCommonSubstring.java
@@ -0,0 +1,130 @@
+/******************************************************************************
+ *  Compilation:  javac LongestCommonSubstring.java
+ *  Execution:    java  LongestCommonSubstring file1.txt file2.txt
+ *  Dependencies: SuffixArray.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/63suffix/tale.txt
+ *                https://algs4.cs.princeton.edu/63suffix/mobydick.txt
+ *  
+ *  Read in two text files and find the longest substring that
+ *  appears in both texts.
+ * 
+ *  % java LongestCommonSubstring tale.txt mobydick.txt
+ *  ' seemed on the point of being '
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LongestCommonSubstring} class provides a {@link SuffixArray}
+ *  client for computing the longest common substring that appears in two
+ *  given strings.
+ *  <p>
+ *  This implementation computes the suffix array of each string and applies a
+ *  merging operation to determine the longest common substring.
+ *  For an alternate implementation, see
+ *  <a href = "https://algs4.cs.princeton.edu/63suffix/LongestCommonSubstringConcatenate.java.html">LongestCommonSubstringConcatenate.java</a>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/63suffix">Section 6.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  <p>
+ *     
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LongestCommonSubstring {
+
+    // Do not instantiate.
+    private LongestCommonSubstring() { }
+
+    // return the longest common prefix of suffix s[p..] and suffix t[q..]
+    private static String lcp(String s, int p, String t, int q) {
+        int n = Math.min(s.length() - p, t.length() - q);
+        for (int i = 0; i < n; i++) {
+            if (s.charAt(p + i) != t.charAt(q + i))
+                return s.substring(p, p + i);
+        }
+        return s.substring(p, p + n);
+    }
+
+    // compare suffix s[p..] and suffix t[q..]
+    private static int compare(String s, int p, String t, int q) {
+        int n = Math.min(s.length() - p, t.length() - q);
+        for (int i = 0; i < n; i++) {
+            if (s.charAt(p + i) != t.charAt(q + i))
+                return s.charAt(p+i) - t.charAt(q+i);
+        }
+        if      (s.length() - p < t.length() - q) return -1;
+        else if (s.length() - p > t.length() - q) return +1;
+        else                                      return  0;
+    }
+
+    /**
+     * Returns the longest common string of the two specified strings.
+     *
+     * @param  s one string
+     * @param  t the other string
+     * @return the longest common string that appears as a substring
+     *         in both {@code s} and {@code t}; the empty string
+     *         if no such string
+     */
+    public static String lcs(String s, String t) {
+        SuffixArray suffix1 = new SuffixArray(s);
+        SuffixArray suffix2 = new SuffixArray(t);
+
+        // find longest common substring by "merging" sorted suffixes 
+        String lcs = "";
+        int i = 0, j = 0;
+        while (i < s.length() && j < t.length()) {
+            int p = suffix1.index(i);
+            int q = suffix2.index(j);
+            String x = lcp(s, p, t, q);
+            if (x.length() > lcs.length()) lcs = x;
+            if (compare(s, p, t, q) < 0) i++;
+            else                         j++;
+        }
+        return lcs;
+    }
+
+    /**
+     * Unit tests the {@code lcs()} method.
+     * Reads in two strings from files specified as command-line arguments;
+     * computes the longest common substring; and prints the results to
+     * standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in1 = new In(args[0]);
+        In in2 = new In(args[1]);
+        String s = in1.readAll().trim().replaceAll("\\s+", " ");
+        String t = in2.readAll().trim().replaceAll("\\s+", " ");
+        StdOut.println("'" + lcs(s, t) + "'");
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LongestRepeatedSubstring.java b/src/main/java/edu/princeton/cs/algs4/LongestRepeatedSubstring.java
new file mode 100644
index 0000000..443adee
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LongestRepeatedSubstring.java
@@ -0,0 +1,113 @@
+/******************************************************************************
+ *  Compilation:  javac LongestRepeatedSubstring.java
+ *  Execution:    java LongestRepeatedSubstring < file.txt
+ *  Dependencies: StdIn.java SuffixArray.java
+ *  Data files:   https://algs4.cs.princeton.edu/63suffix/tale.txt
+ *                https://algs4.cs.princeton.edu/63suffix/tinyTale.txt
+ *                https://algs4.cs.princeton.edu/63suffix/mobydick.txt
+ *  
+ *  Reads a text string from stdin, replaces all consecutive blocks of
+ *  whitespace with a single space, and then computes the longest
+ *  repeated substring in that text using a suffix array.
+ * 
+ *  % java LongestRepeatedSubstring < tinyTale.txt 
+ *  'st of times it was the '
+ *
+ *  % java LongestRepeatedSubstring < mobydick.txt
+ *  ',- Such a funny, sporty, gamy, jesty, joky, hoky-poky lad, is the Ocean, oh! Th'
+ * 
+ *  % java LongestRepeatedSubstring
+ *  aaaaaaaaa
+ *  'aaaaaaaa'
+ *
+ *  % java LongestRepeatedSubstring
+ *  abcdefg
+ *  ''
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LongestRepeatedSubstring} class provides a {@link SuffixArray}
+ *  client for computing the longest repeated substring of a string that
+ *  appears at least twice. The repeated substrings may overlap (but must
+ *  be distinct).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/63suffix">Section 6.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  <p>
+ *  See also {@link LongestCommonSubstring}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LongestRepeatedSubstring {
+
+    // Do not instantiate.
+    private LongestRepeatedSubstring() { }
+
+    /**
+     * Returns the longest common string of the two specified strings.
+     *
+     * @param  s one string
+     * @param  t the other string
+     * @return the longest common string that appears as a substring
+     */
+
+    /**
+     * Returns the longest repeated substring of the specified string.
+     *
+     * @param  text the string
+     * @return the longest repeated substring that appears in {@code text};
+     *         the empty string if no such string
+     */
+    public static String lrs(String text) {
+        int n = text.length();
+        SuffixArray sa = new SuffixArray(text);
+        String lrs = "";
+        for (int i = 1; i < n; i++) {
+            int length = sa.lcp(i);
+            if (length > lrs.length()) {
+                // lrs = sa.select(i).substring(0, length);
+                lrs = text.substring(sa.index(i), sa.index(i) + length);
+            }
+        }
+        return lrs;
+    }
+
+    /**
+     * Unit tests the {@code lrs()} method.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String text = StdIn.readAll().replaceAll("\\s+", " ");
+        StdOut.println("'" + lrs(text) + "'");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LookupCSV.java b/src/main/java/edu/princeton/cs/algs4/LookupCSV.java
new file mode 100644
index 0000000..d228641
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LookupCSV.java
@@ -0,0 +1,99 @@
+/******************************************************************************
+ *  Compilation:  javac LookupCSV.java
+ *  Execution:    java LookupCSV file.csv keyField valField
+ *  Dependencies: ST.java In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/DJIA.csv
+ *                https://algs4.cs.princeton.edu/35applications/UPC.csv
+ *                https://algs4.cs.princeton.edu/35applications/amino.csv
+ *                https://algs4.cs.princeton.edu/35applications/elements.csv
+ *                https://algs4.cs.princeton.edu/35applications/ip.csv
+ *                https://algs4.cs.princeton.edu/35applications/morse.csv
+ *  
+ *  Reads in a set of key-value pairs from a two-column CSV file
+ *  specified on the command line; then, reads in keys from standard
+ *  input and prints out corresponding values.
+ * 
+ *  % java LookupCSV amino.csv 0 3     % java LookupCSV ip.csv 0 1 
+ *  TTA                                www.google.com 
+ *  Leucine                            216.239.41.99 
+ *  ABC                               
+ *  Not found                          % java LookupCSV ip.csv 1 0 
+ *  TCT                                216.239.41.99 
+ *  Serine                             www.google.com 
+ *                                 
+ *  % java LookupCSV amino.csv 3 0     % java LookupCSV DJIA.csv 0 1 
+ *  Glycine                            29-Oct-29 
+ *  GGG                                252.38 
+ *                                     20-Oct-87 
+ *                                     1738.74
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LookupCSV} class provides a data-driven client for reading in a
+ *  key-value pairs from a file; then, printing the values corresponding to the
+ *  keys found on standard input. Both keys and values are strings.
+ *  The fields to serve as the key and value are taken as command-line arguments.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LookupCSV {
+
+    // Do not instantiate.
+    private LookupCSV() { }
+
+    public static void main(String[] args) {
+        int keyField = Integer.parseInt(args[1]);
+        int valField = Integer.parseInt(args[2]);
+
+        // symbol table
+        ST<String, String> st = new ST<String, String>();
+
+        // read in the data from csv file
+        In in = new In(args[0]);
+        while (in.hasNextLine()) {
+            String line = in.readLine();
+            String[] tokens = line.split(",");
+            String key = tokens[keyField];
+            String val = tokens[valField];
+            st.put(key, val);
+        }
+
+        while (!StdIn.isEmpty()) {
+            String s = StdIn.readString();
+            if (st.contains(s)) StdOut.println(st.get(s));
+            else                StdOut.println("Not found");
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/LookupIndex.java b/src/main/java/edu/princeton/cs/algs4/LookupIndex.java
new file mode 100644
index 0000000..4337def
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/LookupIndex.java
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *  Compilation:  javac LookupIndex.java
+ *  Execution:    java LookupIndex movies.txt "/"
+ *  Dependencies: ST.java Queue.java In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/aminoI.csv
+ *                https://algs4.cs.princeton.edu/35applications/movies.txt
+ *
+ *  % java LookupIndex aminoI.csv ","
+ *  Serine
+ *    TCT
+ *    TCA
+ *    TCG
+ *    AGT
+ *    AGC
+ *  TCG
+ *    Serine
+ *
+ *  % java LookupIndex movies.txt "/"
+ *  Bacon, Kevin
+ *    Animal House (1978)
+ *    Apollo 13 (1995)
+ *    Beauty Shop (2005)
+ *    Diner (1982)
+ *    Few Good Men, A (1992)
+ *    Flatliners (1990)
+ *    Footloose (1984)
+ *    Friday the 13th (1980)
+ *    ...
+ *  Tin Men (1987)
+ *    DeBoy, David
+ *    Blumenfeld, Alan
+ *    ...
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code LookupIndex} class provides a data-driven client for reading in a
+ *  key-value pairs from a file; then, printing the values corresponding to the
+ *  keys found on standard input. Keys are strings; values are lists of strings.
+ *  The separating delimiter is taken as a command-line argument. This client
+ *  is sometimes known as an <em>inverted index</em>.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class LookupIndex { 
+
+    // Do not instantiate.
+    private LookupIndex() { }
+
+    public static void main(String[] args) {
+        String filename  = args[0];
+        String separator = args[1];
+        In in = new In(filename);
+
+        ST<String, Queue<String>> st = new ST<String, Queue<String>>();
+        ST<String, Queue<String>> ts = new ST<String, Queue<String>>();
+
+        while (in.hasNextLine()) {
+            String line = in.readLine();
+            String[] fields = line.split(separator);
+            String key = fields[0];
+            for (int i = 1; i < fields.length; i++) {
+                String val = fields[i];
+                if (!st.contains(key)) st.put(key, new Queue<String>());
+                if (!ts.contains(val)) ts.put(val, new Queue<String>());
+                st.get(key).enqueue(val);
+                ts.get(val).enqueue(key);
+            }
+        }
+
+        StdOut.println("Done indexing");
+
+        // read queries from standard input, one per line
+        while (!StdIn.isEmpty()) {
+            String query = StdIn.readLine();
+            if (st.contains(query)) 
+                for (String vals : st.get(query))
+                    StdOut.println("  " + vals);
+            if (ts.contains(query)) 
+                for (String keys : ts.get(query))
+                    StdOut.println("  " + keys);
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/MSD.java b/src/main/java/edu/princeton/cs/algs4/MSD.java
new file mode 100644
index 0000000..8696b0a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/MSD.java
@@ -0,0 +1,249 @@
+/******************************************************************************
+ *  Compilation: javac MSD.java
+ *  Execution:   java MSD < input.txt
+ *  Dependencies: StdIn.java StdOut.java 
+ *  Data files:   https://algs4.cs.princeton.edu/51radix/words3.txt
+ *                https://algs4.cs.princeton.edu/51radix/shells.txt
+ *
+ *  Sort an array of strings or integers using MSD radix sort.
+ *
+ *  % java MSD < shells.txt 
+ *  are
+ *  by
+ *  sea
+ *  seashells
+ *  seashells
+ *  sells
+ *  sells
+ *  she
+ *  she
+ *  shells
+ *  shore
+ *  surely
+ *  the
+ *  the
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code MSD} class provides static methods for sorting an
+ *  array of extended ASCII strings or integers using MSD radix sort.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/51radix">Section 5.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class MSD {
+    private static final int BITS_PER_BYTE =   8;
+    private static final int BITS_PER_INT  =  32;   // each Java int is 32 bits 
+    private static final int R             = 256;   // extended ASCII alphabet size
+    private static final int CUTOFF        =  15;   // cutoff to insertion sort
+
+    // do not instantiate
+    private MSD() { } 
+
+   /**
+     * Rearranges the array of extended ASCII strings in ascending order.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(String[] a) {
+        int n = a.length;
+        String[] aux = new String[n];
+        sort(a, 0, n-1, 0, aux);
+    }
+
+    // return dth character of s, -1 if d = length of string
+    private static int charAt(String s, int d) {
+        assert d >= 0 && d <= s.length();
+        if (d == s.length()) return -1;
+        return s.charAt(d);
+    }
+
+    // sort from a[lo] to a[hi], starting at the dth character
+    private static void sort(String[] a, int lo, int hi, int d, String[] aux) {
+
+        // cutoff to insertion sort for small subarrays
+        if (hi <= lo + CUTOFF) {
+            insertion(a, lo, hi, d);
+            return;
+        }
+
+        // compute frequency counts
+        int[] count = new int[R+2];
+        for (int i = lo; i <= hi; i++) {
+            int c = charAt(a[i], d);
+            count[c+2]++;
+        }
+
+        // transform counts to indicies
+        for (int r = 0; r < R+1; r++)
+            count[r+1] += count[r];
+
+        // distribute
+        for (int i = lo; i <= hi; i++) {
+            int c = charAt(a[i], d);
+            aux[count[c+1]++] = a[i];
+        }
+
+        // copy back
+        for (int i = lo; i <= hi; i++) 
+            a[i] = aux[i - lo];
+
+
+        // recursively sort for each character (excludes sentinel -1)
+        for (int r = 0; r < R; r++)
+            sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
+    }
+
+
+    // insertion sort a[lo..hi], starting at dth character
+    private static void insertion(String[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(String[] a, int i, int j) {
+        String temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+    // is v less than w, starting at character d
+    private static boolean less(String v, String w, int d) {
+        // assert v.substring(0, d).equals(w.substring(0, d));
+        for (int i = d; i < Math.min(v.length(), w.length()); i++) {
+            if (v.charAt(i) < w.charAt(i)) return true;
+            if (v.charAt(i) > w.charAt(i)) return false;
+        }
+        return v.length() < w.length();
+    }
+
+
+   /**
+     * Rearranges the array of 32-bit integers in ascending order.
+     * Currently assumes that the integers are nonnegative.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(int[] a) {
+        int n = a.length;
+        int[] aux = new int[n];
+        sort(a, 0, n-1, 0, aux);
+    }
+
+    // MSD sort from a[lo] to a[hi], starting at the dth byte
+    private static void sort(int[] a, int lo, int hi, int d, int[] aux) {
+
+        // cutoff to insertion sort for small subarrays
+        if (hi <= lo + CUTOFF) {
+            insertion(a, lo, hi, d);
+            return;
+        }
+
+        // compute frequency counts (need R = 256)
+        int[] count = new int[R+1];
+        int mask = R - 1;   // 0xFF;
+        int shift = BITS_PER_INT - BITS_PER_BYTE*d - BITS_PER_BYTE;
+        for (int i = lo; i <= hi; i++) {
+            int c = (a[i] >> shift) & mask;
+            count[c + 1]++;
+        }
+
+        // transform counts to indicies
+        for (int r = 0; r < R; r++)
+            count[r+1] += count[r];
+
+/************* BUGGGY CODE.
+        // for most significant byte, 0x80-0xFF comes before 0x00-0x7F
+        if (d == 0) {
+            int shift1 = count[R] - count[R/2];
+            int shift2 = count[R/2];
+            for (int r = 0; r < R/2; r++)
+                count[r] += shift1;
+            for (int r = R/2; r < R; r++)
+                count[r] -= shift2;
+        }
+************************************/
+        // distribute
+        for (int i = lo; i <= hi; i++) {
+            int c = (a[i] >> shift) & mask;
+            aux[count[c]++] = a[i];
+        }
+
+        // copy back
+        for (int i = lo; i <= hi; i++) 
+            a[i] = aux[i - lo];
+
+        // no more bits
+        if (d == 4) return;
+
+        // recursively sort for each character
+        if (count[0] > 0)
+            sort(a, lo, lo + count[0] - 1, d+1, aux);
+        for (int r = 0; r < R; r++)
+            if (count[r+1] > count[r])
+                sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux);
+    }
+
+    // TODO: insertion sort a[lo..hi], starting at dth character
+    private static void insertion(int[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && a[j] < a[j-1]; j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(int[] a, int i, int j) {
+        int temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+
+    /**
+     * Reads in a sequence of extended ASCII strings from standard input;
+     * MSD radix sorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        int n = a.length;
+        sort(a);
+        for (int i = 0; i < n; i++)
+            StdOut.println(a[i]);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/MaxPQ.java b/src/main/java/edu/princeton/cs/algs4/MaxPQ.java
new file mode 100644
index 0000000..a8d9dd3
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/MaxPQ.java
@@ -0,0 +1,330 @@
+/******************************************************************************
+ *  Compilation:  javac MaxPQ.java
+ *  Execution:    java MaxPQ < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/24pq/tinyPQ.txt
+ *  
+ *  Generic max priority queue implementation with a binary heap.
+ *  Can be used with a comparator instead of the natural order,
+ *  but the generic Key type must still be Comparable.
+ *
+ *  % java MaxPQ < tinyPQ.txt 
+ *  Q X P (6 left on pq)
+ *
+ *  We use a one-based array to simplify parent and child calculations.
+ *
+ *  Can be optimized by replacing full exchanges with half exchanges
+ *  (ala insertion sort).
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code MaxPQ} class represents a priority queue of generic keys.
+ *  It supports the usual <em>insert</em> and <em>delete-the-maximum</em>
+ *  operations, along with methods for peeking at the maximum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  <p>
+ *  This implementation uses a <em>binary heap</em>.
+ *  The <em>insert</em> and <em>delete-the-maximum</em> operations take
+ *  &Theta;(log <em>n</em>) amortized time, where <em>n</em> is the number
+ *  of elements in the priority queue. This is an amortized bound 
+ *  (and not a worst-case bound) because of array resizing operations.
+ *  The <em>min</em>, <em>size</em>, and <em>is-empty</em> operations take 
+ *  &Theta;(1) time in the worst case.
+ *  Construction takes time proportional to the specified capacity or the
+ *  number of items used to initialize the data structure.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Key> the generic type of key on this priority queue
+ */
+
+public class MaxPQ<Key> implements Iterable<Key> {
+    private Key[] pq;                    // store items at indices 1 to n
+    private int n;                       // number of items on priority queue
+    private Comparator<Key> comparator;  // optional comparator
+
+    /**
+     * Initializes an empty priority queue with the given initial capacity.
+     *
+     * @param  initCapacity the initial capacity of this priority queue
+     */
+    public MaxPQ(int initCapacity) {
+        pq = (Key[]) new Object[initCapacity + 1];
+        n = 0;
+    }
+
+    /**
+     * Initializes an empty priority queue.
+     */
+    public MaxPQ() {
+        this(1);
+    }
+
+    /**
+     * Initializes an empty priority queue with the given initial capacity,
+     * using the given comparator.
+     *
+     * @param  initCapacity the initial capacity of this priority queue
+     * @param  comparator the order in which to compare the keys
+     */
+    public MaxPQ(int initCapacity, Comparator<Key> comparator) {
+        this.comparator = comparator;
+        pq = (Key[]) new Object[initCapacity + 1];
+        n = 0;
+    }
+
+    /**
+     * Initializes an empty priority queue using the given comparator.
+     *
+     * @param  comparator the order in which to compare the keys
+     */
+    public MaxPQ(Comparator<Key> comparator) {
+        this(1, comparator);
+    }
+
+    /**
+     * Initializes a priority queue from the array of keys.
+     * Takes time proportional to the number of keys, using sink-based heap construction.
+     *
+     * @param  keys the array of keys
+     */
+    public MaxPQ(Key[] keys) {
+        n = keys.length;
+        pq = (Key[]) new Object[keys.length + 1];
+        for (int i = 0; i < n; i++)
+            pq[i+1] = keys[i];
+        for (int k = n/2; k >= 1; k--)
+            sink(k);
+        assert isMaxHeap();
+    }
+      
+
+
+    /**
+     * Returns true if this priority queue is empty.
+     *
+     * @return {@code true} if this priority queue is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Returns the number of keys on this priority queue.
+     *
+     * @return the number of keys on this priority queue
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns a largest key on this priority queue.
+     *
+     * @return a largest key on this priority queue
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
+        return pq[1];
+    }
+
+    // resize the underlying array to have the given capacity
+    private void resize(int capacity) {
+        assert capacity > n;
+        Key[] temp = (Key[]) new Object[capacity];
+        for (int i = 1; i <= n; i++) {
+            temp[i] = pq[i];
+        }
+        pq = temp;
+    }
+
+
+    /**
+     * Adds a new key to this priority queue.
+     *
+     * @param  x the new key to add to this priority queue
+     */
+    public void insert(Key x) {
+
+        // double size of array if necessary
+        if (n == pq.length - 1) resize(2 * pq.length);
+
+        // add x, and percolate it up to maintain heap invariant
+        pq[++n] = x;
+        swim(n);
+        assert isMaxHeap();
+    }
+
+    /**
+     * Removes and returns a largest key on this priority queue.
+     *
+     * @return a largest key on this priority queue
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public Key delMax() {
+        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
+        Key max = pq[1];
+        exch(1, n--);
+        sink(1);
+        pq[n+1] = null;     // to avoid loitering and help with garbage collection
+        if ((n > 0) && (n == (pq.length - 1) / 4)) resize(pq.length / 2);
+        assert isMaxHeap();
+        return max;
+    }
+
+
+   /***************************************************************************
+    * Helper functions to restore the heap invariant.
+    ***************************************************************************/
+
+    private void swim(int k) {
+        while (k > 1 && less(k/2, k)) {
+            exch(k, k/2);
+            k = k/2;
+        }
+    }
+
+    private void sink(int k) {
+        while (2*k <= n) {
+            int j = 2*k;
+            if (j < n && less(j, j+1)) j++;
+            if (!less(k, j)) break;
+            exch(k, j);
+            k = j;
+        }
+    }
+
+   /***************************************************************************
+    * Helper functions for compares and swaps.
+    ***************************************************************************/
+    private boolean less(int i, int j) {
+        if (comparator == null) {
+            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) < 0;
+        }
+        else {
+            return comparator.compare(pq[i], pq[j]) < 0;
+        }
+    }
+
+    private void exch(int i, int j) {
+        Key swap = pq[i];
+        pq[i] = pq[j];
+        pq[j] = swap;
+    }
+
+    // is pq[1..n] a max heap?
+    private boolean isMaxHeap() {
+        for (int i = 1; i <= n; i++) {
+            if (pq[i] == null) return false;
+        }
+        for (int i = n+1; i < pq.length; i++) {
+            if (pq[i] != null) return false;
+        }
+        if (pq[0] != null) return false;
+        return isMaxHeapOrdered(1);
+    }
+
+    // is subtree of pq[1..n] rooted at k a max heap?
+    private boolean isMaxHeapOrdered(int k) {
+        if (k > n) return true;
+        int left = 2*k;
+        int right = 2*k + 1;
+        if (left  <= n && less(k, left))  return false;
+        if (right <= n && less(k, right)) return false;
+        return isMaxHeapOrdered(left) && isMaxHeapOrdered(right);
+    }
+
+
+   /***************************************************************************
+    * Iterator.
+    ***************************************************************************/
+
+    /**
+     * Returns an iterator that iterates over the keys on this priority queue
+     * in descending order.
+     * The iterator doesn't implement {@code remove()} since it's optional.
+     *
+     * @return an iterator that iterates over the keys in descending order
+     */
+    public Iterator<Key> iterator() {
+        return new HeapIterator();
+    }
+
+    private class HeapIterator implements Iterator<Key> {
+
+        // create a new pq
+        private MaxPQ<Key> copy;
+
+        // add all items to copy of heap
+        // takes linear time since already in heap order so no keys move
+        public HeapIterator() {
+            if (comparator == null) copy = new MaxPQ<Key>(size());
+            else                    copy = new MaxPQ<Key>(size(), comparator);
+            for (int i = 1; i <= n; i++)
+                copy.insert(pq[i]);
+        }
+
+        public boolean hasNext()  { return !copy.isEmpty();                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Key next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            return copy.delMax();
+        }
+    }
+
+    /**
+     * Unit tests the {@code MaxPQ} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        MaxPQ<String> pq = new MaxPQ<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-")) pq.insert(item);
+            else if (!pq.isEmpty()) StdOut.print(pq.delMax() + " ");
+        }
+        StdOut.println("(" + pq.size() + " left on pq)");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Merge.java b/src/main/java/edu/princeton/cs/algs4/Merge.java
new file mode 100644
index 0000000..a05c52f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Merge.java
@@ -0,0 +1,208 @@
+/******************************************************************************
+ *  Compilation:  javac Merge.java
+ *  Execution:    java Merge < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/22mergesort/tiny.txt
+ *                https://algs4.cs.princeton.edu/22mergesort/words3.txt
+ *   
+ *  Sorts a sequence of strings from standard input using mergesort.
+ *   
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Merge < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *    
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *  
+ *  % java Merge < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Merge} class provides static methods for sorting an
+ *  array using a top-down, recursive version of <em>mergesort</em>.
+ *  <p>
+ *  This implementation takes &Theta;(<em>n</em> log <em>n</em>) time
+ *  to sort any array of length <em>n</em> (assuming comparisons
+ *  take constant time). It makes between
+ *  ~ &frac12; <em>n</em> log<sub>2</sub> <em>n</em> and
+ *  ~ 1 <em>n</em> log<sub>2</sub> <em>n</em> compares.
+ *  <p>
+ *  This sorting algorithm is stable.
+ *  It uses &Theta;(<em>n</em>) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/22mergesort">Section 2.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For an optimized version, see {@link MergeX}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Merge {
+
+    // This class should not be instantiated.
+    private Merge() { }
+
+    // stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi]
+    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {
+        // precondition: a[lo .. mid] and a[mid+1 .. hi] are sorted subarrays
+        assert isSorted(a, lo, mid);
+        assert isSorted(a, mid+1, hi);
+
+        // copy to aux[]
+        for (int k = lo; k <= hi; k++) {
+            aux[k] = a[k]; 
+        }
+
+        // merge back to a[]
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)              a[k] = aux[j++];
+            else if (j > hi)               a[k] = aux[i++];
+            else if (less(aux[j], aux[i])) a[k] = aux[j++];
+            else                           a[k] = aux[i++];
+        }
+
+        // postcondition: a[lo .. hi] is sorted
+        assert isSorted(a, lo, hi);
+    }
+
+    // mergesort a[lo..hi] using auxiliary array aux[lo..hi]
+    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {
+        if (hi <= lo) return;
+        int mid = lo + (hi - lo) / 2;
+        sort(a, aux, lo, mid);
+        sort(a, aux, mid + 1, hi);
+        merge(a, aux, lo, mid, hi);
+    }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        Comparable[] aux = new Comparable[a.length];
+        sort(a, aux, 0, a.length-1);
+        assert isSorted(a);
+    }
+
+
+   /***************************************************************************
+    *  Helper sorting function.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+        
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length - 1);
+    }
+
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+
+   /***************************************************************************
+    *  Index mergesort.
+    ***************************************************************************/
+    // stably merge a[lo .. mid] with a[mid+1 .. hi] using aux[lo .. hi]
+    private static void merge(Comparable[] a, int[] index, int[] aux, int lo, int mid, int hi) {
+
+        // copy to aux[]
+        for (int k = lo; k <= hi; k++) {
+            aux[k] = index[k]; 
+        }
+
+        // merge back to a[]
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)                    index[k] = aux[j++];
+            else if (j > hi)                     index[k] = aux[i++];
+            else if (less(a[aux[j]], a[aux[i]])) index[k] = aux[j++];
+            else                                 index[k] = aux[i++];
+        }
+    }
+
+    /**
+     * Returns a permutation that gives the elements in the array in ascending order.
+     * @param a the array
+     * @return a permutation {@code p[]} such that {@code a[p[0]]}, {@code a[p[1]]},
+     *    ..., {@code a[p[N-1]]} are in ascending order
+     */
+    public static int[] indexSort(Comparable[] a) {
+        int n = a.length;
+        int[] index = new int[n];
+        for (int i = 0; i < n; i++)
+            index[i] = i;
+
+        int[] aux = new int[n];
+        sort(a, index, aux, 0, n-1);
+        return index;
+    }
+
+    // mergesort a[lo..hi] using auxiliary array aux[lo..hi]
+    private static void sort(Comparable[] a, int[] index, int[] aux, int lo, int hi) {
+        if (hi <= lo) return;
+        int mid = lo + (hi - lo) / 2;
+        sort(a, index, aux, lo, mid);
+        sort(a, index, aux, mid + 1, hi);
+        merge(a, index, aux, lo, mid, hi);
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; mergesorts them; 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Merge.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/MergeBU.java b/src/main/java/edu/princeton/cs/algs4/MergeBU.java
new file mode 100644
index 0000000..0e35719
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/MergeBU.java
@@ -0,0 +1,149 @@
+/******************************************************************************
+ *  Compilation:  javac MergeBU.java
+ *  Execution:    java MergeBU < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/22mergesort/tiny.txt
+ *                https://algs4.cs.princeton.edu/22mergesort/words3.txt
+ *   
+ *  Sorts a sequence of strings from standard input using
+ *  bottom-up mergesort.
+ *   
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java MergeBU < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *    
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *  
+ *  % java MergeBU < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code MergeBU} class provides static methods for sorting an
+ *  array using <em>bottom-up mergesort</em>. It is non-recursive.
+ *  <p>
+ *  This implementation takes &Theta;(<em>n</em> log <em>n</em>) time
+ *  to sort any array of length <em>n</em> (assuming comparisons
+ *  take constant time). It makes between
+ *  ~ &frac12; <em>n</em> log<sub>2</sub> <em>n</em> and
+ *  ~ 1 <em>n</em> log<sub>2</sub> <em>n</em> compares.
+ *  <p>
+ *  This sorting algorithm is stable.
+ *  It uses &Theta;(<em>n</em>) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/21elementary">Section 2.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class MergeBU {
+
+    // This class should not be instantiated.
+    private MergeBU() { }
+
+    // stably merge a[lo..mid] with a[mid+1..hi] using aux[lo..hi]
+    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {
+
+        // copy to aux[]
+        for (int k = lo; k <= hi; k++) {
+            aux[k] = a[k]; 
+        }
+
+        // merge back to a[]
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)              a[k] = aux[j++];  // this copying is unneccessary
+            else if (j > hi)               a[k] = aux[i++];
+            else if (less(aux[j], aux[i])) a[k] = aux[j++];
+            else                           a[k] = aux[i++];
+        }
+
+    }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        int n = a.length;
+        Comparable[] aux = new Comparable[n];
+        for (int len = 1; len < n; len *= 2) {
+            for (int lo = 0; lo < n-len; lo += len+len) {
+                int mid  = lo+len-1;
+                int hi = Math.min(lo+len+len-1, n-1);
+                merge(a, aux, lo, mid, hi);
+            }
+        }
+        assert isSorted(a);
+    }
+
+  /***********************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; bottom-up
+     * mergesorts them; and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        MergeBU.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/MergeX.java b/src/main/java/edu/princeton/cs/algs4/MergeX.java
new file mode 100644
index 0000000..22f2c49
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/MergeX.java
@@ -0,0 +1,263 @@
+/******************************************************************************
+ *  Compilation:  javac MergeX.java
+ *  Execution:    java MergeX < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/22mergesort/tiny.txt
+ *                https://algs4.cs.princeton.edu/22mergesort/words3.txt
+ *   
+ *  Sorts a sequence of strings from standard input using an
+ *  optimized version of mergesort.
+ *   
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java MergeX < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *    
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *  
+ *  % java MergeX < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+
+/**
+ *  The {@code MergeX} class provides static methods for sorting an
+ *  array using an optimized version of mergesort.
+ *  <p>
+ *  In the worst case, this implementation takes
+ *  &Theta;(<em>n</em> log <em>n</em>) time to sort an array of
+ *  length <em>n</em> (assuming comparisons take constant time).
+ *  <p>
+ *  This sorting algorithm is stable.
+ *  It uses &Theta;(<em>n</em>) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/22mergesort">Section 2.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class MergeX {
+    private static final int CUTOFF = 7;  // cutoff to insertion sort
+
+    // This class should not be instantiated.
+    private MergeX() { }
+
+    private static void merge(Comparable[] src, Comparable[] dst, int lo, int mid, int hi) {
+
+        // precondition: src[lo .. mid] and src[mid+1 .. hi] are sorted subarrays
+        assert isSorted(src, lo, mid);
+        assert isSorted(src, mid+1, hi);
+
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)              dst[k] = src[j++];
+            else if (j > hi)               dst[k] = src[i++];
+            else if (less(src[j], src[i])) dst[k] = src[j++];   // to ensure stability
+            else                           dst[k] = src[i++];
+        }
+
+        // postcondition: dst[lo .. hi] is sorted subarray
+        assert isSorted(dst, lo, hi);
+    }
+
+    private static void sort(Comparable[] src, Comparable[] dst, int lo, int hi) {
+        // if (hi <= lo) return;
+        if (hi <= lo + CUTOFF) { 
+            insertionSort(dst, lo, hi);
+            return;
+        }
+        int mid = lo + (hi - lo) / 2;
+        sort(dst, src, lo, mid);
+        sort(dst, src, mid+1, hi);
+
+        // if (!less(src[mid+1], src[mid])) {
+        //    for (int i = lo; i <= hi; i++) dst[i] = src[i];
+        //    return;
+        // }
+
+        // using System.arraycopy() is a bit faster than the above loop
+        if (!less(src[mid+1], src[mid])) {
+            System.arraycopy(src, lo, dst, lo, hi - lo + 1);
+            return;
+        }
+
+        merge(src, dst, lo, mid, hi);
+    }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        Comparable[] aux = a.clone();
+        sort(aux, a, 0, a.length-1);  
+        assert isSorted(a);
+    }
+
+    // sort from a[lo] to a[hi] using insertion sort
+    private static void insertionSort(Comparable[] a, int lo, int hi) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1]); j--)
+                exch(a, j, j-1);
+    }
+
+
+    /*******************************************************************
+     *  Utility methods.
+     *******************************************************************/
+
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+    // is a[i] < a[j]?
+    private static boolean less(Comparable a, Comparable b) {
+        return a.compareTo(b) < 0;
+    }
+
+    // is a[i] < a[j]?
+    private static boolean less(Object a, Object b, Comparator comparator) {
+        return comparator.compare(a, b) < 0;
+    }
+
+
+    /*******************************************************************
+     *  Version that takes Comparator as argument.
+     *******************************************************************/
+
+    /**
+     * Rearranges the array in ascending order, using the provided order.
+     *
+     * @param a the array to be sorted
+     * @param comparator the comparator that defines the total order
+     */
+    public static void sort(Object[] a, Comparator comparator) {
+        Object[] aux = a.clone();
+        sort(aux, a, 0, a.length-1, comparator);
+        assert isSorted(a, comparator);
+    }
+
+    private static void merge(Object[] src, Object[] dst, int lo, int mid, int hi, Comparator comparator) {
+
+        // precondition: src[lo .. mid] and src[mid+1 .. hi] are sorted subarrays
+        assert isSorted(src, lo, mid, comparator);
+        assert isSorted(src, mid+1, hi, comparator);
+
+        int i = lo, j = mid+1;
+        for (int k = lo; k <= hi; k++) {
+            if      (i > mid)                          dst[k] = src[j++];
+            else if (j > hi)                           dst[k] = src[i++];
+            else if (less(src[j], src[i], comparator)) dst[k] = src[j++];
+            else                                       dst[k] = src[i++];
+        }
+
+        // postcondition: dst[lo .. hi] is sorted subarray
+        assert isSorted(dst, lo, hi, comparator);
+    }
+
+
+    private static void sort(Object[] src, Object[] dst, int lo, int hi, Comparator comparator) {
+        // if (hi <= lo) return;
+        if (hi <= lo + CUTOFF) { 
+            insertionSort(dst, lo, hi, comparator);
+            return;
+        }
+        int mid = lo + (hi - lo) / 2;
+        sort(dst, src, lo, mid, comparator);
+        sort(dst, src, mid+1, hi, comparator);
+
+        // using System.arraycopy() is a bit faster than the above loop
+        if (!less(src[mid+1], src[mid], comparator)) {
+            System.arraycopy(src, lo, dst, lo, hi - lo + 1);
+            return;
+        }
+
+        merge(src, dst, lo, mid, hi, comparator);
+    }
+
+    // sort from a[lo] to a[hi] using insertion sort
+    private static void insertionSort(Object[] a, int lo, int hi, Comparator comparator) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], comparator); j--)
+                exch(a, j, j-1);
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length - 1);
+    }
+
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    private static boolean isSorted(Object[] a, Comparator comparator) {
+        return isSorted(a, 0, a.length - 1, comparator);
+    }
+
+    private static boolean isSorted(Object[] a, int lo, int hi, Comparator comparator) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(a[i], a[i-1], comparator)) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Object[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; mergesorts them
+     * (using an optimized version of mergesort); 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        MergeX.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/MinPQ.java b/src/main/java/edu/princeton/cs/algs4/MinPQ.java
new file mode 100644
index 0000000..2750334
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/MinPQ.java
@@ -0,0 +1,321 @@
+/******************************************************************************
+ *  Compilation:  javac MinPQ.java
+ *  Execution:    java MinPQ < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/24pq/tinyPQ.txt
+ *  
+ *  Generic min priority queue implementation with a binary heap.
+ *  Can be used with a comparator instead of the natural order.
+ *
+ *  % java MinPQ < tinyPQ.txt
+ *  E A E (6 left on pq)
+ *
+ *  We use a one-based array to simplify parent and child calculations.
+ *
+ *  Can be optimized by replacing full exchanges with half exchanges
+ *  (ala insertion sort).
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code MinPQ} class represents a priority queue of generic keys.
+ *  It supports the usual <em>insert</em> and <em>delete-the-minimum</em>
+ *  operations, along with methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  <p>
+ *  This implementation uses a <em>binary heap</em>.
+ *  The <em>insert</em> and <em>delete-the-minimum</em> operations take
+ *  &Theta;(log <em>n</em>) amortized time, where <em>n</em> is the number
+ *  of elements in the priority queue. This is an amortized bound
+ *  (and not a worst-case bound) because of array resizing operations.
+ *  The <em>min</em>, <em>size</em>, and <em>is-empty</em> operations take
+ *  &Theta;(1) time in the worst case.
+ *  Construction takes time proportional to the specified capacity or the
+ *  number of items used to initialize the data structure.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Key> the generic type of key on this priority queue
+ */
+public class MinPQ<Key> implements Iterable<Key> {
+    private Key[] pq;                    // store items at indices 1 to n
+    private int n;                       // number of items on priority queue
+    private Comparator<Key> comparator;  // optional comparator
+
+    /**
+     * Initializes an empty priority queue with the given initial capacity.
+     *
+     * @param  initCapacity the initial capacity of this priority queue
+     */
+    public MinPQ(int initCapacity) {
+        pq = (Key[]) new Object[initCapacity + 1];
+        n = 0;
+    }
+
+    /**
+     * Initializes an empty priority queue.
+     */
+    public MinPQ() {
+        this(1);
+    }
+
+    /**
+     * Initializes an empty priority queue with the given initial capacity,
+     * using the given comparator.
+     *
+     * @param  initCapacity the initial capacity of this priority queue
+     * @param  comparator the order in which to compare the keys
+     */
+    public MinPQ(int initCapacity, Comparator<Key> comparator) {
+        this.comparator = comparator;
+        pq = (Key[]) new Object[initCapacity + 1];
+        n = 0;
+    }
+
+    /**
+     * Initializes an empty priority queue using the given comparator.
+     *
+     * @param  comparator the order in which to compare the keys
+     */
+    public MinPQ(Comparator<Key> comparator) {
+        this(1, comparator);
+    }
+
+    /**
+     * Initializes a priority queue from the array of keys.
+     * <p>
+     * Takes time proportional to the number of keys, using sink-based heap construction.
+     *
+     * @param  keys the array of keys
+     */
+    public MinPQ(Key[] keys) {
+        n = keys.length;
+        pq = (Key[]) new Object[keys.length + 1];
+        for (int i = 0; i < n; i++)
+            pq[i+1] = keys[i];
+        for (int k = n/2; k >= 1; k--)
+            sink(k);
+        assert isMinHeap();
+    }
+
+    /**
+     * Returns true if this priority queue is empty.
+     *
+     * @return {@code true} if this priority queue is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Returns the number of keys on this priority queue.
+     *
+     * @return the number of keys on this priority queue
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns a smallest key on this priority queue.
+     *
+     * @return a smallest key on this priority queue
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
+        return pq[1];
+    }
+
+    // resize the underlying array to have the given capacity
+    private void resize(int capacity) {
+        assert capacity > n;
+        Key[] temp = (Key[]) new Object[capacity];
+        for (int i = 1; i <= n; i++) {
+            temp[i] = pq[i];
+        }
+        pq = temp;
+    }
+
+    /**
+     * Adds a new key to this priority queue.
+     *
+     * @param  x the key to add to this priority queue
+     */
+    public void insert(Key x) {
+        // double size of array if necessary
+        if (n == pq.length - 1) resize(2 * pq.length);
+
+        // add x, and percolate it up to maintain heap invariant
+        pq[++n] = x;
+        swim(n);
+        assert isMinHeap();
+    }
+
+    /**
+     * Removes and returns a smallest key on this priority queue.
+     *
+     * @return a smallest key on this priority queue
+     * @throws NoSuchElementException if this priority queue is empty
+     */
+    public Key delMin() {
+        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
+        Key min = pq[1];
+        exch(1, n--);
+        sink(1);
+        pq[n+1] = null;     // to avoid loitering and help with garbage collection
+        if ((n > 0) && (n == (pq.length - 1) / 4)) resize(pq.length / 2);
+        assert isMinHeap();
+        return min;
+    }
+
+
+   /***************************************************************************
+    * Helper functions to restore the heap invariant.
+    ***************************************************************************/
+
+    private void swim(int k) {
+        while (k > 1 && greater(k/2, k)) {
+            exch(k, k/2);
+            k = k/2;
+        }
+    }
+
+    private void sink(int k) {
+        while (2*k <= n) {
+            int j = 2*k;
+            if (j < n && greater(j, j+1)) j++;
+            if (!greater(k, j)) break;
+            exch(k, j);
+            k = j;
+        }
+    }
+
+   /***************************************************************************
+    * Helper functions for compares and swaps.
+    ***************************************************************************/
+    private boolean greater(int i, int j) {
+        if (comparator == null) {
+            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) > 0;
+        }
+        else {
+            return comparator.compare(pq[i], pq[j]) > 0;
+        }
+    }
+
+    private void exch(int i, int j) {
+        Key swap = pq[i];
+        pq[i] = pq[j];
+        pq[j] = swap;
+    }
+
+    // is pq[1..n] a min heap?
+    private boolean isMinHeap() {
+        for (int i = 1; i <= n; i++) {
+            if (pq[i] == null) return false;
+        }
+        for (int i = n+1; i < pq.length; i++) {
+            if (pq[i] != null) return false;
+        }
+        if (pq[0] != null) return false;
+        return isMinHeapOrdered(1);
+    }
+
+    // is subtree of pq[1..n] rooted at k a min heap?
+    private boolean isMinHeapOrdered(int k) {
+        if (k > n) return true;
+        int left = 2*k;
+        int right = 2*k + 1;
+        if (left  <= n && greater(k, left))  return false;
+        if (right <= n && greater(k, right)) return false;
+        return isMinHeapOrdered(left) && isMinHeapOrdered(right);
+    }
+
+
+    /**
+     * Returns an iterator that iterates over the keys on this priority queue
+     * in ascending order.
+     * <p>
+     * The iterator doesn't implement {@code remove()} since it's optional.
+     *
+     * @return an iterator that iterates over the keys in ascending order
+     */
+    public Iterator<Key> iterator() {
+        return new HeapIterator();
+    }
+
+    private class HeapIterator implements Iterator<Key> {
+        // create a new pq
+        private MinPQ<Key> copy;
+
+        // add all items to copy of heap
+        // takes linear time since already in heap order so no keys move
+        public HeapIterator() {
+            if (comparator == null) copy = new MinPQ<Key>(size());
+            else                    copy = new MinPQ<Key>(size(), comparator);
+            for (int i = 1; i <= n; i++)
+                copy.insert(pq[i]);
+        }
+
+        public boolean hasNext()  { return !copy.isEmpty();                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Key next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            return copy.delMin();
+        }
+    }
+
+    /**
+     * Unit tests the {@code MinPQ} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        MinPQ<String> pq = new MinPQ<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-")) pq.insert(item);
+            else if (!pq.isEmpty()) StdOut.print(pq.delMin() + " ");
+        }
+        StdOut.println("(" + pq.size() + " left on pq)");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Multiway.java b/src/main/java/edu/princeton/cs/algs4/Multiway.java
new file mode 100644
index 0000000..b2343b7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Multiway.java
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *  Compilation:  javac Multiway.java
+ *  Execution:    java Multiway input1.txt input2.txt input3.txt ...
+ *  Dependencies: IndexMinPQ.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/24pq/m1.txt
+ *                https://algs4.cs.princeton.edu/24pq/m2.txt
+ *                https://algs4.cs.princeton.edu/24pq/m3.txt
+ * 
+ *  Merges together the sorted input stream given as command-line arguments
+ *  into a single sorted output stream on standard output.
+ *
+ *  % more m1.txt 
+ *  A B C F G I I Z
+ *
+ *  % more m2.txt 
+ *  B D H P Q Q
+ * 
+ *  % more m3.txt 
+ *  A B E F J N
+ *
+ *  % java Multiway m1.txt m2.txt m3.txt 
+ *  A A B B B C D E F F G H I I J N P Q Q Z 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Multiway} class provides a client for reading in several
+ *  sorted text files and merging them together into a single sorted
+ *  text stream.
+ *  This implementation uses a {@link IndexMinPQ} to perform the multiway
+ *  merge. 
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class Multiway { 
+
+    // This class should not be instantiated.
+    private Multiway() { }
+
+    // merge together the sorted input streams and write the sorted result to standard output
+    private static void merge(In[] streams) {
+        int n = streams.length;
+        IndexMinPQ<String> pq = new IndexMinPQ<String>(n);
+        for (int i = 0; i < n; i++)
+            if (!streams[i].isEmpty())
+                pq.insert(i, streams[i].readString());
+
+        // Extract and print min and read next from its stream. 
+        while (!pq.isEmpty()) {
+            StdOut.print(pq.minKey() + " ");
+            int i = pq.delMin();
+            if (!streams[i].isEmpty())
+                pq.insert(i, streams[i].readString());
+        }
+        StdOut.println();
+    }
+
+
+    /**
+     *  Reads sorted text files specified as command-line arguments;
+     *  merges them together into a sorted output; and writes
+     *  the results to standard output.
+     *  Note: this client does not check that the input files are sorted.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = args.length;
+        In[] streams = new In[n];
+        for (int i = 0; i < n; i++)
+            streams[i] = new In(args[i]);
+        merge(streams);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/MultiwayMinPQ.java b/src/main/java/edu/princeton/cs/algs4/MultiwayMinPQ.java
new file mode 100644
index 0000000..3238f9f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/MultiwayMinPQ.java
@@ -0,0 +1,329 @@
+/******************************************************************************
+ *  Compilation: javac MultiwayMinPQ.java   
+ *  Execution:
+ *  
+ *  A multiway heap.
+ *  
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.Comparator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The MultiwayMinPQ class represents a priority queue of generic keys.
+ *  It supports the usual insert and delete-the-minimum operations.
+ *  It also supports methods for peeking at the minimum key,
+ *  testing if the priority queue is empty, and iterating through
+ *  the keys.
+ *  It is possible to build the priority queue using a Comparator.
+ *  If not, the natural order relation between the keys will be used.
+ *  
+ *  This implementation uses a multiway heap.
+ *  For simplified notations, logarithm in base d will be referred as log-d
+ *  The delete-the-minimum operation takes time proportional to d*log-d(n)
+ *  The insert takes time proportional to log-d(n)
+ *  The is-empty, min-key and size operations take constant time.
+ *  Constructor takes time proportional to the specified capacity.
+ *
+ *  @author Tristan Claverie
+ */
+public class MultiwayMinPQ<Key> implements Iterable<Key> {
+	private final int d; 				//Dimension of the heap
+	private int n;						//Number of keys currently in the heap
+	private int order;					//Number of levels of the tree
+	private Key[] keys;					//Array of keys
+	private final Comparator<Key> comp;	//Comparator over the keys
+	
+	
+    /**
+     * Initializes an empty priority queue
+     * Worst case is O(d)
+     *
+     * @param  d dimension of the heap
+     * @throws java.lang.IllegalArgumentException if {@code d < 2}
+     */
+	public MultiwayMinPQ(int d) {
+		if (d < 2) throw new IllegalArgumentException("Dimension should be 2 or over");
+		this.d = d;
+		order = 1;
+		keys = (Key[]) new Comparable[d << 1];
+		comp = new MyComparator();
+	}
+	
+    /**
+     * Initializes an empty priority queue
+     * Worst case is O(d)
+     *
+     * @param  d dimension of the heap
+     * @param  comparator a Comparator over the keys
+     * @throws java.lang.IllegalArgumentException if {@code d < 2}
+     */
+	public MultiwayMinPQ(Comparator<Key> comparator, int d) {
+		if (d < 2) throw new IllegalArgumentException("Dimension should be 2 or over");
+		this.d = d;
+		order = 1;
+		keys = (Key[]) new Comparable[d << 1];
+		comp = comparator;
+	}
+	
+    /**
+     * Initializes a priority queue with given indexes
+     * Worst case is O(n*log-d(n))
+     *
+     * @param  d dimension of the heap
+     * @param  a an array of keys
+     * @throws java.lang.IllegalArgumentException if {@code d < 2}
+     */
+	public MultiwayMinPQ(Key[] a, int d) {
+		if (d < 2) throw new IllegalArgumentException("Dimension should be 2 or over");
+		this.d = d;
+		order = 1;
+		keys = (Key[]) new Comparable[d << 1];
+		comp = new MyComparator();
+		for (Key key : a) insert(key);
+	}
+	
+    /**
+     * Initializes a priority queue with given indexes
+     * Worst case is O(a*log-d(n))
+     *
+     * @param  d dimension of the heap
+     * @param  comparator a Comparator over the keys
+     * @param  a an array of keys
+     * @throws java.lang.IllegalArgumentException if {@code d < 2}
+     */
+	public MultiwayMinPQ(Comparator<Key> comparator, Key[] a, int d) {
+		if (d < 2) throw new IllegalArgumentException("Dimension should be 2 or over");
+		this.d = d;
+		order = 1;
+		keys = (Key[]) new Comparable[d << 1];
+		comp = comparator;
+		for (Key key : a) insert(key);
+	}
+
+        /**
+	 * Whether the priority queue is empty
+	 * Worst case is O(1)
+	 * @return true if the priority queue is empty, false if not
+	 */
+	public boolean isEmpty() {
+		return n == 0;
+	}
+
+	/**
+	 * Number of elements currently on the priority queue
+	 * Worst case is O(1)
+	 * @return the number of elements on the priority queue
+	 */
+	public int size() {
+		return n;
+	}
+
+	/**
+	 * Puts a Key on the priority queue
+	 * Worst case is O(log-d(n))
+	 * @param key a Key
+	 */
+	public void insert(Key key) {
+		keys[n+d] = key;
+		swim(n++);
+		if (n == keys.length-d) {
+			resize(getN(order+1)+d);
+			order++;
+		}
+	}
+
+	/**
+	 * Gets the minimum key currently in the queue
+	 * Worst case is O(1)
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key currently in the priority queue
+	 */
+	public Key minKey() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		return keys[d];
+	}
+
+	/**
+	 * Deletes the minimum key
+	 * Worst case is O(d*log-d(n))
+	 * @throws java.util.NoSuchElementException if the priority queue is empty
+	 * @return the minimum key
+	 */
+	public Key delMin() {
+		if (isEmpty()) throw new NoSuchElementException("Priority queue is empty");
+		exch(0, --n);
+		sink(0);
+		Key min = keys[n+d];
+		keys[n+d] = null;
+		int number = getN(order-2);
+		if(order > 1 && n == number)  {
+			resize(number+(int)Math.pow(d, order-1)+d);
+			order--;
+		}
+		return min;
+	}
+	
+	/***************************
+	 * General helper functions
+	 **************************/
+	
+	//Compares two keys
+	private boolean greater(int x, int y) {
+		int i = x+d, j = y+d;
+		if (keys[i] == null) return false;
+		if (keys[j] == null) return true;
+		return comp.compare(keys[i], keys[j]) > 0;
+	}
+	
+	//Exchanges the position of two keys
+	private void exch(int x, int y) {
+		int i = x+d, j = y+d;
+		Key swap = keys[i];
+		keys[i] = keys[j];
+		keys[j] = swap;
+	}
+	
+	//Gets the maximum number of keys in the heap, given the number of levels of the tree
+	private int getN(int order) {
+		return (1-((int)Math.pow(d, order+1)))/(1-d);
+	}
+	
+	/***************************
+	 * Functions for moving upward or downward
+	 **************************/
+	
+	//Moves upward
+	private void swim(int i) {
+		if (i > 0 && greater((i-1)/d, i)) {
+			exch(i, (i-1)/d);
+			swim((i-1)/d);
+		}
+	}
+	
+	//Moves downward
+	private void sink(int i) {
+		int child = d*i+1;
+		if (child >= n) return;
+		int min = minChild(i);
+		while (min < n && greater(i, min)) {
+			exch(i, min);
+			i = min;
+			min = minChild(i);
+		}
+	}
+	
+	/***************************
+	 * Deletes the minimum child
+	 **************************/
+	
+	//Return the minimum child of i
+	private int minChild(int i) {
+		int loBound = d*i+1, hiBound = d*i+d;
+		int min = loBound;
+		for (int cur = loBound; cur <= hiBound; cur++) {
+			if (cur < n && greater(min, cur)) min = cur;
+		}
+		return min;
+	}
+	
+	/***************************
+	 * Resize the priority queue
+	 **************************/
+	
+	//Resizes the array containing the keys
+	//If the heap is full, it adds one floor
+	//If the heap has two floors empty, it removes one
+	private void resize(int N) {
+		Key[] array = (Key[]) new Comparable[N];
+		for (int i = 0; i < Math.min(keys.length, array.length); i++) {
+			array[i] = keys[i];
+			keys[i] = null;
+		}
+		keys = array;
+	}
+	
+	/***************************
+	 * Iterator
+	 **************************/
+	
+	/**
+	 * Gets an Iterator over the keys in the priority queue in ascending order
+	 * The Iterator does not implement the remove() method
+	 * iterator() : Worst case is O(n)
+	 * next() : 	Worst case is O(d*log-d(n))
+	 * hasNext() : 	Worst case is O(1)
+	 * @return an Iterator over the keys in the priority queue in ascending order
+	 */
+	
+	public Iterator<Key> iterator() {
+		return new MyIterator();
+	}
+	
+	//Constructs an Iterator over the keys in linear time
+	private class MyIterator implements Iterator<Key> {
+		MultiwayMinPQ<Key> data;
+		
+		public MyIterator() {
+			data = new MultiwayMinPQ<Key>(comp, d);
+			data.keys = (Key[]) new Comparable[keys.length];
+			data.n = n;
+			for (int i = 0; i < keys.length; i++) {
+				data.keys[i] = keys[i];
+			}
+		}
+
+		public boolean hasNext() {
+			return !data.isEmpty();
+		}
+		
+		public Key next() {
+                        if (!hasNext()) throw new NoSuchElementException();
+			return data.delMin();
+		}
+		
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
+	
+	/***************************
+	 * Comparator
+	 **************************/
+	
+	//default Comparator
+	private class MyComparator implements Comparator<Key> {
+		@Override
+		public int compare(Key key1, Key key2) {
+			return ((Comparable<Key>) key1).compareTo(key2);
+		}
+	}
+	
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/NFA.java b/src/main/java/edu/princeton/cs/algs4/NFA.java
new file mode 100644
index 0000000..3481adf
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/NFA.java
@@ -0,0 +1,178 @@
+/******************************************************************************
+ *  Compilation:  javac NFA.java
+ *  Execution:    java NFA regexp text
+ *  Dependencies: Stack.java Bag.java Digraph.java DirectedDFS.java
+ *
+ *  % java NFA "(A*B|AC)D" AAAABD
+ *  true
+ *
+ *  % java NFA "(A*B|AC)D" AAAAC
+ *  false
+ *
+ *  % java NFA "(a|(bc)*d)*" abcbcd
+ *  true
+ *
+ *  % java NFA "(a|(bc)*d)*" abcbcbcdaaaabcbcdaaaddd
+ *  true
+ *
+ *  Remarks
+ *  -----------
+ *  The following features are not supported:
+ *    - The + operator
+ *    - Multiway or
+ *    - Metacharacters in the text
+ *    - Character classes.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code NFA} class provides a data type for creating a
+ *  <em>nondeterministic finite state automaton</em> (NFA) from a regular
+ *  expression and testing whether a given string is matched by that regular
+ *  expression.
+ *  It supports the following operations: <em>concatenation</em>,
+ *  <em>closure</em>, <em>binary or</em>, and <em>parentheses</em>.
+ *  It does not support <em>mutiway or</em>, <em>character classes</em>,
+ *  <em>metacharacters</em> (either in the text or pattern),
+ *  <em>capturing capabilities</em>, <em>greedy</em> or <em>relucantant</em>
+ *  modifiers, and other features in industrial-strength implementations
+ *  such as {@link java.util.regex.Pattern} and {@link java.util.regex.Matcher}.
+ *  <p>
+ *  This implementation builds the NFA using a digraph and a stack
+ *  and simulates the NFA using digraph search (see the textbook for details).
+ *  The constructor takes time proportional to <em>m</em>, where <em>m</em>
+ *  is the number of characters in the regular expression.
+ *  The <em>recognizes</em> method takes time proportional to <em>m n</em>,
+ *  where <em>n</em> is the number of characters in the text.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/54regexp">Section 5.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class NFA { 
+
+    private Digraph graph;     // digraph of epsilon transitions
+    private String regexp;     // regular expression
+    private final int m;       // number of characters in regular expression
+
+    /**
+     * Initializes the NFA from the specified regular expression.
+     *
+     * @param  regexp the regular expression
+     */
+    public NFA(String regexp) {
+        this.regexp = regexp;
+        m = regexp.length();
+        Stack<Integer> ops = new Stack<Integer>(); 
+        graph = new Digraph(m+1); 
+        for (int i = 0; i < m; i++) { 
+            int lp = i; 
+            if (regexp.charAt(i) == '(' || regexp.charAt(i) == '|') 
+                ops.push(i); 
+            else if (regexp.charAt(i) == ')') {
+                int or = ops.pop(); 
+
+                // 2-way or operator
+                if (regexp.charAt(or) == '|') { 
+                    lp = ops.pop();
+                    graph.addEdge(lp, or+1);
+                    graph.addEdge(or, i);
+                }
+                else if (regexp.charAt(or) == '(')
+                    lp = or;
+                else assert false;
+            } 
+
+            // closure operator (uses 1-character lookahead)
+            if (i < m-1 && regexp.charAt(i+1) == '*') { 
+                graph.addEdge(lp, i+1); 
+                graph.addEdge(i+1, lp); 
+            } 
+            if (regexp.charAt(i) == '(' || regexp.charAt(i) == '*' || regexp.charAt(i) == ')') 
+                graph.addEdge(i, i+1);
+        }
+        if (ops.size() != 0)
+            throw new IllegalArgumentException("Invalid regular expression");
+    } 
+
+    /**
+     * Returns true if the text is matched by the regular expression.
+     * 
+     * @param  txt the text
+     * @return {@code true} if the text is matched by the regular expression,
+     *         {@code false} otherwise
+     */
+    public boolean recognizes(String txt) {
+        DirectedDFS dfs = new DirectedDFS(graph, 0);
+        Bag<Integer> pc = new Bag<Integer>();
+        for (int v = 0; v < graph.V(); v++)
+            if (dfs.marked(v)) pc.add(v);
+
+        // Compute possible NFA states for txt[i+1]
+        for (int i = 0; i < txt.length(); i++) {
+            if (txt.charAt(i) == '*' || txt.charAt(i) == '|' || txt.charAt(i) == '(' || txt.charAt(i) == ')')
+                throw new IllegalArgumentException("text contains the metacharacter '" + txt.charAt(i) + "'");
+
+            Bag<Integer> match = new Bag<Integer>();
+            for (int v : pc) {
+                if (v == m) continue;
+                if ((regexp.charAt(v) == txt.charAt(i)) || regexp.charAt(v) == '.')
+                    match.add(v+1); 
+            }
+            dfs = new DirectedDFS(graph, match); 
+            pc = new Bag<Integer>();
+            for (int v = 0; v < graph.V(); v++)
+                if (dfs.marked(v)) pc.add(v);
+
+            // optimization if no states reachable
+            if (pc.size() == 0) return false;
+        }
+
+        // check for accept state
+        for (int v : pc)
+            if (v == m) return true;
+        return false;
+    }
+
+    /**
+     * Unit tests the {@code NFA} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String regexp = "(" + args[0] + ")";
+        String txt = args[1];
+        NFA nfa = new NFA(regexp);
+        StdOut.println(nfa.recognizes(txt));
+    }
+
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/NonrecursiveDFS.java b/src/main/java/edu/princeton/cs/algs4/NonrecursiveDFS.java
new file mode 100644
index 0000000..e7ed716
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/NonrecursiveDFS.java
@@ -0,0 +1,166 @@
+/******************************************************************************
+ *  Compilation:  javac NonrecursiveDFS.java
+ *  Execution:    java NonrecursiveDFS graph.txt s
+ *  Dependencies: Graph.java Queue.java Stack.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/tinyCG.txt
+ *                https://algs4.cs.princeton.edu/41graph/tinyG.txt
+ *                https://algs4.cs.princeton.edu/41graph/mediumG.txt
+ *
+ *  Run nonrecurisve depth-first search on an undirected graph.
+ *  Runs in O(E + V) time using O(V) extra space.
+ *
+ *  Explores the vertices in exactly the same order as DepthFirstSearch.java.
+ *
+ *  %  java Graph tinyG.txt
+ *  13 vertices, 13 edges 
+ *  0: 6 2 1 5 
+ *  1: 0 
+ *  2: 0 
+ *  3: 5 4 
+ *  4: 5 6 3 
+ *  5: 3 4 0 
+ *  6: 0 4 
+ *  7: 8 
+ *  8: 7 
+ *  9: 11 10 12 
+ *  10: 9 
+ *  11: 9 12 
+ *  12: 11 9 
+ *
+ *  % java NonrecursiveDFS tinyG.txt 0
+ *  0 1 2 3 4 5 6 
+ *
+ * % java NonrecursiveDFS tinyG.txt 9
+ * 9 10 11 12 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code NonrecursiveDFS} class represents a data type for finding
+ *  the vertices connected to a source vertex <em>s</em> in the undirected
+ *  graph.
+ *  <p>
+ *  This implementation uses a nonrecursive version of depth-first search
+ *  with an explicit stack.
+ *  See {@link DepthFirstSearch} for the classic recursive version.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the worst
+ *  case, where <em>V</em> is the number of vertices and <em>E</em> is the
+ *  number of edges.
+ *  The {@link #marked(int)} instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the graph). 
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class NonrecursiveDFS {
+    private boolean[] marked;  // marked[v] = is there an s-v path?
+    /**
+     * Computes the vertices connected to the source vertex {@code s} in the graph {@code G}.
+     * @param G the graph
+     * @param s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public NonrecursiveDFS(Graph G, int s) {
+        marked = new boolean[G.V()];
+
+        validateVertex(s);
+
+        // to be able to iterate over each adjacency list, keeping track of which
+        // vertex in each adjacency list needs to be explored next
+        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            adj[v] = G.adj(v).iterator();
+
+        // depth-first search using an explicit stack
+        Stack<Integer> stack = new Stack<Integer>();
+        marked[s] = true;
+        stack.push(s);
+        while (!stack.isEmpty()) {
+            int v = stack.peek();
+            if (adj[v].hasNext()) {
+                int w = adj[v].next();
+                // StdOut.printf("check %d\n", w);
+                if (!marked[w]) {
+                    // discovered vertex w for the first time
+                    marked[w] = true;
+                    // edgeTo[w] = v;
+                    stack.push(w);
+                    // StdOut.printf("dfs(%d)\n", w);
+                }
+            }
+            else {
+                // StdOut.printf("%d done\n", v);
+                stack.pop();
+            }
+        }
+    }
+
+    /**
+     * Is vertex {@code v} connected to the source vertex {@code s}?
+     * @param v the vertex
+     * @return {@code true} if vertex {@code v} is connected to the source vertex {@code s},
+     *    and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean marked(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code NonrecursiveDFS} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Graph G = new Graph(in);
+        int s = Integer.parseInt(args[1]);
+        NonrecursiveDFS dfs = new NonrecursiveDFS(G, s);
+        for (int v = 0; v < G.V(); v++)
+            if (dfs.marked(v))
+                StdOut.print(v + " ");
+        StdOut.println();
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/NonrecursiveDirectedDFS.java b/src/main/java/edu/princeton/cs/algs4/NonrecursiveDirectedDFS.java
new file mode 100644
index 0000000..338be27
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/NonrecursiveDirectedDFS.java
@@ -0,0 +1,147 @@
+/******************************************************************************
+ *  Compilation:  javac NonrecursiveDirectedDFS.java
+ *  Execution:    java NonrecursiveDirectedDFS digraph.txt s
+ *  Dependencies: Digraph.java Queue.java Stack.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Run nonrecurisve depth-first search on an directed graph.
+ *  Runs in O(E + V) time.
+ *
+ *  Explores the vertices in exactly the same order as DirectedDFS.java.
+ *
+ *
+ *  % java NonrecursiveDirectedDFS tinyDG.txt 1
+ *  1
+ *
+ *  % java NonrecursiveDirectedDFS tinyDG.txt 2
+ *  0 1 2 3 4 5
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code NonrecursiveDirectedDFS} class represents a data type for finding
+ *  the vertices reachable from a source vertex <em>s</em> in the digraph.
+ *  <p>
+ *  This implementation uses a nonrecursive version of depth-first search
+ *  with an explicit stack.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class NonrecursiveDirectedDFS {
+    private boolean[] marked;  // marked[v] = is there an s->v path?
+    /**
+     * Computes the vertices reachable from the source vertex {@code s} in the digraph {@code G}.
+     * @param  G the digraph
+     * @param  s the source vertex
+     * @throws IllegalArgumentException unless {@code 0 <= s < V}
+     */
+    public NonrecursiveDirectedDFS(Digraph G, int s) {
+        marked = new boolean[G.V()];
+        validateVertex(s);
+
+        // to be able to iterate over each adjacency list, keeping track of which
+        // vertex in each adjacency list needs to be explored next
+        Iterator<Integer>[] adj = (Iterator<Integer>[]) new Iterator[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            adj[v] = G.adj(v).iterator();
+
+        // depth-first search using an explicit stack
+        Stack<Integer> stack = new Stack<Integer>();
+        marked[s] = true;
+        stack.push(s);
+        while (!stack.isEmpty()) {
+            int v = stack.peek();
+            if (adj[v].hasNext()) {
+                int w = adj[v].next();
+                // StdOut.printf("check %d\n", w);
+                if (!marked[w]) {
+                    // discovered vertex w for the first time
+                    marked[w] = true;
+                    // edgeTo[w] = v;
+                    stack.push(w);
+                    // StdOut.printf("dfs(%d)\n", w);
+                }
+            }
+            else {
+                // StdOut.printf("%d done\n", v);
+                stack.pop();
+            }
+        }
+    }
+
+    /**
+     * Is vertex {@code v} reachable from the source vertex {@code s}?
+     * @param  v the vertex
+     * @return {@code true} if vertex {@code v} is reachable from the source vertex {@code s},
+     *         and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public boolean marked(int v) {
+        validateVertex(v);
+        return marked[v];
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code NonrecursiveDirectedDFS} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        int s = Integer.parseInt(args[1]);
+        NonrecursiveDirectedDFS dfs = new NonrecursiveDirectedDFS(G, s);
+        for (int v = 0; v < G.V(); v++)
+            if (dfs.marked(v))
+                StdOut.print(v + " ");
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Out.java b/src/main/java/edu/princeton/cs/algs4/Out.java
new file mode 100644
index 0000000..cf68471
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Out.java
@@ -0,0 +1,343 @@
+/******************************************************************************
+ *  Compilation:  javac Out.java
+ *  Execution:    java Out
+ *  Dependencies: none
+ *
+ *  Writes data of various types to: stdout, file, or socket.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.net.Socket;
+import java.util.Locale;
+
+/**
+ *  This class provides methods for writing strings and numbers to
+ *  various output streams, including standard output, file, and sockets.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Out {
+
+    // force Unicode UTF-8 encoding; otherwise it's system dependent
+    private static final String CHARSET_NAME = "UTF-8";
+
+    // assume language = English, country = US for consistency with In
+    private static final Locale LOCALE = Locale.US;
+
+    private PrintWriter out;
+
+   /**
+     * Initializes an output stream from a {@link OutputStream}.
+     *
+     * @param  os the {@code OutputStream}
+     */
+    public Out(OutputStream os) {
+        try {
+            OutputStreamWriter osw = new OutputStreamWriter(os, CHARSET_NAME);
+            out = new PrintWriter(osw, true);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+   /**
+     * Initializes an output stream from standard output.
+     */
+    public Out() {
+        this(System.out);
+    }
+
+   /**
+     * Initializes an output stream from a socket.
+     *
+     * @param  socket the socket
+     */
+    public Out(Socket socket) {
+        try {
+            OutputStream os = socket.getOutputStream();
+            OutputStreamWriter osw = new OutputStreamWriter(os, CHARSET_NAME);
+            out = new PrintWriter(osw, true);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+   /**
+     * Initializes an output stream from a file.
+     *
+     * @param  filename the name of the file
+     */
+    public Out(String filename) {
+        try {
+            OutputStream os = new FileOutputStream(filename);
+            OutputStreamWriter osw = new OutputStreamWriter(os, CHARSET_NAME);
+            out = new PrintWriter(osw, true);
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+   /**
+     * Closes the output stream.
+     */
+    public void close() {
+        out.close();
+    }
+
+   /**
+     * Terminates the current line by printing the line-separator string.
+     */
+    public void println() {
+        out.println();
+    }
+
+   /**
+     * Prints an object to this output stream and then terminates the line.
+     *
+     * @param x the object to print
+     */
+    public void println(Object x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a boolean to this output stream and then terminates the line.
+     *
+     * @param x the boolean to print
+     */
+    public void println(boolean x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a character to this output stream and then terminates the line.
+     *
+     * @param x the character to print
+     */
+    public void println(char x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a double to this output stream and then terminates the line.
+     *
+     * @param x the double to print
+     */
+    public void println(double x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a float to this output stream and then terminates the line.
+     *
+     * @param x the float to print
+     */
+    public void println(float x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints an integer to this output stream and then terminates the line.
+     *
+     * @param x the integer to print
+     */
+    public void println(int x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a long to this output stream and then terminates the line.
+     *
+     * @param x the long to print
+     */
+    public void println(long x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a byte to this output stream and then terminates the line.
+     * <p>
+     * To write binary data, see {@link BinaryOut}.
+     *
+     * @param x the byte to print
+     */
+    public void println(byte x) {
+        out.println(x);
+    }
+
+
+
+   /**
+     * Flushes this output stream.
+     */
+    public void print() {
+        out.flush();
+    }
+
+   /**
+     * Prints an object to this output stream and flushes this output stream.
+     * 
+     * @param x the object to print
+     */
+    public void print(Object x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a boolean to this output stream and flushes this output stream.
+     * 
+     * @param x the boolean to print
+     */
+    public void print(boolean x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a character to this output stream and flushes this output stream.
+     * 
+     * @param x the character to print
+     */
+    public void print(char x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a double to this output stream and flushes this output stream.
+     * 
+     * @param x the double to print
+     */
+    public void print(double x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a float to this output stream and flushes this output stream.
+     * 
+     * @param x the float to print
+     */
+    public void print(float x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints an integer to this output stream and flushes this output stream.
+     * 
+     * @param x the integer to print
+     */
+    public void print(int x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a long integer to this output stream and flushes this output stream.
+     * 
+     * @param x the long integer to print
+     */
+    public void print(long x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a byte to this output stream and flushes this output stream.
+     * 
+     * @param x the byte to print
+     */
+    public void print(byte x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a formatted string to this output stream, using the specified format
+     * string and arguments, and then flushes this output stream.
+     *
+     * @param format the format string
+     * @param args   the arguments accompanying the format string
+     */
+    public void printf(String format, Object... args) {
+        out.printf(LOCALE, format, args);
+        out.flush();
+    }
+
+   /**
+     * Prints a formatted string to this output stream, using the specified
+     * locale, format string, and arguments, and then flushes this output stream.
+     *
+     * @param locale the locale
+     * @param format the format string
+     * @param args   the arguments accompanying the format string
+     */
+    public void printf(Locale locale, String format, Object... args) {
+        out.printf(locale, format, args);
+        out.flush();
+    }
+
+
+   /**
+     * A test client.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Out out;
+
+        // write to stdout
+        out = new Out();
+        out.println("Test 1");
+        out.close();
+
+        // write to a file
+        out = new Out("test.txt");
+        out.println("Test 2");
+        out.close();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Particle.java b/src/main/java/edu/princeton/cs/algs4/Particle.java
new file mode 100644
index 0000000..34c65c5
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Particle.java
@@ -0,0 +1,253 @@
+/******************************************************************************
+ *  Compilation:  javac Particle.java
+ *  Execution:    none
+ *  Dependencies: StdDraw.java
+ *      
+ *  A particle moving in the unit box with a given position, velocity,
+ *  radius, and mass.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.Color;
+
+/**
+ *  The {@code Particle} class represents a particle moving in the unit box,
+ *  with a given position, velocity, radius, and mass. Methods are provided
+ *  for moving the particle and for predicting and resolvling elastic
+ *  collisions with vertical walls, horizontal walls, and other particles.
+ *  This data type is mutable because the position and velocity change.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/61event">Section 6.1</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Particle {
+    private static final double INFINITY = Double.POSITIVE_INFINITY;
+
+    private double rx, ry;        // position
+    private double vx, vy;        // velocity
+    private int count;            // number of collisions so far
+    private final double radius;  // radius
+    private final double mass;    // mass
+    private final Color color;    // color
+
+
+    /**
+     * Initializes a particle with the specified position, velocity, radius, mass, and color.
+     *
+     * @param  rx <em>x</em>-coordinate of position
+     * @param  ry <em>y</em>-coordinate of position
+     * @param  vx <em>x</em>-coordinate of velocity
+     * @param  vy <em>y</em>-coordinate of velocity
+     * @param  radius the radius
+     * @param  mass the mass
+     * @param  color the color
+     */
+    public Particle(double rx, double ry, double vx, double vy, double radius, double mass, Color color) {
+        this.vx = vx;
+        this.vy = vy;
+        this.rx = rx;
+        this.ry = ry;
+        this.radius = radius;
+        this.mass   = mass;
+        this.color  = color;
+    }
+         
+    /**
+     * Initializes a particle with a random position and velocity.
+     * The position is uniform in the unit box; the velocity in
+     * either direciton is chosen uniformly at random.
+     */
+    public Particle() {
+        rx     = StdRandom.uniform(0.0, 1.0);
+        ry     = StdRandom.uniform(0.0, 1.0);
+        vx     = StdRandom.uniform(-0.005, 0.005);
+        vy     = StdRandom.uniform(-0.005, 0.005);
+        radius = 0.02;
+        mass   = 0.5;
+        color  = Color.BLACK;
+    }
+
+    /**
+     * Moves this particle in a straight line (based on its velocity)
+     * for the specified amount of time.
+     *
+     * @param  dt the amount of time
+     */
+    public void move(double dt) {
+        rx += vx * dt;
+        ry += vy * dt;
+    }
+
+    /**
+     * Draws this particle to standard draw.
+     */
+    public void draw() {
+        StdDraw.setPenColor(color);
+        StdDraw.filledCircle(rx, ry, radius);
+    }
+
+    /**
+     * Returns the number of collisions involving this particle with
+     * vertical walls, horizontal walls, or other particles.
+     * This is equal to the number of calls to {@link #bounceOff},
+     * {@link #bounceOffVerticalWall}, and
+     * {@link #bounceOffHorizontalWall}.
+     *
+     * @return the number of collisions involving this particle with
+     *         vertical walls, horizontal walls, or other particles
+     */
+    public int count() {
+        return count;
+    }
+
+    /**
+     * Returns the amount of time for this particle to collide with the specified
+     * particle, assuming no interening collisions.
+     *
+     * @param  that the other particle
+     * @return the amount of time for this particle to collide with the specified
+     *         particle, assuming no interening collisions; 
+     *         {@code Double.POSITIVE_INFINITY} if the particles will not collide
+     */
+    public double timeToHit(Particle that) {
+        if (this == that) return INFINITY;
+        double dx  = that.rx - this.rx;
+        double dy  = that.ry - this.ry;
+        double dvx = that.vx - this.vx;
+        double dvy = that.vy - this.vy;
+        double dvdr = dx*dvx + dy*dvy;
+        if (dvdr > 0) return INFINITY;
+        double dvdv = dvx*dvx + dvy*dvy;
+        if (dvdv == 0) return INFINITY;
+        double drdr = dx*dx + dy*dy;
+        double sigma = this.radius + that.radius;
+        double d = (dvdr*dvdr) - dvdv * (drdr - sigma*sigma);
+        // if (drdr < sigma*sigma) StdOut.println("overlapping particles");
+        if (d < 0) return INFINITY;
+        return -(dvdr + Math.sqrt(d)) / dvdv;
+    }
+
+    /**
+     * Returns the amount of time for this particle to collide with a vertical
+     * wall, assuming no interening collisions.
+     *
+     * @return the amount of time for this particle to collide with a vertical wall,
+     *         assuming no interening collisions; 
+     *         {@code Double.POSITIVE_INFINITY} if the particle will not collide
+     *         with a vertical wall
+     */
+    public double timeToHitVerticalWall() {
+        if      (vx > 0) return (1.0 - rx - radius) / vx;
+        else if (vx < 0) return (radius - rx) / vx;  
+        else             return INFINITY;
+    }
+
+    /**
+     * Returns the amount of time for this particle to collide with a horizontal
+     * wall, assuming no interening collisions.
+     *
+     * @return the amount of time for this particle to collide with a horizontal wall,
+     *         assuming no interening collisions; 
+     *         {@code Double.POSITIVE_INFINITY} if the particle will not collide
+     *         with a horizontal wall
+     */
+    public double timeToHitHorizontalWall() {
+        if      (vy > 0) return (1.0 - ry - radius) / vy;
+        else if (vy < 0) return (radius - ry) / vy;
+        else             return INFINITY;
+    }
+
+    /**
+     * Updates the velocities of this particle and the specified particle according
+     * to the laws of elastic collision. Assumes that the particles are colliding
+     * at this instant.
+     *
+     * @param  that the other particle
+     */
+    public void bounceOff(Particle that) {
+        double dx  = that.rx - this.rx;
+        double dy  = that.ry - this.ry;
+        double dvx = that.vx - this.vx;
+        double dvy = that.vy - this.vy;
+        double dvdr = dx*dvx + dy*dvy;             // dv dot dr
+        double dist = this.radius + that.radius;   // distance between particle centers at collison
+
+        // magnitude of normal force
+        double magnitude = 2 * this.mass * that.mass * dvdr / ((this.mass + that.mass) * dist);
+
+        // normal force, and in x and y directions
+        double fx = magnitude * dx / dist;
+        double fy = magnitude * dy / dist;
+
+        // update velocities according to normal force
+        this.vx += fx / this.mass;
+        this.vy += fy / this.mass;
+        that.vx -= fx / that.mass;
+        that.vy -= fy / that.mass;
+
+        // update collision counts
+        this.count++;
+        that.count++;
+    }
+
+    /**
+     * Updates the velocity of this particle upon collision with a vertical
+     * wall (by reflecting the velocity in the <em>x</em>-direction).
+     * Assumes that the particle is colliding with a vertical wall at this instant.
+     */
+    public void bounceOffVerticalWall() {
+        vx = -vx;
+        count++;
+    }
+
+    /**
+     * Updates the velocity of this particle upon collision with a horizontal
+     * wall (by reflecting the velocity in the <em>y</em>-direction).
+     * Assumes that the particle is colliding with a horizontal wall at this instant.
+     */
+    public void bounceOffHorizontalWall() {
+        vy = -vy;
+        count++;
+    }
+
+    /**
+     * Returns the kinetic energy of this particle.
+     * The kinetic energy is given by the formula 1/2 <em>m</em> <em>v</em><sup>2</sup>,
+     * where <em>m</em> is the mass of this particle and <em>v</em> is its velocity.
+     *
+     * @return the kinetic energy of this particle
+     */
+    public double kineticEnergy() {
+        return 0.5 * mass * (vx*vx + vy*vy);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/PatriciaSET.java b/src/main/java/edu/princeton/cs/algs4/PatriciaSET.java
new file mode 100644
index 0000000..6b45ec2
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/PatriciaSET.java
@@ -0,0 +1,458 @@
+/******************************************************************************
+ *  Compilation:  javac PatriciaSET.java
+ *  Execution:    java PatriciaSET
+ *  Dependencies: StdOut.java StdRandom.java Queue.java
+ *  Data files:   n/a
+ *
+ *  A set implementation based on PATRICIA.
+ *
+ *  % java PatriciaSET 1000000 1
+ *  Creating dataset (1000000 items)...
+ *  Shuffling...
+ *  Adding (1000000 items)...
+ *  Iterating...
+ *  1000000 items iterated
+ *  Shuffling...
+ *  Deleting (500000 items)...
+ *  Iterating...
+ *  500000 items iterated
+ *  Checking...
+ *  500000 items found and 500000 (deleted) items missing
+ *  Deleting the rest (500000 items)...
+ *  PASS 1 TESTS SUCCEEDED
+ *  %
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code PatriciaSET} class provides an implementation of an
+ *  unordered set, with the restriction that the items (keys) are of class
+ *  {@link java.lang.String}. It supports the usual <em>add</em>,
+ *  <em>contains</em>, <em>delete</em>, <em>size</em>, and <em>is-empty</em>
+ *  methods. It also provides an <em>iterator</em> method for iterating over all
+ *  the elements in the set.
+ *  <p>
+ *  This unordered set class implements PATRICIA (Practical Algorithm to
+ *  Retrieve Information Coded In Alphanumeric). In spite of the acronym, string
+ *  keys are not limited to alphanumeric content. A key may possess any string
+ *  value, with one exception: a zero-length string is not permitted.
+ *  <p>
+ *  Unlike other generic set implementations that can accept a parameterized key
+ *  type, this set class can only accommodate keys of class
+ *  {@link java.lang.String}. This unfortunate restriction stems from a
+ *  limitation in Java. Although Java provides excellent support for generic
+ *  programming, the current infrastructure somewhat limits generic collection
+ *  implementations to those that employ comparison-based or hash-based methods.
+ *  PATRICIA does not employ comparisons or hashing; instead, it relies on
+ *  bit-test operations. Because Java does not furnish any generic abstractions
+ *  (or implementations) for bit-testing the contents of an object, providing
+ *  support for generic keys using PATRICIA does not seem practical.
+ *  <p>
+ *  PATRICIA is a variation of a trie, and it is often classified as a
+ *  space-optimized trie. In a classical trie, each level represents a
+ *  subsequent digit in a key. In PATRICIA, nodes only exist to identify the
+ *  digits (bits) that distinguish the individual keys within the trie. Because
+ *  PATRICIA uses a radix of two, each node has only two children, like a binary
+ *  tree. Also like a binary tree, the number of nodes, within the trie, equals
+ *  the number of keys. Consequently, some classify PATRICIA as a tree.
+ *  <p>
+ *  The analysis of PATRICIA is complicated. The theoretical wost-case
+ *  performance for an <em>add</em>, <em>contains</em>, or <em>delete</em>
+ *  operation is <strong>O(N)</strong>, when <strong>N</strong> is less than
+ *  <strong>W</strong> (where <strong>W</strong> is the length in bits of the
+ *  longest key), and <strong>O(W)</strong>, when <strong>N</strong> is greater
+ *  than <strong>W</strong>. However, the worst case is unlikely to occur with
+ *  typical use. The average (and usual) performance of PATRICIA is
+ *  approximately <strong>~lg N</strong> for each <em>add</em>,
+ *  <em>contains</em>, or <em>delete</em> operation. Although this appears to
+ *  put PATRICIA on the same footing as binary trees, this time complexity
+ *  represents the number of single-bit test operations (under PATRICIA), and
+ *  not full-key comparisons (as required by binary trees). After the single-bit
+ *  tests conclude, PATRICIA requires just one full-key comparison to confirm
+ *  the existence (or absence) of the key (per <em>add</em>, <em>contains</em>,
+ *  or <em>delete</em> operation).
+ *  <p>
+ *  In practice, decent implementations of PATRICIA can often outperform
+ *  balanced binary trees, and even hash tables. Although this particular
+ *  implementation performs well, the source code was written with an emphasis
+ *  on clarity, and not performance. PATRICIA performs admirably when its
+ *  bit-testing loops are well tuned. Consider using the source code as a guide,
+ *  should you need to produce an optimized implementation, for anther key type,
+ *  or in another programming language.
+ *  <p>
+ *  Other resources for PATRICIA:<br>
+ *  Sedgewick, R. (1990) <i>Algorithms in C</i>, Addison-Wesley<br>
+ *  Knuth, D. (1973) <i>The Art of Computer Programming</i>, Addison-Wesley<br>
+ *
+ *  @author John Hentosh (based on an implementation by Robert Sedgewick)
+ */
+public class PatriciaSET implements Iterable<String> {
+    private Node head;
+    private int count;
+
+    /* An inner Node class specifies the objects that hold each key. The b
+     * value indicates the relevant bit position.
+     */
+    private class Node {
+        private Node left, right;
+        private String key;
+        private int b;
+
+        public Node(String key, int b) {
+            this.key = key;
+            this.b = b;
+        }
+    };
+
+    /**
+     * Initializes an empty PATRICIA-based set.
+     */
+    /* The constructor creates a head (sentinel) node that contains a
+     * zero-length string.
+     */
+    public PatriciaSET() {
+        head = new Node("", 0);
+        head.left = head;
+        head.right = head;
+        count = 0;
+    }
+
+    /**
+     * Adds the key to the set if it is not already present.
+     * @param key the key to add
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public void add(String key) {
+        if (key == null) throw new IllegalArgumentException("called add(null)");
+        if (key.length() == 0) throw new IllegalArgumentException("invalid key");
+        Node p;
+        Node x = head;
+        do {
+            p = x;
+            if (safeBitTest(key, x.b)) x = x.right;
+            else                       x = x.left;
+        } while (p.b < x.b);
+        if (!x.key.equals(key)) {
+            int b = firstDifferingBit(x.key, key);
+            x = head;
+            do {
+                p = x;
+                if (safeBitTest(key, x.b)) x = x.right;
+                else                       x = x.left;
+            } while (p.b < x.b && x.b < b);
+            Node t = new Node(key, b);
+            if (safeBitTest(key, b)) {
+                t.left  = x;
+                t.right = t;
+            }
+            else {
+                t.left  = t;
+                t.right = x;
+            }
+            if (safeBitTest(key, p.b)) p.right = t;
+            else                       p.left = t;
+            count++;
+        }
+    }
+
+    /**
+     * Does the set contain the given key?
+     * @param key the key
+     * @return {@code true} if the set contains {@code key} and
+     * {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public boolean contains(String key) {
+        if (key == null) throw new IllegalArgumentException("called contains(null)");
+        if (key.length() == 0) throw new IllegalArgumentException("invalid key");
+        Node p;
+        Node x = head;
+        do {
+            p = x;
+            if (safeBitTest(key, x.b)) x = x.right;
+            else                       x = x.left;
+        } while (p.b < x.b);
+        return x.key.equals(key);
+    }
+
+    /**
+     * Removes the key from the set if the key is present.
+     * @param key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public void delete(String key) {
+        if (key == null) throw new IllegalArgumentException("called delete(null)");
+        if (key.length() == 0) throw new IllegalArgumentException("invalid key");
+        Node g;             // previous previous (grandparent)
+        Node p = head;      // previous (parent)
+        Node x = head;      // node to delete
+        do {
+            g = p;
+            p = x;
+            if (safeBitTest(key, x.b)) x = x.right;
+            else                       x = x.left;
+        } while (p.b < x.b);
+        if (x.key.equals(key)) {
+            Node z;
+            Node y = head;
+            do {            // find the true parent (z) of x
+                z = y;
+                if (safeBitTest(key, y.b)) y = y.right;
+                else                       y = y.left;
+            } while (y != x);
+            if (x == p) {   // case 1: remove (leaf node) x
+                Node c;     // child of x
+                if (safeBitTest(key, x.b)) c = x.left;
+                else                       c = x.right;
+                if (safeBitTest(key, z.b)) z.right = c;
+                else                       z.left  = c;
+            }
+            else {          // case 2: p replaces (internal node) x
+                Node c;     // child of p
+                if (safeBitTest(key, p.b)) c = p.left;
+                else                       c = p.right;
+                if (safeBitTest(key, g.b)) g.right = c;
+                else                       g.left  = c;
+                if (safeBitTest(key, z.b)) z.right = p;
+                else                       z.left  = p;
+                p.left = x.left;
+                p.right = x.right;
+                p.b = x.b;
+            }
+            count--;
+        }
+    }
+
+    /**
+     * Is the set empty?
+     * @return {@code true} if the set is empty, and {@code false}
+     * otherwise
+     */
+    boolean isEmpty() {
+        return count == 0;
+    }
+
+    /**
+     * Returns the number of keys in the set.
+     * @return the number of keys in the set
+     */
+    int size() {
+        return count;
+    }
+
+    /**
+     * Returns all of the keys in the set, as an iterator.
+     * To iterate over all of the keys in a set named {@code set}, use the
+     * foreach notation: {@code for (Key key : set)}.
+     * @return an iterator to all of the keys in the set
+     */
+    public Iterator<String> iterator() {
+        Queue<String> queue = new Queue<String>();
+        if (head.left  != head) collect(head.left,  0, queue);
+        if (head.right != head) collect(head.right, 0, queue);
+        return queue.iterator();
+    }
+
+    private void collect(Node x, int b, Queue<String> queue) {
+        if (x.b > b) {
+            collect(x.left, x.b, queue);
+            queue.enqueue(x.key);
+            collect(x.right, x.b, queue);
+        }
+    }
+
+    /**
+     * Returns a string representation of this set.
+     * @return a string representation of this set, with the keys separated
+     * by single spaces
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (String key : this) s.append(key + " ");
+        if (s.length() > 0) s.deleteCharAt(s.length() - 1);
+        return s.toString();
+    }
+
+    /* The safeBitTest function logically appends a terminating sequence (when
+     * required) to extend (logically) the string beyond its length.
+     *
+     * The inner loops of the get and put methods flow much better when they
+     * are not concerned with the lengths of strings, so a trick is employed to
+     * allow the get and put methods to view every string as an "infinite"
+     * sequence of bits. Logically, every string gets a '\uffff' character,
+     * followed by an "infinite" sequence of '\u0000' characters, appended to
+     * the end.
+     *
+     * Note that the '\uffff' character serves to mark the end of the string,
+     * and it is necessary. Simply padding with '\u0000' is insufficient to
+     * make all unique Unicode strings "look" unique to the get and put methods
+     * (because these methods do not regard string lengths).
+     */
+    private static boolean safeBitTest(String key, int b) {
+        if (b < key.length() * 16)      return bitTest(key, b) != 0;
+        if (b > key.length() * 16 + 15) return false;   // padding
+        /* 16 bits of 0xffff */         return true;    // end marker
+    }
+
+    private static int bitTest(String key, int b) {
+        return (key.charAt(b >>> 4) >>> (b & 0xf)) & 1;
+    }
+
+    /* Like the safeBitTest function, the safeCharAt function makes every
+     * string look like an "infinite" sequence of characters. Logically, every
+     * string gets a '\uffff' character, followed by an "infinite" sequence of
+     * '\u0000' characters, appended to the end.
+     */
+    private static int safeCharAt(String key, int i) {
+        if (i < key.length()) return key.charAt(i);
+        if (i > key.length()) return 0x0000;            // padding
+        else                  return 0xffff;            // end marker
+    }
+
+    /* For efficiency's sake, the firstDifferingBit function compares entire
+     * characters first, and then considers the individual bits (once it finds
+     * two characters that do not match). Also, the least significant bits of
+     * an individual character are examined first. There are many Unicode
+     * alphabets where most (if not all) of the "action" occurs in the least
+     * significant bits.
+     *
+     * Notice that the very first character comparison excludes the
+     * least-significant bit. The firstDifferingBit function must never return
+     * zero; otherwise, a node would become created as a child to the head
+     * (sentinel) node that matches the bit-index value (zero) stored in the
+     * head node. This would violate the invariant that bit-index values
+     * increase as you descend into the trie.
+     */
+    private static int firstDifferingBit(String k1, String k2) {
+        int i = 0;
+        int c1 = safeCharAt(k1, 0) & ~1;
+        int c2 = safeCharAt(k2, 0) & ~1;
+        if (c1 == c2) {
+            i = 1;
+            while (safeCharAt(k1, i) == safeCharAt(k2, i)) i++;
+            c1 = safeCharAt(k1, i);
+            c2 = safeCharAt(k2, i);
+        }
+        int b = 0;
+        while (((c1 >>> b) & 1) == ((c2 >>> b) & 1)) b++;
+        return i * 16 + b;
+    }
+
+    /**
+     * Unit tests the {@code PatriciaSET} data type.
+     * This test fixture runs a series of tests on a randomly generated dataset.
+     * You may specify up to two integer parameters on the command line. The
+     * first parameter indicates the size of the dataset. The second parameter
+     * controls the number of passes (a new random dataset becomes generated at
+     * the start of each pass).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        PatriciaSET set = new PatriciaSET();
+        int limitItem = 1000000;
+        int limitPass = 1;
+        int countPass = 0;
+        boolean ok = true;
+
+        if (args.length > 0) limitItem = Integer.parseInt(args[0]);
+        if (args.length > 1) limitPass = Integer.parseInt(args[1]);
+
+        do {
+            String[] a = new String[limitItem];
+
+            StdOut.printf("Creating dataset (%d items)...\n", limitItem);
+            for (int i = 0; i < limitItem; i++)
+                a[i] = Integer.toString(i, 16);
+
+            StdOut.printf("Shuffling...\n");
+            StdRandom.shuffle(a);
+
+            StdOut.printf("Adding (%d items)...\n", limitItem);
+            for (int i = 0; i < limitItem; i++)
+                set.add(a[i]);
+
+            int countItems = 0;
+            StdOut.printf("Iterating...\n");
+            for (String key : set) countItems++;
+            StdOut.printf("%d items iterated\n", countItems);
+            if (countItems != limitItem)  ok = false;
+            if (countItems != set.size()) ok = false;
+
+            StdOut.printf("Shuffling...\n");
+            StdRandom.shuffle(a);
+
+            int limitDelete = limitItem / 2;
+            StdOut.printf("Deleting (%d items)...\n", limitDelete);
+            for (int i = 0; i < limitDelete; i++)
+                set.delete(a[i]);
+
+            countItems = 0;
+            StdOut.printf("Iterating...\n");
+            for (String key : set) countItems++;
+            StdOut.printf("%d items iterated\n", countItems);
+            if (countItems != limitItem - limitDelete) ok = false;
+            if (countItems != set.size())              ok = false;
+
+            int countDelete = 0;
+            int countRemain = 0;
+            StdOut.printf("Checking...\n");
+            for (int i = 0; i < limitItem; i++) {
+                if (i < limitDelete) {
+                    if (!set.contains(a[i])) countDelete++;
+                }
+                else {
+                    if (set.contains(a[i])) countRemain++;
+                }
+            }
+            StdOut.printf("%d items found and %d (deleted) items missing\n",
+                countRemain, countDelete);
+            if (countRemain + countDelete != limitItem)  ok = false;
+            if (countRemain               != set.size()) ok = false;
+            if (set.isEmpty())                           ok = false;
+
+            StdOut.printf("Deleting the rest (%d items)...\n",
+                limitItem - countDelete);
+            for (int i = countDelete; i < limitItem; i++)
+                set.delete(a[i]);
+            if (!set.isEmpty()) ok = false;
+
+            countPass++;
+            if (ok) StdOut.printf("PASS %d TESTS SUCCEEDED\n", countPass);
+            else    StdOut.printf("PASS %d TESTS FAILED\n",    countPass);
+        } while (ok && countPass < limitPass);
+
+        if (!ok) throw new java.lang.RuntimeException("TESTS FAILED");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/PatriciaST.java b/src/main/java/edu/princeton/cs/algs4/PatriciaST.java
new file mode 100644
index 0000000..870d9f3
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/PatriciaST.java
@@ -0,0 +1,477 @@
+/******************************************************************************
+ *  Compilation:  javac PatriciaST.java
+ *  Execution:    java PatriciaST
+ *  Dependencies: StdOut.java StdRandom.java Queue.java
+ *  Data files:   n/a
+ *
+ *  A symbol table implementation based on PATRICIA.
+ *
+ *  % java PatriciaST 1000000 1
+ *  Creating dataset (1000000 items)...
+ *  Shuffling...
+ *  Adding (1000000 items)...
+ *  Iterating...
+ *  1000000 items iterated
+ *  Shuffling...
+ *  Deleting (500000 items)...
+ *  Iterating...
+ *  500000 items iterated
+ *  Checking...
+ *  500000 items found and 500000 (deleted) items missing
+ *  Deleting the rest (500000 items)...
+ *  PASS 1 TESTS SUCCEEDED
+ *  %
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code PatriciaST} class provides an implementation of an unordered
+ *  symbol table of key-value pairs, with the restriction that the key is of
+ *  class {@link java.lang.String}. It supports the usual <em>put</em>,
+ *  <em>get</em>, <em>contains</em>, <em>delete</em>, <em>size</em>, and
+ *  <em>is-empty</em> methods. It also provides a <em>keys</em> method for
+ *  iterating over all of the keys. A symbol table implements the
+ *  <em>associative array</em> abstraction: when associating a value with a key
+ *  that is already in the symbol table, the convention is to replace the old
+ *  value with the new value. Unlike {@link java.util.Map}, this class uses the
+ *  convention that values cannot be {@code null}‚Äîsetting the value
+ *  associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  This unordered symbol table class implements PATRICIA (Practical Algorithm
+ *  to Retrieve Information Coded In Alphanumeric). In spite of the acronym,
+ *  string keys are not limited to alphanumeric content. A key may possess any
+ *  string value, except for the string of zero length (the empty string).
+ *  <p>
+ *  Unlike other generic symbol table implementations that can accept a
+ *  parameterized key type, this symbol table class can only accommodate keys
+ *  of class {@link java.lang.String}. This unfortunate restriction stems from a
+ *  limitation in Java. Although Java provides excellent support for generic
+ *  programming, the current infrastructure somewhat limits generic collection
+ *  implementations to those that employ comparison-based or hash-based methods.
+ *  PATRICIA does not employ comparisons or hashing; instead, it relies on
+ *  bit-test operations. Because Java does not furnish any generic abstractions
+ *  (or implementations) for bit-testing the contents of an object, providing
+ *  support for generic keys using PATRICIA does not seem practical.
+ *  <p>
+ *  PATRICIA is a variation of a trie, and it is often classified as a
+ *  space-optimized trie. In a classical trie, each level represents a
+ *  subsequent digit in a key. In PATRICIA, nodes only exist to identify the
+ *  digits (bits) that distinguish the individual keys within the trie. Because
+ *  PATRICIA uses a radix of two, each node has only two children, like a binary
+ *  tree. Also like a binary tree, the number of nodes, within the trie, equals
+ *  the number of keys. Consequently, some classify PATRICIA as a tree.
+ *  <p>
+ *  The analysis of PATRICIA is complicated. The theoretical wost-case
+ *  performance for a <em>get</em>, <em>put</em>, or <em>delete</em> operation
+ *  is <strong>O(N)</strong>, when <strong>N</strong> is less than
+ *  <strong>W</strong> (where <strong>W</strong> is the length in bits of the
+ *  longest key), and <strong>O(W)</strong>, when <strong>N</strong> is greater
+ *  than <strong>W</strong>. However, the worst case is unlikely to occur with
+ *  typical use. The average (and usual) performance of PATRICIA is
+ *  approximately <strong>~lg N</strong> for each <em>get</em>, <em>put</em>, or
+ *  <em>delete</em> operation. Although this appears to put PATRICIA on the same
+ *  footing as binary trees, this time complexity represents the number of
+ *  single-bit test operations (under PATRICIA), and not full-key comparisons
+ *  (as required by binary trees). After the single-bit tests conclude, PATRICIA
+ *  requires just one full-key comparison to confirm the existence (or absence)
+ *  of the key (per <em>get</em>, <em>put</em>, or <em>delete</em> operation).
+ *  <p>
+ *  In practice, decent implementations of PATRICIA can often outperform
+ *  balanced binary trees, and even hash tables. Although this particular
+ *  implementation performs well, the source code was written with an emphasis
+ *  on clarity, and not performance. PATRICIA performs admirably when its
+ *  bit-testing loops are well tuned. Consider using the source code as a guide,
+ *  should you need to produce an optimized implementation, for anther key type,
+ *  or in another programming language.
+ *  <p>
+ *  Other resources for PATRICIA:<br>
+ *  Sedgewick, R. (1990) <i>Algorithms in C</i>, Addison-Wesley<br>
+ *  Knuth, D. (1973) <i>The Art of Computer Programming</i>, Addison-Wesley<br>
+ *
+ *  @author John Hentosh (based on an implementation by Robert Sedgewick)
+ */
+public class PatriciaST<Value> {
+    private Node head;
+    private int count;
+
+    /* An inner Node class specifies the objects that hold each key-value pair.
+     * The b value indicates the relevant bit position.
+     */
+    private class Node {
+        private Node left, right;
+        private String key;
+        private Value val;
+        private int b;
+
+        public Node(String key, Value val, int b) {
+            this.key = key;
+            this.val = val;
+            this.b = b;
+        }
+    };
+
+    /**
+     * Initializes an empty PATRICIA-based symbol table.
+     */
+    /* The constructor creates a head (sentinel) node that contains a
+     * zero-length string.
+     */
+    public PatriciaST() {
+        head = new Node("", null, 0);
+        head.left = head;
+        head.right = head;
+        count = 0;
+    }
+
+    /**
+     * Places a key-value pair into the symbol table. If the table already
+     * contains the specified key, then its associated value becomes updated.
+     * If the value provided is {@code null}, then the key becomes removed
+     * from the symbol table.
+     * @param key the key
+     * @param val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public void put(String key, Value val) {
+        if (key == null) throw new IllegalArgumentException("called put(null)");
+        if (key.length() == 0) throw new IllegalArgumentException("invalid key");
+        if (val == null) delete(key);
+        Node p;
+        Node x = head;
+        do {
+            p = x;
+            if (safeBitTest(key, x.b)) x = x.right;
+            else                       x = x.left;
+        } while (p.b < x.b);
+        if (!x.key.equals(key)) {
+            int b = firstDifferingBit(x.key, key);
+            x = head;
+            do {
+                p = x;
+                if (safeBitTest(key, x.b)) x = x.right;
+                else                       x = x.left;
+            } while (p.b < x.b && x.b < b);
+            Node t = new Node(key, val, b);
+            if (safeBitTest(key, b)) {
+                t.left  = x;
+                t.right = t;
+            }
+            else {
+                t.left  = t;
+                t.right = x;
+            }
+            if (safeBitTest(key, p.b)) p.right = t;
+            else                       p.left  = t;
+            count++;
+        }
+        else x.val = val;
+    }
+
+    /**
+     * Retrieves the value associated with the given key.
+     * @param key the key
+     * @return the value associated with the given key if the key is in the
+     * symbol table and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public Value get(String key) {
+        if (key == null) throw new IllegalArgumentException("called get(null)");
+        if (key.length() == 0) throw new IllegalArgumentException("invalid key");
+        Node p;
+        Node x = head;
+        do {
+            p = x;
+            if (safeBitTest(key, x.b)) x = x.right;
+            else                       x = x.left;
+        } while (p.b < x.b);
+        if (x.key.equals(key)) return x.val;
+        else                   return null;
+    }
+
+    /**
+     * Removes a key and its associated value from the symbol table, if it
+     * exists.
+     * @param key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public void delete(String key) {
+        if (key == null) throw new IllegalArgumentException("called delete(null)");
+        if (key.length() == 0) throw new IllegalArgumentException("invalid key");
+        Node g;             // previous previous (grandparent)
+        Node p = head;      // previous (parent)
+        Node x = head;      // node to delete
+        do {
+            g = p;
+            p = x;
+            if (safeBitTest(key, x.b)) x = x.right;
+            else                       x = x.left;
+        } while (p.b < x.b);
+        if (x.key.equals(key)) {
+            Node z;
+            Node y = head;
+            do {            // find the true parent (z) of x
+                z = y;
+                if (safeBitTest(key, y.b)) y = y.right;
+                else                       y = y.left;
+            } while (y != x);
+            if (x == p) {   // case 1: remove (leaf node) x
+                Node c;     // child of x
+                if (safeBitTest(key, x.b)) c = x.left;
+                else                       c = x.right;
+                if (safeBitTest(key, z.b)) z.right = c;
+                else                       z.left  = c;
+            }
+            else {          // case 2: p replaces (internal node) x
+                Node c;     // child of p
+                if (safeBitTest(key, p.b)) c = p.left;
+                else                       c = p.right;
+                if (safeBitTest(key, g.b)) g.right = c;
+                else                       g.left  = c;
+                if (safeBitTest(key, z.b)) z.right = p;
+                else                       z.left  = p;
+                p.left = x.left;
+                p.right = x.right;
+                p.b = x.b;
+            }
+            count--;
+        }
+    }
+
+    /**
+     * Returns {@code true} if the key-value pair, specified by the given
+     * key, exists within the symbol table.
+     * @param key the key
+     * @return {@code true} if this symbol table contains the given
+     * {@code key} and {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws IllegalArgumentException if {@code key} is the empty string.
+     */
+    public boolean contains(String key) {
+        return get(key) != null;
+    }
+
+    /**
+     * Returns {@code true} if the symbol table is empty.
+     * @return {@code true} if this symbol table is empty and
+     * {@code false} otherwise
+     */
+    boolean isEmpty() {
+        return count == 0;
+    }
+
+    /**
+     * Returns the number of key-value pairs within the symbol table.
+     * @return the number of key-value pairs within this symbol table
+     */
+    int size() {
+        return count;
+    }
+
+    /**
+     * Returns all keys in the symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named
+     * {@code st}, use the foreach notation:
+     * {@code for (Key key : st.keys())}.
+     * @return all keys in the symbol table as an {@code Iterable}
+     */
+    public Iterable<String> keys() {
+        Queue<String> queue = new Queue<String>();
+        if (head.left  != head) keys(head.left,  0, queue);
+        if (head.right != head) keys(head.right, 0, queue);
+        return queue;
+    }
+
+    private void keys(Node x, int b, Queue<String> queue) {
+        if (x.b > b) {
+            keys(x.left, x.b, queue);
+            queue.enqueue(x.key);
+            keys(x.right, x.b, queue);
+        }
+    }
+
+    /* The safeBitTest function logically appends a terminating sequence (when
+     * required) to extend (logically) the string beyond its length.
+     *
+     * The inner loops of the get and put methods flow much better when they
+     * are not concerned with the lengths of strings, so a trick is employed to
+     * allow the get and put methods to view every string as an "infinite"
+     * sequence of bits. Logically, every string gets a '\uffff' character,
+     * followed by an "infinite" sequence of '\u0000' characters, appended to
+     * the end.
+     *
+     * Note that the '\uffff' character serves to mark the end of the string,
+     * and it is necessary. Simply padding with '\u0000' is insufficient to
+     * make all unique Unicode strings "look" unique to the get and put methods
+     * (because these methods do not regard string lengths).
+     */
+    private static boolean safeBitTest(String key, int b) {
+        if (b < key.length() * 16)      return bitTest(key, b) != 0;
+        if (b > key.length() * 16 + 15) return false;   // padding
+        /* 16 bits of 0xffff */         return true;    // end marker
+    }
+
+    private static int bitTest(String key, int b) {
+        return (key.charAt(b >>> 4) >>> (b & 0xf)) & 1;
+    }
+
+    /* Like the safeBitTest function, the safeCharAt function makes every
+     * string look like an "infinite" sequence of characters. Logically, every
+     * string gets a '\uffff' character, followed by an "infinite" sequence of
+     * '\u0000' characters, appended to the end.
+     */
+    private static int safeCharAt(String key, int i) {
+        if (i < key.length()) return key.charAt(i);
+        if (i > key.length()) return 0x0000;            // padding
+        else                  return 0xffff;            // end marker
+    }
+
+    /* For efficiency's sake, the firstDifferingBit function compares entire
+     * characters first, and then considers the individual bits (once it finds
+     * two characters that do not match). Also, the least significant bits of
+     * an individual character are examined first. There are many Unicode
+     * alphabets where most (if not all) of the "action" occurs in the least
+     * significant bits.
+     *
+     * Notice that the very first character comparison excludes the
+     * least-significant bit. The firstDifferingBit function must never return
+     * zero; otherwise, a node would become created as a child to the head
+     * (sentinel) node that matches the bit-index value (zero) stored in the
+     * head node. This would violate the invariant that bit-index values
+     * increase as you descend into the trie.
+     */
+    private static int firstDifferingBit(String k1, String k2) {
+        int i = 0;
+        int c1 = safeCharAt(k1, 0) & ~1;
+        int c2 = safeCharAt(k2, 0) & ~1;
+        if (c1 == c2) {
+            i = 1;
+            while (safeCharAt(k1, i) == safeCharAt(k2, i)) i++;
+            c1 = safeCharAt(k1, i);
+            c2 = safeCharAt(k2, i);
+        }
+        int b = 0;
+        while (((c1 >>> b) & 1) == ((c2 >>> b) & 1)) b++;
+        return i * 16 + b;
+    }
+
+    /**
+     * Unit tests the {@code PatriciaST} data type.
+     * This test fixture runs a series of tests on a randomly generated dataset.
+     * You may specify up to two integer parameters on the command line. The
+     * first parameter indicates the size of the dataset. The second parameter
+     * controls the number of passes (a new random dataset becomes generated at
+     * the start of each pass).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        PatriciaST<Integer> st = new PatriciaST<Integer>();
+        int limitItem = 1000000;
+        int limitPass = 1;
+        int countPass = 0;
+        boolean ok = true;
+
+        if (args.length > 0) limitItem = Integer.parseInt(args[0]);
+        if (args.length > 1) limitPass = Integer.parseInt(args[1]);
+
+        do {
+            String[] a = new String[limitItem];
+            int[]    v = new int[limitItem];
+
+            StdOut.printf("Creating dataset (%d items)...\n", limitItem);
+            for (int i = 0; i < limitItem; i++) {
+                a[i] = Integer.toString(i, 16);
+                v[i] = i;
+            }
+
+            StdOut.printf("Shuffling...\n");
+            StdRandom.shuffle(v);
+
+            StdOut.printf("Adding (%d items)...\n", limitItem);
+            for (int i = 0; i < limitItem; i++)
+                st.put(a[v[i]], v[i]);
+
+            int countKeys = 0;
+            StdOut.printf("Iterating...\n");
+            for (String key : st.keys()) countKeys++;
+            StdOut.printf("%d items iterated\n", countKeys);
+            if (countKeys != limitItem) ok = false;
+            if (countKeys != st.size()) ok = false;
+
+            StdOut.printf("Shuffling...\n");
+            StdRandom.shuffle(v);
+
+            int limitDelete = limitItem / 2;
+            StdOut.printf("Deleting (%d items)...\n", limitDelete);
+            for (int i = 0; i < limitDelete; i++)
+                st.delete(a[v[i]]);
+
+            countKeys = 0;
+            StdOut.printf("Iterating...\n");
+            for (String key : st.keys()) countKeys++;
+            StdOut.printf("%d items iterated\n", countKeys);
+            if (countKeys != limitItem - limitDelete) ok = false;
+            if (countKeys != st.size())               ok = false;
+
+            int countDelete = 0;
+            int countRemain = 0;
+            StdOut.printf("Checking...\n");
+            for (int i = 0; i < limitItem; i++) {
+                if (i < limitDelete) {
+                    if (!st.contains(a[v[i]])) countDelete++;
+                }
+                else {
+                    int val = st.get(a[v[i]]);
+                    if (val == v[i]) countRemain++;
+                }
+            }
+            StdOut.printf("%d items found and %d (deleted) items missing\n",
+                countRemain, countDelete);
+            if (countRemain + countDelete != limitItem) ok = false;
+            if (countRemain               != st.size()) ok = false;
+            if (st.isEmpty())                           ok = false;
+
+            StdOut.printf("Deleting the rest (%d items)...\n",
+                limitItem - countDelete);
+            for (int i = countDelete; i < limitItem; i++)
+                st.delete(a[v[i]]);
+            if (!st.isEmpty()) ok = false;
+
+            countPass++;
+            if (ok) StdOut.printf("PASS %d TESTS SUCCEEDED\n", countPass);
+            else    StdOut.printf("PASS %d TESTS FAILED\n",    countPass);
+        } while (ok && countPass < limitPass);
+
+        if (!ok) throw new java.lang.RuntimeException("TESTS FAILED");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Picture.java b/src/main/java/edu/princeton/cs/algs4/Picture.java
new file mode 100644
index 0000000..7ad8f38
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Picture.java
@@ -0,0 +1,516 @@
+/******************************************************************************
+ *  Compilation:  javac Picture.java
+ *  Execution:    java Picture imagename
+ *  Dependencies: none
+ *
+ *  Data type for manipulating individual pixels of an image. The original
+ *  image can be read from a file in JPG, GIF, or PNG format, or the
+ *  user can create a blank image of a given dimension. Includes methods for
+ *  displaying the image in a window on the screen or saving to a file.
+ *
+ *  % java Picture mandrill.jpg
+ *
+ *  Remarks
+ *  -------
+ *   - pixel (x, y) is column x and row y, where (0, 0) is upper left
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.Color;
+import java.awt.FileDialog;
+import java.awt.Toolkit;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.KeyEvent;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import javax.imageio.ImageIO;
+import javax.swing.ImageIcon;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.JPanel;
+import javax.swing.KeyStroke;
+
+
+/**
+ *  This class provides methods for manipulating individual pixels of
+ *  an image using the RGB color format. The alpha component (for transparency)
+ *  is not currently supported.
+ *  The original image can be read from a {@code PNG}, {@code GIF},
+ *  or {@code JPEG} file or the user can create a blank image of a given dimension.
+ *  This class includes methods for displaying the image in a window on
+ *  the screen or saving it to a file.
+ *  <p>
+ *  Pixel (<em>col</em>, <em>row</em>) is column <em>col</em> and row <em>row</em>.
+ *  By default, the origin (0, 0) is the pixel in the top-left corner,
+ *  which is a common convention in image processing.
+ *  The method {@link #setOriginLowerLeft()} change the origin to the lower left.
+ *  <p>
+ *  The {@code get()} and {@code set()} methods use {@link Color} objects to get
+ *  or set the color of the specified pixel.
+ *  The {@code getRGB()} and {@code setRGB()} methods use a 32-bit {@code int}
+ *  to encode the color, thereby avoiding the need to create temporary
+ *  {@code Color} objects. The red (R), green (G), and blue (B) components 
+ *  are encoded using the least significant 24 bits.
+ *  Given a 32-bit {@code int} encoding the color, the following code extracts
+ *  the RGB components:
+ * <blockquote><pre>
+ *  int r = (rgb &gt;&gt; 16) &amp; 0xFF;
+ *  int g = (rgb &gt;&gt;  8) &amp; 0xFF;
+ *  int b = (rgb &gt;&gt;  0) &amp; 0xFF;
+ *  </pre></blockquote> 
+ *  Given the RGB components (8-bits each) of a color,
+ *  the following statement packs it into a 32-bit {@code int}:
+ * <blockquote><pre>
+ *  int rgb = (r &lt;&lt; 16) + (g &lt;&lt; 8) + (b &lt;&lt; 0);
+ * </pre></blockquote> 
+ *  <p>
+ *  A <em>W</em>-by-<em>H</em> picture uses ~ 4 <em>W H</em> bytes of memory,
+ *  since the color of each pixel is encoded as a 32-bit <code>int</code>.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *  See {@link GrayscalePicture} for a version that supports grayscale images.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class Picture implements ActionListener {
+    private BufferedImage image;               // the rasterized image
+    private JFrame frame;                      // on-screen view
+    private String filename;                   // name of file
+    private boolean isOriginUpperLeft = true;  // location of origin
+    private final int width, height;           // width and height
+
+   /**
+     * Creates a {@code width}-by-{@code height} picture, with {@code width} columns
+     * and {@code height} rows, where each pixel is black.
+     *
+     * @param width the width of the picture
+     * @param height the height of the picture
+     * @throws IllegalArgumentException if {@code width} is negative or zero
+     * @throws IllegalArgumentException if {@code height} is negative or zero
+     */
+    public Picture(int width, int height) {
+        if (width  <= 0) throw new IllegalArgumentException("width must be positive");
+        if (height <= 0) throw new IllegalArgumentException("height must be positive");
+        this.width  = width;
+        this.height = height;
+        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+        // set to TYPE_INT_ARGB here and in next constructor to support transparency
+    }
+
+   /**
+     * Creates a new picture that is a deep copy of the argument picture.
+     *
+     * @param  picture the picture to copy
+     * @throws IllegalArgumentException if {@code picture} is {@code null}
+     */
+    public Picture(Picture picture) {
+        if (picture == null) throw new IllegalArgumentException("constructor argument is null");
+
+        width  = picture.width();
+        height = picture.height();
+        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+        filename = picture.filename;
+        isOriginUpperLeft = picture.isOriginUpperLeft;
+        for (int col = 0; col < width(); col++)
+            for (int row = 0; row < height(); row++)
+                image.setRGB(col, row, picture.image.getRGB(col, row));
+    }
+
+   /**
+     * Creates a picture by reading an image from a file or URL.
+     *
+     * @param  name the name of the file (.png, .gif, or .jpg) or URL.
+     * @throws IllegalArgumentException if cannot read image
+     * @throws IllegalArgumentException if {@code name} is {@code null}
+     */
+    public Picture(String name) {
+        if (name == null) throw new IllegalArgumentException("constructor argument is null");
+        if (name.length() == 0) throw new IllegalArgumentException("constructor argument is the empty string");
+
+        this.filename = name;
+        try {
+            // try to read from file in working directory
+            File file = new File(name);
+            if (file.isFile()) {
+                image = ImageIO.read(file);
+            }
+
+            else {
+
+                // resource relative to .class file
+                URL url = getClass().getResource(filename);
+
+                // resource relative to classloader root
+                if (url == null) {
+                    url = getClass().getClassLoader().getResource(name);
+                }
+
+                // or URL from web
+                if (url == null) {
+                    url = new URL(name);
+                }
+
+                image = ImageIO.read(url);
+            }
+
+            if (image == null) {
+                throw new IllegalArgumentException("could not read image: " + name);
+            }
+
+            width  = image.getWidth(null);
+            height = image.getHeight(null);
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("could not open image: " + name, ioe);
+        }
+    }
+
+   /**
+     * Creates a picture by reading the image from a PNG, GIF, or JPEG file.
+     *
+     * @param file the file
+     * @throws IllegalArgumentException if cannot read image
+     * @throws IllegalArgumentException if {@code file} is {@code null}
+     */
+    public Picture(File file) {
+        if (file == null) throw new IllegalArgumentException("constructor argument is null");
+
+        try {
+            image = ImageIO.read(file);
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("could not open file: " + file, ioe);
+        }
+        if (image == null) {
+            throw new IllegalArgumentException("could not read file: " + file);
+        }
+        width  = image.getWidth(null);
+        height = image.getHeight(null);
+        filename = file.getName();
+    }
+
+   /**
+     * Returns a {@link JLabel} containing this picture, for embedding in a {@link JPanel},
+     * {@link JFrame} or other GUI widget.
+     *
+     * @return the {@code JLabel}
+     */
+    public JLabel getJLabel() {
+        if (image == null) return null;         // no image available
+        ImageIcon icon = new ImageIcon(image);
+        return new JLabel(icon);
+    }
+
+   /**
+     * Sets the origin to be the upper left pixel. This is the default.
+     */
+    public void setOriginUpperLeft() {
+        isOriginUpperLeft = true;
+    }
+
+   /**
+     * Sets the origin to be the lower left pixel.
+     */
+    public void setOriginLowerLeft() {
+        isOriginUpperLeft = false;
+    }
+
+   /**
+     * Displays the picture in a window on the screen.
+     */
+
+    // getMenuShortcutKeyMask() deprecated in Java 10 but its replacement
+    // getMenuShortcutKeyMaskEx() is not available in Java 8
+    @SuppressWarnings("deprecation") 
+    public void show() {
+
+        // create the GUI for viewing the image if needed
+        if (frame == null) {
+            frame = new JFrame();
+
+            JMenuBar menuBar = new JMenuBar();
+            JMenu menu = new JMenu("File");
+            menuBar.add(menu);
+            JMenuItem menuItem1 = new JMenuItem(" Save...   ");
+            menuItem1.addActionListener(this);
+            menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,
+                                     Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
+            menu.add(menuItem1);
+            frame.setJMenuBar(menuBar);
+
+
+
+            frame.setContentPane(getJLabel());
+            // f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
+            if (filename == null) frame.setTitle(width + "-by-" + height);
+            else                  frame.setTitle(filename);
+            frame.setResizable(false);
+            frame.pack();
+            frame.setVisible(true);
+        }
+
+        // draw
+        frame.repaint();
+    }
+
+   /**
+     * Returns the height of the picture.
+     *
+     * @return the height of the picture (in pixels)
+     */
+    public int height() {
+        return height;
+    }
+
+   /**
+     * Returns the width of the picture.
+     *
+     * @return the width of the picture (in pixels)
+     */
+    public int width() {
+        return width;
+    }
+
+    private void validateRowIndex(int row) {
+        if (row < 0 || row >= height())
+            throw new IllegalArgumentException("row index must be between 0 and " + (height() - 1) + ": " + row);
+    }
+
+    private void validateColumnIndex(int col) {
+        if (col < 0 || col >= width())
+            throw new IllegalArgumentException("column index must be between 0 and " + (width() - 1) + ": " + col);
+    }
+
+   /**
+     * Returns the color of pixel ({@code col}, {@code row}) as a {@link java.awt.Color}.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @return the color of pixel ({@code col}, {@code row})
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     */
+    public Color get(int col, int row) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        int rgb = getRGB(col, row);
+        return new Color(rgb);
+    }
+
+   /**
+     * Returns the color of pixel ({@code col}, {@code row}) as an {@code int}.
+     * Using this method can be more efficient than {@link #get(int, int)} because
+     * it does not create a {@code Color} object.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @return the integer representation of the color of pixel ({@code col}, {@code row})
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     */
+    public int getRGB(int col, int row) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        if (isOriginUpperLeft) return image.getRGB(col, row);
+        else                   return image.getRGB(col, height - row - 1);
+    }
+
+   /**
+     * Sets the color of pixel ({@code col}, {@code row}) to given color.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @param color the color
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     * @throws IllegalArgumentException if {@code color} is {@code null}
+     */
+    public void set(int col, int row, Color color) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        if (color == null) throw new IllegalArgumentException("color argument is null");
+        int rgb = color.getRGB();
+        setRGB(col, row, rgb);
+    }
+
+   /**
+     * Sets the color of pixel ({@code col}, {@code row}) to given color.
+     *
+     * @param col the column index
+     * @param row the row index
+     * @param rgb the integer representation of the color
+     * @throws IllegalArgumentException unless both {@code 0 <= col < width} and {@code 0 <= row < height}
+     */
+    public void setRGB(int col, int row, int rgb) {
+        validateColumnIndex(col);
+        validateRowIndex(row);
+        if (isOriginUpperLeft) image.setRGB(col, row, rgb);
+        else                   image.setRGB(col, height - row - 1, rgb);
+    }
+
+   /**
+     * Returns true if this picture is equal to the argument picture.
+     *
+     * @param other the other picture
+     * @return {@code true} if this picture is the same dimension as {@code other}
+     *         and if all pixels have the same color; {@code false} otherwise
+     */
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Picture that = (Picture) other;
+        if (this.width()  != that.width())  return false;
+        if (this.height() != that.height()) return false;
+        for (int col = 0; col < width(); col++)
+            for (int row = 0; row < height(); row++)
+                if (this.getRGB(col, row) != that.getRGB(col, row)) return false;
+        return true;
+    }
+
+   /**
+     * Returns a string representation of this picture.
+     * The result is a <code>width</code>-by-<code>height</code> matrix of pixels,
+     * where the color of a pixel is represented using 6 hex digits to encode
+     * the red, green, and blue components.
+     *
+     * @return a string representation of this picture
+     */
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(width +"-by-" + height + " picture (RGB values given in hex)\n");
+        for (int row = 0; row < height; row++) {
+            for (int col = 0; col < width; col++) {
+                int rgb = 0;
+                if (isOriginUpperLeft) rgb = image.getRGB(col, row);
+                else                   rgb = image.getRGB(col, height - row - 1);
+                sb.append(String.format("#%06X ", rgb & 0xFFFFFF));
+            }
+            sb.append("\n");
+        }
+        return sb.toString().trim();
+    }
+
+    /**
+     * This operation is not supported because pictures are mutable.
+     *
+     * @return does not return a value
+     * @throws UnsupportedOperationException if called
+     */
+    public int hashCode() {
+        throw new UnsupportedOperationException("hashCode() is not supported because pictures are mutable");
+    }
+
+   /**
+     * Saves the picture to a file in either PNG or JPEG format.
+     * The filetype extension must be either .png or .jpg.
+     *
+     * @param name the name of the file
+     * @throws IllegalArgumentException if {@code name} is {@code null}
+     */
+    public void save(String name) {
+        if (name == null) throw new IllegalArgumentException("argument to save() is null");
+  	if (name.length() == 0) throw new IllegalArgumentException("argument to save() is the empty string");
+        File file = new File(name);
+        if (file == null) throw new IllegalArgumentException("could not open file: '" + name + "'");
+        filename = file.getName();
+        String suffix = filename.substring(filename.lastIndexOf('.') + 1);
+        if ("jpg".equalsIgnoreCase(suffix) || "png".equalsIgnoreCase(suffix)) {
+            try {
+                ImageIO.write(image, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        else {
+            System.out.println("Error: filename must end in '.jpg' or '.png'");
+        }
+    }
+
+   /**
+     * Saves the picture to a file in a PNG or JPEG image format.
+     *
+     * @param  file the file
+     * @throws IllegalArgumentException if {@code file} is {@code null}
+     */
+    public void save(File file) {
+        if (file == null) throw new IllegalArgumentException("argument to save() is null");
+        filename = file.getName();
+        if (frame != null) frame.setTitle(filename);
+        String suffix = filename.substring(filename.lastIndexOf('.') + 1);
+        if ("jpg".equalsIgnoreCase(suffix) || "png".equalsIgnoreCase(suffix)) {
+            try {
+                ImageIO.write(image, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        else {
+            System.out.println("Error: filename must end in .jpg or .png");
+        }
+    }
+
+   /**
+     * Opens a save dialog box when the user selects "Save As" from the menu.
+     */
+    @Override
+    public void actionPerformed(ActionEvent e) {
+        FileDialog chooser = new FileDialog(frame,
+                             "Use a .png or .jpg extension", FileDialog.SAVE);
+        chooser.setVisible(true);
+        if (chooser.getFile() != null) {
+            save(chooser.getDirectory() + File.separator + chooser.getFile());
+        }
+    }
+
+   /**
+     * Unit tests this {@code Picture} data type.
+     * Reads a picture specified by the command-line argument,
+     * and shows it in a window on the screen.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Picture picture = new Picture(args[0]);
+        System.out.printf("%d-by-%d\n", picture.width(), picture.height());
+        picture.show();
+    }
+
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/PictureDump.java b/src/main/java/edu/princeton/cs/algs4/PictureDump.java
new file mode 100644
index 0000000..bcd4e9a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/PictureDump.java
@@ -0,0 +1,90 @@
+/******************************************************************************
+ *  Compilation:  javac PictureDump.java
+ *  Execution:    java PictureDump width height < file
+ *  Dependencies: BinaryStdIn.java Picture.java
+ *  Data file:    http://introcs.cs.princeton.edu/stdlib/abra.txt
+ *  
+ *  Reads in a binary file and writes out the bits as w-by-h picture,
+ *  with the 1 bits in black and the 0 bits in white.
+ *
+ *  % more abra.txt 
+ *  ABRACADABRA!
+ *
+ *  % java PictureDump 16 6 < abra.txt
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.Color;
+
+
+/**
+ *  The {@code PictureDump} class provides a client for displaying the contents
+ *  of a binary file as a black-and-white picture.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  <p>
+ *  See also {@link BinaryDump} and {@link HexDump}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class PictureDump {
+
+    // Do not instantiate.
+    private PictureDump() { }
+
+    /**
+     * Reads in a sequence of bytes from standard input and draws
+     * them to standard drawing output as a width-by-height picture,
+     * using black for 1 and white for 0 (and red for any leftover
+     * pixels).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int width = Integer.parseInt(args[0]);
+        int height = Integer.parseInt(args[1]);
+        Picture picture = new Picture(width, height);
+        for (int row = 0; row < height; row++) {
+            for (int col = 0; col < width; col++) {
+                if (!BinaryStdIn.isEmpty()) {
+                    boolean bit = BinaryStdIn.readBoolean();
+                    if (bit) picture.set(col, row, Color.BLACK);
+                    else     picture.set(col, row, Color.WHITE);
+                }
+                else {
+                    picture.set(col, row, Color.RED);
+                }
+            }
+        }
+        picture.show();
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/PlayMusic.java b/src/main/java/edu/princeton/cs/algs4/PlayMusic.java
new file mode 100644
index 0000000..f9f14e4
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/PlayMusic.java
@@ -0,0 +1,114 @@
+import java.io.InputStream;
+import java.io.IOException;
+
+import java.applet.*;
+import java.net.*;
+import java.io.*;
+
+import javax.sound.sampled.AudioFormat;
+import javax.sound.sampled.AudioInputStream;
+import javax.sound.sampled.AudioSystem;
+import javax.sound.sampled.DataLine;
+import javax.sound.sampled.LineUnavailableException;
+import javax.sound.sampled.SourceDataLine;
+import javax.sound.sampled.UnsupportedAudioFileException;
+
+
+public class PlayMusic {
+
+    // play sound file using Applet.newAudioClip();
+    private static void playApplet(String filename) {
+        URL url = null;
+        try {
+            File file = new File(filename);
+            if (file.canRead()) url = file.toURI().toURL();
+        }
+        catch (MalformedURLException e) { e.printStackTrace(); }
+        // URL url = StdAudio.class.getResource(filename);
+        if (url == null) throw new RuntimeException("audio " + filename + " not found");
+        AudioClip clip = Applet.newAudioClip(url);
+        clip.play();
+    }
+
+
+    public static synchronized void play(final String filename) {
+
+        // code adapted from: http://stackoverflow.com/questions/26305/how-can-i-play-sound-in-java
+        try {
+            System.out.println("trying AudioSystem.getClip()");
+
+            // check if file format is supported
+            // (if not, will throw an UnsupportedAudioFileException)
+            InputStream is = PlayMusic.class.getResourceAsStream(filename);
+            AudioInputStream ais = AudioSystem.getAudioInputStream(is);
+
+            new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    stream(filename);
+                }
+            }).start();
+        }
+
+        // let's try Applet.newAudioClip() instead
+        catch (UnsupportedAudioFileException e) {
+            System.out.println("trying Applet.newAudioClip()");
+            playApplet(filename);
+            System.out.println("done 2");
+            return;
+        }
+
+        // something else went wrong
+        catch (Exception e) {
+            System.out.println(e);
+            System.out.println("Could not play " + filename);
+        }
+
+    }
+
+
+    // https://www3.ntu.edu.sg/home/ehchua/programming/java/J8c_PlayingSound.html
+    // play a wav or aif file
+    // javax.sound.sampled.Clip fails for long clips (on some systems)
+    private static void stream(String filename) {
+        SourceDataLine line = null;
+//        int BUFFER_SIZE = 65526; // 64K buffer
+        int BUFFER_SIZE = 4096; // 4K buffer
+
+        try {
+            InputStream is = PlayMusic.class.getResourceAsStream(filename);
+            AudioInputStream ais = AudioSystem.getAudioInputStream(is);
+            AudioFormat audioFormat = ais.getFormat();
+            DataLine.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);
+            line = (SourceDataLine) AudioSystem.getLine(info);
+            line.open(audioFormat);
+            line.start();
+            byte[] samples = new byte[BUFFER_SIZE];
+            int count = 0;
+            while ((count = ais.read(samples, 0, BUFFER_SIZE)) != -1) {
+                line.write(samples, 0, count);
+            }
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+        catch (UnsupportedAudioFileException e) {
+            e.printStackTrace();
+        }
+        catch (LineUnavailableException e) {
+            e.printStackTrace();
+        }
+        finally {
+            if (line != null) {
+                line.drain();
+                line.close();
+            }
+        }
+    }
+
+    public static void main(String[] args) {
+        String filename = args[0];
+        play(filename);
+        System.out.println("done");
+    }
+}
diff --git a/src/main/java/edu/princeton/cs/algs4/Point2D.java b/src/main/java/edu/princeton/cs/algs4/Point2D.java
new file mode 100644
index 0000000..d9980c6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Point2D.java
@@ -0,0 +1,396 @@
+/******************************************************************************
+ *  Compilation:  javac Point2D.java
+ *  Execution:    java Point2D x0 y0 n
+ *  Dependencies: StdDraw.java StdRandom.java
+ *
+ *  Immutable point data type for points in the plane.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+import java.util.Comparator;
+
+
+/**
+ *  The {@code Point} class is an immutable data type to encapsulate a
+ *  two-dimensional point with real-value coordinates.
+ *  <p>
+ *  Note: in order to deal with the difference behavior of double and 
+ *  Double with respect to -0.0 and +0.0, the Point2D constructor converts
+ *  any coordinates that are -0.0 to +0.0.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class Point2D implements Comparable<Point2D> {
+
+    /**
+     * Compares two points by x-coordinate.
+     */
+    public static final Comparator<Point2D> X_ORDER = new XOrder();
+
+    /**
+     * Compares two points by y-coordinate.
+     */
+    public static final Comparator<Point2D> Y_ORDER = new YOrder();
+
+    /**
+     * Compares two points by polar radius.
+     */
+    public static final Comparator<Point2D> R_ORDER = new ROrder();
+
+    private final double x;    // x coordinate
+    private final double y;    // y coordinate
+
+    /**
+     * Initializes a new point (x, y).
+     * @param x the x-coordinate
+     * @param y the y-coordinate
+     * @throws IllegalArgumentException if either {@code x} or {@code y}
+     *    is {@code Double.NaN}, {@code Double.POSITIVE_INFINITY} or
+     *    {@code Double.NEGATIVE_INFINITY}
+     */
+    public Point2D(double x, double y) {
+        if (Double.isInfinite(x) || Double.isInfinite(y))
+            throw new IllegalArgumentException("Coordinates must be finite");
+        if (Double.isNaN(x) || Double.isNaN(y))
+            throw new IllegalArgumentException("Coordinates cannot be NaN");
+        if (x == 0.0) this.x = 0.0;  // convert -0.0 to +0.0
+        else          this.x = x;
+
+        if (y == 0.0) this.y = 0.0;  // convert -0.0 to +0.0
+        else          this.y = y;
+    }
+
+    /**
+     * Returns the x-coordinate.
+     * @return the x-coordinate
+     */
+    public double x() {
+        return x;
+    }
+
+    /**
+     * Returns the y-coordinate.
+     * @return the y-coordinate
+     */
+    public double y() {
+        return y;
+    }
+
+    /**
+     * Returns the polar radius of this point.
+     * @return the polar radius of this point in polar coordiantes: sqrt(x*x + y*y)
+     */
+    public double r() {
+        return Math.sqrt(x*x + y*y);
+    }
+
+    /**
+     * Returns the angle of this point in polar coordinates.
+     * @return the angle (in radians) of this point in polar coordiantes (between ‚Äì&pi; and &pi;)
+     */
+    public double theta() {
+        return Math.atan2(y, x);
+    }
+
+    /**
+     * Returns the angle between this point and that point.
+     * @return the angle in radians (between ‚Äì&pi; and &pi;) between this point and that point (0 if equal)
+     */
+    private double angleTo(Point2D that) {
+        double dx = that.x - this.x;
+        double dy = that.y - this.y;
+        return Math.atan2(dy, dx);
+    }
+
+    /**
+     * Returns true if a‚Üíb‚Üíc is a counterclockwise turn.
+     * @param a first point
+     * @param b second point
+     * @param c third point
+     * @return { -1, 0, +1 } if a‚Üíb‚Üíc is a { clockwise, collinear; counterclocwise } turn.
+     */
+    public static int ccw(Point2D a, Point2D b, Point2D c) {
+        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
+        if      (area2 < 0) return -1;
+        else if (area2 > 0) return +1;
+        else                return  0;
+    }
+
+    /**
+     * Returns twice the signed area of the triangle a-b-c.
+     * @param a first point
+     * @param b second point
+     * @param c third point
+     * @return twice the signed area of the triangle a-b-c
+     */
+    public static double area2(Point2D a, Point2D b, Point2D c) {
+        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
+    }
+
+    /**
+     * Returns the Euclidean distance between this point and that point.
+     * @param that the other point
+     * @return the Euclidean distance between this point and that point
+     */
+    public double distanceTo(Point2D that) {
+        double dx = this.x - that.x;
+        double dy = this.y - that.y;
+        return Math.sqrt(dx*dx + dy*dy);
+    }
+
+    /**
+     * Returns the square of the Euclidean distance between this point and that point.
+     * @param that the other point
+     * @return the square of the Euclidean distance between this point and that point
+     */
+    public double distanceSquaredTo(Point2D that) {
+        double dx = this.x - that.x;
+        double dy = this.y - that.y;
+        return dx*dx + dy*dy;
+    }
+
+    /**
+     * Compares two points by y-coordinate, breaking ties by x-coordinate.
+     * Formally, the invoking point (x0, y0) is less than the argument point (x1, y1)
+     * if and only if either {@code y0 < y1} or if {@code y0 == y1} and {@code x0 < x1}.
+     *
+     * @param  that the other point
+     * @return the value {@code 0} if this string is equal to the argument
+     *         string (precisely when {@code equals()} returns {@code true});
+     *         a negative integer if this point is less than the argument
+     *         point; and a positive integer if this point is greater than the
+     *         argument point
+     */
+    public int compareTo(Point2D that) {
+        if (this.y < that.y) return -1;
+        if (this.y > that.y) return +1;
+        if (this.x < that.x) return -1;
+        if (this.x > that.x) return +1;
+        return 0;
+    }
+
+    /**
+     * Compares two points by polar angle (between 0 and 2&pi;) with respect to this point.
+     *
+     * @return the comparator
+     */
+    public Comparator<Point2D> polarOrder() {
+        return new PolarOrder();
+    }
+
+    /**
+     * Compares two points by atan2() angle (between ‚Äì&pi; and &pi;) with respect to this point.
+     *
+     * @return the comparator
+     */
+    public Comparator<Point2D> atan2Order() {
+        return new Atan2Order();
+    }
+
+    /**
+     * Compares two points by distance to this point.
+     *
+     * @return the comparator
+     */
+    public Comparator<Point2D> distanceToOrder() {
+        return new DistanceToOrder();
+    }
+
+    // compare points according to their x-coordinate
+    private static class XOrder implements Comparator<Point2D> {
+        public int compare(Point2D p, Point2D q) {
+            if (p.x < q.x) return -1;
+            if (p.x > q.x) return +1;
+            return 0;
+        }
+    }
+
+    // compare points according to their y-coordinate
+    private static class YOrder implements Comparator<Point2D> {
+        public int compare(Point2D p, Point2D q) {
+            if (p.y < q.y) return -1;
+            if (p.y > q.y) return +1;
+            return 0;
+        }
+    }
+
+    // compare points according to their polar radius
+    private static class ROrder implements Comparator<Point2D> {
+        public int compare(Point2D p, Point2D q) {
+            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);
+            if (delta < 0) return -1;
+            if (delta > 0) return +1;
+            return 0;
+        }
+    }
+ 
+    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point
+    private class Atan2Order implements Comparator<Point2D> {
+        public int compare(Point2D q1, Point2D q2) {
+            double angle1 = angleTo(q1);
+            double angle2 = angleTo(q2);
+            if      (angle1 < angle2) return -1;
+            else if (angle1 > angle2) return +1;
+            else                      return  0;
+        }
+    }
+
+    // compare other points relative to polar angle (between 0 and 2pi) they make with this Point
+    private class PolarOrder implements Comparator<Point2D> {
+        public int compare(Point2D q1, Point2D q2) {
+            double dx1 = q1.x - x;
+            double dy1 = q1.y - y;
+            double dx2 = q2.x - x;
+            double dy2 = q2.y - y;
+
+            if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below
+            else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above
+            else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal
+                if      (dx1 >= 0 && dx2 < 0) return -1;
+                else if (dx2 >= 0 && dx1 < 0) return +1;
+                else                          return  0;
+            }
+            else return -ccw(Point2D.this, q1, q2);     // both above or below
+
+            // Note: ccw() recomputes dx1, dy1, dx2, and dy2
+        }
+    }
+
+    // compare points according to their distance to this point
+    private class DistanceToOrder implements Comparator<Point2D> {
+        public int compare(Point2D p, Point2D q) {
+            double dist1 = distanceSquaredTo(p);
+            double dist2 = distanceSquaredTo(q);
+            if      (dist1 < dist2) return -1;
+            else if (dist1 > dist2) return +1;
+            else                    return  0;
+        }
+    }
+
+
+    /**       
+     * Compares this point to the specified point.
+     *       
+     * @param  other the other point
+     * @return {@code true} if this point equals {@code other};
+     *         {@code false} otherwise
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Point2D that = (Point2D) other;
+        return this.x == that.x && this.y == that.y;
+    }
+
+    /**
+     * Return a string representation of this point.
+     * @return a string representation of this point in the format (x, y)
+     */
+    @Override
+    public String toString() {
+        return "(" + x + ", " + y + ")";
+    }
+
+    /**
+     * Returns an integer hash code for this point.
+     * @return an integer hash code for this point
+     */
+    @Override
+    public int hashCode() {
+        int hashX = ((Double) x).hashCode();
+        int hashY = ((Double) y).hashCode();
+        return 31*hashX + hashY;
+    }
+
+    /**
+     * Plot this point using standard draw.
+     */
+    public void draw() {
+        StdDraw.point(x, y);
+    }
+
+    /**
+     * Plot a line from this point to that point using standard draw.
+     * @param that the other point
+     */
+    public void drawTo(Point2D that) {
+        StdDraw.line(this.x, this.y, that.x, that.y);
+    }
+
+
+    /**
+     * Unit tests the point data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int x0 = Integer.parseInt(args[0]);
+        int y0 = Integer.parseInt(args[1]);
+        int n = Integer.parseInt(args[2]);
+
+        StdDraw.setCanvasSize(800, 800);
+        StdDraw.setXscale(0, 100);
+        StdDraw.setYscale(0, 100);
+        StdDraw.setPenRadius(0.005);
+        StdDraw.enableDoubleBuffering();
+
+        Point2D[] points = new Point2D[n];
+        for (int i = 0; i < n; i++) {
+            int x = StdRandom.uniform(100);
+            int y = StdRandom.uniform(100);
+            points[i] = new Point2D(x, y);
+            points[i].draw();
+        }
+
+        // draw p = (x0, x1) in red
+        Point2D p = new Point2D(x0, y0);
+        StdDraw.setPenColor(StdDraw.RED);
+        StdDraw.setPenRadius(0.02);
+        p.draw();
+
+
+        // draw line segments from p to each point, one at a time, in polar order
+        StdDraw.setPenRadius();
+        StdDraw.setPenColor(StdDraw.BLUE);
+        Arrays.sort(points, p.polarOrder());
+        for (int i = 0; i < n; i++) {
+            p.drawTo(points[i]);
+            StdDraw.show();
+            StdDraw.pause(100);
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Polynomial.java b/src/main/java/edu/princeton/cs/algs4/Polynomial.java
new file mode 100644
index 0000000..8627c49
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Polynomial.java
@@ -0,0 +1,293 @@
+/******************************************************************************
+ *  Compilation:  javac Polynomial.java
+ *  Execution:    java Polynomial
+ *
+ *  Polynomials with integer coefficients.
+ *
+ *  % java Polynomial
+ *  zero(x)     = 0
+ *  p(x)        = 4x^3 + 3x^2 + 2x + 1
+ *  q(x)        = 3x^2 + 5
+ *  p(x) + q(x) = 4x^3 + 6x^2 + 2x + 6
+ *  p(x) * q(x) = 12x^5 + 9x^4 + 26x^3 + 18x^2 + 10x + 5
+ *  p(q(x))     = 108x^6 + 567x^4 + 996x^2 + 586
+ *  p(x) - p(x) = 0
+ *  0 - p(x)    = -4x^3 - 3x^2 - 2x - 1
+ *  p(3)        = 142
+ *  p'(x)       = 12x^2 + 6x + 2
+ *  p''(x)      = 24x + 6
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Polynomial} class represents a polynomial with integer
+ *  coefficients.
+ *  Polynomials are immutable: their values cannot be changed after they
+ *  are created.
+ *  It includes methods for addition, subtraction, multiplication, composition,
+ *  differentiation, and evaluation.
+ *  <p>
+ *  This computes correct results if all arithmetic performed is
+ *  without overflow.
+ *  <p> 
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/99scientific">Section 9.9</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Polynomial {
+    private int[] coef;   // coefficients p(x) = sum { coef[i] * x^i }
+    private int degree;   // degree of polynomial (-1 for the zero polynomial)
+
+    /**
+     * Initializes a new polynomial a x^b
+     * @param a the leading coefficient
+     * @param b the exponent
+     * @throws IllegalArgumentException if {@code b} is negative
+     */
+    public Polynomial(int a, int b) {
+        if (b < 0) {
+            throw new IllegalArgumentException("exponent cannot be negative: " + b);
+        }
+        coef = new int[b+1];
+        coef[b] = a;
+        reduce();
+    }
+
+    // pre-compute the degree of the polynomial, in case of leading zero coefficients
+    // (that is, the length of the array need not relate to the degree of the polynomial)
+    private void reduce() {
+        degree = -1;
+        for (int i = coef.length - 1; i >= 0; i--) {
+            if (coef[i] != 0) {
+                degree = i;
+                return;
+            }
+        }
+    }
+
+    /**
+     * Returns the degree of this polynomial.
+     * @return the degree of this polynomial, -1 for the zero polynomial.
+     */
+    public int degree() {
+        return degree;
+    }
+
+    /**
+     * Returns the sum of this polynomial and the specified polynomial.
+     *
+     * @param  that the other polynomial
+     * @return the polynomial whose value is {@code (this(x) + that(x))}
+     */
+    public Polynomial plus(Polynomial that) {
+        Polynomial poly = new Polynomial(0, Math.max(this.degree, that.degree));
+        for (int i = 0; i <= this.degree; i++) poly.coef[i] += this.coef[i];
+        for (int i = 0; i <= that.degree; i++) poly.coef[i] += that.coef[i];
+        poly.reduce();
+        return poly;
+    }
+
+    /**
+     * Returns the result of subtracting the specified polynomial
+     * from this polynomial.
+     *
+     * @param  that the other polynomial
+     * @return the polynomial whose value is {@code (this(x) - that(x))}
+     */
+    public Polynomial minus(Polynomial that) {
+        Polynomial poly = new Polynomial(0, Math.max(this.degree, that.degree));
+        for (int i = 0; i <= this.degree; i++) poly.coef[i] += this.coef[i];
+        for (int i = 0; i <= that.degree; i++) poly.coef[i] -= that.coef[i];
+        poly.reduce();
+        return poly;
+    }
+
+    /**
+     * Returns the product of this polynomial and the specified polynomial.
+     * Takes time proportional to the product of the degrees.
+     * (Faster algorithms are known, e.g., via FFT.)
+     *
+     * @param  that the other polynomial
+     * @return the polynomial whose value is {@code (this(x) * that(x))}
+     */
+    public Polynomial times(Polynomial that) {
+        Polynomial poly = new Polynomial(0, this.degree + that.degree);
+        for (int i = 0; i <= this.degree; i++)
+            for (int j = 0; j <= that.degree; j++)
+                poly.coef[i+j] += (this.coef[i] * that.coef[j]);
+        poly.reduce();
+        return poly;
+    }
+
+    /**
+     * Returns the composition of this polynomial and the specified
+     * polynomial.
+     * Takes time proportional to the product of the degrees.
+     * (Faster algorithms are known, e.g., via FFT.)
+     *
+     * @param  that the other polynomial
+     * @return the polynomial whose value is {@code (this(that(x)))}
+     */
+    public Polynomial compose(Polynomial that) {
+        Polynomial poly = new Polynomial(0, 0);
+        for (int i = this.degree; i >= 0; i--) {
+            Polynomial term = new Polynomial(this.coef[i], 0);
+            poly = term.plus(that.times(poly));
+        }
+        return poly;
+    }
+
+
+    /**       
+     * Compares this polynomial to the specified polynomial.
+     *       
+     * @param  other the other polynoimal
+     * @return {@code true} if this polynomial equals {@code other};
+     *         {@code false} otherwise
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Polynomial that = (Polynomial) other;
+        if (this.degree != that.degree) return false;
+        for (int i = this.degree; i >= 0; i--)
+            if (this.coef[i] != that.coef[i]) return false;
+        return true;
+    }
+
+    /**
+     * Returns the result of differentiating this polynomial.
+     *
+     * @return the polynomial whose value is {@code this'(x)}
+     */
+    public Polynomial differentiate() {
+        if (degree == 0) return new Polynomial(0, 0);
+        Polynomial poly = new Polynomial(0, degree - 1);
+        poly.degree = degree - 1;
+        for (int i = 0; i < degree; i++)
+            poly.coef[i] = (i + 1) * coef[i + 1];
+        return poly;
+    }
+
+    /**
+     * Returns the result of evaluating this polynomial at the point x.
+     *
+     * @param  x the point at which to evaluate the polynomial
+     * @return the integer whose value is {@code (this(x))}
+     */
+    public int evaluate(int x) {
+        int p = 0;
+        for (int i = degree; i >= 0; i--)
+            p = coef[i] + (x * p);
+        return p;
+    }
+
+    /**
+     * Compares two polynomials by degree, breaking ties by coefficient of leading term.
+     *
+     * @param  that the other point
+     * @return the value {@code 0} if this polynomial is equal to the argument
+     *         polynomial (precisely when {@code equals()} returns {@code true});
+     *         a negative integer if this polynomialt is less than the argument
+     *         polynomial; and a positive integer if this polynomial is greater than the
+     *         argument point
+     */
+    public int compareTo(Polynomial that) {
+        if (this.degree < that.degree) return -1;
+        if (this.degree > that.degree) return +1;
+        for (int i = this.degree; i >= 0; i--) {
+            if (this.coef[i] < that.coef[i]) return -1;
+            if (this.coef[i] > that.coef[i]) return +1;
+        }
+        return 0;
+    }
+
+    /**
+     * Return a string representation of this polynomial.
+     * @return a string representation of this polynomial in the format
+     *         4x^5 - 3x^2 + 11x + 5
+     */
+    @Override
+    public String toString() {
+        if      (degree == -1) return "0";
+        else if (degree ==  0) return "" + coef[0];
+        else if (degree ==  1) return coef[1] + "x + " + coef[0];
+        String s = coef[degree] + "x^" + degree;
+        for (int i = degree - 1; i >= 0; i--) {
+            if      (coef[i] == 0) continue;
+            else if (coef[i]  > 0) s = s + " + " + (coef[i]);
+            else if (coef[i]  < 0) s = s + " - " + (-coef[i]);
+            if      (i == 1) s = s + "x";
+            else if (i >  1) s = s + "x^" + i;
+        }
+        return s;
+    }
+
+    /**
+     * Unit tests the polynomial data type.
+     *
+     * @param args the command-line arguments (none)
+     */
+    public static void main(String[] args) { 
+        Polynomial zero = new Polynomial(0, 0);
+
+        Polynomial p1   = new Polynomial(4, 3);
+        Polynomial p2   = new Polynomial(3, 2);
+        Polynomial p3   = new Polynomial(1, 0);
+        Polynomial p4   = new Polynomial(2, 1);
+        Polynomial p    = p1.plus(p2).plus(p3).plus(p4);   // 4x^3 + 3x^2 + 1
+
+        Polynomial q1   = new Polynomial(3, 2);
+        Polynomial q2   = new Polynomial(5, 0);
+        Polynomial q    = q1.plus(q2);                     // 3x^2 + 5
+
+
+        Polynomial r    = p.plus(q);
+        Polynomial s    = p.times(q);
+        Polynomial t    = p.compose(q);
+        Polynomial u    = p.minus(p);
+
+        StdOut.println("zero(x)     = " + zero);
+        StdOut.println("p(x)        = " + p);
+        StdOut.println("q(x)        = " + q);
+        StdOut.println("p(x) + q(x) = " + r);
+        StdOut.println("p(x) * q(x) = " + s);
+        StdOut.println("p(q(x))     = " + t);
+        StdOut.println("p(x) - p(x) = " + u);
+        StdOut.println("0 - p(x)    = " + zero.minus(p));
+        StdOut.println("p(3)        = " + p.evaluate(3));
+        StdOut.println("p'(x)       = " + p.differentiate());
+        StdOut.println("p''(x)      = " + p.differentiate().differentiate());
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/PrimMST.java b/src/main/java/edu/princeton/cs/algs4/PrimMST.java
new file mode 100644
index 0000000..f3dcb94
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/PrimMST.java
@@ -0,0 +1,254 @@
+/******************************************************************************
+ *  Compilation:  javac PrimMST.java
+ *  Execution:    java PrimMST filename.txt
+ *  Dependencies: EdgeWeightedGraph.java Edge.java Queue.java
+ *                IndexMinPQ.java UF.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/43mst/tinyEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/mediumEWG.txt
+ *                https://algs4.cs.princeton.edu/43mst/largeEWG.txt
+ *
+ *  Compute a minimum spanning forest using Prim's algorithm.
+ *
+ *  %  java PrimMST tinyEWG.txt 
+ *  1-7 0.19000
+ *  0-2 0.26000
+ *  2-3 0.17000
+ *  4-5 0.35000
+ *  5-7 0.28000
+ *  6-2 0.40000
+ *  0-7 0.16000
+ *  1.81000
+ *
+ *  % java PrimMST mediumEWG.txt
+ *  1-72   0.06506
+ *  2-86   0.05980
+ *  3-67   0.09725
+ *  4-55   0.06425
+ *  5-102  0.03834
+ *  6-129  0.05363
+ *  7-157  0.00516
+ *  ...
+ *  10.46351
+ *
+ *  % java PrimMST largeEWG.txt
+ *  ...
+ *  647.66307
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code PrimMST} class represents a data type for computing a
+ *  <em>minimum spanning tree</em> in an edge-weighted graph.
+ *  The edge weights can be positive, zero, or negative and need not
+ *  be distinct. If the graph is not connected, it computes a <em>minimum
+ *  spanning forest</em>, which is the union of minimum spanning trees
+ *  in each connected component. The {@code weight()} method returns the 
+ *  weight of a minimum spanning tree and the {@code edges()} method
+ *  returns its edges.
+ *  <p>
+ *  This implementation uses <em>Prim's algorithm</em> with an indexed
+ *  binary heap.
+ *  The constructor takes &Theta;(<em>E</em> log <em>V</em>) time in
+ *  the worst case, where <em>V</em> is the number of
+ *  vertices and <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the 
+ *  edge-weighted graph).
+ *  <p>
+ *  This {@code weight()} method correctly computes the weight of the MST
+ *  if all arithmetic performed is without floating-point rounding error
+ *  or arithmetic overflow.
+ *  This is the case if all edge weights are non-negative integers
+ *  and the weight of the MST does not exceed 2<sup>52</sup>.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For alternate implementations, see {@link LazyPrimMST}, {@link KruskalMST},
+ *  and {@link BoruvkaMST}.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class PrimMST {
+    private static final double FLOATING_POINT_EPSILON = 1E-12;
+
+    private Edge[] edgeTo;        // edgeTo[v] = shortest edge from tree vertex to non-tree vertex
+    private double[] distTo;      // distTo[v] = weight of shortest such edge
+    private boolean[] marked;     // marked[v] = true if v on tree, false otherwise
+    private IndexMinPQ<Double> pq;
+
+    /**
+     * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
+     * @param G the edge-weighted graph
+     */
+    public PrimMST(EdgeWeightedGraph G) {
+        edgeTo = new Edge[G.V()];
+        distTo = new double[G.V()];
+        marked = new boolean[G.V()];
+        pq = new IndexMinPQ<Double>(G.V());
+        for (int v = 0; v < G.V(); v++)
+            distTo[v] = Double.POSITIVE_INFINITY;
+
+        for (int v = 0; v < G.V(); v++)      // run from each vertex to find
+            if (!marked[v]) prim(G, v);      // minimum spanning forest
+
+        // check optimality conditions
+        assert check(G);
+    }
+
+    // run Prim's algorithm in graph G, starting from vertex s
+    private void prim(EdgeWeightedGraph G, int s) {
+        distTo[s] = 0.0;
+        pq.insert(s, distTo[s]);
+        while (!pq.isEmpty()) {
+            int v = pq.delMin();
+            scan(G, v);
+        }
+    }
+
+    // scan vertex v
+    private void scan(EdgeWeightedGraph G, int v) {
+        marked[v] = true;
+        for (Edge e : G.adj(v)) {
+            int w = e.other(v);
+            if (marked[w]) continue;         // v-w is obsolete edge
+            if (e.weight() < distTo[w]) {
+                distTo[w] = e.weight();
+                edgeTo[w] = e;
+                if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
+                else                pq.insert(w, distTo[w]);
+            }
+        }
+    }
+
+    /**
+     * Returns the edges in a minimum spanning tree (or forest).
+     * @return the edges in a minimum spanning tree (or forest) as
+     *    an iterable of edges
+     */
+    public Iterable<Edge> edges() {
+        Queue<Edge> mst = new Queue<Edge>();
+        for (int v = 0; v < edgeTo.length; v++) {
+            Edge e = edgeTo[v];
+            if (e != null) {
+                mst.enqueue(e);
+            }
+        }
+        return mst;
+    }
+
+    /**
+     * Returns the sum of the edge weights in a minimum spanning tree (or forest).
+     * @return the sum of the edge weights in a minimum spanning tree (or forest)
+     */
+    public double weight() {
+        double weight = 0.0;
+        for (Edge e : edges())
+            weight += e.weight();
+        return weight;
+    }
+
+
+    // check optimality conditions (takes time proportional to E V lg* V)
+    private boolean check(EdgeWeightedGraph G) {
+
+        // check weight
+        double totalWeight = 0.0;
+        for (Edge e : edges()) {
+            totalWeight += e.weight();
+        }
+        if (Math.abs(totalWeight - weight()) > FLOATING_POINT_EPSILON) {
+            System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n", totalWeight, weight());
+            return false;
+        }
+
+        // check that it is acyclic
+        UF uf = new UF(G.V());
+        for (Edge e : edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) == uf.find(w)) {
+                System.err.println("Not a forest");
+                return false;
+            }
+            uf.union(v, w);
+        }
+
+        // check that it is a spanning forest
+        for (Edge e : G.edges()) {
+            int v = e.either(), w = e.other(v);
+            if (uf.find(v) != uf.find(w)) {
+                System.err.println("Not a spanning forest");
+                return false;
+            }
+        }
+
+        // check that it is a minimal spanning forest (cut optimality conditions)
+        for (Edge e : edges()) {
+
+            // all edges in MST except e
+            uf = new UF(G.V());
+            for (Edge f : edges()) {
+                int x = f.either(), y = f.other(x);
+                if (f != e) uf.union(x, y);
+            }
+
+            // check that e is min weight edge in crossing cut
+            for (Edge f : G.edges()) {
+                int x = f.either(), y = f.other(x);
+                if (uf.find(x) != uf.find(y)) {
+                    if (f.weight() < e.weight()) {
+                        System.err.println("Edge " + f + " violates cut optimality conditions");
+                        return false;
+                    }
+                }
+            }
+
+        }
+
+        return true;
+    }
+
+    /**
+     * Unit tests the {@code PrimMST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
+        PrimMST mst = new PrimMST(G);
+        for (Edge e : mst.edges()) {
+            StdOut.println(e);
+        }
+        StdOut.printf("%.5f\n", mst.weight());
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Queue.java b/src/main/java/edu/princeton/cs/algs4/Queue.java
new file mode 100644
index 0000000..f2d3837
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Queue.java
@@ -0,0 +1,204 @@
+/******************************************************************************
+ *  Compilation:  javac Queue.java
+ *  Execution:    java Queue < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/13stacks/tobe.txt  
+ *
+ *  A generic queue, implemented using a linked list.
+ *
+ *  % java Queue < tobe.txt 
+ *  to be or not to be (2 left on queue)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code Queue} class represents a first-in-first-out (FIFO)
+ *  queue of generic items.
+ *  It supports the usual <em>enqueue</em> and <em>dequeue</em>
+ *  operations, along with methods for peeking at the first item,
+ *  testing if the queue is empty, and iterating through
+ *  the items in FIFO order.
+ *  <p>
+ *  This implementation uses a singly linked list with a static nested class for
+ *  linked-list nodes. See {@link LinkedQueue} for the version from the
+ *  textbook that uses a non-static nested class.
+ *  See {@link ResizingArrayQueue} for a version that uses a resizing array.
+ *  The <em>enqueue</em>, <em>dequeue</em>, <em>peek</em>, <em>size</em>, and <em>is-empty</em>
+ *  operations all take constant time in the worst case.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Item> the generic type of an item in this queue
+ */
+public class Queue<Item> implements Iterable<Item> {
+    private Node<Item> first;    // beginning of queue
+    private Node<Item> last;     // end of queue
+    private int n;               // number of elements on queue
+
+    // helper linked list class
+    private static class Node<Item> {
+        private Item item;
+        private Node<Item> next;
+    }
+
+    /**
+     * Initializes an empty queue.
+     */
+    public Queue() {
+        first = null;
+        last  = null;
+        n = 0;
+    }
+
+    /**
+     * Returns true if this queue is empty.
+     *
+     * @return {@code true} if this queue is empty; {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return first == null;
+    }
+
+    /**
+     * Returns the number of items in this queue.
+     *
+     * @return the number of items in this queue
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns the item least recently added to this queue.
+     *
+     * @return the item least recently added to this queue
+     * @throws NoSuchElementException if this queue is empty
+     */
+    public Item peek() {
+        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
+        return first.item;
+    }
+
+    /**
+     * Adds the item to this queue.
+     *
+     * @param  item the item to add
+     */
+    public void enqueue(Item item) {
+        Node<Item> oldlast = last;
+        last = new Node<Item>();
+        last.item = item;
+        last.next = null;
+        if (isEmpty()) first = last;
+        else           oldlast.next = last;
+        n++;
+    }
+
+    /**
+     * Removes and returns the item on this queue that was least recently added.
+     *
+     * @return the item on this queue that was least recently added
+     * @throws NoSuchElementException if this queue is empty
+     */
+    public Item dequeue() {
+        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
+        Item item = first.item;
+        first = first.next;
+        n--;
+        if (isEmpty()) last = null;   // to avoid loitering
+        return item;
+    }
+
+    /**
+     * Returns a string representation of this queue.
+     *
+     * @return the sequence of items in FIFO order, separated by spaces
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (Item item : this) {
+            s.append(item);
+            s.append(' ');
+        }
+        return s.toString();
+    } 
+
+    /**
+     * Returns an iterator that iterates over the items in this queue in FIFO order.
+     *
+     * @return an iterator that iterates over the items in this queue in FIFO order
+     */
+    public Iterator<Item> iterator()  {
+        return new LinkedIterator(first);  
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class LinkedIterator implements Iterator<Item> {
+        private Node<Item> current;
+
+        public LinkedIterator(Node<Item> first) {
+            current = first;
+        }
+
+        public boolean hasNext()  { return current != null;                     }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = current.item;
+            current = current.next; 
+            return item;
+        }
+    }
+
+
+    /**
+     * Unit tests the {@code Queue} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Queue<String> queue = new Queue<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-"))
+                queue.enqueue(item);
+            else if (!queue.isEmpty())
+                StdOut.print(queue.dequeue() + " ");
+        }
+        StdOut.println("(" + queue.size() + " left on queue)");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Quick.java b/src/main/java/edu/princeton/cs/algs4/Quick.java
new file mode 100644
index 0000000..06d7978
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Quick.java
@@ -0,0 +1,212 @@
+/******************************************************************************
+ *  Compilation:  javac Quick.java
+ *  Execution:    java Quick < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/23quicksort/tiny.txt
+ *                https://algs4.cs.princeton.edu/23quicksort/words3.txt
+ *
+ *  Sorts a sequence of strings from standard input using quicksort.
+ *   
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Quick < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *       
+ *  % java Quick < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *
+ *
+ *  Remark: For a type-safe version that uses static generics, see
+ *
+ *    https://algs4.cs.princeton.edu/23quicksort/QuickPedantic.java
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Quick} class provides static methods for sorting an
+ *  array and selecting the ith smallest element in an array using quicksort.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/23quicksort">Section 2.3</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Quick {
+
+    // This class should not be instantiated.
+    private Quick() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        StdRandom.shuffle(a);
+        sort(a, 0, a.length - 1);
+        assert isSorted(a);
+    }
+
+    // quicksort the subarray from a[lo] to a[hi]
+    private static void sort(Comparable[] a, int lo, int hi) { 
+        if (hi <= lo) return;
+        int j = partition(a, lo, hi);
+        sort(a, lo, j-1);
+        sort(a, j+1, hi);
+        assert isSorted(a, lo, hi);
+    }
+
+    // partition the subarray a[lo..hi] so that a[lo..j-1] <= a[j] <= a[j+1..hi]
+    // and return the index j.
+    private static int partition(Comparable[] a, int lo, int hi) {
+        int i = lo;
+        int j = hi + 1;
+        Comparable v = a[lo];
+        while (true) { 
+
+            // find item on lo to swap
+            while (less(a[++i], v)) {
+                if (i == hi) break;
+            }
+
+            // find item on hi to swap
+            while (less(v, a[--j])) {
+                if (j == lo) break;      // redundant since a[lo] acts as sentinel
+            }
+
+            // check if pointers cross
+            if (i >= j) break;
+
+            exch(a, i, j);
+        }
+
+        // put partitioning item v at a[j]
+        exch(a, lo, j);
+
+        // now, a[lo .. j-1] <= a[j] <= a[j+1 .. hi]
+        return j;
+    }
+
+    /**
+     * Rearranges the array so that {@code a[k]} contains the kth smallest key;
+     * {@code a[0]} through {@code a[k-1]} are less than (or equal to) {@code a[k]}; and
+     * {@code a[k+1]} through {@code a[n-1]} are greater than (or equal to) {@code a[k]}.
+     *
+     * @param  a the array
+     * @param  k the rank of the key
+     * @return the key of rank {@code k}
+     * @throws IllegalArgumentException unless {@code 0 <= k < a.length}
+     */
+    public static Comparable select(Comparable[] a, int k) {
+        if (k < 0 || k >= a.length) {
+            throw new IllegalArgumentException("index is not between 0 and " + a.length + ": " + k);
+        }
+        StdRandom.shuffle(a);
+        int lo = 0, hi = a.length - 1;
+        while (hi > lo) {
+            int i = partition(a, lo, hi);
+            if      (i > k) hi = i - 1;
+            else if (i < k) lo = i + 1;
+            else return a[i];
+        }
+        return a[lo];
+    }
+
+
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        if (v == w) return false;   // optimization when reference equals
+        return v.compareTo(w) < 0;
+    }
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length - 1);
+    }
+
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; quicksorts them; 
+     * and prints them to standard output in ascending order. 
+     * Shuffles the array and then prints the strings again to
+     * standard output, but this time, using the select method.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Quick.sort(a);
+        show(a);
+        assert isSorted(a);
+
+        // shuffle
+        StdRandom.shuffle(a);
+
+        // display results again using select
+        StdOut.println();
+        for (int i = 0; i < a.length; i++) {
+            String ith = (String) Quick.select(a, i);
+            StdOut.println(ith);
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Quick3string.java b/src/main/java/edu/princeton/cs/algs4/Quick3string.java
new file mode 100644
index 0000000..557fe4f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Quick3string.java
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *  Compilation:  javac Quick3string.java
+ *  Execution:    java Quick3string < input.txt
+ *  Dependencies: StdIn.java StdOut.java 
+ *  Data files:   https://algs4.cs.princeton.edu/51radix/words3.txt
+ *                https://algs4.cs.princeton.edu/51radix/shells.txt
+ *
+ *  Reads string from standard input and 3-way string quicksort them.
+ *
+ *  % java Quick3string < shell.txt
+ *  are
+ *  by
+ *  sea
+ *  seashells
+ *  seashells
+ *  sells
+ *  sells
+ *  she
+ *  she
+ *  shells
+ *  shore
+ *  surely
+ *  the
+ *  the
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Quick3string} class provides static methods for sorting an
+ *  array of strings using 3-way radix quicksort.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/51radix">Section 5.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Quick3string {
+    private static final int CUTOFF =  15;   // cutoff to insertion sort
+
+    // do not instantiate
+    private Quick3string() { } 
+
+    /**  
+     * Rearranges the array of strings in ascending order.
+     *
+     * @param a the array to be sorted
+     */
+    public static void sort(String[] a) {
+        StdRandom.shuffle(a);
+        sort(a, 0, a.length-1, 0);
+        assert isSorted(a);
+    }
+
+    // return the dth character of s, -1 if d = length of s
+    private static int charAt(String s, int d) { 
+        assert d >= 0 && d <= s.length();
+        if (d == s.length()) return -1;
+        return s.charAt(d);
+    }
+
+
+    // 3-way string quicksort a[lo..hi] starting at dth character
+    private static void sort(String[] a, int lo, int hi, int d) { 
+
+        // cutoff to insertion sort for small subarrays
+        if (hi <= lo + CUTOFF) {
+            insertion(a, lo, hi, d);
+            return;
+        }
+
+        int lt = lo, gt = hi;
+        int v = charAt(a[lo], d);
+        int i = lo + 1;
+        while (i <= gt) {
+            int t = charAt(a[i], d);
+            if      (t < v) exch(a, lt++, i++);
+            else if (t > v) exch(a, i, gt--);
+            else              i++;
+        }
+
+        // a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]. 
+        sort(a, lo, lt-1, d);
+        if (v >= 0) sort(a, lt, gt, d+1);
+        sort(a, gt+1, hi, d);
+    }
+
+    // sort from a[lo] to a[hi], starting at the dth character
+    private static void insertion(String[] a, int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1], d); j--)
+                exch(a, j, j-1);
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(String[] a, int i, int j) {
+        String temp = a[i];
+        a[i] = a[j];
+        a[j] = temp;
+    }
+
+    // is v less than w, starting at character d
+    // DEPRECATED BECAUSE OF SLOW SUBSTRING EXTRACTION IN JAVA 7
+    // private static boolean less(String v, String w, int d) {
+    //    assert v.substring(0, d).equals(w.substring(0, d));
+    //    return v.substring(d).compareTo(w.substring(d)) < 0; 
+    // }
+
+    // is v less than w, starting at character d
+    private static boolean less(String v, String w, int d) {
+        assert v.substring(0, d).equals(w.substring(0, d));
+        for (int i = d; i < Math.min(v.length(), w.length()); i++) {
+            if (v.charAt(i) < w.charAt(i)) return true;
+            if (v.charAt(i) > w.charAt(i)) return false;
+        }
+        return v.length() < w.length();
+    }
+
+    // is the array sorted
+    private static boolean isSorted(String[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (a[i].compareTo(a[i-1]) < 0) return false;
+        return true;
+    }
+
+
+    /**
+     * Reads in a sequence of fixed-length strings from standard input;
+     * 3-way radix quicksorts them;
+     * and prints them to standard output in ascending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read in the strings from standard input
+        String[] a = StdIn.readAllStrings();
+        int n = a.length;
+
+        // sort the strings
+        sort(a);
+
+        // print the results
+        for (int i = 0; i < n; i++)
+            StdOut.println(a[i]);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Quick3way.java b/src/main/java/edu/princeton/cs/algs4/Quick3way.java
new file mode 100644
index 0000000..2cc0216
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Quick3way.java
@@ -0,0 +1,148 @@
+/******************************************************************************
+ *  Compilation:  javac Quick3way.java
+ *  Execution:    java Quick3way < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/23quicksort/tiny.txt
+ *                https://algs4.cs.princeton.edu/23quicksort/words3.txt
+ *   
+ *  Sorts a sequence of strings from standard input using 3-way quicksort.
+ *   
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Quick3way < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *    
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *  
+ *  % java Quick3way < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Quick3way} class provides static methods for sorting an
+ *  array using quicksort with 3-way partitioning.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/23quicksort">Section 2.3</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Quick3way {
+
+    // This class should not be instantiated.
+    private Quick3way() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        StdRandom.shuffle(a);
+        sort(a, 0, a.length - 1);
+        assert isSorted(a);
+    }
+
+    // quicksort the subarray a[lo .. hi] using 3-way partitioning
+    private static void sort(Comparable[] a, int lo, int hi) { 
+        if (hi <= lo) return;
+        int lt = lo, gt = hi;
+        Comparable v = a[lo];
+        int i = lo + 1;
+        while (i <= gt) {
+            int cmp = a[i].compareTo(v);
+            if      (cmp < 0) exch(a, lt++, i++);
+            else if (cmp > 0) exch(a, i, gt--);
+            else              i++;
+        }
+
+        // a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]. 
+        sort(a, lo, lt-1);
+        sort(a, gt+1, hi);
+        assert isSorted(a, lo, hi);
+    }
+
+
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length - 1);
+    }
+
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; 3-way
+     * quicksorts them; and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Quick3way.sort(a);
+        show(a);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/QuickBentleyMcIlroy.java b/src/main/java/edu/princeton/cs/algs4/QuickBentleyMcIlroy.java
new file mode 100644
index 0000000..5f59ce3
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/QuickBentleyMcIlroy.java
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *  Compilation:  javac QuickBentleyMcIlroy.java
+ *  Execution:    java QuickBentleyMcIlroy < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/23quicksort/tiny.txt
+ *                https://algs4.cs.princeton.edu/23quicksort/words3.txt
+ *  
+ *  Uses the Bentley-McIlroy 3-way partitioning scheme,
+ *  chooses the partitioning element using Tukey's ninther,
+ *  and cuts off to insertion sort.
+ *
+ *  Reference: Engineering a Sort Function by Jon L. Bentley
+ *  and M. Douglas McIlroy. Software-Practice and Experience,
+ *  Vol. 23 (11), 1249-1265 (November 1993).
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code QuickBentleyMcIlroy} class provides static methods for sorting
+ *  an array using an optimized version of quicksort (using Bentley-McIlroy
+ *  3-way partitioning, Tukey's ninther, and cutoff to insertion sort).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/23quicksort">Section 2.3</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class QuickBentleyMcIlroy {
+
+    // cutoff to insertion sort, must be >= 1
+    private static final int INSERTION_SORT_CUTOFF = 8;
+
+    // cutoff to median-of-3 partitioning
+    private static final int MEDIAN_OF_3_CUTOFF = 40;
+
+    // This class should not be instantiated.
+    private QuickBentleyMcIlroy() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        sort(a, 0, a.length - 1);
+    }
+
+    private static void sort(Comparable[] a, int lo, int hi) { 
+        int n = hi - lo + 1;
+
+        // cutoff to insertion sort
+        if (n <= INSERTION_SORT_CUTOFF) {
+            insertionSort(a, lo, hi);
+            return;
+        }
+
+        // use median-of-3 as partitioning element
+        else if (n <= MEDIAN_OF_3_CUTOFF) {
+            int m = median3(a, lo, lo + n/2, hi);
+            exch(a, m, lo);
+        }
+
+        // use Tukey ninther as partitioning element
+        else  {
+            int eps = n/8;
+            int mid = lo + n/2;
+            int m1 = median3(a, lo, lo + eps, lo + eps + eps);
+            int m2 = median3(a, mid - eps, mid, mid + eps);
+            int m3 = median3(a, hi - eps - eps, hi - eps, hi); 
+            int ninther = median3(a, m1, m2, m3);
+            exch(a, ninther, lo);
+        }
+
+        // Bentley-McIlroy 3-way partitioning
+        int i = lo, j = hi+1;
+        int p = lo, q = hi+1;
+        Comparable v = a[lo];
+        while (true) {
+            while (less(a[++i], v))
+                if (i == hi) break;
+            while (less(v, a[--j]))
+                if (j == lo) break;
+
+            // pointers cross
+            if (i == j && eq(a[i], v))
+                exch(a, ++p, i);
+            if (i >= j) break;
+
+            exch(a, i, j);
+            if (eq(a[i], v)) exch(a, ++p, i);
+            if (eq(a[j], v)) exch(a, --q, j);
+        }
+
+
+        i = j + 1;
+        for (int k = lo; k <= p; k++)
+            exch(a, k, j--);
+        for (int k = hi; k >= q; k--)
+            exch(a, k, i++);
+
+        sort(a, lo, j);
+        sort(a, i, hi);
+    }
+
+
+    // sort from a[lo] to a[hi] using insertion sort
+    private static void insertionSort(Comparable[] a, int lo, int hi) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(a[j], a[j-1]); j--)
+                exch(a, j, j-1);
+    }
+
+
+    // return the index of the median element among a[i], a[j], and a[k]
+    private static int median3(Comparable[] a, int i, int j, int k) {
+        return (less(a[i], a[j]) ?
+               (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) :
+               (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i));
+    }
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        if (v == w) return false;    // optimization when reference equal
+        return v.compareTo(w) < 0;
+    }
+
+    // does v == w ?
+    private static boolean eq(Comparable v, Comparable w) {
+        if (v == w) return true;    // optimization when reference equal
+        return v.compareTo(w) == 0;
+    }
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; quicksorts them
+     * (using an optimized version of quicksort); 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        QuickBentleyMcIlroy.sort(a);
+        assert isSorted(a);
+        show(a);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/QuickFindUF.java b/src/main/java/edu/princeton/cs/algs4/QuickFindUF.java
new file mode 100644
index 0000000..c71066a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/QuickFindUF.java
@@ -0,0 +1,200 @@
+/******************************************************************************
+ *  Compilation:  javac QuickFindUF.java
+ *  Execution:  java QuickFindUF < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/15uf/tinyUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/mediumUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/largeUF.txt
+ *
+ *  Quick-find algorithm.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code QuickFindUF} class represents a <em>union‚Äìfind data type</em>
+ *  (also known as the <em>disjoint-sets data type</em>).
+ *  It supports the classic <em>union</em> and <em>find</em> operations,
+ *  along with a <em>count</em> operation that returns the total number
+ *  of sets.
+ *  <p>
+ *  The union‚Äìfind data type models a collection of sets containing
+ *  <em>n</em> elements, with each element in exactly one set.
+ *  The elements are named 0 through <em>n</em>‚Äì1.
+ *  Initially, there are <em>n</em> sets, with each element in its
+ *  own set. The <em>canonical element</em> of a set
+ *  (also known as the <em>root</em>, <em>identifier</em>,
+ *  <em>leader</em>, or <em>set representative</em>)
+ *  is one distinguished element in the set. Here is a summary of
+ *  the operations:
+ *  <ul>
+ *  <li><em>find</em>(<em>p</em>) returns the canonical element
+ *      of the set containing <em>p</em>. The <em>find</em> operation
+ *      returns the same value for two elements if and only if
+ *      they are in the same set.
+ *  <li><em>union</em>(<em>p</em>, <em>q</em>) merges the set
+ *      containing element <em>p</em> with the set containing
+ *      element <em>q</em>. That is, if <em>p</em> and <em>q</em>
+ *      are in different sets, replace these two sets
+ *      with a new set that is the union of the two.
+ *  <li><em>count</em>() returns the number of sets.
+ *  </ul>
+ *  <p>
+ *  The canonical element of a set can change only when the set
+ *  itself changes during a call to <em>union</em>&mdash;it cannot
+ *  change during a call to either <em>find</em> or <em>count</em>.
+ *  <p>
+ *  This implementation uses <em>quick find</em>.
+ *  The constructor takes &Theta;(<em>n</em>) time, where <em>n</em>
+ *  is the number of sites.
+ *  The <em>find</em>, <em>connected</em>, and <em>count</em>
+ *  operations take &Theta;(1) time; the <em>union</em> operation
+ *  takes &Theta;(<em>n</em>) time.
+ *  <p>
+ *  For alternative implementations of the same API, see
+ *  {@link UF}, {@link QuickUnionUF}, and {@link WeightedQuickUnionUF}.
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/15uf">Section 1.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class QuickFindUF {
+    private int[] id;    // id[i] = component identifier of i
+    private int count;   // number of components
+
+    /**
+     * Initializes an empty union-find data structure with
+     * {@code n} elements {@code 0} through {@code n-1}. 
+     * Initially, each elements is in its own set.
+     *
+     * @param  n the number of elements
+     * @throws IllegalArgumentException if {@code n < 0}
+     */
+    public QuickFindUF(int n) {
+        count = n;
+        id = new int[n];
+        for (int i = 0; i < n; i++)
+            id[i] = i;
+    }
+
+    /**
+     * Returns the number of sets.
+     *
+     * @return the number of sets (between {@code 1} and {@code n})
+     */
+    public int count() {
+        return count;
+    }
+  
+    /**
+     * Returns the canonical element of the set containing element {@code p}.
+     *
+     * @param  p an element
+     * @return the canonical element of the set containing {@code p}
+     * @throws IllegalArgumentException unless {@code 0 <= p < n}
+     */
+    public int find(int p) {
+        validate(p);
+        return id[p];
+    }
+
+    // validate that p is a valid index
+    private void validate(int p) {
+        int n = id.length;
+        if (p < 0 || p >= n) {
+            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));
+        }
+    }
+
+    /**
+     * Returns true if the two elements are in the same set.
+     * 
+     * @param  p one element
+     * @param  q the other element
+     * @return {@code true} if {@code p} and {@code q} are in the same set;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     * @deprecated Replace with two calls to {@link #find(int)}.
+     */
+    @Deprecated
+    public boolean connected(int p, int q) {
+        validate(p);
+        validate(q);
+        return id[p] == id[q];
+    }
+  
+    /**
+     * Merges the set containing element {@code p} with the 
+     * the set containing element {@code q}.
+     *
+     * @param  p one element
+     * @param  q the other element
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     */
+    public void union(int p, int q) {
+        validate(p);
+        validate(q);
+        int pID = id[p];   // needed for correctness
+        int qID = id[q];   // to reduce the number of array accesses
+
+        // p and q are already in the same component
+        if (pID == qID) return;
+
+        for (int i = 0; i < id.length; i++)
+            if (id[i] == pID) id[i] = qID;
+        count--;
+    }
+
+    /**
+     * Reads an integer {@code n} and a sequence of pairs of integers
+     * (between {@code 0} and {@code n-1}) from standard input, where each integer
+     * in the pair represents some element;
+     * if the elements are in different sets, merge the two sets
+     * and print the pair to standard output.
+     * 
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        QuickFindUF uf = new QuickFindUF(n);
+        while (!StdIn.isEmpty()) {
+            int p = StdIn.readInt();
+            int q = StdIn.readInt();
+            if (uf.find(p) == uf.find(q)) continue;
+            uf.union(p, q);
+            StdOut.println(p + " " + q);
+        }
+        StdOut.println(uf.count() + " components");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/QuickUnionUF.java b/src/main/java/edu/princeton/cs/algs4/QuickUnionUF.java
new file mode 100644
index 0000000..167690b
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/QuickUnionUF.java
@@ -0,0 +1,195 @@
+/******************************************************************************
+ *  Compilation:  javac QuickUnionUF.java
+ *  Execution:  java QuickUnionUF < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/15uf/tinyUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/mediumUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/largeUF.txt
+ *
+ *  Quick-union algorithm.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code QuickUnionUF} class represents a <em>union‚Äìfind data type</em>
+ *  (also known as the <em>disjoint-sets data type</em>).
+ *  It supports the classic <em>union</em> and <em>find</em> operations,
+ *  along with a <em>count</em> operation that returns the total number
+ *  of sets.
+ *  <p>
+ *  The union‚Äìfind data type models a collection of sets containing
+ *  <em>n</em> elements, with each element in exactly one set.
+ *  The elements are named 0 through <em>n</em>‚Äì1.
+ *  Initially, there are <em>n</em> sets, with each element in its
+ *  own set. The <em>canonical element</em> of a set
+ *  (also known as the <em>root</em>, <em>identifier</em>,
+ *  <em>leader</em>, or <em>set representative</em>)
+ *  is one distinguished element in the set. Here is a summary of
+ *  the operations:
+ *  <ul>
+ *  <li><em>find</em>(<em>p</em>) returns the canonical element
+ *      of the set containing <em>p</em>. The <em>find</em> operation
+ *      returns the same value for two elements if and only if
+ *      they are in the same set.
+ *  <li><em>union</em>(<em>p</em>, <em>q</em>) merges the set
+ *      containing element <em>p</em> with the set containing
+ *      element <em>q</em>. That is, if <em>p</em> and <em>q</em>
+ *      are in different sets, replace these two sets
+ *      with a new set that is the union of the two.
+ *  <li><em>count</em>() returns the number of sets.
+ *  </ul>
+ *  <p>
+ *  The canonical element of a set can change only when the set
+ *  itself changes during a call to <em>union</em>&mdash;it cannot
+ *  change during a call to either <em>find</em> or <em>count</em>.
+ *  <p>
+ *  This implementation uses <em>quick union</em>.
+ *  The constructor takes &Theta;(<em>n</em>) time, where
+ *  <em>n</em> is the number of sites.
+ *  The <em>union</em> and <em>find</em> operations take
+ *  &Theta;(<em>n</em>) time in the worst case.
+ *  The <em>count</em> operation takes &Theta;(1) time.
+ *  <p>
+ *  For alternative implementations of the same API, see
+ *  {@link UF}, {@link QuickFindUF}, and {@link WeightedQuickUnionUF}.
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/15uf">Section 1.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class QuickUnionUF {
+    private int[] parent;  // parent[i] = parent of i
+    private int count;     // number of components
+
+    /**
+     * Initializes an empty union-find data structure with
+     * {@code n} elements {@code 0} through {@code n-1}. 
+     * Initially, each elements is in its own set.
+     *
+     * @param  n the number of elements
+     * @throws IllegalArgumentException if {@code n < 0}
+     */
+    public QuickUnionUF(int n) {
+        parent = new int[n];
+        count = n;
+        for (int i = 0; i < n; i++) {
+            parent[i] = i;
+        }
+    }
+
+    /**
+     * Returns the number of sets.
+     *
+     * @return the number of sets (between {@code 1} and {@code n})
+     */
+    public int count() {
+        return count;
+    }
+  
+    /**
+     * Returns the canonical element of the set containing element {@code p}.
+     *
+     * @param  p an element
+     * @return the canonical element of the set containing {@code p}
+     * @throws IllegalArgumentException unless {@code 0 <= p < n}
+     */
+    public int find(int p) {
+        validate(p);
+        while (p != parent[p])
+            p = parent[p];
+        return p;
+    }
+
+    // validate that p is a valid index
+    private void validate(int p) {
+        int n = parent.length;
+        if (p < 0 || p >= n) {
+            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));
+        }
+    }
+
+    /**
+     * Returns true if the two elements are in the same set.
+     * 
+     * @param  p one element
+     * @param  q the other element
+     * @return {@code true} if {@code p} and {@code q} are in the same set;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     * @deprecated Replace with two calls to {@link #find(int)}.
+     */
+    @Deprecated
+    public boolean connected(int p, int q) {
+        return find(p) == find(q);
+    }
+
+    /**
+     * Merges the set containing element {@code p} with the 
+     * the set containing element {@code q}.
+     *
+     * @param  p one element
+     * @param  q the other element
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     */
+    public void union(int p, int q) {
+        int rootP = find(p);
+        int rootQ = find(q);
+        if (rootP == rootQ) return;
+        parent[rootP] = rootQ; 
+        count--;
+    }
+
+    /**
+     * Reads an integer {@code n} and a sequence of pairs of integers
+     * (between {@code 0} and {@code n-1}) from standard input, where each integer
+     * in the pair represents some element;
+     * if the elements are in different sets, merge the two sets
+     * and print the pair to standard output.
+     * 
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        QuickUnionUF uf = new QuickUnionUF(n);
+        while (!StdIn.isEmpty()) {
+            int p = StdIn.readInt();
+            int q = StdIn.readInt();
+            if (uf.find(p) == uf.find(q)) continue;
+            uf.union(p, q);
+            StdOut.println(p + " " + q);
+        }
+        StdOut.println(uf.count() + " components");
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/QuickX.java b/src/main/java/edu/princeton/cs/algs4/QuickX.java
new file mode 100644
index 0000000..76ba38b
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/QuickX.java
@@ -0,0 +1,175 @@
+/******************************************************************************
+ *  Compilation:  javac QuickX.java
+ *  Execution:    java QuickX < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/23quicksort/tiny.txt
+ *                https://algs4.cs.princeton.edu/23quicksort/words3.txt
+ *  
+ *  Uses the Hoare's 2-way partitioning scheme, chooses the partitioning
+ *  element using median-of-3, and cuts off to insertion sort.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code QuickX} class provides static methods for sorting an array
+ *  using an optimized version of quicksort (using Hoare's 2-way partitioning
+ *  algorithm, median-of-3 to choose the partitioning element, and cutoff
+ *  to insertion sort).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/23quicksort">Section 2.3</a>   
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class QuickX {
+
+    // cutoff to insertion sort, must be >= 1
+    private static final int INSERTION_SORT_CUTOFF = 8;
+
+    // This class should not be instantiated.
+    private QuickX() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        // StdRandom.shuffle(a);
+        sort(a, 0, a.length - 1);
+        assert isSorted(a);
+    }
+
+    // quicksort the subarray from a[lo] to a[hi]
+    private static void sort(Comparable[] a, int lo, int hi) { 
+        if (hi <= lo) return;
+
+        // cutoff to insertion sort (Insertion.sort() uses half-open intervals)
+        int n = hi - lo + 1;
+        if (n <= INSERTION_SORT_CUTOFF) {
+            Insertion.sort(a, lo, hi + 1);
+            return;
+        }
+
+        int j = partition(a, lo, hi);
+        sort(a, lo, j-1);
+        sort(a, j+1, hi);
+    }
+
+    // partition the subarray a[lo..hi] so that a[lo..j-1] <= a[j] <= a[j+1..hi]
+    // and return the index j.
+    private static int partition(Comparable[] a, int lo, int hi) {
+        int n = hi - lo + 1;
+        int m = median3(a, lo, lo + n/2, hi);
+        exch(a, m, lo);
+
+        int i = lo;
+        int j = hi + 1;
+        Comparable v = a[lo];
+
+        // a[lo] is unique largest element
+        while (less(a[++i], v)) {
+            if (i == hi) { exch(a, lo, hi); return hi; }
+        }
+
+        // a[lo] is unique smallest element
+        while (less(v, a[--j])) {
+            if (j == lo + 1) return lo;
+        }
+
+        // the main loop
+        while (i < j) { 
+            exch(a, i, j);
+            while (less(a[++i], v)) ;
+            while (less(v, a[--j])) ;
+        }
+
+        // put partitioning item v at a[j]
+        exch(a, lo, j);
+
+        // now, a[lo .. j-1] <= a[j] <= a[j+1 .. hi]
+        return j;
+    }
+
+    // return the index of the median element among a[i], a[j], and a[k]
+    private static int median3(Comparable[] a, int i, int j, int k) {
+        return (less(a[i], a[j]) ?
+               (less(a[j], a[k]) ? j : less(a[i], a[k]) ? k : i) :
+               (less(a[k], a[j]) ? j : less(a[k], a[i]) ? k : i));
+    }
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; quicksorts them
+     * (using an optimized version of 2-way quicksort); 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        QuickX.sort(a);
+        assert isSorted(a);
+        show(a);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/RabinKarp.java b/src/main/java/edu/princeton/cs/algs4/RabinKarp.java
new file mode 100644
index 0000000..65d6693
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/RabinKarp.java
@@ -0,0 +1,195 @@
+/******************************************************************************
+ *  Compilation:  javac RabinKarp.java
+ *  Execution:    java RabinKarp pat txt
+ *  Dependencies: StdOut.java
+ *
+ *  Reads in two strings, the pattern and the input text, and
+ *  searches for the pattern in the input text using the
+ *  Las Vegas version of the Rabin-Karp algorithm.
+ *
+ *  % java RabinKarp abracadabra abacadabrabracabracadabrabrabracad
+ *  pattern: abracadabra
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  match:                 abracadabra          
+ *
+ *  % java RabinKarp rab abacadabrabracabracadabrabrabracad
+ *  pattern: rab
+ *  text:    abacadabrabracabracadabrabrabracad 
+ *  match:           rab                         
+ *
+ *  % java RabinKarp bcara abacadabrabracabracadabrabrabracad
+ *  pattern: bcara
+ *  text:         abacadabrabracabracadabrabrabracad 
+ *
+ *  %  java RabinKarp rabrabracad abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad
+ *  pattern:                        rabrabracad
+ *
+ *  % java RabinKarp abacad abacadabrabracabracadabrabrabracad
+ *  text:    abacadabrabracabracadabrabrabracad
+ *  pattern: abacad
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.math.BigInteger;
+import java.util.Random;
+
+/**
+ *  The {@code RabinKarp} class finds the first occurrence of a pattern string
+ *  in a text string.
+ *  <p>
+ *  This implementation uses the Rabin-Karp algorithm.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/53substring">Section 5.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class RabinKarp {
+    private String pat;      // the pattern  // needed only for Las Vegas
+    private long patHash;    // pattern hash value
+    private int m;           // pattern length
+    private long q;          // a large prime, small enough to avoid long overflow
+    private int R;           // radix
+    private long RM;         // R^(M-1) % Q
+
+    /**
+     * Preprocesses the pattern string.
+     *
+     * @param pattern the pattern string
+     * @param R the alphabet size
+     */
+    public RabinKarp(char[] pattern, int R) {
+        this.pat = String.valueOf(pattern);
+        this.R = R;        
+        throw new UnsupportedOperationException("Operation not supported yet");
+    }
+
+    /**
+     * Preprocesses the pattern string.
+     *
+     * @param pat the pattern string
+     */
+    public RabinKarp(String pat) {
+        this.pat = pat;      // save pattern (needed only for Las Vegas)
+        R = 256;
+        m = pat.length();
+        q = longRandomPrime();
+
+        // precompute R^(m-1) % q for use in removing leading digit
+        RM = 1;
+        for (int i = 1; i <= m-1; i++)
+            RM = (R * RM) % q;
+        patHash = hash(pat, m);
+    } 
+
+    // Compute hash for key[0..m-1]. 
+    private long hash(String key, int m) { 
+        long h = 0; 
+        for (int j = 0; j < m; j++) 
+            h = (R * h + key.charAt(j)) % q;
+        return h;
+    }
+
+    // Las Vegas version: does pat[] match txt[i..i-m+1] ?
+    private boolean check(String txt, int i) {
+        for (int j = 0; j < m; j++) 
+            if (pat.charAt(j) != txt.charAt(i + j)) 
+                return false; 
+        return true;
+    }
+
+    // Monte Carlo version: always return true
+    // private boolean check(int i) {
+    //    return true;
+    //}
+ 
+    /**
+     * Returns the index of the first occurrrence of the pattern string
+     * in the text string.
+     *
+     * @param  txt the text string
+     * @return the index of the first occurrence of the pattern string
+     *         in the text string; n if no such match
+     */
+    public int search(String txt) {
+        int n = txt.length(); 
+        if (n < m) return n;
+        long txtHash = hash(txt, m); 
+
+        // check for match at offset 0
+        if ((patHash == txtHash) && check(txt, 0))
+            return 0;
+
+        // check for hash match; if hash match, check for exact match
+        for (int i = m; i < n; i++) {
+            // Remove leading digit, add trailing digit, check for match. 
+            txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q; 
+            txtHash = (txtHash*R + txt.charAt(i)) % q; 
+
+            // match
+            int offset = i - m + 1;
+            if ((patHash == txtHash) && check(txt, offset))
+                return offset;
+        }
+
+        // no match
+        return n;
+    }
+
+
+    // a random 31-bit prime
+    private static long longRandomPrime() {
+        BigInteger prime = BigInteger.probablePrime(31, new Random());
+        return prime.longValue();
+    }
+
+    /** 
+     * Takes a pattern string and an input string as command-line arguments;
+     * searches for the pattern string in the text string; and prints
+     * the first occurrence of the pattern string in the text string.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String pat = args[0];
+        String txt = args[1];
+
+        RabinKarp searcher = new RabinKarp(pat);
+        int offset = searcher.search(txt);
+
+        // print results
+        StdOut.println("text:    " + txt);
+
+        // from brute force search method 1
+        StdOut.print("pattern: ");
+        for (int i = 0; i < offset; i++)
+            StdOut.print(" ");
+        StdOut.println(pat);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/RandomSeq.java b/src/main/java/edu/princeton/cs/algs4/RandomSeq.java
new file mode 100644
index 0000000..ae0f6bb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/RandomSeq.java
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *  Compilation:  javac RandomSeq.java
+ *  Execution:    java RandomSeq n lo hi
+ *  Dependencies: StdOut.java
+ *
+ *  Prints N numbers between lo and hi.
+ *
+ *  % java RandomSeq 5 100.0 200.0
+ *  123.43
+ *  153.13
+ *  144.38
+ *  155.18
+ *  104.02
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code RandomSeq} class is a client that prints out a pseudorandom
+ *  sequence of real numbers in a given range.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/11model">Section 1.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class RandomSeq { 
+
+    // this class should not be instantiated
+    private RandomSeq() { }
+
+
+    /**
+     * Reads in two command-line arguments lo and hi and prints n uniformly
+     * random real numbers in [lo, hi) to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // command-line arguments
+        int n = Integer.parseInt(args[0]);
+
+        // for backward compatibility with Intro to Programming in Java version of RandomSeq
+        if (args.length == 1) {
+            // generate and print n numbers between 0.0 and 1.0
+            for (int i = 0; i < n; i++) {
+                double x = StdRandom.uniform();
+                StdOut.println(x);
+            }
+        }
+
+        else if (args.length == 3) {
+            double lo = Double.parseDouble(args[1]);
+            double hi = Double.parseDouble(args[2]);
+
+            // generate and print n numbers between lo and hi
+            for (int i = 0; i < n; i++) {
+                double x = StdRandom.uniform(lo, hi);
+                StdOut.printf("%.2f\n", x);
+            }
+        }
+
+        else {
+            throw new IllegalArgumentException("Invalid number of arguments");
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/RectHV.java b/src/main/java/edu/princeton/cs/algs4/RectHV.java
new file mode 100644
index 0000000..c376e77
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/RectHV.java
@@ -0,0 +1,248 @@
+/******************************************************************************
+ *  Compilation:  javac RectHV.java
+ *  Execution:    none
+ *  Dependencies: Point2D.java
+ *
+ *  Immutable data type for 2D axis-aligned rectangle.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code RectHV} class is an immutable data type to encapsulate a
+ *  two-dimensional axis-aligned rectagle with real-value coordinates.
+ *  The rectangle is <em>closed</em>‚Äîit includes the points on the boundary.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public final class RectHV {
+    private final double xmin, ymin;   // minimum x- and y-coordinates
+    private final double xmax, ymax;   // maximum x- and y-coordinates
+
+    /**
+     * Initializes a new rectangle [<em>xmin</em>, <em>xmax</em>]
+     * x [<em>ymin</em>, <em>ymax</em>].
+     *
+     * @param  xmin the <em>x</em>-coordinate of the lower-left endpoint
+     * @param  ymin the <em>y</em>-coordinate of the lower-left endpoint
+     * @param  xmax the <em>x</em>-coordinate of the upper-right endpoint
+     * @param  ymax the <em>y</em>-coordinate of the upper-right endpoint
+     * @throws IllegalArgumentException if any of {@code xmin},
+     *         {@code ymin}, {@code xmax}, or {@code ymax}
+     *         is {@code Double.NaN}.
+     * @throws IllegalArgumentException if {@code xmax < xmin} or {@code ymax < ymin}.
+     */
+    public RectHV(double xmin, double ymin, double xmax, double ymax) {
+        this.xmin = xmin;
+        this.ymin = ymin;
+        this.xmax = xmax;
+        this.ymax = ymax;
+        if (Double.isNaN(xmin) || Double.isNaN(xmax)) {
+            throw new IllegalArgumentException("x-coordinate is NaN: " + toString());
+        }
+        if (Double.isNaN(ymin) || Double.isNaN(ymax)) {
+            throw new IllegalArgumentException("y-coordinate is NaN: " + toString());
+        }
+        if (xmax < xmin) {
+            throw new IllegalArgumentException("xmax < xmin: " + toString());
+        }
+        if (ymax < ymin) {
+            throw new IllegalArgumentException("ymax < ymin: " + toString());
+        }
+    }
+
+    /**
+     * Returns the minimum <em>x</em>-coordinate of any point in this rectangle.
+     *
+     * @return the minimum <em>x</em>-coordinate of any point in this rectangle
+     */
+    public double xmin() {
+        return xmin;
+    }
+
+    /**
+     * Returns the maximum <em>x</em>-coordinate of any point in this rectangle.
+     *
+     * @return the maximum <em>x</em>-coordinate of any point in this rectangle
+     */
+    public double xmax() {
+        return xmax;
+    }
+
+    /**
+     * Returns the minimum <em>y</em>-coordinate of any point in this rectangle.
+     *
+     * @return the minimum <em>y</em>-coordinate of any point in this rectangle
+     */
+    public double ymin() {
+        return ymin;
+    }
+
+    /**
+     * Returns the maximum <em>y</em>-coordinate of any point in this rectangle.
+     *
+     * @return the maximum <em>y</em>-coordinate of any point in this rectangle
+     */
+    public double ymax() {
+        return ymax;
+    }
+
+    /**
+     * Returns the width of this rectangle.
+     *
+     * @return the width of this rectangle {@code xmax - xmin}
+     */
+    public double width() {
+        return xmax - xmin;
+    }
+
+    /**
+     * Returns the height of this rectangle.
+     *
+     * @return the height of this rectangle {@code ymax - ymin}
+     */
+    public double height() {
+        return ymax - ymin;
+    }
+
+    /**
+     * Returns true if the two rectangles intersect. This includes
+     * <em>improper intersections</em> (at points on the boundary
+     * of each rectangle) and <em>nested intersctions</em>
+     * (when one rectangle is contained inside the other)
+     *
+     * @param  that the other rectangle
+     * @return {@code true} if this rectangle intersect the argument
+               rectangle at one or more points
+     */
+    public boolean intersects(RectHV that) {
+        return this.xmax >= that.xmin && this.ymax >= that.ymin
+            && that.xmax >= this.xmin && that.ymax >= this.ymin;
+    }
+
+    /**
+     * Returns true if this rectangle contain the point.
+     * @param  p the point
+     * @return {@code true} if this rectangle contain the point {@code p},
+               possibly at the boundary; {@code false} otherwise
+     */
+    public boolean contains(Point2D p) {
+        return (p.x() >= xmin) && (p.x() <= xmax)
+            && (p.y() >= ymin) && (p.y() <= ymax);
+    }
+
+    /**
+     * Returns the Euclidean distance between this rectangle and the point {@code p}.
+     *
+     * @param  p the point
+     * @return the Euclidean distance between the point {@code p} and the closest point
+               on this rectangle; 0 if the point is contained in this rectangle
+     */
+    public double distanceTo(Point2D p) {
+        return Math.sqrt(this.distanceSquaredTo(p));
+    }
+
+    /**
+     * Returns the square of the Euclidean distance between this rectangle and the point {@code p}.
+     *
+     * @param  p the point
+     * @return the square of the Euclidean distance between the point {@code p} and
+     *         the closest point on this rectangle; 0 if the point is contained
+     *         in this rectangle
+     */
+    public double distanceSquaredTo(Point2D p) {
+        double dx = 0.0, dy = 0.0;
+        if      (p.x() < xmin) dx = p.x() - xmin;
+        else if (p.x() > xmax) dx = p.x() - xmax;
+        if      (p.y() < ymin) dy = p.y() - ymin;
+        else if (p.y() > ymax) dy = p.y() - ymax;
+        return dx*dx + dy*dy;
+    }
+
+    /**
+     * Compares this rectangle to the specified rectangle.
+     *
+     * @param  other the other rectangle
+     * @return {@code true} if this rectangle equals {@code other};
+     *         {@code false} otherwise
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        RectHV that = (RectHV) other;
+        if (this.xmin != that.xmin) return false;
+        if (this.ymin != that.ymin) return false;
+        if (this.xmax != that.xmax) return false;
+        if (this.ymax != that.ymax) return false;
+        return true;
+    }
+
+    /**
+     * Returns an integer hash code for this rectangle.
+     * @return an integer hash code for this rectangle
+     */
+    @Override
+    public int hashCode() {
+        int hash1 = ((Double) xmin).hashCode();
+        int hash2 = ((Double) ymin).hashCode();
+        int hash3 = ((Double) xmax).hashCode();
+        int hash4 = ((Double) ymax).hashCode();
+        return 31*(31*(31*hash1 + hash2) + hash3) + hash4;
+    }
+
+    /**
+     * Returns a string representation of this rectangle.
+     *
+     * @return a string representation of this rectangle, using the format
+     *         {@code [xmin, xmax] x [ymin, ymax]}
+     */
+    @Override
+    public String toString() {
+        return "[" + xmin + ", " + xmax + "] x [" + ymin + ", " + ymax + "]";
+    }
+
+    /**
+     * Draws this rectangle to standard draw.
+     */
+    public void draw() {
+        StdDraw.line(xmin, ymin, xmax, ymin);
+        StdDraw.line(xmax, ymin, xmax, ymax);
+        StdDraw.line(xmax, ymax, xmin, ymax);
+        StdDraw.line(xmin, ymax, xmin, ymin);
+    }
+
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/RedBlackBST.java b/src/main/java/edu/princeton/cs/algs4/RedBlackBST.java
new file mode 100644
index 0000000..a9aac49
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/RedBlackBST.java
@@ -0,0 +1,758 @@
+/******************************************************************************
+ *  Compilation:  javac RedBlackBST.java
+ *  Execution:    java RedBlackBST < input.txt
+ *  Dependencies: StdIn.java StdOut.java  
+ *  Data files:   https://algs4.cs.princeton.edu/33balanced/tinyST.txt  
+ *    
+ *  A symbol table implemented using a left-leaning red-black BST.
+ *  This is the 2-3 version.
+ *
+ *  Note: commented out assertions because DrJava now enables assertions
+ *        by default.
+ *
+ *  % more tinyST.txt
+ *  S E A R C H E X A M P L E
+ *  
+ *  % java RedBlackBST < tinyST.txt
+ *  A 8
+ *  C 4
+ *  E 12
+ *  H 5
+ *  L 11
+ *  M 9
+ *  P 10
+ *  R 3
+ *  S 0
+ *  X 7
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code BST} class represents an ordered symbol table of generic
+ *  key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides ordered methods for finding the <em>minimum</em>,
+ *  <em>maximum</em>, <em>floor</em>, and <em>ceiling</em>.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  It requires that
+ *  the key type implements the {@code Comparable} interface and calls the
+ *  {@code compareTo()} and method to compare two keys. It does not call either
+ *  {@code equals()} or {@code hashCode()}.
+ *  <p>
+ *  This implementation uses a <em>left-leaning red-black BST</em>. 
+ *  The <em>put</em>, <em>get</em>, <em>contains</em>, <em>remove</em>,
+ *  <em>minimum</em>, <em>maximum</em>, <em>ceiling</em>, <em>floor</em>,
+ *  <em>rank</em>, and <em>select</em> operations each take
+ *  &Theta;(log <em>n</em>) time in the worst case, where <em>n</em> is the
+ *  number of key-value pairs in the symbol table.
+ *  The <em>size</em>, and <em>is-empty</em> operations take &Theta;(1) time.
+ *  The <em>keys</em> methods take
+ *  <em>O</em>(log <em>n</em> + <em>m</em>) time, where <em>m</em> is
+ *  the number of keys returned by the iterator.
+ *  Construction takes &Theta;(1) time.
+ *  <p>
+ *  For alternative implementations of the symbol table API, see {@link ST},
+ *  {@link BinarySearchST}, {@link SequentialSearchST}, {@link BST},
+ *  {@link SeparateChainingHashST}, {@link LinearProbingHashST}, and
+ *  {@link AVLTreeST}.
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/33balanced">Section 3.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class RedBlackBST<Key extends Comparable<Key>, Value> {
+
+    private static final boolean RED   = true;
+    private static final boolean BLACK = false;
+
+    private Node root;     // root of the BST
+
+    // BST helper node data type
+    private class Node {
+        private Key key;           // key
+        private Value val;         // associated data
+        private Node left, right;  // links to left and right subtrees
+        private boolean color;     // color of parent link
+        private int size;          // subtree count
+
+        public Node(Key key, Value val, boolean color, int size) {
+            this.key = key;
+            this.val = val;
+            this.color = color;
+            this.size = size;
+        }
+    }
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public RedBlackBST() {
+    }
+
+   /***************************************************************************
+    *  Node helper methods.
+    ***************************************************************************/
+    // is node x red; false if x is null ?
+    private boolean isRed(Node x) {
+        if (x == null) return false;
+        return x.color == RED;
+    }
+
+    // number of node in subtree rooted at x; 0 if x is null
+    private int size(Node x) {
+        if (x == null) return 0;
+        return x.size;
+    } 
+
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return size(root);
+    }
+
+   /**
+     * Is this symbol table empty?
+     * @return {@code true} if this symbol table is empty and {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return root == null;
+    }
+
+
+   /***************************************************************************
+    *  Standard BST search.
+    ***************************************************************************/
+
+    /**
+     * Returns the value associated with the given key.
+     * @param key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *     and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null");
+        return get(root, key);
+    }
+
+    // value associated with the given key in subtree rooted at x; null if no such key
+    private Value get(Node x, Key key) {
+        while (x != null) {
+            int cmp = key.compareTo(x.key);
+            if      (cmp < 0) x = x.left;
+            else if (cmp > 0) x = x.right;
+            else              return x.val;
+        }
+        return null;
+    }
+
+    /**
+     * Does this symbol table contain the given key?
+     * @param key the key
+     * @return {@code true} if this symbol table contains {@code key} and
+     *     {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        return get(key) != null;
+    }
+
+   /***************************************************************************
+    *  Red-black tree insertion.
+    ***************************************************************************/
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param key the key
+     * @param val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
+        if (val == null) {
+            delete(key);
+            return;
+        }
+
+        root = put(root, key, val);
+        root.color = BLACK;
+        // assert check();
+    }
+
+    // insert the key-value pair in the subtree rooted at h
+    private Node put(Node h, Key key, Value val) { 
+        if (h == null) return new Node(key, val, RED, 1);
+
+        int cmp = key.compareTo(h.key);
+        if      (cmp < 0) h.left  = put(h.left,  key, val); 
+        else if (cmp > 0) h.right = put(h.right, key, val); 
+        else              h.val   = val;
+
+        // fix-up any right-leaning links
+        if (isRed(h.right) && !isRed(h.left))      h = rotateLeft(h);
+        if (isRed(h.left)  &&  isRed(h.left.left)) h = rotateRight(h);
+        if (isRed(h.left)  &&  isRed(h.right))     flipColors(h);
+        h.size = size(h.left) + size(h.right) + 1;
+
+        return h;
+    }
+
+   /***************************************************************************
+    *  Red-black tree deletion.
+    ***************************************************************************/
+
+    /**
+     * Removes the smallest key and associated value from the symbol table.
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMin() {
+        if (isEmpty()) throw new NoSuchElementException("BST underflow");
+
+        // if both children of root are black, set root to red
+        if (!isRed(root.left) && !isRed(root.right))
+            root.color = RED;
+
+        root = deleteMin(root);
+        if (!isEmpty()) root.color = BLACK;
+        // assert check();
+    }
+
+    // delete the key-value pair with the minimum key rooted at h
+    private Node deleteMin(Node h) { 
+        if (h.left == null)
+            return null;
+
+        if (!isRed(h.left) && !isRed(h.left.left))
+            h = moveRedLeft(h);
+
+        h.left = deleteMin(h.left);
+        return balance(h);
+    }
+
+
+    /**
+     * Removes the largest key and associated value from the symbol table.
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public void deleteMax() {
+        if (isEmpty()) throw new NoSuchElementException("BST underflow");
+
+        // if both children of root are black, set root to red
+        if (!isRed(root.left) && !isRed(root.right))
+            root.color = RED;
+
+        root = deleteMax(root);
+        if (!isEmpty()) root.color = BLACK;
+        // assert check();
+    }
+
+    // delete the key-value pair with the maximum key rooted at h
+    private Node deleteMax(Node h) { 
+        if (isRed(h.left))
+            h = rotateRight(h);
+
+        if (h.right == null)
+            return null;
+
+        if (!isRed(h.right) && !isRed(h.right.left))
+            h = moveRedRight(h);
+
+        h.right = deleteMax(h.right);
+
+        return balance(h);
+    }
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).    
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) { 
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
+        if (!contains(key)) return;
+
+        // if both children of root are black, set root to red
+        if (!isRed(root.left) && !isRed(root.right))
+            root.color = RED;
+
+        root = delete(root, key);
+        if (!isEmpty()) root.color = BLACK;
+        // assert check();
+    }
+
+    // delete the key-value pair with the given key rooted at h
+    private Node delete(Node h, Key key) { 
+        // assert get(h, key) != null;
+
+        if (key.compareTo(h.key) < 0)  {
+            if (!isRed(h.left) && !isRed(h.left.left))
+                h = moveRedLeft(h);
+            h.left = delete(h.left, key);
+        }
+        else {
+            if (isRed(h.left))
+                h = rotateRight(h);
+            if (key.compareTo(h.key) == 0 && (h.right == null))
+                return null;
+            if (!isRed(h.right) && !isRed(h.right.left))
+                h = moveRedRight(h);
+            if (key.compareTo(h.key) == 0) {
+                Node x = min(h.right);
+                h.key = x.key;
+                h.val = x.val;
+                // h.val = get(h.right, min(h.right).key);
+                // h.key = min(h.right).key;
+                h.right = deleteMin(h.right);
+            }
+            else h.right = delete(h.right, key);
+        }
+        return balance(h);
+    }
+
+   /***************************************************************************
+    *  Red-black tree helper functions.
+    ***************************************************************************/
+
+    // make a left-leaning link lean to the right
+    private Node rotateRight(Node h) {
+        assert (h != null) && isRed(h.left);
+        // assert (h != null) && isRed(h.left) &&  !isRed(h.right);  // for insertion only
+        Node x = h.left;
+        h.left = x.right;
+        x.right = h;
+        x.color = x.right.color;
+        x.right.color = RED;
+        x.size = h.size;
+        h.size = size(h.left) + size(h.right) + 1;
+        return x;
+    }
+
+    // make a right-leaning link lean to the left
+    private Node rotateLeft(Node h) {
+        assert (h != null) && isRed(h.right);
+        // assert (h != null) && isRed(h.right) && !isRed(h.left);  // for insertion only
+        Node x = h.right;
+        h.right = x.left;
+        x.left = h;
+        x.color = x.left.color;
+        x.left.color = RED;
+        x.size = h.size;
+        h.size = size(h.left) + size(h.right) + 1;
+        return x;
+    }
+
+    // flip the colors of a node and its two children
+    private void flipColors(Node h) {
+        // h must have opposite color of its two children
+        // assert (h != null) && (h.left != null) && (h.right != null);
+        // assert (!isRed(h) &&  isRed(h.left) &&  isRed(h.right))
+        //    || (isRed(h)  && !isRed(h.left) && !isRed(h.right));
+        h.color = !h.color;
+        h.left.color = !h.left.color;
+        h.right.color = !h.right.color;
+    }
+
+    // Assuming that h is red and both h.left and h.left.left
+    // are black, make h.left or one of its children red.
+    private Node moveRedLeft(Node h) {
+        // assert (h != null);
+        // assert isRed(h) && !isRed(h.left) && !isRed(h.left.left);
+
+        flipColors(h);
+        if (isRed(h.right.left)) { 
+            h.right = rotateRight(h.right);
+            h = rotateLeft(h);
+            flipColors(h);
+        }
+        return h;
+    }
+
+    // Assuming that h is red and both h.right and h.right.left
+    // are black, make h.right or one of its children red.
+    private Node moveRedRight(Node h) {
+        // assert (h != null);
+        // assert isRed(h) && !isRed(h.right) && !isRed(h.right.left);
+        flipColors(h);
+        if (isRed(h.left.left)) { 
+            h = rotateRight(h);
+            flipColors(h);
+        }
+        return h;
+    }
+
+    // restore red-black tree invariant
+    private Node balance(Node h) {
+        // assert (h != null);
+
+        if (isRed(h.right) && !isRed(h.left))    h = rotateLeft(h);
+        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
+        if (isRed(h.left) && isRed(h.right))     flipColors(h);
+
+        h.size = size(h.left) + size(h.right) + 1;
+        return h;
+    }
+
+
+   /***************************************************************************
+    *  Utility functions.
+    ***************************************************************************/
+
+    /**
+     * Returns the height of the BST (for debugging).
+     * @return the height of the BST (a 1-node tree has height 0)
+     */
+    public int height() {
+        return height(root);
+    }
+    private int height(Node x) {
+        if (x == null) return -1;
+        return 1 + Math.max(height(x.left), height(x.right));
+    }
+
+   /***************************************************************************
+    *  Ordered symbol table methods.
+    ***************************************************************************/
+
+    /**
+     * Returns the smallest key in the symbol table.
+     * @return the smallest key in the symbol table
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("calls min() with empty symbol table");
+        return min(root).key;
+    } 
+
+    // the smallest key in subtree rooted at x; null if no such key
+    private Node min(Node x) { 
+        // assert x != null;
+        if (x.left == null) return x; 
+        else                return min(x.left); 
+    } 
+
+    /**
+     * Returns the largest key in the symbol table.
+     * @return the largest key in the symbol table
+     * @throws NoSuchElementException if the symbol table is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("calls max() with empty symbol table");
+        return max(root).key;
+    } 
+
+    // the largest key in the subtree rooted at x; null if no such key
+    private Node max(Node x) { 
+        // assert x != null;
+        if (x.right == null) return x; 
+        else                 return max(x.right); 
+    } 
+
+
+    /**
+     * Returns the largest key in the symbol table less than or equal to {@code key}.
+     * @param key the key
+     * @return the largest key in the symbol table less than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key floor(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
+        if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
+        Node x = floor(root, key);
+        if (x == null) throw new NoSuchElementException("argument to floor() is too small");
+        else           return x.key;
+    }    
+
+    // the largest key in the subtree rooted at x less than or equal to the given key
+    private Node floor(Node x, Key key) {
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp == 0) return x;
+        if (cmp < 0)  return floor(x.left, key);
+        Node t = floor(x.right, key);
+        if (t != null) return t; 
+        else           return x;
+    }
+
+    /**
+     * Returns the smallest key in the symbol table greater than or equal to {@code key}.
+     * @param key the key
+     * @return the smallest key in the symbol table greater than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key ceiling(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
+        if (isEmpty()) throw new NoSuchElementException("calls ceiling() with empty symbol table");
+        Node x = ceiling(root, key);
+        if (x == null) throw new NoSuchElementException("argument to ceiling() is too small");
+        else           return x.key;  
+    }
+
+    // the smallest key in the subtree rooted at x greater than or equal to the given key
+    private Node ceiling(Node x, Key key) {  
+        if (x == null) return null;
+        int cmp = key.compareTo(x.key);
+        if (cmp == 0) return x;
+        if (cmp > 0)  return ceiling(x.right, key);
+        Node t = ceiling(x.left, key);
+        if (t != null) return t; 
+        else           return x;
+    }
+
+    /**
+     * Return the key in the symbol table of a given {@code rank}.
+     * This key has the property that there are {@code rank} keys in
+     * the symbol table that are smaller. In other words, this key is the
+     * ({@code rank}+1)st smallest key in the symbol table.
+     *
+     * @param  rank the order statistic
+     * @return the key in the symbol table of given {@code rank}
+     * @throws IllegalArgumentException unless {@code rank} is between 0 and
+     *        <em>n</em>‚Äì1
+     */
+    public Key select(int rank) {
+        if (rank < 0 || rank >= size()) {
+            throw new IllegalArgumentException("argument to select() is invalid: " + rank);
+        }
+        return select(root, rank);
+    }
+
+    // Return key in BST rooted at x of given rank.
+    // Precondition: rank is in legal range.
+    private Key select(Node x, int rank) {
+        if (x == null) return null;
+        int leftSize = size(x.left);
+        if      (leftSize > rank) return select(x.left,  rank);
+        else if (leftSize < rank) return select(x.right, rank - leftSize - 1); 
+        else                      return x.key;
+    }
+
+    /**
+     * Return the number of keys in the symbol table strictly less than {@code key}.
+     * @param key the key
+     * @return the number of keys in the symbol table strictly less than {@code key}
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public int rank(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to rank() is null");
+        return rank(key, root);
+    } 
+
+    // number of keys less than key in the subtree rooted at x
+    private int rank(Key key, Node x) {
+        if (x == null) return 0; 
+        int cmp = key.compareTo(x.key); 
+        if      (cmp < 0) return rank(key, x.left); 
+        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right); 
+        else              return size(x.left); 
+    } 
+
+   /***************************************************************************
+    *  Range count and range search.
+    ***************************************************************************/
+
+    /**
+     * Returns all keys in the symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     * @return all keys in the symbol table as an {@code Iterable}
+     */
+    public Iterable<Key> keys() {
+        if (isEmpty()) return new Queue<Key>();
+        return keys(min(), max());
+    }
+
+    /**
+     * Returns all keys in the symbol table in the given range,
+     * as an {@code Iterable}.
+     *
+     * @param  lo minimum endpoint
+     * @param  hi maximum endpoint
+     * @return all keys in the symbol table between {@code lo} 
+     *    (inclusive) and {@code hi} (inclusive) as an {@code Iterable}
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *    is {@code null}
+     */
+    public Iterable<Key> keys(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to keys() is null");
+        if (hi == null) throw new IllegalArgumentException("second argument to keys() is null");
+
+        Queue<Key> queue = new Queue<Key>();
+        // if (isEmpty() || lo.compareTo(hi) > 0) return queue;
+        keys(root, queue, lo, hi);
+        return queue;
+    } 
+
+    // add the keys between lo and hi in the subtree rooted at x
+    // to the queue
+    private void keys(Node x, Queue<Key> queue, Key lo, Key hi) { 
+        if (x == null) return; 
+        int cmplo = lo.compareTo(x.key); 
+        int cmphi = hi.compareTo(x.key); 
+        if (cmplo < 0) keys(x.left, queue, lo, hi); 
+        if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key); 
+        if (cmphi > 0) keys(x.right, queue, lo, hi); 
+    } 
+
+    /**
+     * Returns the number of keys in the symbol table in the given range.
+     *
+     * @param  lo minimum endpoint
+     * @param  hi maximum endpoint
+     * @return the number of keys in the symbol table between {@code lo} 
+     *    (inclusive) and {@code hi} (inclusive)
+     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
+     *    is {@code null}
+     */
+    public int size(Key lo, Key hi) {
+        if (lo == null) throw new IllegalArgumentException("first argument to size() is null");
+        if (hi == null) throw new IllegalArgumentException("second argument to size() is null");
+
+        if (lo.compareTo(hi) > 0) return 0;
+        if (contains(hi)) return rank(hi) - rank(lo) + 1;
+        else              return rank(hi) - rank(lo);
+    }
+
+
+   /***************************************************************************
+    *  Check integrity of red-black tree data structure.
+    ***************************************************************************/
+    private boolean check() {
+        if (!isBST())            StdOut.println("Not in symmetric order");
+        if (!isSizeConsistent()) StdOut.println("Subtree counts not consistent");
+        if (!isRankConsistent()) StdOut.println("Ranks not consistent");
+        if (!is23())             StdOut.println("Not a 2-3 tree");
+        if (!isBalanced())       StdOut.println("Not balanced");
+        return isBST() && isSizeConsistent() && isRankConsistent() && is23() && isBalanced();
+    }
+
+    // does this binary tree satisfy symmetric order?
+    // Note: this test also ensures that data structure is a binary tree since order is strict
+    private boolean isBST() {
+        return isBST(root, null, null);
+    }
+
+    // is the tree rooted at x a BST with all keys strictly between min and max
+    // (if min or max is null, treat as empty constraint)
+    // Credit: Bob Dondero's elegant solution
+    private boolean isBST(Node x, Key min, Key max) {
+        if (x == null) return true;
+        if (min != null && x.key.compareTo(min) <= 0) return false;
+        if (max != null && x.key.compareTo(max) >= 0) return false;
+        return isBST(x.left, min, x.key) && isBST(x.right, x.key, max);
+    } 
+
+    // are the size fields correct?
+    private boolean isSizeConsistent() { return isSizeConsistent(root); }
+    private boolean isSizeConsistent(Node x) {
+        if (x == null) return true;
+        if (x.size != size(x.left) + size(x.right) + 1) return false;
+        return isSizeConsistent(x.left) && isSizeConsistent(x.right);
+    } 
+
+    // check that ranks are consistent
+    private boolean isRankConsistent() {
+        for (int i = 0; i < size(); i++)
+            if (i != rank(select(i))) return false;
+        for (Key key : keys())
+            if (key.compareTo(select(rank(key))) != 0) return false;
+        return true;
+    }
+
+    // Does the tree have no red right links, and at most one (left)
+    // red links in a row on any path?
+    private boolean is23() { return is23(root); }
+    private boolean is23(Node x) {
+        if (x == null) return true;
+        if (isRed(x.right)) return false;
+        if (x != root && isRed(x) && isRed(x.left))
+            return false;
+        return is23(x.left) && is23(x.right);
+    } 
+
+    // do all paths from root to leaf have same number of black edges?
+    private boolean isBalanced() { 
+        int black = 0;     // number of black links on path from root to min
+        Node x = root;
+        while (x != null) {
+            if (!isRed(x)) black++;
+            x = x.left;
+        }
+        return isBalanced(root, black);
+    }
+
+    // does every path from the root to a leaf have the given number of black links?
+    private boolean isBalanced(Node x, int black) {
+        if (x == null) return black == 0;
+        if (!isRed(x)) black--;
+        return isBalanced(x.left, black) && isBalanced(x.right, black);
+    } 
+
+
+    /**
+     * Unit tests the {@code RedBlackBST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        RedBlackBST<String, Integer> st = new RedBlackBST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+        StdOut.println();
+        for (String s : st.keys())
+            StdOut.println(s + " " + st.get(s));
+        StdOut.println();
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/ResizingArrayBag.java b/src/main/java/edu/princeton/cs/algs4/ResizingArrayBag.java
new file mode 100644
index 0000000..188bafe
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ResizingArrayBag.java
@@ -0,0 +1,143 @@
+/******************************************************************************
+ *  Compilation:  javac ResizingArrayBag.java
+ *  Execution:    java ResizingArrayBag
+ *  Dependencies: StdIn.java StdOut.java
+ *  
+ *  Bag implementation with a resizing array.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code ResizingArrayBag} class represents a bag (or multiset) of 
+ *  generic items. It supports insertion and iterating over the 
+ *  items in arbitrary order.
+ *  <p>
+ *  This implementation uses a resizing array.
+ *  See {@link LinkedBag} for a version that uses a singly linked list.
+ *  The <em>add</em> operation takes constant amortized time; the
+ *  <em>isEmpty</em>, and <em>size</em> operations
+ *  take constant time. Iteration takes time proportional to the number of items.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class ResizingArrayBag<Item> implements Iterable<Item> {
+    // initial capacity of underlying resizing array
+    private static final int INIT_CAPACITY = 8;
+
+    private Item[] a;         // array of items
+    private int n;            // number of elements on bag
+
+    /**
+     * Initializes an empty bag.
+     */
+    public ResizingArrayBag() {
+        a = (Item[]) new Object[INIT_CAPACITY];
+        n = 0;
+    }
+
+    /**
+     * Is this bag empty?
+     * @return true if this bag is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Returns the number of items in this bag.
+     * @return the number of items in this bag
+     */
+    public int size() {
+        return n;
+    }
+
+    // resize the underlying array holding the elements
+    private void resize(int capacity) {
+        assert capacity >= n;
+        Item[] copy = (Item[]) new Object[capacity];
+        for (int i = 0; i < n; i++)
+            copy[i] = a[i];
+        a = copy;
+    }
+
+    /**
+     * Adds the item to this bag.
+     * @param item the item to add to this bag
+     */
+    public void add(Item item) {
+        if (n == a.length) resize(2*a.length);    // double size of array if necessary
+        a[n++] = item;                            // add item
+    }
+
+
+    /**
+     * Returns an iterator that iterates over the items in the bag in arbitrary order.
+     * @return an iterator that iterates over the items in the bag in arbitrary order
+     */
+    public Iterator<Item> iterator() {
+        return new ArrayIterator();
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class ArrayIterator implements Iterator<Item> {
+        private int i = 0;
+        public boolean hasNext()  { return i < n;                               }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            return a[i++];
+        }
+    }
+
+    /**
+     * Unit tests the {@code ResizingArrayBag} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        ResizingArrayBag<String> bag = new ResizingArrayBag<String>();
+        bag.add("Hello");
+        bag.add("World");
+        bag.add("how");
+        bag.add("are");
+        bag.add("you");
+
+        for (String s : bag)
+            StdOut.println(s);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/ResizingArrayQueue.java b/src/main/java/edu/princeton/cs/algs4/ResizingArrayQueue.java
new file mode 100644
index 0000000..19d3fe6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ResizingArrayQueue.java
@@ -0,0 +1,188 @@
+/******************************************************************************
+ *  Compilation:  javac ResizingArrayQueue.java
+ *  Execution:    java ResizingArrayQueue < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/13stacks/tobe.txt  
+ *  
+ *  Queue implementation with a resizing array.
+ *
+ *  % java ResizingArrayQueue < tobe.txt 
+ *  to be or not to be (2 left on queue)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code ResizingArrayQueue} class represents a first-in-first-out (FIFO)
+ *  queue of generic items.
+ *  It supports the usual <em>enqueue</em> and <em>dequeue</em>
+ *  operations, along with methods for peeking at the first item,
+ *  testing if the queue is empty, and iterating through
+ *  the items in FIFO order.
+ *  <p>
+ *  This implementation uses a resizing array, which double the underlying array
+ *  when it is full and halves the underlying array when it is one-quarter full.
+ *  The <em>enqueue</em> and <em>dequeue</em> operations take constant amortized time.
+ *  The <em>size</em>, <em>peek</em>, and <em>is-empty</em> operations takes
+ *  constant time in the worst case. 
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class ResizingArrayQueue<Item> implements Iterable<Item> {
+    // initial capacity of underlying resizing array
+    private static final int INIT_CAPACITY = 8;
+
+    private Item[] q;       // queue elements
+    private int n;          // number of elements on queue
+    private int first;      // index of first element of queue
+    private int last;       // index of next available slot
+
+
+    /**
+     * Initializes an empty queue.
+     */
+    public ResizingArrayQueue() {
+        q = (Item[]) new Object[INIT_CAPACITY];
+        n = 0;
+        first = 0;
+        last = 0;
+    }
+
+    /**
+     * Is this queue empty?
+     * @return true if this queue is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Returns the number of items in this queue.
+     * @return the number of items in this queue
+     */
+    public int size() {
+        return n;
+    }
+
+    // resize the underlying array
+    private void resize(int capacity) {
+        assert capacity >= n;
+        Item[] copy = (Item[]) new Object[capacity];
+        for (int i = 0; i < n; i++) {
+            copy[i] = q[(first + i) % q.length];
+        }
+        q = copy;
+        first = 0;
+        last  = n;
+    }
+
+    /**
+     * Adds the item to this queue.
+     * @param item the item to add
+     */
+    public void enqueue(Item item) {
+        // double size of array if necessary and recopy to front of array
+        if (n == q.length) resize(2*q.length);   // double size of array if necessary
+        q[last++] = item;                        // add item
+        if (last == q.length) last = 0;          // wrap-around
+        n++;
+    }
+
+    /**
+     * Removes and returns the item on this queue that was least recently added.
+     * @return the item on this queue that was least recently added
+     * @throws java.util.NoSuchElementException if this queue is empty
+     */
+    public Item dequeue() {
+        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
+        Item item = q[first];
+        q[first] = null;                            // to avoid loitering
+        n--;
+        first++;
+        if (first == q.length) first = 0;           // wrap-around
+        // shrink size of array if necessary
+        if (n > 0 && n == q.length/4) resize(q.length/2); 
+        return item;
+    }
+
+    /**
+     * Returns the item least recently added to this queue.
+     * @return the item least recently added to this queue
+     * @throws java.util.NoSuchElementException if this queue is empty
+     */
+    public Item peek() {
+        if (isEmpty()) throw new NoSuchElementException("Queue underflow");
+        return q[first];
+    }
+
+
+    /**
+     * Returns an iterator that iterates over the items in this queue in FIFO order.
+     * @return an iterator that iterates over the items in this queue in FIFO order
+     */
+    public Iterator<Item> iterator() {
+        return new ArrayIterator();
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class ArrayIterator implements Iterator<Item> {
+        private int i = 0;
+        public boolean hasNext()  { return i < n;                               }
+        public void remove()      { throw new UnsupportedOperationException();  }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = q[(i + first) % q.length];
+            i++;
+            return item;
+        }
+    }
+
+   /**
+     * Unit tests the {@code ResizingArrayQueue} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        ResizingArrayQueue<String> queue = new ResizingArrayQueue<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-")) queue.enqueue(item);
+            else if (!queue.isEmpty()) StdOut.print(queue.dequeue() + " ");
+        }
+        StdOut.println("(" + queue.size() + " left on queue)");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/ResizingArrayStack.java b/src/main/java/edu/princeton/cs/algs4/ResizingArrayStack.java
new file mode 100644
index 0000000..7957923
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ResizingArrayStack.java
@@ -0,0 +1,197 @@
+/******************************************************************************
+ *  Compilation:  javac ResizingArrayStack.java
+ *  Execution:    java ResizingArrayStack < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/13stacks/tobe.txt
+ *  
+ *  Stack implementation with a resizing array.
+ *
+ *  % more tobe.txt 
+ *  to be or not to - be - - that - - - is
+ *
+ *  % java ResizingArrayStack < tobe.txt
+ *  to be not that or be (2 left on stack)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ *  The {@code ResizingArrayStack} class represents a last-in-first-out (LIFO) stack
+ *  of generic items.
+ *  It supports the usual <em>push</em> and <em>pop</em> operations, along with methods
+ *  for peeking at the top item, testing if the stack is empty, and iterating through
+ *  the items in LIFO order.
+ *  <p>
+ *  This implementation uses a resizing array, which double the underlying array
+ *  when it is full and halves the underlying array when it is one-quarter full.
+ *  The <em>push</em> and <em>pop</em> operations take constant amortized time.
+ *  The <em>size</em>, <em>peek</em>, and <em>is-empty</em> operations takes
+ *  constant time in the worst case. 
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class ResizingArrayStack<Item> implements Iterable<Item> {
+
+    // initial capacity of underlying resizing array
+    private static final int INIT_CAPACITY = 8;
+
+    private Item[] a;         // array of items
+    private int n;            // number of elements on stack
+
+
+    /**
+     * Initializes an empty stack.
+     */
+    public ResizingArrayStack() {
+        a = (Item[]) new Object[INIT_CAPACITY];
+        n = 0;
+    }
+
+    /**
+     * Is this stack empty?
+     * @return true if this stack is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return n == 0;
+    }
+
+    /**
+     * Returns the number of items in the stack.
+     * @return the number of items in the stack
+     */
+    public int size() {
+        return n;
+    }
+
+
+    // resize the underlying array holding the elements
+    private void resize(int capacity) {
+        assert capacity >= n;
+
+        // textbook implementation
+        Item[] copy = (Item[]) new Object[capacity];
+        for (int i = 0; i < n; i++) {
+            copy[i] = a[i];
+        }
+        a = copy;
+
+       // alternative implementation
+       // a = java.util.Arrays.copyOf(a, capacity);
+    }
+
+
+
+    /**
+     * Adds the item to this stack.
+     * @param item the item to add
+     */
+    public void push(Item item) {
+        if (n == a.length) resize(2*a.length);    // double size of array if necessary
+        a[n++] = item;                            // add item
+    }
+
+    /**
+     * Removes and returns the item most recently added to this stack.
+     * @return the item most recently added
+     * @throws java.util.NoSuchElementException if this stack is empty
+     */
+    public Item pop() {
+        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
+        Item item = a[n-1];
+        a[n-1] = null;                              // to avoid loitering
+        n--;
+        // shrink size of array if necessary
+        if (n > 0 && n == a.length/4) resize(a.length/2);
+        return item;
+    }
+
+
+    /**
+     * Returns (but does not remove) the item most recently added to this stack.
+     * @return the item most recently added to this stack
+     * @throws java.util.NoSuchElementException if this stack is empty
+     */
+    public Item peek() {
+        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
+        return a[n-1];
+    }
+
+    /**
+     * Returns an iterator to this stack that iterates through the items in LIFO order.
+     * @return an iterator to this stack that iterates through the items in LIFO order.
+     */
+    public Iterator<Item> iterator() {
+        return new ReverseArrayIterator();
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class ReverseArrayIterator implements Iterator<Item> {
+        private int i;
+
+        public ReverseArrayIterator() {
+            i = n-1;
+        }
+
+        public boolean hasNext() {
+            return i >= 0;
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            return a[i--];
+        }
+    }
+
+
+    /**
+     * Unit tests the {@code Stack} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        ResizingArrayStack<String> stack = new ResizingArrayStack<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-")) stack.push(item);
+            else if (!stack.isEmpty()) StdOut.print(stack.pop() + " ");
+        }
+        StdOut.println("(" + stack.size() + " left on stack)");
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/RunLength.java b/src/main/java/edu/princeton/cs/algs4/RunLength.java
new file mode 100644
index 0000000..ef73177
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/RunLength.java
@@ -0,0 +1,127 @@
+/******************************************************************************
+ *  Compilation:  javac RunLength.java
+ *  Execution:    java RunLength - < input.txt   (compress)
+ *  Execution:    java RunLength + < input.txt   (expand)
+ *  Dependencies: BinaryIn.java BinaryOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/55compression/4runs.bin
+ *                https://algs4.cs.princeton.edu/55compression/q32x48.bin
+ *                https://algs4.cs.princeton.edu/55compression/q64x96.bin
+ *
+ *  Compress or expand binary input from standard input using
+ *  run-length encoding.
+ *
+ *  % java BinaryDump 40 < 4runs.bin 
+ *  0000000000000001111111000000011111111111
+ *  40 bits
+ *
+ *  This has runs of 15 0s, 7 1s, 7 0s, and 11 1s.
+ *
+ *  % java RunLength - < 4runs.bin | java HexDump
+ *  0f 07 07 0b
+ *  4 bytes
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code RunLength} class provides static methods for compressing
+ *  and expanding a binary input using run-length coding with 8-bit
+ *  run lengths.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/55compression">Section 5.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class RunLength {
+    private static final int R    = 256;
+    private static final int LG_R = 8;
+
+    // Do not instantiate.
+    private RunLength() { }
+
+    /**
+     * Reads a sequence of bits from standard input (that are encoded
+     * using run-length encoding with 8-bit run lengths); decodes them;
+     * and writes the results to standard output.
+     */
+    public static void expand() { 
+        boolean b = false; 
+        while (!BinaryStdIn.isEmpty()) {
+            int run = BinaryStdIn.readInt(LG_R);
+            for (int i = 0; i < run; i++)
+                BinaryStdOut.write(b);
+            b = !b;
+        }
+        BinaryStdOut.close();
+    }
+
+    /**
+     * Reads a sequence of bits from standard input; compresses
+     * them using run-length coding with 8-bit run lengths; and writes the
+     * results to standard output.
+     */
+    public static void compress() { 
+        char run = 0; 
+        boolean old = false;
+        while (!BinaryStdIn.isEmpty()) { 
+            boolean b = BinaryStdIn.readBoolean();
+            if (b != old) {
+                BinaryStdOut.write(run, LG_R);
+                run = 1;
+                old = !old;
+            }
+            else { 
+                if (run == R-1) { 
+                    BinaryStdOut.write(run, LG_R);
+                    run = 0;
+                    BinaryStdOut.write(run, LG_R);
+                }
+                run++;
+            } 
+        } 
+        BinaryStdOut.write(run, LG_R);
+        BinaryStdOut.close();
+    }
+
+
+    /**
+     * Sample client that calls {@code compress()} if the command-line
+     * argument is "-" an {@code expand()} if it is "+".
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        if      (args[0].equals("-")) compress();
+        else if (args[0].equals("+")) expand();
+        else throw new IllegalArgumentException("Illegal command line argument");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SET.java b/src/main/java/edu/princeton/cs/algs4/SET.java
new file mode 100644
index 0000000..09713fb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SET.java
@@ -0,0 +1,369 @@
+/******************************************************************************
+ *  Compilation:  javac SET.java
+ *  Execution:    java SET
+ *  Dependencies: StdOut.java
+ *  
+ *  Set implementation using Java's TreeSet library.
+ *  Does not allow duplicates.
+ *
+ *  % java SET
+ *  128.112.136.11
+ *  208.216.181.15
+ *  null
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.TreeSet;
+
+/**
+ *  The {@code SET} class represents an ordered set of comparable keys.
+ *  It supports the usual <em>add</em>, <em>contains</em>, and <em>delete</em>
+ *  methods. It also provides ordered methods for finding the <em>minimum</em>,
+ *  <em>maximum</em>, <em>floor</em>, and <em>ceiling</em> and set methods
+ *  for <em>union</em>, <em>intersection</em>, and <em>equality</em>.
+ *  <p>
+ *  Even though this implementation include the method {@code equals()}, it
+ *  does not support the method {@code hashCode()} because sets are mutable.
+ *  <p>
+ *  This implementation uses a balanced binary search tree. It requires that
+ *  the key type implements the {@code Comparable} interface and calls the
+ *  {@code compareTo()} and method to compare two keys. It does not call either
+ *  {@code equals()} or {@code hashCode()}.
+ *  The <em>add</em>, <em>contains</em>, <em>delete</em>, <em>minimum</em>,
+ *  <em>maximum</em>, <em>ceiling</em>, and <em>floor</em> methods take
+ *  logarithmic time in the worst case.
+ *  The <em>size</em>, and <em>is-empty</em> operations take constant time.
+ *  Construction takes constant time.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms in Java, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Key> the generic type of a key in this set
+ */
+
+public class SET<Key extends Comparable<Key>> implements Iterable<Key> {
+    private TreeSet<Key> set;
+
+    /**
+     * Initializes an empty set.
+     */
+    public SET() {
+        set = new TreeSet<Key>();
+    }
+
+    /**
+     * Initializes a new set that is an independent copy of the specified set.
+     *
+     * @param x the set to copy
+     */
+    public SET(SET<Key> x) {
+        set = new TreeSet<Key>(x.set);
+    }
+
+    /**
+     * Adds the key to this set (if it is not already present).
+     *
+     * @param  key the key to add
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void add(Key key) {
+        if (key == null) throw new IllegalArgumentException("called add() with a null key");
+        set.add(key);
+    }
+
+
+    /**
+     * Returns true if this set contains the given key.
+     *
+     * @param  key the key
+     * @return {@code true} if this set contains {@code key};
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("called contains() with a null key");
+        return set.contains(key);
+    }
+
+    /**
+     * Removes the specified key from this set (if the set contains the specified key).
+     * This is equivalent to {@code remove()}, but we plan to deprecate {@code delete()}.
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("called delete() with a null key");
+        set.remove(key);
+    }
+
+    /**
+     * Removes the specified key from this set (if the set contains the specified key).
+     * This is equivalent to {@code delete()}, but we plan to deprecate {@code delete()}.
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void remove(Key key) {
+        if (key == null) throw new IllegalArgumentException("called remove() with a null key");
+        set.remove(key);
+    }
+
+    /**
+     * Returns the number of keys in this set.
+     *
+     * @return the number of keys in this set
+     */
+    public int size() {
+        return set.size();
+    }
+
+    /**
+     * Returns true if this set is empty.
+     *
+     * @return {@code true} if this set is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+ 
+    /**
+     * Returns all of the keys in this set, as an iterator.
+     * To iterate over all of the keys in a set named {@code set}, use the
+     * foreach notation: {@code for (Key key : set)}.
+     *
+     * @return an iterator to all of the keys in this set
+     */
+    public Iterator<Key> iterator() {
+        return set.iterator();
+    }
+
+    /**
+     * Returns the largest key in this set.
+     *
+     * @return the largest key in this set
+     * @throws NoSuchElementException if this set is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("called max() with empty set");
+        return set.last();
+    }
+
+    /**
+     * Returns the smallest key in this set.
+     *
+     * @return the smallest key in this set
+     * @throws NoSuchElementException if this set is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("called min() with empty set");
+        return set.first();
+    }
+
+
+    /**
+     * Returns the smallest key in this set greater than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the smallest key in this set greater than or equal to {@code key}
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws NoSuchElementException if there is no such key
+     */
+    public Key ceiling(Key key) {
+        if (key == null) throw new IllegalArgumentException("called ceiling() with a null key");
+        Key k = set.ceiling(key);
+        if (k == null) throw new NoSuchElementException("all keys are less than " + key);
+        return k;
+    }
+
+    /**
+     * Returns the largest key in this set less than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the largest key in this set table less than or equal to {@code key}
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     * @throws NoSuchElementException if there is no such key
+     */
+    public Key floor(Key key) {
+        if (key == null) throw new IllegalArgumentException("called floor() with a null key");
+        Key k = set.floor(key);
+        if (k == null) throw new NoSuchElementException("all keys are greater than " + key);
+        return k;
+    }
+
+    /**
+     * Returns the union of this set and that set.
+     *
+     * @param  that the other set
+     * @return the union of this set and that set
+     * @throws IllegalArgumentException if {@code that} is {@code null}
+     */
+    public SET<Key> union(SET<Key> that) {
+        if (that == null) throw new IllegalArgumentException("called union() with a null argument");
+        SET<Key> c = new SET<Key>();
+        for (Key x : this) {
+            c.add(x);
+        }
+        for (Key x : that) {
+            c.add(x);
+        }
+        return c;
+    }
+
+    /**
+     * Returns the intersection of this set and that set.
+     *
+     * @param  that the other set
+     * @return the intersection of this set and that set
+     * @throws IllegalArgumentException if {@code that} is {@code null}
+     */
+    public SET<Key> intersects(SET<Key> that) {
+        if (that == null) throw new IllegalArgumentException("called intersects() with a null argument");
+        SET<Key> c = new SET<Key>();
+        if (this.size() < that.size()) {
+            for (Key x : this) {
+                if (that.contains(x)) c.add(x);
+            }
+        }
+        else {
+            for (Key x : that) {
+                if (this.contains(x)) c.add(x);
+            }
+        }
+        return c;
+    }
+
+    /**       
+     * Compares this set to the specified set.
+     * <p>
+     * Note that this method declares two empty sets to be equal
+     * even if they are parameterized by different generic types.
+     * This is consistent with the behavior of {@code equals()} 
+     * within Java's Collections framework.
+     *       
+     * @param  other the other set
+     * @return {@code true} if this set equals {@code other};
+     *         {@code false} otherwise
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        SET that = (SET) other;
+        return this.set.equals(that.set);
+    }
+
+    /**
+     * This operation is not supported because sets are mutable.
+     *
+     * @return does not return a value
+     * @throws UnsupportedOperationException if called
+     */
+    @Override
+    public int hashCode() {
+        throw new UnsupportedOperationException("hashCode() is not supported because sets are mutable");
+    }
+
+    /**
+     * Returns a string representation of this set.
+     *
+     * @return a string representation of this set, enclosed in curly braces,
+     *         with adjacent keys separated by a comma and a space
+     */
+    @Override
+    public String toString() {
+        String s = set.toString();
+        return "{ " + s.substring(1, s.length() - 1) + " }";
+    }
+
+    /**
+     * Unit tests the {@code SET} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        SET<String> set = new SET<String>();
+        StdOut.println("set = " + set);
+
+        // insert some keys
+        set.add("www.cs.princeton.edu");
+        set.add("www.cs.princeton.edu");    // overwrite old value
+        set.add("www.princeton.edu");
+        set.add("www.math.princeton.edu");
+        set.add("www.yale.edu");
+        set.add("www.amazon.com");
+        set.add("www.simpsons.com");
+        set.add("www.stanford.edu");
+        set.add("www.google.com");
+        set.add("www.ibm.com");
+        set.add("www.apple.com");
+        set.add("www.slashdot.com");
+        set.add("www.whitehouse.gov");
+        set.add("www.espn.com");
+        set.add("www.snopes.com");
+        set.add("www.movies.com");
+        set.add("www.cnn.com");
+        set.add("www.iitb.ac.in");
+
+
+        StdOut.println(set.contains("www.cs.princeton.edu"));
+        StdOut.println(!set.contains("www.harvardsucks.com"));
+        StdOut.println(set.contains("www.simpsons.com"));
+        StdOut.println();
+
+        StdOut.println("ceiling(www.simpsonr.com) = " + set.ceiling("www.simpsonr.com"));
+        StdOut.println("ceiling(www.simpsons.com) = " + set.ceiling("www.simpsons.com"));
+        StdOut.println("ceiling(www.simpsont.com) = " + set.ceiling("www.simpsont.com"));
+        StdOut.println("floor(www.simpsonr.com)   = " + set.floor("www.simpsonr.com"));
+        StdOut.println("floor(www.simpsons.com)   = " + set.floor("www.simpsons.com"));
+        StdOut.println("floor(www.simpsont.com)   = " + set.floor("www.simpsont.com"));
+        StdOut.println();
+
+        StdOut.println("set = " + set);
+        StdOut.println();
+
+        // print out all keys in this set in lexicographic order
+        for (String s : set) {
+            StdOut.println(s);
+        }
+
+        StdOut.println();
+        SET<String> set2 = new SET<String>(set);
+        StdOut.println(set.equals(set2));
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/ST.java b/src/main/java/edu/princeton/cs/algs4/ST.java
new file mode 100644
index 0000000..2844cdc
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ST.java
@@ -0,0 +1,273 @@
+/******************************************************************************
+ *  Compilation:  javac ST.java
+ *  Execution:    java ST < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/35applications/tinyST.txt
+ *  
+ *  Sorted symbol table implementation using a java.util.TreeMap.
+ *  Does not allow duplicates.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.TreeMap;
+
+/**
+ *  The {@code ST} class represents an ordered symbol table of generic
+ *  key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides ordered methods for finding the <em>minimum</em>,
+ *  <em>maximum</em>, <em>floor</em>, and <em>ceiling</em>.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  It requires that
+ *  the key type implements the {@code Comparable} interface and calls the
+ *  {@code compareTo()} and method to compare two keys. It does not call either
+ *  {@code equals()} or {@code hashCode()}.
+ *  <p>
+ *  This implementation uses a <em>red-black BST</em>.
+ *  The <em>put</em>, <em>get</em>, <em>contains</em>, <em>remove</em>,
+ *  <em>minimum</em>, <em>maximum</em>, <em>ceiling</em>, and <em>floor</em>
+ *  operations each take &Theta;(log <em>n</em>) time in the worst case,
+ *  where <em>n</em> is the number of key-value pairs in the symbol table.
+ *  The <em>size</em> and <em>is-empty</em> operations take &Theta;(1) time.
+ *  Construction takes &Theta;(1) time.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Key> the generic type of keys in this symbol table
+ *  @param <Value> the generic type of values in this symbol table
+ */
+public class ST<Key extends Comparable<Key>, Value> implements Iterable<Key> {
+
+    private TreeMap<Key, Value> st;
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public ST() {
+        st = new TreeMap<Key, Value>();
+    }
+
+
+    /**
+     * Returns the value associated with the given key in this symbol table.
+     *
+     * @param  key the key
+     * @return the value associated with the given key if the key is in this symbol table;
+     *         {@code null} if the key is not in this symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("calls get() with null key");
+        return st.get(key);
+    }
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("calls put() with null key");
+        if (val == null) st.remove(key);
+        else             st.put(key, val);
+    }
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).
+     * This is equivalent to {@code remove()}, but we plan to deprecate {@code delete()}.
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("calls delete() with null key");
+        st.remove(key);
+    }
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).
+     * This is equivalent to {@code delete()}, but we plan to deprecate {@code delete()}.
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void remove(Key key) {
+        if (key == null) throw new IllegalArgumentException("calls remove() with null key");
+        st.remove(key);
+    }
+
+    /**
+     * Returns true if this symbol table contain the given key.
+     *
+     * @param  key the key
+     * @return {@code true} if this symbol table contains {@code key} and
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("calls contains() with null key");
+        return st.containsKey(key);
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     *
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return st.size();
+    }
+
+    /**
+     * Returns true if this symbol table is empty.
+     *
+     * @return {@code true} if this symbol table is empty and {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns all keys in this symbol table.
+     * <p>
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     *
+     * @return all keys in this symbol table
+     */
+    public Iterable<Key> keys() {
+        return st.keySet();
+    }
+
+    /**
+     * Returns all of the keys in this symbol table.
+     * To iterate over all of the keys in a symbol table named {@code st}, use the
+     * foreach notation: {@code for (Key key : st)}.
+     * <p>
+     * This method is provided for backward compatibility with the version from
+     * <em>Introduction to Programming in Java: An Interdisciplinary Approach.</em>
+     *
+     * @return     an iterator to all of the keys in this symbol table
+     * @deprecated Replaced by {@link #keys()}.
+     */
+    @Deprecated
+    public Iterator<Key> iterator() {
+        return st.keySet().iterator();
+    }
+
+    /**
+     * Returns the smallest key in this symbol table.
+     *
+     * @return the smallest key in this symbol table
+     * @throws NoSuchElementException if this symbol table is empty
+     */
+    public Key min() {
+        if (isEmpty()) throw new NoSuchElementException("calls min() with empty symbol table");
+        return st.firstKey();
+    }
+
+    /**
+     * Returns the largest key in this symbol table.
+     *
+     * @return the largest key in this symbol table
+     * @throws NoSuchElementException if this symbol table is empty
+     */
+    public Key max() {
+        if (isEmpty()) throw new NoSuchElementException("calls max() with empty symbol table");
+        return st.lastKey();
+    }
+
+    /**
+     * Returns the smallest key in this symbol table greater than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the smallest key in this symbol table greater than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key ceiling(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null");
+        Key k = st.ceilingKey(key);
+        if (k == null) throw new NoSuchElementException("argument to ceiling() is too large");
+        return k;
+    }
+
+    /**
+     * Returns the largest key in this symbol table less than or equal to {@code key}.
+     *
+     * @param  key the key
+     * @return the largest key in this symbol table less than or equal to {@code key}
+     * @throws NoSuchElementException if there is no such key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Key floor(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to floor() is null");
+        Key k = st.floorKey(key);
+        if (k == null) throw new NoSuchElementException("argument to floor() is too small");
+        return k;
+    }
+
+    /**
+     * Unit tests the {@code ST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        ST<String, Integer> st = new ST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+        for (String s : st.keys())
+            StdOut.println(s + " " + st.get(s));
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SegmentTree.java b/src/main/java/edu/princeton/cs/algs4/SegmentTree.java
new file mode 100644
index 0000000..7ec7907
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SegmentTree.java
@@ -0,0 +1,358 @@
+/******************************************************************************
+ *  Compilation:  javac SegmentTree.java
+ *  Execution:    java SegmentTree
+ *  
+ *  A segment tree data structure.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ * The {@code SegmentTree} class is an structure for efficient search of cummulative data.
+ * It performs  Range Minimum Query and Range Sum Query in O(log(n)) time.
+ * It can be easily customizable to support Range Max Query, Range Multiplication Query etc.
+ * <p>
+ * Also it has been develop with  {@code LazyPropagation} for range updates, which means
+ * when you perform update operations over a range, the update process affects the least nodes as possible
+ * so that the bigger the range you want to update the less time it consumes to update it. Eventually those changes will be propagated
+ * to the children and the whole array will be up to date.
+ * <p>
+ * Example:
+ * <p>
+ * SegmentTreeHeap st = new SegmentTreeHeap(new Integer[]{1,3,4,2,1, -2, 4});
+ * st.update(0,3, 1)
+ * In the above case only the node that represents the range [0,3] will be updated (and not their children) so in this case
+ * the update task will be less than n*log(n)
+ *
+ * Memory usage:  O(n)
+ *
+ * @author Ricardo Pacheco 
+ */
+public class SegmentTree {
+
+    private Node[] heap;
+    private int[] array;
+    private int size;
+
+    /**
+     * Time-Complexity:  O(n*log(n))
+     *
+     * @param array the Initialization array
+     */
+    public SegmentTree(int[] array) {
+        this.array = Arrays.copyOf(array, array.length);
+        //The max size of this array is about 2 * 2 ^ log2(n) + 1
+        size = (int) (2 * Math.pow(2.0, Math.floor((Math.log((double) array.length) / Math.log(2.0)) + 1)));
+        heap = new Node[size];
+        build(1, 0, array.length);
+    }
+
+
+    public int size() {
+        return array.length;
+    }
+
+    //Initialize the Nodes of the Segment tree
+    private void build(int v, int from, int size) {
+        heap[v] = new Node();
+        heap[v].from = from;
+        heap[v].to = from + size - 1;
+
+        if (size == 1) {
+            heap[v].sum = array[from];
+            heap[v].min = array[from];
+        } else {
+            //Build childs
+            build(2 * v, from, size / 2);
+            build(2 * v + 1, from + size / 2, size - size / 2);
+
+            heap[v].sum = heap[2 * v].sum + heap[2 * v + 1].sum;
+            //min = min of the children
+            heap[v].min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);
+        }
+    }
+
+    /**
+     * Range Sum Query
+     *
+     * Time-Complexity: O(log(n))
+     *
+     * @param  from from index
+     * @param  to to index
+     * @return sum
+     */
+    public int rsq(int from, int to) {
+        return rsq(1, from, to);
+    }
+
+    private int rsq(int v, int from, int to) {
+        Node n = heap[v];
+
+        //If you did a range update that contained this node, you can infer the Sum without going down the tree
+        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {
+            return (to - from + 1) * n.pendingVal;
+        }
+
+        if (contains(from, to, n.from, n.to)) {
+            return heap[v].sum;
+        }
+
+        if (intersects(from, to, n.from, n.to)) {
+            propagate(v);
+            int leftSum = rsq(2 * v, from, to);
+            int rightSum = rsq(2 * v + 1, from, to);
+
+            return leftSum + rightSum;
+        }
+
+        return 0;
+    }
+
+    /**
+     * Range Min Query
+     * 
+     * Time-Complexity: O(log(n))
+     *
+     * @param  from from index
+     * @param  to to index
+     * @return min
+     */
+    public int rMinQ(int from, int to) {
+        return rMinQ(1, from, to);
+    }
+
+    private int rMinQ(int v, int from, int to) {
+        Node n = heap[v];
+
+
+        //If you did a range update that contained this node, you can infer the Min value without going down the tree
+        if (n.pendingVal != null && contains(n.from, n.to, from, to)) {
+            return n.pendingVal;
+        }
+
+        if (contains(from, to, n.from, n.to)) {
+            return heap[v].min;
+        }
+
+        if (intersects(from, to, n.from, n.to)) {
+            propagate(v);
+            int leftMin = rMinQ(2 * v, from, to);
+            int rightMin = rMinQ(2 * v + 1, from, to);
+
+            return Math.min(leftMin, rightMin);
+        }
+
+        return Integer.MAX_VALUE;
+    }
+
+
+    /**
+     * Range Update Operation.
+     * With this operation you can update either one position or a range of positions with a given number.
+     * The update operations will update the less it can to update the whole range (Lazy Propagation).
+     * The values will be propagated lazily from top to bottom of the segment tree.
+     * This behavior is really useful for updates on portions of the array
+     * <p>
+     * Time-Complexity: O(log(n))
+     *
+     * @param from  from index
+     * @param to    to index
+     * @param value value
+     */
+    public void update(int from, int to, int value) {
+        update(1, from, to, value);
+    }
+
+    private void update(int v, int from, int to, int value) {
+
+        //The Node of the heap tree represents a range of the array with bounds: [n.from, n.to]
+        Node n = heap[v];
+
+        /**
+         * If the updating-range contains the portion of the current Node  We lazily update it.
+         * This means We do NOT update each position of the vector, but update only some temporal
+         * values into the Node; such values into the Node will be propagated down to its children only when they need to.
+         */
+        if (contains(from, to, n.from, n.to)) {
+            change(n, value);
+        }
+
+        if (n.size() == 1) return;
+
+        if (intersects(from, to, n.from, n.to)) {
+            /**
+             * Before keeping going down to the tree We need to propagate the
+             * the values that have been temporally/lazily saved into this Node to its children
+             * So that when We visit them the values  are properly updated
+             */
+            propagate(v);
+
+            update(2 * v, from, to, value);
+            update(2 * v + 1, from, to, value);
+
+            n.sum = heap[2 * v].sum + heap[2 * v + 1].sum;
+            n.min = Math.min(heap[2 * v].min, heap[2 * v + 1].min);
+        }
+    }
+
+    //Propagate temporal values to children
+    private void propagate(int v) {
+        Node n = heap[v];
+
+        if (n.pendingVal != null) {
+            change(heap[2 * v], n.pendingVal);
+            change(heap[2 * v + 1], n.pendingVal);
+            n.pendingVal = null; //unset the pending propagation value
+        }
+    }
+
+    //Save the temporal values that will be propagated lazily
+    private void change(Node n, int value) {
+        n.pendingVal = value;
+        n.sum = n.size() * value;
+        n.min = value;
+        array[n.from] = value;
+
+    }
+
+    //Test if the range1 contains range2
+    private boolean contains(int from1, int to1, int from2, int to2) {
+        return from2 >= from1 && to2 <= to1;
+    }
+
+    //check inclusive intersection, test if range1[from1, to1] intersects range2[from2, to2]
+    private boolean intersects(int from1, int to1, int from2, int to2) {
+        return from1 <= from2 && to1 >= from2   //  (.[..)..] or (.[...]..)
+                || from1 >= from2 && from1 <= to2; // [.(..]..) or [..(..)..
+    }
+
+    //The Node class represents a partition range of the array.
+    static class Node {
+        int sum;
+        int min;
+        //Here We store the value that will be propagated lazily
+        Integer pendingVal = null;
+        int from;
+        int to;
+
+        int size() {
+            return to - from + 1;
+        }
+
+    }
+
+    /**
+     * Read the following commands:
+     * init n v     Initializes the array of size n with all v's
+     * set a b c... Initializes the array  with [a, b, c ...]
+     * rsq a b      Range Sum Query for the range [a, b]
+     * rmq a b      Range Min Query for the range [a, b]
+     * up  a b v    Update the [a,b] portion of the array with value v.
+     * exit
+     * <p>
+     * Example:
+     * init
+     * set 1 2 3 4 5 6
+     * rsq 1 3
+     * Sum from 1 to 3 = 6
+     * rmq 1 3
+     * Min from 1 to 3 = 1
+     * input up 1 3
+     * [3,2,3,4,5,6]
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+
+        SegmentTree st = null;
+
+        String cmd = "cmp";
+        while (true) {
+            String[] line = StdIn.readLine().split(" ");
+
+            if (line[0].equals("exit")) break;
+
+            int arg1 = 0, arg2 = 0, arg3 = 0;
+
+            if (line.length > 1) {
+                arg1 = Integer.parseInt(line[1]);
+            }
+            if (line.length > 2) {
+                arg2 = Integer.parseInt(line[2]);
+            }
+            if (line.length > 3) {
+                arg3 = Integer.parseInt(line[3]);
+            }
+
+            if ((!line[0].equals("set") && !line[0].equals("init")) && st == null) {
+                StdOut.println("Segment Tree not initialized");
+                continue;
+            }
+            int array[];
+            if (line[0].equals("set")) {
+                array = new int[line.length - 1];
+                for (int i = 0; i < line.length - 1; i++) {
+                    array[i] = Integer.parseInt(line[i + 1]);
+                }
+                st = new SegmentTree(array);
+            }
+            else if (line[0].equals("init")) {
+                array = new int[arg1];
+                Arrays.fill(array, arg2);
+                st = new SegmentTree(array);
+
+                for (int i = 0; i < st.size(); i++) {
+                    StdOut.print(st.rsq(i, i) + " ");
+                }
+                StdOut.println();
+            }
+
+            else if (line[0].equals("up")) {
+                st.update(arg1, arg2, arg3);
+                for (int i = 0; i < st.size(); i++) {
+                    StdOut.print(st.rsq(i, i) + " ");
+                }
+                StdOut.println();
+            }
+            else if (line[0].equals("rsq")) {
+                StdOut.printf("Sum from %d to %d = %d%n", arg1, arg2, st.rsq(arg1, arg2));
+            }
+            else if (line[0].equals("rmq")) {
+                StdOut.printf("Min from %d to %d = %d%n", arg1, arg2, st.rMinQ(arg1, arg2));
+            }
+            else {
+                StdOut.println("Invalid command");
+            }
+
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Selection.java b/src/main/java/edu/princeton/cs/algs4/Selection.java
new file mode 100644
index 0000000..f1024d9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Selection.java
@@ -0,0 +1,181 @@
+/******************************************************************************
+ *  Compilation:  javac Selection.java
+ *  Execution:    java  Selection < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/21elementary/tiny.txt
+ *                https://algs4.cs.princeton.edu/21elementary/words3.txt
+ *   
+ *  Sorts a sequence of strings from standard input using selection sort.
+ *   
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Selection < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *    
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *  
+ *  % java Selection < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Comparator;
+
+/**
+ *  The {@code Selection} class provides static methods for sorting an
+ *  array using <em>selection sort</em>.
+ *  This implementation makes ~ &frac12; <em>n</em><sup>2</sup> compares to sort
+ *  any array of length <em>n</em>, so it is not suitable for sorting large arrays.
+ *  It performs exactly <em>n</em> exchanges.
+ *  <p>
+ *  This sorting algorithm is not stable. It uses &Theta;(1) extra memory
+ *  (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/21elementary">Section 2.1</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Selection {
+
+    // This class should not be instantiated.
+    private Selection() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            int min = i;
+            for (int j = i+1; j < n; j++) {
+                if (less(a[j], a[min])) min = j;
+            }
+            exch(a, i, min);
+            assert isSorted(a, 0, i);
+        }
+        assert isSorted(a);
+    }
+
+    /**
+     * Rearranges the array in ascending order, using a comparator.
+     * @param a the array
+     * @param comparator the comparator specifying the order
+     */
+    public static void sort(Object[] a, Comparator comparator) {
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            int min = i;
+            for (int j = i+1; j < n; j++) {
+                if (less(comparator, a[j], a[min])) min = j;
+            }
+            exch(a, i, min);
+            assert isSorted(a, comparator, 0, i);
+        }
+        assert isSorted(a, comparator);
+    }
+
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+
+    // is v < w ?
+    private static boolean less(Comparator comparator, Object v, Object w) {
+        return comparator.compare(v, w) < 0;
+    }
+        
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+
+    // is the array a[] sorted?
+    private static boolean isSorted(Comparable[] a) {
+        return isSorted(a, 0, a.length - 1);
+    }
+        
+    // is the array sorted from a[lo] to a[hi]
+    private static boolean isSorted(Comparable[] a, int lo, int hi) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // is the array a[] sorted?
+    private static boolean isSorted(Object[] a, Comparator comparator) {
+        return isSorted(a, comparator, 0, a.length - 1);
+    }
+
+    // is the array sorted from a[lo] to a[hi]
+    private static boolean isSorted(Object[] a, Comparator comparator, int lo, int hi) {
+        for (int i = lo + 1; i <= hi; i++)
+            if (less(comparator, a[i], a[i-1])) return false;
+        return true;
+    }
+
+
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; selection sorts them; 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Selection.sort(a);
+        show(a);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SeparateChainingHashST.java b/src/main/java/edu/princeton/cs/algs4/SeparateChainingHashST.java
new file mode 100644
index 0000000..b2cd778
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SeparateChainingHashST.java
@@ -0,0 +1,238 @@
+/******************************************************************************
+ *  Compilation:  javac SeparateChainingHashST.java
+ *  Execution:    java SeparateChainingHashST < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/34hash/tinyST.txt
+ *
+ *  A symbol table implemented with a separate-chaining hash table.
+ * 
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code SeparateChainingHashST} class represents a symbol table of generic
+ *  key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  This implementation uses a separate chaining hash table. It requires that
+ *  the key type overrides the {@code equals()} and {@code hashCode()} methods.
+ *  The expected time per <em>put</em>, <em>contains</em>, or <em>remove</em>
+ *  operation is constant, subject to the uniform hashing assumption.
+ *  The <em>size</em>, and <em>is-empty</em> operations take constant time.
+ *  Construction takes constant time.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/34hash">Section 3.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  For other implementations, see {@link ST}, {@link BinarySearchST},
+ *  {@link SequentialSearchST}, {@link BST}, {@link RedBlackBST}, and
+ *  {@link LinearProbingHashST},
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class SeparateChainingHashST<Key, Value> {
+    private static final int INIT_CAPACITY = 4;
+
+    private int n;                                // number of key-value pairs
+    private int m;                                // hash table size
+    private SequentialSearchST<Key, Value>[] st;  // array of linked-list symbol tables
+
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public SeparateChainingHashST() {
+        this(INIT_CAPACITY);
+    } 
+
+    /**
+     * Initializes an empty symbol table with {@code m} chains.
+     * @param m the initial number of chains
+     */
+    public SeparateChainingHashST(int m) {
+        this.m = m;
+        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[m];
+        for (int i = 0; i < m; i++)
+            st[i] = new SequentialSearchST<Key, Value>();
+    } 
+
+    // resize the hash table to have the given number of chains,
+    // rehashing all of the keys
+    private void resize(int chains) {
+        SeparateChainingHashST<Key, Value> temp = new SeparateChainingHashST<Key, Value>(chains);
+        for (int i = 0; i < m; i++) {
+            for (Key key : st[i].keys()) {
+                temp.put(key, st[i].get(key));
+            }
+        }
+        this.m  = temp.m;
+        this.n  = temp.n;
+        this.st = temp.st;
+    }
+
+    // hash function for keys - returns value between 0 and m-1
+    private int hashTextbook(Key key) {
+        return (key.hashCode() & 0x7fffffff) % m;
+    }
+
+    // hash function for keys - returns value between 0 and m-1 (assumes m is a power of 2)
+    // (from Java 7 implementation, protects against poor quality hashCode() implementations)
+    private int hash(Key key) {
+        int h = key.hashCode();
+        h ^= (h >>> 20) ^ (h >>> 12) ^ (h >>> 7) ^ (h >>> 4);
+        return h & (m-1);
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     *
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    } 
+
+    /**
+     * Returns true if this symbol table is empty.
+     *
+     * @return {@code true} if this symbol table is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns true if this symbol table contains the specified key.
+     *
+     * @param  key the key
+     * @return {@code true} if this symbol table contains {@code key};
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        return get(key) != null;
+    } 
+
+    /**
+     * Returns the value associated with the specified key in this symbol table.
+     *
+     * @param  key the key
+     * @return the value associated with {@code key} in the symbol table;
+     *         {@code null} if no such value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null");
+        int i = hash(key);
+        return st[i].get(key);
+    } 
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
+        if (val == null) {
+            delete(key);
+            return;
+        }
+
+        // double table size if average length of list >= 10
+        if (n >= 10*m) resize(2*m);
+
+        int i = hash(key);
+        if (!st[i].contains(key)) n++;
+        st[i].put(key, val);
+    } 
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).    
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
+
+        int i = hash(key);
+        if (st[i].contains(key)) n--;
+        st[i].delete(key);
+
+        // halve table size if average length of list <= 2
+        if (m > INIT_CAPACITY && n <= 2*m) resize(m/2);
+    } 
+
+    // return keys in symbol table as an Iterable
+    public Iterable<Key> keys() {
+        Queue<Key> queue = new Queue<Key>();
+        for (int i = 0; i < m; i++) {
+            for (Key key : st[i].keys())
+                queue.enqueue(key);
+        }
+        return queue;
+    } 
+
+
+    /**
+     * Unit tests the {@code SeparateChainingHashST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) { 
+        SeparateChainingHashST<String, Integer> st = new SeparateChainingHashST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+
+        // print keys
+        for (String s : st.keys()) 
+            StdOut.println(s + " " + st.get(s)); 
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SequentialSearchST.java b/src/main/java/edu/princeton/cs/algs4/SequentialSearchST.java
new file mode 100644
index 0000000..d214008
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SequentialSearchST.java
@@ -0,0 +1,238 @@
+/******************************************************************************
+ *  Compilation:  javac SequentialSearchST.java
+ *  Execution:    java SequentialSearchST
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/31elementary/tinyST.txt  
+ *  
+ *  Symbol table implementation with sequential search in an
+ *  unordered linked list of key-value pairs.
+ *
+ *  % more tinyST.txt
+ *  S E A R C H E X A M P L E
+ *
+ *  % java SequentialSearchST < tinyST.txt 
+ *  L 11
+ *  P 10
+ *  M 9
+ *  X 7
+ *  H 5
+ *  C 4
+ *  R 3
+ *  A 8
+ *  E 12
+ *  S 0
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code SequentialSearchST} class represents an (unordered)
+ *  symbol table of generic key-value pairs.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides a <em>keys</em> method for iterating over all of the keys.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  The class also uses the convention that values cannot be {@code null}. Setting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  It relies on the {@code equals()} method to test whether two keys
+ *  are equal. It does not call either the {@code compareTo()} or
+ *  {@code hashCode()} method. 
+ *  <p>
+ *  This implementation uses a <em>singly linked list</em> and
+ *  <em>sequential search</em>.
+ *  The <em>put</em> and <em>delete</em> operations take &Theta;(<em>n</em>).
+ *  The <em>get</em> and <em>contains</em> operations takes &Theta;(<em>n</em>)
+ *  time in the worst case.
+ *  The <em>size</em>, and <em>is-empty</em> operations take &Theta;(1) time.
+ *  Construction takes &Theta;(1) time.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/31elementary">Section 3.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class SequentialSearchST<Key, Value> {
+    private int n;           // number of key-value pairs
+    private Node first;      // the linked list of key-value pairs
+
+    // a helper linked list data type
+    private class Node {
+        private Key key;
+        private Value val;
+        private Node next;
+
+        public Node(Key key, Value val, Node next)  {
+            this.key  = key;
+            this.val  = val;
+            this.next = next;
+        }
+    }
+
+    /**
+     * Initializes an empty symbol table.
+     */
+    public SequentialSearchST() {
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     *
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Returns true if this symbol table is empty.
+     *
+     * @return {@code true} if this symbol table is empty;
+     *         {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns true if this symbol table contains the specified key.
+     *
+     * @param  key the key
+     * @return {@code true} if this symbol table contains {@code key};
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        return get(key) != null;
+    }
+
+    /**
+     * Returns the value associated with the given key in this symbol table.
+     *
+     * @param  key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *     and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null"); 
+        for (Node x = first; x != null; x = x.next) {
+            if (key.equals(x.key))
+                return x.val;
+        }
+        return null;
+    }
+
+    /**
+     * Inserts the specified key-value pair into the symbol table, overwriting the old 
+     * value with the new value if the symbol table already contains the specified key.
+     * Deletes the specified key (and its associated value) from this symbol table
+     * if the specified value is {@code null}.
+     *
+     * @param  key the key
+     * @param  val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(Key key, Value val) {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null"); 
+        if (val == null) {
+            delete(key);
+            return;
+        }
+
+        for (Node x = first; x != null; x = x.next) {
+            if (key.equals(x.key)) {
+                x.val = val;
+                return;
+            }
+        }
+        first = new Node(key, val, first);
+        n++;
+    }
+
+    /**
+     * Removes the specified key and its associated value from this symbol table     
+     * (if the key is in this symbol table).    
+     *
+     * @param  key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(Key key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null"); 
+        first = delete(first, key);
+    }
+
+    // delete key in linked list beginning at Node x
+    // warning: function call stack too large if table is large
+    private Node delete(Node x, Key key) {
+        if (x == null) return null;
+        if (key.equals(x.key)) {
+            n--;
+            return x.next;
+        }
+        x.next = delete(x.next, key);
+        return x;
+    }
+
+
+    /**
+     * Returns all keys in the symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     *
+     * @return all keys in the symbol table
+     */
+    public Iterable<Key> keys()  {
+        Queue<Key> queue = new Queue<Key>();
+        for (Node x = first; x != null; x = x.next)
+            queue.enqueue(x.key);
+        return queue;
+    }
+
+
+    /**
+     * Unit tests the {@code SequentialSearchST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        SequentialSearchST<String, Integer> st = new SequentialSearchST<String, Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+        for (String s : st.keys())
+            StdOut.println(s + " " + st.get(s));
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Shell.java b/src/main/java/edu/princeton/cs/algs4/Shell.java
new file mode 100644
index 0000000..6383c17
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Shell.java
@@ -0,0 +1,152 @@
+/******************************************************************************
+ *  Compilation:  javac Shell.java
+ *  Execution:    java Shell < input.txt
+ *  Dependencies: StdOut.java StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/21elementary/tiny.txt
+ *                https://algs4.cs.princeton.edu/21elementary/words3.txt
+ *   
+ *  Sorts a sequence of strings from standard input using shellsort.
+ *
+ *  % more tiny.txt
+ *  S O R T E X A M P L E
+ *
+ *  % java Shell < tiny.txt
+ *  A E E L M O P R S T X                 [ one string per line ]
+ *    
+ *  % more words3.txt
+ *  bed bug dad yes zoo ... all bad yet
+ *  
+ *  % java Shell < words3.txt
+ *  all bad bed bug dad ... yes yet zoo    [ one string per line ]
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Shell} class provides static methods for sorting an
+ *  array using <em>Shellsort</em> with
+ *  <a href = "https://oeis.org/A003462"> Knuth's increment sequence</a>
+ *  (1, 4, 13, 40, ...). In the worst case, this implementation makes
+ *  &Theta;(<em>n</em><sup>3/2</sup>) compares and exchanges to sort
+ *  an array of length <em>n</em>.
+ *  <p>
+ *  This sorting algorithm is not stable.
+ *  It uses &Theta;(1) extra memory (not including the input array).
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/21elementary">Section 2.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *  
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Shell {
+
+    // This class should not be instantiated.
+    private Shell() { }
+
+    /**
+     * Rearranges the array in ascending order, using the natural order.
+     * @param a the array to be sorted
+     */
+    public static void sort(Comparable[] a) {
+        int n = a.length;
+
+        // 3x+1 increment sequence:  1, 4, 13, 40, 121, 364, 1093, ... 
+        int h = 1;
+        while (h < n/3) h = 3*h + 1; 
+
+        while (h >= 1) {
+            // h-sort the array
+            for (int i = h; i < n; i++) {
+                for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) {
+                    exch(a, j, j-h);
+                }
+            }
+            assert isHsorted(a, h); 
+            h /= 3;
+        }
+        assert isSorted(a);
+    }
+
+
+
+   /***************************************************************************
+    *  Helper sorting functions.
+    ***************************************************************************/
+    
+    // is v < w ?
+    private static boolean less(Comparable v, Comparable w) {
+        return v.compareTo(w) < 0;
+    }
+        
+    // exchange a[i] and a[j]
+    private static void exch(Object[] a, int i, int j) {
+        Object swap = a[i];
+        a[i] = a[j];
+        a[j] = swap;
+    }
+
+
+   /***************************************************************************
+    *  Check if array is sorted - useful for debugging.
+    ***************************************************************************/
+    private static boolean isSorted(Comparable[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (less(a[i], a[i-1])) return false;
+        return true;
+    }
+
+    // is the array h-sorted?
+    private static boolean isHsorted(Comparable[] a, int h) {
+        for (int i = h; i < a.length; i++)
+            if (less(a[i], a[i-h])) return false;
+        return true;
+    }
+
+    // print array to standard output
+    private static void show(Comparable[] a) {
+        for (int i = 0; i < a.length; i++) {
+            StdOut.println(a[i]);
+        }
+    }
+
+    /**
+     * Reads in a sequence of strings from standard input; Shellsorts them; 
+     * and prints them to standard output in ascending order. 
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String[] a = StdIn.readAllStrings();
+        Shell.sort(a);
+        show(a);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SparseVector.java b/src/main/java/edu/princeton/cs/algs4/SparseVector.java
new file mode 100644
index 0000000..a65300c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SparseVector.java
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *  Compilation:  javac SparseVector.java
+ *  Execution:    java SparseVector
+ *  Dependencies: StdOut.java
+ *  
+ *  A sparse vector, implementing using a symbol table.
+ *
+ *  [Not clear we need the instance variable N except for error checking.]
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code SparseVector} class represents a <em>d</em>-dimensional mathematical vector.
+ *  Vectors are mutable: their values can be changed after they are created.
+ *  It includes methods for addition, subtraction,
+ *  dot product, scalar product, unit vector, and Euclidean norm.
+ *  <p>
+ *  The implementation is a symbol table of indices and values for which the vector
+ *  coordinates are nonzero. This makes it efficient when most of the vector coordindates
+  * are zero.
+ *  <p>
+ *  For additional documentation,    
+ *  see <a href="https://algs4.cs.princeton.edu/35applications">Section 3.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *  See also {@link Vector} for an immutable (dense) vector data type.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class SparseVector {
+    private int d;                   // dimension
+    private ST<Integer, Double> st;  // the vector, represented by index-value pairs
+
+   /**
+     * Initializes a d-dimensional zero vector.
+     * @param d the dimension of the vector
+     */
+    public SparseVector(int d) {
+        this.d  = d;
+        this.st = new ST<Integer, Double>();
+    }
+
+   /**
+     * Sets the ith coordinate of this vector to the specified value.
+     *
+     * @param  i the index
+     * @param  value the new value
+     * @throws IllegalArgumentException unless i is between 0 and d-1
+     */
+    public void put(int i, double value) {
+        if (i < 0 || i >= d) throw new IllegalArgumentException("Illegal index");
+        if (value == 0.0) st.delete(i);
+        else              st.put(i, value);
+    }
+
+   /**
+     * Returns the ith coordinate of this vector.
+     *
+     * @param  i the index
+     * @return the value of the ith coordinate of this vector
+     * @throws IllegalArgumentException unless i is between 0 and d-1
+     */
+    public double get(int i) {
+        if (i < 0 || i >= d) throw new IllegalArgumentException("Illegal index");
+        if (st.contains(i)) return st.get(i);
+        else                return 0.0;
+    }
+
+   /**
+     * Returns the number of nonzero entries in this vector.
+     *
+     * @return the number of nonzero entries in this vector
+     */
+    public int nnz() {
+        return st.size();
+    }
+
+   /**
+     * Returns the dimension of this vector.
+     *
+     * @return the dimension of this vector
+     * @deprecated Replaced by {@link #dimension()}.
+     */
+    @Deprecated
+    public int size() {
+        return d;
+    }
+
+   /**
+     * Returns the dimension of this vector.
+     *
+     * @return the dimension of this vector
+     */
+    public int dimension() {
+        return d;
+    }
+
+    /**
+     * Returns the inner product of this vector with the specified vector.
+     *
+     * @param  that the other vector
+     * @return the dot product between this vector and that vector
+     * @throws IllegalArgumentException if the lengths of the two vectors are not equal
+     */
+    public double dot(SparseVector that) {
+        if (this.d != that.d) throw new IllegalArgumentException("Vector lengths disagree");
+        double sum = 0.0;
+
+        // iterate over the vector with the fewest nonzeros
+        if (this.st.size() <= that.st.size()) {
+            for (int i : this.st.keys())
+                if (that.st.contains(i)) sum += this.get(i) * that.get(i);
+        }
+        else  {
+            for (int i : that.st.keys())
+                if (this.st.contains(i)) sum += this.get(i) * that.get(i);
+        }
+        return sum;
+    }
+
+
+    /**
+     * Returns the inner product of this vector with the specified array.
+     *
+     * @param  that the array
+     * @return the dot product between this vector and that array
+     * @throws IllegalArgumentException if the dimensions of the vector and the array are not equal
+     */
+    public double dot(double[] that) {
+        double sum = 0.0;
+        for (int i : st.keys())
+            sum += that[i] * this.get(i);
+        return sum;
+    }
+
+    /**
+     * Returns the magnitude of this vector.
+     * This is also known as the L2 norm or the Euclidean norm.
+     * 
+     * @return the magnitude of this vector
+     */
+    public double magnitude() {
+        return Math.sqrt(this.dot(this));
+    }
+
+
+    /**
+     * Returns the Euclidean norm of this vector.
+     *
+     * @return the Euclidean norm of this vector
+     * @deprecated Replaced by {@link #magnitude()}.
+     */
+    @Deprecated
+    public double norm() {
+        return Math.sqrt(this.dot(this));
+    }
+
+    /**
+     * Returns the scalar-vector product of this vector with the specified scalar.
+     *
+     * @param  alpha the scalar
+     * @return the scalar-vector product of this vector with the specified scalar
+     */
+    public SparseVector scale(double alpha) {
+        SparseVector c = new SparseVector(d);
+        for (int i : this.st.keys()) c.put(i, alpha * this.get(i));
+        return c;
+    }
+
+    /**
+     * Returns the sum of this vector and the specified vector.
+     *
+     * @param  that the vector to add to this vector
+     * @return the sum of this vector and that vector
+     * @throws IllegalArgumentException if the dimensions of the two vectors are not equal
+     */
+    public SparseVector plus(SparseVector that) {
+        if (this.d != that.d) throw new IllegalArgumentException("Vector lengths disagree");
+        SparseVector c = new SparseVector(d);
+        for (int i : this.st.keys()) c.put(i, this.get(i));                // c = this
+        for (int i : that.st.keys()) c.put(i, that.get(i) + c.get(i));     // c = c + that
+        return c;
+    }
+
+   /**
+     * Returns a string representation of this vector.
+     * @return a string representation of this vector, which consists of the 
+     *         the vector entries, separates by commas, enclosed in parentheses
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (int i : st.keys()) {
+            s.append("(" + i + ", " + st.get(i) + ") ");
+        }
+        return s.toString();
+    }
+
+
+    /**
+     * Unit tests the {@code SparseVector} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        SparseVector a = new SparseVector(10);
+        SparseVector b = new SparseVector(10);
+        a.put(3, 0.50);
+        a.put(9, 0.75);
+        a.put(6, 0.11);
+        a.put(6, 0.00);
+        b.put(3, 0.60);
+        b.put(4, 0.90);
+        StdOut.println("a = " + a);
+        StdOut.println("b = " + b);
+        StdOut.println("a dot b = " + a.dot(b));
+        StdOut.println("a + b   = " + a.plus(b));
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Stack.java b/src/main/java/edu/princeton/cs/algs4/Stack.java
new file mode 100644
index 0000000..fe49925
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Stack.java
@@ -0,0 +1,215 @@
+/******************************************************************************
+ *  Compilation:  javac Stack.java
+ *  Execution:    java Stack < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/13stacks/tobe.txt
+ *
+ *  A generic stack, implemented using a singly linked list.
+ *  Each stack element is of type Item.
+ *
+ *  This version uses a static nested class Node (to save 8 bytes per
+ *  Node), whereas the version in the textbook uses a non-static nested
+ *  class (for simplicity).
+ *  
+ *  % more tobe.txt 
+ *  to be or not to - be - - that - - - is
+ *
+ *  % java Stack < tobe.txt
+ *  to be not that or be (2 left on stack)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+
+/**
+ *  The {@code Stack} class represents a last-in-first-out (LIFO) stack of generic items.
+ *  It supports the usual <em>push</em> and <em>pop</em> operations, along with methods
+ *  for peeking at the top item, testing if the stack is empty, and iterating through
+ *  the items in LIFO order.
+ *  <p>
+ *  This implementation uses a singly linked list with a static nested class for
+ *  linked-list nodes. See {@link LinkedStack} for the version from the
+ *  textbook that uses a non-static nested class.
+ *  See {@link ResizingArrayStack} for a version that uses a resizing array.
+ *  The <em>push</em>, <em>pop</em>, <em>peek</em>, <em>size</em>, and <em>is-empty</em>
+ *  operations all take constant time in the worst case.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *
+ *  @param <Item> the generic type of an item in this stack
+ */
+public class Stack<Item> implements Iterable<Item> {
+    private Node<Item> first;     // top of stack
+    private int n;                // size of the stack
+
+    // helper linked list class
+    private static class Node<Item> {
+        private Item item;
+        private Node<Item> next;
+    }
+
+    /**
+     * Initializes an empty stack.
+     */
+    public Stack() {
+        first = null;
+        n = 0;
+    }
+
+    /**
+     * Returns true if this stack is empty.
+     *
+     * @return true if this stack is empty; false otherwise
+     */
+    public boolean isEmpty() {
+        return first == null;
+    }
+
+    /**
+     * Returns the number of items in this stack.
+     *
+     * @return the number of items in this stack
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Adds the item to this stack.
+     *
+     * @param  item the item to add
+     */
+    public void push(Item item) {
+        Node<Item> oldfirst = first;
+        first = new Node<Item>();
+        first.item = item;
+        first.next = oldfirst;
+        n++;
+    }
+
+    /**
+     * Removes and returns the item most recently added to this stack.
+     *
+     * @return the item most recently added
+     * @throws NoSuchElementException if this stack is empty
+     */
+    public Item pop() {
+        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
+        Item item = first.item;        // save item to return
+        first = first.next;            // delete first node
+        n--;
+        return item;                   // return the saved item
+    }
+
+
+    /**
+     * Returns (but does not remove) the item most recently added to this stack.
+     *
+     * @return the item most recently added to this stack
+     * @throws NoSuchElementException if this stack is empty
+     */
+    public Item peek() {
+        if (isEmpty()) throw new NoSuchElementException("Stack underflow");
+        return first.item;
+    }
+
+    /**
+     * Returns a string representation of this stack.
+     *
+     * @return the sequence of items in this stack in LIFO order, separated by spaces
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (Item item : this) {
+            s.append(item);
+            s.append(' ');
+        }
+        return s.toString();
+    }
+       
+
+    /**
+     * Returns an iterator to this stack that iterates through the items in LIFO order.
+     *
+     * @return an iterator to this stack that iterates through the items in LIFO order
+     */
+    public Iterator<Item> iterator() {
+        return new LinkedIterator(first);
+    }
+
+    // an iterator, doesn't implement remove() since it's optional
+    private class LinkedIterator implements Iterator<Item> {
+        private Node<Item> current;
+
+        public LinkedIterator(Node<Item> first) {
+            current = first;
+        }
+
+        public boolean hasNext() {
+            return current != null;
+        }
+
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+
+        public Item next() {
+            if (!hasNext()) throw new NoSuchElementException();
+            Item item = current.item;
+            current = current.next; 
+            return item;
+        }
+    }
+
+
+    /**
+     * Unit tests the {@code Stack} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Stack<String> stack = new Stack<String>();
+        while (!StdIn.isEmpty()) {
+            String item = StdIn.readString();
+            if (!item.equals("-"))
+                stack.push(item);
+            else if (!stack.isEmpty())
+                StdOut.print(stack.pop() + " ");
+        }
+        StdOut.println("(" + stack.size() + " left on stack)");
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StaticSETofInts.java b/src/main/java/edu/princeton/cs/algs4/StaticSETofInts.java
new file mode 100644
index 0000000..aeefe90
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StaticSETofInts.java
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *  Compilation:  javac StaticSetOfInts.java
+ *  Execution:    none
+ *  Dependencies: StdOut.java
+ *  
+ *  Data type to store a set of integers.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ *  The {@code StaticSETofInts} class represents a set of integers.
+ *  It supports searching for a given integer is in the set. It accomplishes
+ *  this by keeping the set of integers in a sorted array and using
+ *  binary search to find the given integer.
+ *  <p>
+ *  The <em>rank</em> and <em>contains</em> operations take
+ *  logarithmic time in the worst case.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class StaticSETofInts {
+    private int[] a;
+
+    /**
+     * Initializes a set of integers specified by the integer array.
+     * @param keys the array of integers
+     * @throws IllegalArgumentException if the array contains duplicate integers
+     */
+    public StaticSETofInts(int[] keys) {
+
+        // defensive copy
+        a = new int[keys.length];
+        for (int i = 0; i < keys.length; i++)
+            a[i] = keys[i];
+
+        // sort the integers
+        Arrays.sort(a);
+
+        // check for duplicates
+        for (int i = 1; i < a.length; i++)
+            if (a[i] == a[i-1])
+                throw new IllegalArgumentException("Argument arrays contains duplicate keys.");
+    }
+
+    /**
+     * Is the key in this set of integers?
+     * @param key the search key
+     * @return true if the set of integers contains the key; false otherwise
+     */
+    public boolean contains(int key) {
+        return rank(key) != -1;
+    }
+
+    /**
+     * Returns either the index of the search key in the sorted array
+     * (if the key is in the set) or -1 (if the key is not in the set).
+     * @param key the search key
+     * @return the number of keys in this set less than the key (if the key is in the set)
+     * or -1 (if the key is not in the set).
+     */
+    public int rank(int key) {
+        int lo = 0;
+        int hi = a.length - 1;
+        while (lo <= hi) {
+            // Key is in a[lo..hi] or not present.
+            int mid = lo + (hi - lo) / 2;
+            if      (key < a[mid]) hi = mid - 1;
+            else if (key > a[mid]) lo = mid + 1;
+            else return mid;
+        }
+        return -1;
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdArrayIO.java b/src/main/java/edu/princeton/cs/algs4/StdArrayIO.java
new file mode 100644
index 0000000..f10428d
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdArrayIO.java
@@ -0,0 +1,310 @@
+/******************************************************************************
+ *  Compilation:  javac StdArrayIO.java
+ *  Execution:    java StdArrayIO < input.txt
+ *  Dependencies: StdOut.java
+ *  Data files:    https://introcs.cs.princeton.edu/java/22library/tinyDouble1D.txt
+ *                 https://introcs.cs.princeton.edu/java/22library/tinyDouble2D.txt
+ *                 https://introcs.cs.princeton.edu/java/22library/tinyBoolean2D.txt
+ *
+ *  A library for reading in 1D and 2D arrays of integers, doubles,
+ *  and booleans from standard input and printing them out to
+ *  standard output.
+ *
+ *  % more tinyDouble1D.txt 
+ *  4
+ *    .000  .246  .222  -.032
+ *
+ *  % more tinyDouble2D.txt 
+ *  4 3 
+ *    .000  .270  .000 
+ *    .246  .224 -.036 
+ *    .222  .176  .0893 
+ *   -.032  .739  .270 
+ *
+ *  % more tinyBoolean2D.txt 
+ *  4 3 
+ *    1 1 0
+ *    0 0 0
+ *    0 1 1
+ *    1 1 1
+ *
+ *  % cat tinyDouble1D.txt tinyDouble2D.txt tinyBoolean2D.txt | java StdArrayIO
+ *  4
+ *    0.00000   0.24600   0.22200  -0.03200 
+ *  
+ *  4 3
+ *    0.00000   0.27000   0.00000 
+ *    0.24600   0.22400  -0.03600 
+ *    0.22200   0.17600   0.08930 
+ *    0.03200   0.73900   0.27000 
+ *
+ *  4 3
+ *  1 1 0 
+ *  0 0 0 
+ *  0 1 1 
+ *  1 1 1 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  <i>Standard array IO</i>. This class provides methods for reading
+ *  in 1D and 2D arrays from standard input and printing out to 
+ *  standard output.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/22libary">Section 2.2</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class StdArrayIO {
+
+    // it doesn't make sense to instantiate this class
+    private StdArrayIO() { }
+
+    /**
+     * Reads a 1D array of doubles from standard input and returns it.
+     *
+     * @return the 1D array of doubles
+     */
+    public static double[] readDouble1D() {
+        int n = StdIn.readInt();
+        double[] a = new double[n];
+        for (int i = 0; i < n; i++) {
+            a[i] = StdIn.readDouble();
+        }
+        return a;
+    }
+
+    /**
+     * Prints an array of doubles to standard output.
+     *
+     * @param a the 1D array of doubles
+     */
+    public static void print(double[] a) {
+        int n = a.length;
+        StdOut.println(n);
+        for (int i = 0; i < n; i++) {
+            StdOut.printf("%9.5f ", a[i]);
+        }
+        StdOut.println();
+    }
+
+        
+    /**
+     * Reads a 2D array of doubles from standard input and returns it.
+     *
+     * @return the 2D array of doubles
+     */
+    public static double[][] readDouble2D() {
+        int m = StdIn.readInt();
+        int n = StdIn.readInt();
+        double[][] a = new double[m][n];
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                a[i][j] = StdIn.readDouble();
+            }
+        }
+        return a;
+    }
+
+    /**
+     * Prints the 2D array of doubles to standard output.
+     *
+     * @param a the 2D array of doubles
+     */
+    public static void print(double[][] a) {
+        int m = a.length;
+        int n = a[0].length;
+        StdOut.println(m + " " + n);
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                StdOut.printf("%9.5f ", a[i][j]);
+            }
+            StdOut.println();
+        }
+    }
+
+
+    /**
+     * Reads a 1D array of integers from standard input and returns it.
+     *
+     * @return the 1D array of integers
+     */
+    public static int[] readInt1D() {
+        int n = StdIn.readInt();
+        int[] a = new int[n];
+        for (int i = 0; i < n; i++) {
+            a[i] = StdIn.readInt();
+        }
+        return a;
+    }
+
+    /**
+     * Prints an array of integers to standard output.
+     *
+     * @param a the 1D array of integers
+     */
+    public static void print(int[] a) {
+        int n = a.length;
+        StdOut.println(n);
+        for (int i = 0; i < n; i++) {
+            StdOut.printf("%9d ", a[i]);
+        }
+        StdOut.println();
+    }
+
+        
+    /**
+     * Reads a 2D array of integers from standard input and returns it.
+     *
+     * @return the 2D array of integers
+     */
+    public static int[][] readInt2D() {
+        int m = StdIn.readInt();
+        int n = StdIn.readInt();
+        int[][] a = new int[m][n];
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                a[i][j] = StdIn.readInt();
+            }
+        }
+        return a;
+    }
+
+    /**
+     * Print a 2D array of integers to standard output.
+     *
+     * @param a the 2D array of integers
+     */
+    public static void print(int[][] a) {
+        int m = a.length;
+        int n = a[0].length;
+        StdOut.println(m + " " + n);
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                StdOut.printf("%9d ", a[i][j]);
+            }
+            StdOut.println();
+        }
+    }
+
+
+    /**
+     * Reads a 1D array of booleans from standard input and returns it.
+     *
+     * @return the 1D array of booleans
+     */
+    public static boolean[] readBoolean1D() {
+        int n = StdIn.readInt();
+        boolean[] a = new boolean[n];
+        for (int i = 0; i < n; i++) {
+            a[i] = StdIn.readBoolean();
+        }
+        return a;
+    }
+
+    /**
+     * Prints a 1D array of booleans to standard output.
+     *
+     * @param a the 1D array of booleans
+     */
+    public static void print(boolean[] a) {
+        int n = a.length;
+        StdOut.println(n);
+        for (int i = 0; i < n; i++) {
+            if (a[i]) StdOut.print("1 ");
+            else      StdOut.print("0 ");
+        }
+        StdOut.println();
+    }
+
+    /**
+     * Reads a 2D array of booleans from standard input and returns it.
+     *
+     * @return the 2D array of booleans
+     */
+    public static boolean[][] readBoolean2D() {
+        int m = StdIn.readInt();
+        int n = StdIn.readInt();
+        boolean[][] a = new boolean[m][n];
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                a[i][j] = StdIn.readBoolean();
+            }
+        }
+        return a;
+    }
+
+   /**
+     * Prints a 2D array of booleans to standard output.
+     *
+     * @param a the 2D array of booleans
+     */
+    public static void print(boolean[][] a) {
+        int m = a.length;
+        int n = a[0].length;
+        StdOut.println(m + " " + n);
+        for (int i = 0; i < m; i++) {
+            for (int j = 0; j < n; j++) {
+                if (a[i][j]) StdOut.print("1 ");
+                else         StdOut.print("0 ");
+            }
+            StdOut.println();
+        }
+    }
+
+
+   /**
+     * Unit tests {@code StdArrayIO}.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // read and print an array of doubles
+        double[] a = StdArrayIO.readDouble1D();
+        StdArrayIO.print(a);
+        StdOut.println();
+
+        // read and print a matrix of doubles
+        double[][] b = StdArrayIO.readDouble2D();
+        StdArrayIO.print(b);
+        StdOut.println();
+
+        // read and print a matrix of doubles
+        boolean[][] d = StdArrayIO.readBoolean2D();
+        StdArrayIO.print(d);
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdAudio.java b/src/main/java/edu/princeton/cs/algs4/StdAudio.java
new file mode 100644
index 0000000..d687fd5
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdAudio.java
@@ -0,0 +1,480 @@
+/******************************************************************************
+ *  Compilation:  javac StdAudio.java
+ *  Execution:    java StdAudio
+ *  Dependencies: none
+ *  
+ *  Simple library for reading, writing, and manipulating .wav files.
+ *
+ *
+ *  Limitations
+ *  -----------
+ *    - Assumes the audio is monaural, little endian, with sampling rate
+ *      of 44,100
+ *    - check when reading .wav files from a .jar file ?
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import javax.sound.sampled.Clip;
+
+import java.io.File;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+
+import java.net.URL;
+
+import javax.sound.sampled.AudioFileFormat;
+import javax.sound.sampled.AudioFormat;
+import javax.sound.sampled.AudioInputStream;
+import javax.sound.sampled.AudioSystem;
+import javax.sound.sampled.DataLine;
+import javax.sound.sampled.LineUnavailableException;
+import javax.sound.sampled.SourceDataLine;
+import javax.sound.sampled.UnsupportedAudioFileException;
+
+import javax.sound.sampled.LineListener;
+import javax.sound.sampled.LineEvent;
+
+/**
+ *  <i>Standard audio</i>. This class provides a basic capability for
+ *  creating, reading, and saving audio. 
+ *  <p>
+ *  The audio format uses a sampling rate of 44,100 Hz, 16-bit, monaural.
+ *
+ *  <p>
+ *  For additional documentation, see <a href="https://introcs.cs.princeton.edu/15inout">Section 1.5</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class StdAudio {
+
+    /**
+     *  The sample rate: 44,100 Hz for CD quality audio.
+     */
+    public static final int SAMPLE_RATE = 44100;
+
+    private static final int BYTES_PER_SAMPLE = 2;       // 16-bit audio
+    private static final int BITS_PER_SAMPLE = 16;       // 16-bit audio
+    private static final double MAX_16_BIT = 32768;
+    private static final int SAMPLE_BUFFER_SIZE = 4096;
+
+    private static final int MONO   = 1;
+    private static final int STEREO = 2;
+    private static final boolean LITTLE_ENDIAN = false;
+    private static final boolean BIG_ENDIAN    = true;
+    private static final boolean SIGNED        = true;
+    private static final boolean UNSIGNED      = false;
+
+
+    private static SourceDataLine line;   // to play the sound
+    private static byte[] buffer;         // our internal buffer
+    private static int bufferSize = 0;    // number of samples currently in internal buffer
+
+    private StdAudio() {
+        // can not instantiate
+    }
+   
+    // static initializer
+    static {
+        init();
+    }
+
+    // open up an audio stream
+    private static void init() {
+        try {
+            // 44,100 Hz, 16-bit audio, mono, signed PCM, little endian
+            AudioFormat format = new AudioFormat((float) SAMPLE_RATE, BITS_PER_SAMPLE, MONO, SIGNED, LITTLE_ENDIAN);
+            DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);
+
+            line = (SourceDataLine) AudioSystem.getLine(info);
+            line.open(format, SAMPLE_BUFFER_SIZE * BYTES_PER_SAMPLE);
+            
+            // the internal buffer is a fraction of the actual buffer size, this choice is arbitrary
+            // it gets divided because we can't expect the buffered data to line up exactly with when
+            // the sound card decides to push out its samples.
+            buffer = new byte[SAMPLE_BUFFER_SIZE * BYTES_PER_SAMPLE/3];
+        }
+        catch (LineUnavailableException e) {
+            System.out.println(e.getMessage());
+        }
+
+        // no sound gets made before this call
+        line.start();
+    }
+
+    // get an AudioInputStream object from a file
+    private static AudioInputStream getAudioInputStreamFromFile(String filename) {
+        if (filename == null) {
+            throw new IllegalArgumentException("filename is null");
+        }
+
+        try {
+            // first try to read file from local file system
+            File file = new File(filename);
+            if (file.exists()) {
+                return AudioSystem.getAudioInputStream(file);
+            }
+
+            // resource relative to .class file
+            InputStream is1 = StdAudio.class.getResourceAsStream(filename);
+            if (is1 != null) {
+                return AudioSystem.getAudioInputStream(is1);
+            }
+
+            // resource relative to classloader root
+            InputStream is2 = StdAudio.class.getClassLoader().getResourceAsStream(filename);
+            if (is2 != null) {
+                return AudioSystem.getAudioInputStream(is2);
+            }
+
+            // give up
+            else {
+                throw new IllegalArgumentException("could not read '" + filename + "'");
+            }
+        }
+        catch (IOException e) {
+            throw new IllegalArgumentException("could not read '" + filename + "'", e);
+        }
+        catch (UnsupportedAudioFileException e) {
+            throw new IllegalArgumentException("file of unsupported audio format: '" + filename + "'", e);
+        }
+    }
+
+    /**
+     * Closes standard audio.
+     */
+    public static void close() {
+        line.drain();
+        line.stop();
+    }
+    
+    /**
+     * Writes one sample (between -1.0 and +1.0) to standard audio.
+     * If the sample is outside the range, it will be clipped.
+     *
+     * @param  sample the sample to play
+     * @throws IllegalArgumentException if the sample is {@code Double.NaN}
+     */
+    public static void play(double sample) {
+        if (Double.isNaN(sample)) throw new IllegalArgumentException("sample is NaN");
+
+        // clip if outside [-1, +1]
+        if (sample < -1.0) sample = -1.0;
+        if (sample > +1.0) sample = +1.0;
+
+        // convert to bytes
+        short s = (short) (MAX_16_BIT * sample);
+        if (sample == 1.0) s = Short.MAX_VALUE;   // special case since 32768 not a short
+        buffer[bufferSize++] = (byte) s;
+        buffer[bufferSize++] = (byte) (s >> 8);   // little endian
+
+        // send to sound card if buffer is full        
+        if (bufferSize >= buffer.length) {
+            line.write(buffer, 0, buffer.length);
+            bufferSize = 0;
+        }
+    }
+
+    /**
+     * Writes the array of samples (between -1.0 and +1.0) to standard audio.
+     * If a sample is outside the range, it will be clipped.
+     *
+     * @param  samples the array of samples to play
+     * @throws IllegalArgumentException if any sample is {@code Double.NaN}
+     * @throws IllegalArgumentException if {@code samples} is {@code null}
+     */
+    public static void play(double[] samples) {
+        if (samples == null) throw new IllegalArgumentException("argument to play() is null");
+        for (int i = 0; i < samples.length; i++) {
+            play(samples[i]);
+        }
+    }
+
+    /**
+     * Reads audio samples from a file (in .wav or .au format) and returns
+     * them as a double array with values between -1.0 and +1.0.
+     * The audio file must be 16-bit with a sampling rate of 44,100.
+     * It can be mono or stereo.
+     *
+     * @param  filename the name of the audio file
+     * @return the array of samples
+     */
+    public static double[] read(String filename) {
+
+        // make sure that AudioFormat is 16-bit, 44,100 Hz, little endian
+        final AudioInputStream ais = getAudioInputStreamFromFile(filename);
+        AudioFormat audioFormat = ais.getFormat();
+
+        // require sampling rate = 44,100 Hz
+        if (audioFormat.getSampleRate() != SAMPLE_RATE) {
+            throw new IllegalArgumentException("StdAudio.read() currently supports only a sample rate of " + SAMPLE_RATE + " Hz\n"
+                                             + "audio format: " + audioFormat);
+        }
+
+        // require 16-bit audio
+        if (audioFormat.getSampleSizeInBits() != BITS_PER_SAMPLE) {
+            throw new IllegalArgumentException("StdAudio.read() currently supports only " + BITS_PER_SAMPLE + "-bit audio\n"
+                                             + "audio format: " + audioFormat);
+        }
+
+        // require little endian
+        if (audioFormat.isBigEndian()) {
+            throw new IllegalArgumentException("StdAudio.read() currently supports only audio stored using little endian\n"
+                                             + "audio format: " + audioFormat);
+        }
+
+        byte[] bytes = null;
+        try {
+            int bytesToRead = ais.available();
+            bytes = new byte[bytesToRead];
+            int bytesRead = ais.read(bytes);
+            if (bytesToRead != bytesRead) {
+                throw new IllegalStateException("read only " + bytesRead + " of " + bytesToRead + " bytes"); 
+            }
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("could not read '" + filename + "'", ioe);
+        }
+
+        int n = bytes.length;
+
+        // little endian, mono
+        if (audioFormat.getChannels() == MONO) {
+            double[] data = new double[n/2];
+            for (int i = 0; i < n/2; i++) {
+                // little endian, mono
+                data[i] = ((short) (((bytes[2*i+1] & 0xFF) << 8) | (bytes[2*i] & 0xFF))) / ((double) MAX_16_BIT);
+            }
+            return data;
+        }
+
+        // little endian, stereo
+        else if (audioFormat.getChannels() == STEREO) {
+            double[] data = new double[n/4];
+            for (int i = 0; i < n/4; i++) {
+                double left  = ((short) (((bytes[4*i+1] & 0xFF) << 8) | (bytes[4*i + 0] & 0xFF))) / ((double) MAX_16_BIT);
+                double right = ((short) (((bytes[4*i+3] & 0xFF) << 8) | (bytes[4*i + 2] & 0xFF))) / ((double) MAX_16_BIT);
+                data[i] = (left + right) / 2.0;
+            }
+            return data;
+        }
+
+        // TODO: handle big endian (or other formats)
+        else throw new IllegalStateException("audio format is neither mono or stereo");
+    }
+
+    /**
+     * Saves the double array as an audio file (using .wav or .au format).
+     *
+     * @param  filename the name of the audio file
+     * @param  samples the array of samples
+     * @throws IllegalArgumentException if unable to save {@code filename}
+     * @throws IllegalArgumentException if {@code samples} is {@code null}
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     * @throws IllegalArgumentException if {@code filename} extension is not {@code .wav}
+     *         or {@code .au}
+     */
+    public static void save(String filename, double[] samples) {
+        if (filename == null) {
+            throw new IllegalArgumentException("filenameis null");
+        }
+        if (samples == null) {
+            throw new IllegalArgumentException("samples[] is null");
+        }
+
+        // assumes 16-bit samples with sample rate = 44,100 Hz
+        // use 16-bit audio, mono, signed PCM, little Endian
+        AudioFormat format = new AudioFormat(SAMPLE_RATE, 16, MONO, SIGNED, LITTLE_ENDIAN);
+        byte[] data = new byte[2 * samples.length];
+        for (int i = 0; i < samples.length; i++) {
+            int temp = (short) (samples[i] * MAX_16_BIT);
+            if (samples[i] == 1.0) temp = Short.MAX_VALUE;   // special case since 32768 not a short
+            data[2*i + 0] = (byte) temp;
+            data[2*i + 1] = (byte) (temp >> 8);   // little endian
+        }
+
+        // now save the file
+        try {
+            ByteArrayInputStream bais = new ByteArrayInputStream(data);
+            AudioInputStream ais = new AudioInputStream(bais, format, samples.length);
+            if (filename.endsWith(".wav") || filename.endsWith(".WAV")) {
+                AudioSystem.write(ais, AudioFileFormat.Type.WAVE, new File(filename));
+            }
+            else if (filename.endsWith(".au") || filename.endsWith(".AU")) {
+                AudioSystem.write(ais, AudioFileFormat.Type.AU, new File(filename));
+            }
+            else {
+                throw new IllegalArgumentException("file type for saving must be .wav or .au");
+            }
+        }
+        catch (IOException ioe) {
+            throw new IllegalArgumentException("unable to save file '" + filename + "'", ioe);
+        }
+    }
+
+
+
+    /**
+     * Plays an audio file (in .wav, .mid, or .au format) in a background thread.
+     *
+     * @param filename the name of the audio file
+     * @throws IllegalArgumentException if unable to play {@code filename}
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public static synchronized void play(final String filename) {
+        new Thread(new Runnable() {
+            public void run() {
+                AudioInputStream ais = getAudioInputStreamFromFile(filename);
+                stream(ais);
+            }
+        }).start();
+    }
+
+
+    // https://www3.ntu.edu.sg/home/ehchua/programming/java/J8c_PlayingSound.html
+    // play a wav or aif file
+    // javax.sound.sampled.Clip fails for long clips (on some systems), perhaps because
+    // JVM closes (see remedy in loop)
+    private static void stream(AudioInputStream ais) {
+        SourceDataLine line = null;
+        int BUFFER_SIZE = 4096; // 4K buffer
+
+        try {
+            AudioFormat audioFormat = ais.getFormat();
+            DataLine.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);
+            line = (SourceDataLine) AudioSystem.getLine(info);
+            line.open(audioFormat);
+            line.start();
+            byte[] samples = new byte[BUFFER_SIZE];
+            int count = 0;
+            while ((count = ais.read(samples, 0, BUFFER_SIZE)) != -1) {
+                line.write(samples, 0, count);
+            }
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+        catch (LineUnavailableException e) {
+            e.printStackTrace();
+        }
+        finally {
+            if (line != null) {
+                line.drain();
+                line.close();
+            }
+        }
+    }
+
+    /**
+     * Loops an audio file (in .wav, .mid, or .au format) in a background thread.
+     *
+     * @param filename the name of the audio file
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public static synchronized void loop(String filename) {
+        if (filename == null) throw new IllegalArgumentException();
+
+        final AudioInputStream ais = getAudioInputStreamFromFile(filename);
+
+        try {
+            Clip clip = AudioSystem.getClip();
+            // Clip clip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));
+            clip.open(ais);
+            clip.loop(Clip.LOOP_CONTINUOUSLY);
+        }
+        catch (LineUnavailableException e) {
+            e.printStackTrace();
+        }
+        catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        // keep JVM open
+        new Thread(new Runnable() {
+            public void run() {
+                while (true) {
+                    try {
+                       Thread.sleep(1000);
+                    }
+                    catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }).start();
+    }
+
+
+   /***************************************************************************
+    * Unit tests {@code StdAudio}.
+    ***************************************************************************/
+
+    // create a note (sine wave) of the given frequency (Hz), for the given
+    // duration (seconds) scaled to the given volume (amplitude)
+    private static double[] note(double hz, double duration, double amplitude) {
+        int n = (int) (StdAudio.SAMPLE_RATE * duration);
+        double[] a = new double[n+1];
+        for (int i = 0; i <= n; i++)
+            a[i] = amplitude * Math.sin(2 * Math.PI * i * hz / StdAudio.SAMPLE_RATE);
+        return a;
+    }
+
+    /**
+     * Test client - play an A major scale to standard audio.
+     *
+     * @param args the command-line arguments
+     */
+    /**
+     * Test client - play an A major scale to standard audio.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        
+        // 440 Hz for 1 sec
+        double freq = 440.0;
+        for (int i = 0; i <= StdAudio.SAMPLE_RATE; i++) {
+            StdAudio.play(0.5 * Math.sin(2*Math.PI * freq * i / StdAudio.SAMPLE_RATE));
+        }
+        
+        // scale increments
+        int[] steps = { 0, 2, 4, 5, 7, 9, 11, 12 };
+        for (int i = 0; i < steps.length; i++) {
+            double hz = 440.0 * Math.pow(2, steps[i] / 12.0);
+            StdAudio.play(note(hz, 1.0, 0.5));
+        }
+
+
+        // need to call this in non-interactive stuff so the program doesn't terminate
+        // until all the sound leaves the speaker.
+        StdAudio.close(); 
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdDraw.java b/src/main/java/edu/princeton/cs/algs4/StdDraw.java
new file mode 100644
index 0000000..f209b18
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdDraw.java
@@ -0,0 +1,2120 @@
+/******************************************************************************
+ *  Compilation:  javac StdDraw.java
+ *  Execution:    java StdDraw
+ *  Dependencies: none
+ *
+ *  Standard drawing library. This class provides a basic capability for
+ *  creating drawings with your programs. It uses a simple graphics model that
+ *  allows you to create drawings consisting of geometric shapes (e.g.,
+ *  points, lines, circles, rectangles) in a window on your computer
+ *  and to save the drawings to a file.
+ *
+ *  Todo
+ *  ----
+ *    -  Add support for gradient fill, etc.
+ *    -  Fix setCanvasSize() so that it can be called only once.
+ *    -  Should setCanvasSize() reset xScale(), yScale(), penRadius(),
+ *       penColor(), and font()
+ *    -  On some systems, drawing a line (or other shape) that extends way
+ *       beyond canvas (e.g., to infinity) dimensions does not get drawn.
+ *
+ *  Remarks
+ *  -------
+ *    -  don't use AffineTransform for rescaling since it inverts
+ *       images and strings
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.FileDialog;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Image;
+import java.awt.MediaTracker;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+
+import java.awt.geom.Arc2D;
+import java.awt.geom.Ellipse2D;
+import java.awt.geom.GeneralPath;
+import java.awt.geom.Line2D;
+import java.awt.geom.Rectangle2D;
+
+import java.awt.image.BufferedImage;
+import java.awt.image.DirectColorModel;
+import java.awt.image.WritableRaster;
+
+import java.io.File;
+import java.io.IOException;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import java.util.LinkedList;
+import java.util.TreeSet;
+import java.util.NoSuchElementException;
+import javax.imageio.ImageIO;
+
+import javax.swing.ImageIcon;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.KeyStroke;
+
+/**
+ *  The {@code StdDraw} class provides a basic capability for
+ *  creating drawings with your programs. It uses a simple graphics model that
+ *  allows you to create drawings consisting of points, lines, squares, 
+ *  circles, and other geometric shapes in a window on your computer and
+ *  to save the drawings to a file. Standard drawing also includes
+ *  facilities for text, color, pictures, and animation, along with
+ *  user interaction via the keyboard and mouse.
+ *  <p>
+ *  <b>Getting started.</b>
+ *  To use this class, you must have {@code StdDraw.class} in your
+ *  Java classpath. If you used our autoinstaller, you should be all set.
+ *  Otherwise, either download
+ *  <a href = "https://introcs.cs.princeton.edu/java/code/stdlib.jar">stdlib.jar</a>
+ *  and add to your Java classpath or download
+ *  <a href = "https://introcs.cs.princeton.edu/java/stdlib/StdDraw.java">StdDraw.java</a>
+ *  and put a copy in your working directory.
+ *  <p>
+ *  Now, type the following short program into your editor:
+ *  <pre>
+ *   public class TestStdDraw {
+ *       public static void main(String[] args) {
+ *           StdDraw.setPenRadius(0.05);
+ *           StdDraw.setPenColor(StdDraw.BLUE);
+ *           StdDraw.point(0.5, 0.5);
+ *           StdDraw.setPenColor(StdDraw.MAGENTA);
+ *           StdDraw.line(0.2, 0.2, 0.8, 0.2);
+ *       }
+ *   }
+ *  </pre>
+ *  If you compile and execute the program, you should see a window
+ *  appear with a thick magenta line and a blue point.
+ *  This program illustrates the two main types of methods in standard
+ *  drawing‚Äîmethods that draw geometric shapes and methods that
+ *  control drawing parameters.
+ *  The methods {@code StdDraw.line()} and {@code StdDraw.point()}
+ *  draw lines and points; the methods {@code StdDraw.setPenRadius()}
+ *  and {@code StdDraw.setPenColor()} control the line thickness and color.
+ *  <p>
+ *  <b>Points and lines.</b>
+ *  You can draw points and line segments with the following methods:
+ *  <ul>
+ *  <li> {@link #point(double x, double y)}
+ *  <li> {@link #line(double x1, double y1, double x2, double y2)}
+ *  </ul>
+ *  <p>
+ *  The <em>x</em>- and <em>y</em>-coordinates must be in the drawing area
+ *  (between 0 and 1 and by default) or the points and lines will not be visible.
+ *  <p>
+ *  <b>Squares, circles, rectangles, and ellipses.</b>
+ *  You can draw squares, circles, rectangles, and ellipses using
+ *  the following methods:
+ *  <ul>
+ *  <li> {@link #circle(double x, double y, double radius)}
+ *  <li> {@link #ellipse(double x, double y, double semiMajorAxis, double semiMinorAxis)}
+ *  <li> {@link #square(double x, double y, double halfLength)}
+ *  <li> {@link #rectangle(double x, double y, double halfWidth, double halfHeight)}
+ *  </ul>
+ *  <p>
+ *  All of these methods take as arguments the location and size of the shape.
+ *  The location is always specified by the <em>x</em>- and <em>y</em>-coordinates
+ *  of its <em>center</em>.
+ *  The size of a circle is specified by its radius and the size of an ellipse is
+ *  specified by the lengths of its semi-major and semi-minor axes.
+ *  The size of a square or rectangle is specified by its half-width or half-height.
+ *  The convention for drawing squares and rectangles is parallel to those for
+ *  drawing circles and ellipses, but may be unexpected to the uninitiated.
+ *  <p>
+ *  The methods above trace outlines of the given shapes. The following methods
+ *  draw filled versions:
+ *  <ul>
+ *  <li> {@link #filledCircle(double x, double y, double radius)}
+ *  <li> {@link #filledEllipse(double x, double y, double semiMajorAxis, double semiMinorAxis)}
+ *  <li> {@link #filledSquare(double x, double y, double radius)}
+ *  <li> {@link #filledRectangle(double x, double y, double halfWidth, double halfHeight)}
+ *  </ul>
+ *  <p>
+ *  <b>Circular arcs.</b>
+ *  You can draw circular arcs with the following method:
+ *  <ul>
+ *  <li> {@link #arc(double x, double y, double radius, double angle1, double angle2)}
+ *  </ul>
+ *  <p>
+ *  The arc is from the circle centered at (<em>x</em>, <em>y</em>) of the specified radius.
+ *  The arc extends from angle1 to angle2. By convention, the angles are
+ *  <em>polar</em> (counterclockwise angle from the <em>x</em>-axis)
+ *  and represented in degrees. For example, {@code StdDraw.arc(0.0, 0.0, 1.0, 0, 90)}
+ *  draws the arc of the unit circle from 3 o'clock (0 degrees) to 12 o'clock (90 degrees).
+ *  <p>
+ *  <b>Polygons.</b>
+ *  You can draw polygons with the following methods:
+ *  <ul>
+ *  <li> {@link #polygon(double[] x, double[] y)}
+ *  <li> {@link #filledPolygon(double[] x, double[] y)}
+ *  </ul>
+ *  <p>
+ *  The points in the polygon are ({@code x[i]}, {@code y[i]}).
+ *  For example, the following code fragment draws a filled diamond
+ *  with vertices (0.1, 0.2), (0.2, 0.3), (0.3, 0.2), and (0.2, 0.1):
+ *  <pre>
+ *   double[] x = { 0.1, 0.2, 0.3, 0.2 };
+ *   double[] y = { 0.2, 0.3, 0.2, 0.1 };
+ *   StdDraw.filledPolygon(x, y);
+ *  </pre>
+ *  <p>
+ *  <b>Pen size.</b>
+ *  The pen is circular, so that when you set the pen radius to <em>r</em>
+ *  and draw a point, you get a circle of radius <em>r</em>. Also, lines are
+ *  of thickness 2<em>r</em> and have rounded ends. The default pen radius
+ *  is 0.005 and is not affected by coordinate scaling. This default pen
+ *  radius is about 1/200 the width of the default canvas, so that if
+ *  you draw 100 points equally spaced along a horizontal or vertical line,
+ *  you will be able to see individual circles, but if you draw 200 such
+ *  points, the result will look like a line.
+ *  <ul>
+ *  <li> {@link #setPenRadius(double radius)}
+ *  </ul>
+ *  <p>
+ *  For example, {@code StdDraw.setPenRadius(0.025)} makes
+ *  the thickness of the lines and the size of the points to be five times
+ *  the 0.005 default.
+ *  To draw points with the minimum possible radius (one pixel on typical
+ *  displays), set the pen radius to 0.0.
+ *  <p>
+ *  <b>Pen color.</b>
+ *  All geometric shapes (such as points, lines, and circles) are drawn using
+ *  the current pen color. By default, it is black.
+ *  You can change the pen color with the following methods:
+ *  <ul>
+ *  <li> {@link #setPenColor(int red, int green, int blue)}
+ *  <li> {@link #setPenColor(Color color)}
+ *  </ul>
+ *  <p>
+ *  The first method allows you to specify colors using the RGB color system.
+ *  This <a href = "http://johndyer.name/lab/colorpicker/">color picker</a>
+ *  is a convenient way to find a desired color.
+ *  The second method allows you to specify colors using the
+ *  {@link Color} data type that is discussed in Chapter 3. Until then,
+ *  you can use this method with one of these predefined colors in standard drawing:
+ *  {@link #BLACK}, {@link #BLUE}, {@link #CYAN}, {@link #DARK_GRAY}, {@link #GRAY},
+ *  {@link #GREEN}, {@link #LIGHT_GRAY}, {@link #MAGENTA}, {@link #ORANGE},
+ *  {@link #PINK}, {@link #RED}, {@link #WHITE}, {@link #YELLOW},
+ *  {@link #BOOK_BLUE}, {@link #BOOK_LIGHT_BLUE}, {@link #BOOK_RED}, and
+ *  {@link #PRINCETON_ORANGE}.
+ *  For example, {@code StdDraw.setPenColor(StdDraw.MAGENTA)} sets the
+ *  pen color to magenta.
+ *  <p>
+ *  <b>Canvas size.</b>
+ *  By default, all drawing takes places in a 512-by-512 canvas.
+ *  The canvas does not include the window title or window border.
+ *  You can change the size of the canvas with the following method:
+ *  <ul>
+ *  <li> {@link #setCanvasSize(int width, int height)}
+ *  </ul>
+ *  <p>
+ *  This sets the canvas size to be <em>width</em>-by-<em>height</em> pixels.
+ *  It also erases the current drawing and resets the coordinate system,
+ *  pen radius, pen color, and font back to their default values.
+ *  Ordinarly, this method is called once, at the very beginning of a program.
+ *  For example, {@code StdDraw.setCanvasSize(800, 800)}
+ *  sets the canvas size to be 800-by-800 pixels.
+ *  <p>
+ *  <b>Canvas scale and coordinate system.</b>
+ *  By default, all drawing takes places in the unit square, with (0, 0) at
+ *  lower left and (1, 1) at upper right. You can change the default
+ *  coordinate system with the following methods:
+ *  <ul>
+ *  <li> {@link #setXscale(double xmin, double xmax)}
+ *  <li> {@link #setYscale(double ymin, double ymax)}
+ *  <li> {@link #setScale(double min, double max)}
+ *  </ul>
+ *  <p>
+ *  The arguments are the coordinates of the minimum and maximum 
+ *  <em>x</em>- or <em>y</em>-coordinates that will appear in the canvas.
+ *  For example, if you  wish to use the default coordinate system but
+ *  leave a small margin, you can call {@code StdDraw.setScale(-.05, 1.05)}.
+ *  <p>
+ *  These methods change the coordinate system for subsequent drawing
+ *  commands; they do not affect previous drawings.
+ *  These methods do not change the canvas size; so, if the <em>x</em>-
+ *  and <em>y</em>-scales are different, squares will become rectangles
+ *  and circles will become ellipses.
+ *  <p>
+ *  <b>Text.</b>
+ *  You can use the following methods to annotate your drawings with text:
+ *  <ul>
+ *  <li> {@link #text(double x, double y, String text)}
+ *  <li> {@link #text(double x, double y, String text, double degrees)}
+ *  <li> {@link #textLeft(double x, double y, String text)}
+ *  <li> {@link #textRight(double x, double y, String text)}
+ *  </ul>
+ *  <p>
+ *  The first two methods write the specified text in the current font,
+ *  centered at (<em>x</em>, <em>y</em>).
+ *  The second method allows you to rotate the text.
+ *  The last two methods either left- or right-align the text at (<em>x</em>, <em>y</em>).
+ *  <p>
+ *  The default font is a Sans Serif font with point size 16.
+ *  You can use the following method to change the font:
+ *  <ul>
+ *  <li> {@link #setFont(Font font)}
+ *  </ul>
+ *  <p>
+ *  You use the {@link Font} data type to specify the font. This allows you to
+ *  choose the face, size, and style of the font. For example, the following
+ *  code fragment sets the font to Arial Bold, 60 point.
+ *  <pre>
+ *   Font font = new Font("Arial", Font.BOLD, 60);
+ *   StdDraw.setFont(font);
+ *   StdDraw.text(0.5, 0.5, "Hello, World");
+ *  </pre>
+ *  <p>
+ *  <b>Images.</b>
+ *  You can use the following methods to add images to your drawings:
+ *  <ul>
+ *  <li> {@link #picture(double x, double y, String filename)}
+ *  <li> {@link #picture(double x, double y, String filename, double degrees)}
+ *  <li> {@link #picture(double x, double y, String filename, double scaledWidth, double scaledHeight)}
+ *  <li> {@link #picture(double x, double y, String filename, double scaledWidth, double scaledHeight, double degrees)}
+ *  </ul>
+ *  <p>
+ *  These methods draw the specified image, centered at (<em>x</em>, <em>y</em>).
+ *  The supported image formats are JPEG, PNG, and GIF.
+ *  The image will display at its native size, independent of the coordinate system.
+ *  Optionally, you can rotate the image a specified number of degrees counterclockwise
+ *  or rescale it to fit snugly inside a width-by-height bounding box.
+ *  <p>
+ *  <b>Saving to a file.</b>
+ *  You save your image to a file using the <em>File ‚Üí Save</em> menu option.
+ *  You can also save a file programatically using the following method:
+ *  <ul>
+ *  <li> {@link #save(String filename)}
+ *  </ul>
+ *  <p>
+ *  The supported image formats are JPEG and PNG. The filename must have either the
+ *  extension .jpg or .png.
+ *  We recommend using PNG for drawing that consist solely of geometric shapes and JPEG 
+ *  for drawings that contains pictures.
+ *  <p>
+ *  <b>Clearing the canvas.</b>
+ *  To clear the entire drawing canvas, you can use the following methods:
+ *  <ul>
+ *  <li> {@link #clear()}
+ *  <li> {@link #clear(Color color)}
+ *  </ul>
+ *  <p>
+ *  The first method clears the canvas to white; the second method
+ *  allows you to specify a color of your choice. For example,
+ *  {@code StdDraw.clear(StdDraw.LIGHT_GRAY)} clears the canvas to a shade
+ *  of gray.
+ *  <p>
+ *  <b>Computer animations and double buffering.</b>
+ *  Double buffering is one of the most powerful features of standard drawing,
+ *  enabling computer animations.
+ *  The following methods control the way in which objects are drawn:
+ *  <ul>
+ *  <li> {@link #enableDoubleBuffering()}
+ *  <li> {@link #disableDoubleBuffering()}
+ *  <li> {@link #show()}
+ *  <li> {@link #pause(int t)}
+ *  </ul>
+ *  <p>
+ *  By default, double buffering is disabled, which means that as soon as you
+ *  call a drawing
+ *  method‚Äîsuch as {@code point()} or {@code line()}‚Äîthe
+ *  results appear on the screen.
+ *  <p>
+ *  When double buffering is enabled by calling {@link #enableDoubleBuffering()},
+ *  all drawing takes place on the <em>offscreen canvas</em>. The offscreen canvas
+ *  is not displayed. Only when you call
+ *  {@link #show()} does your drawing get copied from the offscreen canvas to
+ *  the onscreen canvas, where it is displayed in the standard drawing window. You 
+ *  can think of double buffering as collecting all of the lines, points, shapes,
+ *  and text that you tell it to draw, and then drawing them all
+ *  <em>simultaneously</em>, upon request.
+ *  <p>
+ *  The most important use of double buffering is to produce computer
+ *  animations, creating the illusion of motion by rapidly
+ *  displaying static drawings. To produce an animation, repeat
+ *  the following four steps:
+ *  <ul>
+ *  <li> Clear the offscreen canvas.
+ *  <li> Draw objects on the offscreen canvas.
+ *  <li> Copy the offscreen canvas to the onscreen canvas.
+ *  <li> Wait for a short while.
+ *  </ul>
+ *  <p>
+ *  The {@link #clear()}, {@link #show()}, and {@link #pause(int t)} methods
+ *  support the first, third, and fourth of these steps, respectively.
+ *  <p>
+ *  For example, this code fragment animates two balls moving in a circle.
+ *  <pre>
+ *   StdDraw.setScale(-2, +2);
+ *   StdDraw.enableDoubleBuffering();
+ *
+ *   for (double t = 0.0; true; t += 0.02) {
+ *       double x = Math.sin(t);
+ *       double y = Math.cos(t);
+ *       StdDraw.clear();
+ *       StdDraw.filledCircle(x, y, 0.05);
+ *       StdDraw.filledCircle(-x, -y, 0.05);
+ *       StdDraw.show();
+ *       StdDraw.pause(20);
+ *   }
+ *  </pre>
+ *  <p>
+ *  <b>Keyboard and mouse inputs.</b>
+ *  Standard drawing has very basic support for keyboard and mouse input.
+ *  It is much less powerful than most user interface libraries provide, but also much simpler.
+ *  You can use the following methods to intercept mouse events:
+ *  <ul>
+ *  <li> {@link #isMousePressed()}
+ *  <li> {@link #mouseX()}
+ *  <li> {@link #mouseY()}
+ *  </ul>
+ *  <p>
+ *  The first method tells you whether a mouse button is currently being pressed.
+ *  The last two methods tells you the <em>x</em>- and <em>y</em>-coordinates of the mouse's
+ *  current position, using the same coordinate system as the canvas (the unit square, by default).
+ *  You should use these methods in an animation loop that waits a short while before trying
+ *  to poll the mouse for its current state.
+ *  You can use the following methods to intercept keyboard events:
+ *  <ul>
+ *  <li> {@link #hasNextKeyTyped()}
+ *  <li> {@link #nextKeyTyped()}
+ *  <li> {@link #isKeyPressed(int keycode)}
+ *  </ul>
+ *  <p>
+ *  If the user types lots of keys, they will be saved in a list until you process them.
+ *  The first method tells you whether the user has typed a key (that your program has
+ *  not yet processed).
+ *  The second method returns the next key that the user typed (that your program has
+ *  not yet processed) and removes it from the list of saved keystrokes.
+ *  The third method tells you whether a key is currently being pressed.
+ *  <p>
+ *  <b>Accessing control parameters.</b>
+ *  You can use the following methods to access the current pen color, pen radius,
+ *  and font:
+ *  <ul>
+ *  <li> {@link #getPenColor()}
+ *  <li> {@link #getPenRadius()}
+ *  <li> {@link #getFont()}
+ *  </ul>
+ *  <p>
+ *  These methods are useful when you want to temporarily change a
+ *  control parameter and reset it back to its original value.
+ *  <p>
+ *  <b>Corner cases.</b>
+ *  Here are some corner cases.
+ *  <ul>
+ *  <li> Drawing an object outside (or partly outside) the canvas is permitted.
+ *       However, only the part of the object that appears inside the canvas
+ *       will be visible.
+ *  <li> Any method that is passed a {@code null} argument will throw an
+ *       {@link IllegalArgumentException}.
+ *  <li> Any method that is passed a {@link Double#NaN},
+ *       {@link Double#POSITIVE_INFINITY}, or {@link Double#NEGATIVE_INFINITY}
+ *       argument will throw an {@link IllegalArgumentException}.
+ *  <li> Due to floating-point issues, an object drawn with an <em>x</em>- or
+ *       <em>y</em>-coordinate that is way outside the canvas (such as the line segment
+ *       from (0.5, ‚Äì10^308) to (0.5, 10^308) may not be visible even in the
+ *       part of the canvas where it should be.
+ *  </ul>
+ *  <p>
+ *  <b>Performance tricks.</b>
+ *  Standard drawing is capable of drawing large amounts of data.
+ *  Here are a few tricks and tips:
+ *  <ul>
+ *  <li> Use <em>double buffering</em> for static drawing with a large
+ *       number of objects.
+ *       That is, call {@link #enableDoubleBuffering()} before
+ *       the sequence of drawing commands and call {@link #show()} afterwards.
+ *       Incrementally displaying a complex drawing while it is being
+ *       created can be intolerably inefficient on many computer systems.
+ *  <li> When drawing computer animations, call {@code show()}
+ *       only once per frame, not after drawing each individual object.
+ *  <li> If you call {@code picture()} multiple times with the same filename,
+ *       Java will cache the image, so you do not incur the cost of reading
+ *       from a file each time.
+ *  </ul>
+ *  <p>
+ *  <b>Known bugs and issues.</b>
+ *  <ul>
+ *  <li> The {@code picture()} methods may not draw the portion of the image that is
+ *       inside the canvas if the center point (<em>x</em>, <em>y</em>) is outside the
+ *       canvas.
+ *       This bug appears only on some systems.
+ *  </ul>
+ *  <p>
+ *  <b>Reference.</b>
+ *  For additional documentation,
+ *  see <a href="https://introcs.cs.princeton.edu/15inout">Section 1.5</a> of
+ *  <em>Computer Science: An Interdisciplinary Approach</em>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class StdDraw implements ActionListener, MouseListener, MouseMotionListener, KeyListener {
+
+    /**
+     *  The color black.
+     */
+    public static final Color BLACK = Color.BLACK;
+
+    /**
+     *  The color blue.
+     */
+    public static final Color BLUE = Color.BLUE;
+
+    /**
+     *  The color cyan.
+     */
+    public static final Color CYAN = Color.CYAN;
+
+    /**
+     *  The color dark gray.
+     */
+    public static final Color DARK_GRAY = Color.DARK_GRAY;
+
+    /**
+     *  The color gray.
+     */
+    public static final Color GRAY = Color.GRAY;
+
+    /**
+     *  The color green.
+     */
+    public static final Color GREEN  = Color.GREEN;
+
+    /**
+     *  The color light gray.
+     */
+    public static final Color LIGHT_GRAY = Color.LIGHT_GRAY;
+
+    /**
+     *  The color magenta.
+     */
+    public static final Color MAGENTA = Color.MAGENTA;
+
+    /**
+     *  The color orange.
+     */
+    public static final Color ORANGE = Color.ORANGE;
+
+    /**
+     *  The color pink.
+     */
+    public static final Color PINK = Color.PINK;
+
+    /**
+     *  The color red.
+     */
+    public static final Color RED = Color.RED;
+
+    /**
+     *  The color white.
+     */
+    public static final Color WHITE = Color.WHITE;
+
+    /**
+     *  The color yellow.
+     */
+    public static final Color YELLOW = Color.YELLOW;
+
+    /**
+     * Shade of blue used in <em>Introduction to Programming in Java</em>.
+     * It is Pantone 300U. The RGB values are approximately (9, 90, 166).
+     */
+    public static final Color BOOK_BLUE = new Color(9, 90, 166);
+
+    /**
+     * Shade of light blue used in <em>Introduction to Programming in Java</em>.
+     * The RGB values are approximately (103, 198, 243).
+     */
+    public static final Color BOOK_LIGHT_BLUE = new Color(103, 198, 243);
+
+    /**
+     * Shade of red used in <em>Algorithms, 4th edition</em>.
+     * It is Pantone 1805U. The RGB values are approximately (150, 35, 31).
+     */
+    public static final Color BOOK_RED = new Color(150, 35, 31);
+
+    /**
+     * Shade of orange used in Princeton University's identity.
+     * It is PMS 158. The RGB values are approximately (245, 128, 37).
+     */
+    public static final Color PRINCETON_ORANGE = new Color(245, 128, 37);
+
+    // default colors
+    private static final Color DEFAULT_PEN_COLOR   = BLACK;
+    private static final Color DEFAULT_CLEAR_COLOR = WHITE;
+
+    // current pen color
+    private static Color penColor;
+
+    // default canvas size is DEFAULT_SIZE-by-DEFAULT_SIZE
+    private static final int DEFAULT_SIZE = 512;
+    private static int width  = DEFAULT_SIZE;
+    private static int height = DEFAULT_SIZE;
+
+    // default pen radius
+    private static final double DEFAULT_PEN_RADIUS = 0.002;
+
+    // current pen radius
+    private static double penRadius;
+
+    // show we draw immediately or wait until next show?
+    private static boolean defer = false;
+
+    // boundary of drawing canvas, 0% border
+    // private static final double BORDER = 0.05;
+    private static final double BORDER = 0.00;
+    private static final double DEFAULT_XMIN = 0.0;
+    private static final double DEFAULT_XMAX = 1.0;
+    private static final double DEFAULT_YMIN = 0.0;
+    private static final double DEFAULT_YMAX = 1.0;
+    private static double xmin, ymin, xmax, ymax;
+
+    // for synchronization
+    private static Object mouseLock = new Object();
+    private static Object keyLock = new Object();
+
+    // default font
+    private static final Font DEFAULT_FONT = new Font("SansSerif", Font.PLAIN, 16);
+
+    // current font
+    private static Font font;
+
+    // double buffered graphics
+    private static BufferedImage offscreenImage, onscreenImage;
+    private static Graphics2D offscreen, onscreen;
+
+    // singleton for callbacks: avoids generation of extra .class files
+    private static StdDraw std = new StdDraw();
+
+    // the frame for drawing to the screen
+    private static JFrame frame;
+
+    // mouse state
+    private static boolean isMousePressed = false;
+    private static double mouseX = 0;
+    private static double mouseY = 0;
+
+    // queue of typed key characters
+    private static LinkedList<Character> keysTyped;
+
+    // set of key codes currently pressed down
+    private static TreeSet<Integer> keysDown;
+
+    // singleton pattern: client can't instantiate
+    private StdDraw() { }
+
+
+    // static initializer
+    static {
+        init();
+    }
+
+    /**
+     * Sets the canvas (drawing area) to be 512-by-512 pixels.
+     * This also erases the current drawing and resets the coordinate system,
+     * pen radius, pen color, and font back to their default values.
+     * Ordinarly, this method is called once, at the very beginning
+     * of a program.
+     */
+    public static void setCanvasSize() {
+        setCanvasSize(DEFAULT_SIZE, DEFAULT_SIZE);
+    }
+
+    /**
+     * Sets the canvas (drawing area) to be <em>width</em>-by-<em>height</em> pixels.
+     * This also erases the current drawing and resets the coordinate system,
+     * pen radius, pen color, and font back to their default values.
+     * Ordinarly, this method is called once, at the very beginning
+     * of a program.
+     *
+     * @param  canvasWidth the width as a number of pixels
+     * @param  canvasHeight the height as a number of pixels
+     * @throws IllegalArgumentException unless both {@code canvasWidth} and
+     *         {@code canvasHeight} are positive
+     */
+    public static void setCanvasSize(int canvasWidth, int canvasHeight) {
+        if (canvasWidth <= 0) throw new IllegalArgumentException("width must be positive");
+        if (canvasHeight <= 0) throw new IllegalArgumentException("height must be positive");
+        width = canvasWidth;
+        height = canvasHeight;
+        init();
+    }
+
+    // init
+    private static void init() {
+        if (frame != null) frame.setVisible(false);
+        frame = new JFrame();
+        offscreenImage = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_ARGB);
+        onscreenImage  = new BufferedImage(2*width, 2*height, BufferedImage.TYPE_INT_ARGB);
+        offscreen = offscreenImage.createGraphics();
+        onscreen  = onscreenImage.createGraphics();
+        offscreen.scale(2.0, 2.0);  // since we made it 2x as big
+
+        setXscale();
+        setYscale();
+        offscreen.setColor(DEFAULT_CLEAR_COLOR);
+        offscreen.fillRect(0, 0, width, height);
+        setPenColor();
+        setPenRadius();
+        setFont();
+        clear();
+
+        // initialize keystroke buffers
+        keysTyped = new LinkedList<Character>();
+        keysDown = new TreeSet<Integer>();
+
+        // add antialiasing
+        RenderingHints hints = new RenderingHints(RenderingHints.KEY_ANTIALIASING,
+                                                  RenderingHints.VALUE_ANTIALIAS_ON);
+        hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
+        offscreen.addRenderingHints(hints);
+
+        // frame stuff
+        RetinaImageIcon icon = new RetinaImageIcon(onscreenImage);
+        JLabel draw = new JLabel(icon);
+
+        draw.addMouseListener(std);
+        draw.addMouseMotionListener(std);
+
+        frame.setContentPane(draw);
+        frame.addKeyListener(std);    // JLabel cannot get keyboard focus
+        frame.setFocusTraversalKeysEnabled(false);  // allow VK_TAB with isKeyPressed()
+        frame.setResizable(false);
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            // closes all windows
+        // frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);      // closes only current window
+        frame.setTitle("Standard Draw");
+        frame.setJMenuBar(createMenuBar());
+        frame.pack();
+        frame.requestFocusInWindow();
+        frame.setVisible(true);
+    }
+
+    // create the menu bar (changed to private)
+    private static JMenuBar createMenuBar() {
+        JMenuBar menuBar = new JMenuBar();
+        JMenu menu = new JMenu("File");
+        menuBar.add(menu);
+        JMenuItem menuItem1 = new JMenuItem(" Save...   ");
+        menuItem1.addActionListener(std);
+        // Java 10+: replace getMenuShortcutKeyMask() with getMenuShortcutKeyMaskEx()
+        menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,
+                                Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
+        menu.add(menuItem1);
+        return menuBar;
+    }
+
+   /***************************************************************************
+    *  User and screen coordinate systems.
+    ***************************************************************************/
+
+    // throw an IllegalArgumentException if x is NaN or infinite
+    private static void validate(double x, String name) {
+        if (Double.isNaN(x)) throw new IllegalArgumentException(name + " is NaN");
+        if (Double.isInfinite(x)) throw new IllegalArgumentException(name + " is infinite");
+    }
+
+    // throw an IllegalArgumentException if s is null
+    private static void validateNonnegative(double x, String name) {
+        if (x < 0) throw new IllegalArgumentException(name + " negative");
+    }
+
+    // throw an IllegalArgumentException if s is null
+    private static void validateNotNull(Object x, String name) {
+        if (x == null) throw new IllegalArgumentException(name + " is null");
+    }
+
+
+    /**
+     * Sets the <em>x</em>-scale to be the default (between 0.0 and 1.0).
+     */
+    public static void setXscale() {
+        setXscale(DEFAULT_XMIN, DEFAULT_XMAX);
+    }
+
+    /**
+     * Sets the <em>y</em>-scale to be the default (between 0.0 and 1.0).
+     */
+    public static void setYscale() {
+        setYscale(DEFAULT_YMIN, DEFAULT_YMAX);
+    }
+
+    /**
+     * Sets the <em>x</em>-scale and <em>y</em>-scale to be the default
+     * (between 0.0 and 1.0).
+     */
+    public static void setScale() {
+        setXscale();
+        setYscale();
+    }
+
+    /**
+     * Sets the <em>x</em>-scale to the specified range.
+     *
+     * @param  min the minimum value of the <em>x</em>-scale
+     * @param  max the maximum value of the <em>x</em>-scale
+     * @throws IllegalArgumentException if {@code (max == min)}
+     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite
+     */
+    public static void setXscale(double min, double max) {
+        validate(min, "min");
+        validate(max, "max");
+        double size = max - min;
+        if (size == 0.0) throw new IllegalArgumentException("the min and max are the same");
+        synchronized (mouseLock) {
+            xmin = min - BORDER * size;
+            xmax = max + BORDER * size;
+        }
+    }
+
+    /**
+     * Sets the <em>y</em>-scale to the specified range.
+     *
+     * @param  min the minimum value of the <em>y</em>-scale
+     * @param  max the maximum value of the <em>y</em>-scale
+     * @throws IllegalArgumentException if {@code (max == min)}
+     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite
+     */
+    public static void setYscale(double min, double max) {
+        validate(min, "min");
+        validate(max, "max");
+        double size = max - min;
+        if (size == 0.0) throw new IllegalArgumentException("the min and max are the same");
+        synchronized (mouseLock) {
+            ymin = min - BORDER * size;
+            ymax = max + BORDER * size;
+        }
+    }
+
+    /**
+     * Sets both the <em>x</em>-scale and <em>y</em>-scale to the (same) specified range.
+     *
+     * @param  min the minimum value of the <em>x</em>- and <em>y</em>-scales
+     * @param  max the maximum value of the <em>x</em>- and <em>y</em>-scales
+     * @throws IllegalArgumentException if {@code (max == min)}
+     * @throws IllegalArgumentException if either {@code min} or {@code max} is either NaN or infinite
+     */
+    public static void setScale(double min, double max) {
+        validate(min, "min");
+        validate(max, "max");
+        double size = max - min;
+        if (size == 0.0) throw new IllegalArgumentException("the min and max are the same");
+        synchronized (mouseLock) {
+            xmin = min - BORDER * size;
+            xmax = max + BORDER * size;
+            ymin = min - BORDER * size;
+            ymax = max + BORDER * size;
+        }
+    }
+
+    // helper functions that scale from user coordinates to screen coordinates and back
+    private static double  scaleX(double x) { return width  * (x - xmin) / (xmax - xmin); }
+    private static double  scaleY(double y) { return height * (ymax - y) / (ymax - ymin); }
+    private static double factorX(double w) { return w * width  / Math.abs(xmax - xmin);  }
+    private static double factorY(double h) { return h * height / Math.abs(ymax - ymin);  }
+    private static double   userX(double x) { return xmin + x * (xmax - xmin) / width;    }
+    private static double   userY(double y) { return ymax - y * (ymax - ymin) / height;   }
+
+
+    /**
+     * Clears the screen to the default color (white).
+     */
+    public static void clear() {
+        clear(DEFAULT_CLEAR_COLOR);
+    }
+
+    /**
+     * Clears the screen to the specified color.
+     *
+     * @param color the color to make the background
+     * @throws IllegalArgumentException if {@code color} is {@code null}
+     */
+    public static void clear(Color color) {
+        validateNotNull(color, "color");
+        offscreen.setColor(color);
+        offscreen.fillRect(0, 0, width, height);
+        offscreen.setColor(penColor);
+        draw();
+    }
+
+    /**
+     * Returns the current pen radius.
+     *
+     * @return the current value of the pen radius
+     */
+    public static double getPenRadius() {
+        return penRadius;
+    }
+
+    /**
+     * Sets the pen size to the default size (0.002).
+     * The pen is circular, so that lines have rounded ends, and when you set the
+     * pen radius and draw a point, you get a circle of the specified radius.
+     * The pen radius is not affected by coordinate scaling.
+     */
+    public static void setPenRadius() {
+        setPenRadius(DEFAULT_PEN_RADIUS);
+    }
+
+    /**
+     * Sets the radius of the pen to the specified size.
+     * The pen is circular, so that lines have rounded ends, and when you set the
+     * pen radius and draw a point, you get a circle of the specified radius.
+     * The pen radius is not affected by coordinate scaling.
+     *
+     * @param  radius the radius of the pen
+     * @throws IllegalArgumentException if {@code radius} is negative, NaN, or infinite
+     */
+    public static void setPenRadius(double radius) {
+        validate(radius, "pen radius");
+        validateNonnegative(radius, "pen radius");
+
+        penRadius = radius;
+        float scaledPenRadius = (float) (radius * DEFAULT_SIZE);
+        BasicStroke stroke = new BasicStroke(scaledPenRadius, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
+        // BasicStroke stroke = new BasicStroke(scaledPenRadius);
+        offscreen.setStroke(stroke);
+    }
+
+    /**
+     * Returns the current pen color.
+     *
+     * @return the current pen color
+     */
+    public static Color getPenColor() {
+        return penColor;
+    }
+
+    /**
+     * Sets the pen color to the default color (black).
+     */
+    public static void setPenColor() {
+        setPenColor(DEFAULT_PEN_COLOR);
+    }
+
+    /**
+     * Sets the pen color to the specified color.
+     * <p>
+     * The predefined pen colors are
+     * {@code StdDraw.BLACK}, {@code StdDraw.BLUE}, {@code StdDraw.CYAN},
+     * {@code StdDraw.DARK_GRAY}, {@code StdDraw.GRAY}, {@code StdDraw.GREEN},
+     * {@code StdDraw.LIGHT_GRAY}, {@code StdDraw.MAGENTA}, {@code StdDraw.ORANGE},
+     * {@code StdDraw.PINK}, {@code StdDraw.RED}, {@code StdDraw.WHITE}, and
+     * {@code StdDraw.YELLOW}.
+     *
+     * @param color the color to make the pen
+     * @throws IllegalArgumentException if {@code color} is {@code null}
+     */
+    public static void setPenColor(Color color) {
+        validateNotNull(color, "color");
+        penColor = color;
+        offscreen.setColor(penColor);
+    }
+
+    /**
+     * Sets the pen color to the specified RGB color.
+     *
+     * @param  red the amount of red (between 0 and 255)
+     * @param  green the amount of green (between 0 and 255)
+     * @param  blue the amount of blue (between 0 and 255)
+     * @throws IllegalArgumentException if {@code red}, {@code green},
+     *         or {@code blue} is outside its prescribed range
+     */
+    public static void setPenColor(int red, int green, int blue) {
+        if (red   < 0 || red   >= 256) throw new IllegalArgumentException("red must be between 0 and 255");
+        if (green < 0 || green >= 256) throw new IllegalArgumentException("green must be between 0 and 255");
+        if (blue  < 0 || blue  >= 256) throw new IllegalArgumentException("blue must be between 0 and 255");
+        setPenColor(new Color(red, green, blue));
+    }
+
+    /**
+     * Returns the current font.
+     *
+     * @return the current font
+     */
+    public static Font getFont() {
+        return font;
+    }
+
+    /**
+     * Sets the font to the default font (sans serif, 16 point).
+     */
+    public static void setFont() {
+        setFont(DEFAULT_FONT);
+    }
+
+    /**
+     * Sets the font to the specified value.
+     *
+     * @param font the font
+     * @throws IllegalArgumentException if {@code font} is {@code null}
+     */
+    public static void setFont(Font font) {
+        validateNotNull(font, "font");
+        StdDraw.font = font;
+    }
+
+
+   /***************************************************************************
+    *  Drawing geometric shapes.
+    ***************************************************************************/
+
+    /**
+     * Draws a line segment between (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) and
+     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>).
+     *
+     * @param  x0 the <em>x</em>-coordinate of one endpoint
+     * @param  y0 the <em>y</em>-coordinate of one endpoint
+     * @param  x1 the <em>x</em>-coordinate of the other endpoint
+     * @param  y1 the <em>y</em>-coordinate of the other endpoint
+     * @throws IllegalArgumentException if any coordinate is either NaN or infinite
+     */
+    public static void line(double x0, double y0, double x1, double y1) {
+        validate(x0, "x0");
+        validate(y0, "y0");
+        validate(x1, "x1");
+        validate(y1, "y1");
+        offscreen.draw(new Line2D.Double(scaleX(x0), scaleY(y0), scaleX(x1), scaleY(y1)));
+        draw();
+    }
+
+    /**
+     * Draws one pixel at (<em>x</em>, <em>y</em>).
+     * This method is private because pixels depend on the display.
+     * To achieve the same effect, set the pen radius to 0 and call {@code point()}.
+     *
+     * @param  x the <em>x</em>-coordinate of the pixel
+     * @param  y the <em>y</em>-coordinate of the pixel
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    private static void pixel(double x, double y) {
+        validate(x, "x");
+        validate(y, "y");
+        offscreen.fillRect((int) Math.round(scaleX(x)), (int) Math.round(scaleY(y)), 1, 1);
+    }
+
+    /**
+     * Draws a point centered at (<em>x</em>, <em>y</em>).
+     * The point is a filled circle whose radius is equal to the pen radius.
+     * To draw a single-pixel point, first set the pen radius to 0.
+     *
+     * @param x the <em>x</em>-coordinate of the point
+     * @param y the <em>y</em>-coordinate of the point
+     * @throws IllegalArgumentException if either {@code x} or {@code y} is either NaN or infinite
+     */
+    public static void point(double x, double y) {
+        validate(x, "x");
+        validate(y, "y");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double r = penRadius;
+        float scaledPenRadius = (float) (r * DEFAULT_SIZE);
+
+        // double ws = factorX(2*r);
+        // double hs = factorY(2*r);
+        // if (ws <= 1 && hs <= 1) pixel(x, y);
+        if (scaledPenRadius <= 1) pixel(x, y);
+        else offscreen.fill(new Ellipse2D.Double(xs - scaledPenRadius/2, ys - scaledPenRadius/2,
+                                                 scaledPenRadius, scaledPenRadius));
+        draw();
+    }
+
+    /**
+     * Draws a circle of the specified radius, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the circle
+     * @param  y the <em>y</em>-coordinate of the center of the circle
+     * @param  radius the radius of the circle
+     * @throws IllegalArgumentException if {@code radius} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void circle(double x, double y, double radius) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(radius, "radius");
+        validateNonnegative(radius, "radius");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*radius);
+        double hs = factorY(2*radius);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled circle of the specified radius, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the circle
+     * @param  y the <em>y</em>-coordinate of the center of the circle
+     * @param  radius the radius of the circle
+     * @throws IllegalArgumentException if {@code radius} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void filledCircle(double x, double y, double radius) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(radius, "radius");
+        validateNonnegative(radius, "radius");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*radius);
+        double hs = factorY(2*radius);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+
+    /**
+     * Draws an ellipse with the specified semimajor and semiminor axes,
+     * centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the ellipse
+     * @param  y the <em>y</em>-coordinate of the center of the ellipse
+     * @param  semiMajorAxis is the semimajor axis of the ellipse
+     * @param  semiMinorAxis is the semiminor axis of the ellipse
+     * @throws IllegalArgumentException if either {@code semiMajorAxis}
+     *         or {@code semiMinorAxis} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void ellipse(double x, double y, double semiMajorAxis, double semiMinorAxis) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(semiMajorAxis, "semimajor axis");
+        validate(semiMinorAxis, "semiminor axis");
+        validateNonnegative(semiMajorAxis, "semimajor axis");
+        validateNonnegative(semiMinorAxis, "semiminor axis");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*semiMajorAxis);
+        double hs = factorY(2*semiMinorAxis);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled ellipse with the specified semimajor and semiminor axes,
+     * centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the ellipse
+     * @param  y the <em>y</em>-coordinate of the center of the ellipse
+     * @param  semiMajorAxis is the semimajor axis of the ellipse
+     * @param  semiMinorAxis is the semiminor axis of the ellipse
+     * @throws IllegalArgumentException if either {@code semiMajorAxis}
+     *         or {@code semiMinorAxis} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void filledEllipse(double x, double y, double semiMajorAxis, double semiMinorAxis) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(semiMajorAxis, "semimajor axis");
+        validate(semiMinorAxis, "semiminor axis");
+        validateNonnegative(semiMajorAxis, "semimajor axis");
+        validateNonnegative(semiMinorAxis, "semiminor axis");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*semiMajorAxis);
+        double hs = factorY(2*semiMinorAxis);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Ellipse2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+
+    /**
+     * Draws a circular arc of the specified radius,
+     * centered at (<em>x</em>, <em>y</em>), from angle1 to angle2 (in degrees).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the circle
+     * @param  y the <em>y</em>-coordinate of the center of the circle
+     * @param  radius the radius of the circle
+     * @param  angle1 the starting angle. 0 would mean an arc beginning at 3 o'clock.
+     * @param  angle2 the angle at the end of the arc. For example, if
+     *         you want a 90 degree arc, then angle2 should be angle1 + 90.
+     * @throws IllegalArgumentException if {@code radius} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void arc(double x, double y, double radius, double angle1, double angle2) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(radius, "arc radius");
+        validate(angle1, "angle1");
+        validate(angle2, "angle2");
+        validateNonnegative(radius, "arc radius");
+
+        while (angle2 < angle1) angle2 += 360;
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*radius);
+        double hs = factorY(2*radius);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Arc2D.Double(xs - ws/2, ys - hs/2, ws, hs, angle1, angle2 - angle1, Arc2D.OPEN));
+        draw();
+    }
+
+    /**
+     * Draws a square of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the square
+     * @param  y the <em>y</em>-coordinate of the center of the square
+     * @param  halfLength one half the length of any side of the square
+     * @throws IllegalArgumentException if {@code halfLength} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void square(double x, double y, double halfLength) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfLength, "halfLength");
+        validateNonnegative(halfLength, "half length");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfLength);
+        double hs = factorY(2*halfLength);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled square of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the square
+     * @param  y the <em>y</em>-coordinate of the center of the square
+     * @param  halfLength one half the length of any side of the square
+     * @throws IllegalArgumentException if {@code halfLength} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void filledSquare(double x, double y, double halfLength) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfLength, "halfLength");
+        validateNonnegative(halfLength, "half length");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfLength);
+        double hs = factorY(2*halfLength);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+
+    /**
+     * Draws a rectangle of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the rectangle
+     * @param  y the <em>y</em>-coordinate of the center of the rectangle
+     * @param  halfWidth one half the width of the rectangle
+     * @param  halfHeight one half the height of the rectangle
+     * @throws IllegalArgumentException if either {@code halfWidth} or {@code halfHeight} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void rectangle(double x, double y, double halfWidth, double halfHeight) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfWidth, "halfWidth");
+        validate(halfHeight, "halfHeight");
+        validateNonnegative(halfWidth, "half width");
+        validateNonnegative(halfHeight, "half height");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfWidth);
+        double hs = factorY(2*halfHeight);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.draw(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+    /**
+     * Draws a filled rectangle of the specified size, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the center of the rectangle
+     * @param  y the <em>y</em>-coordinate of the center of the rectangle
+     * @param  halfWidth one half the width of the rectangle
+     * @param  halfHeight one half the height of the rectangle
+     * @throws IllegalArgumentException if either {@code halfWidth} or {@code halfHeight} is negative
+     * @throws IllegalArgumentException if any argument is either NaN or infinite
+     */
+    public static void filledRectangle(double x, double y, double halfWidth, double halfHeight) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(halfWidth, "halfWidth");
+        validate(halfHeight, "halfHeight");
+        validateNonnegative(halfWidth, "half width");
+        validateNonnegative(halfHeight, "half height");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(2*halfWidth);
+        double hs = factorY(2*halfHeight);
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else offscreen.fill(new Rectangle2D.Double(xs - ws/2, ys - hs/2, ws, hs));
+        draw();
+    }
+
+
+    /**
+     * Draws a polygon with the vertices 
+     * (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),
+     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ...,
+     * (<em>x</em><sub><em>n</em>‚Äì1</sub>, <em>y</em><sub><em>n</em>‚Äì1</sub>).
+     *
+     * @param  x an array of all the <em>x</em>-coordinates of the polygon
+     * @param  y an array of all the <em>y</em>-coordinates of the polygon
+     * @throws IllegalArgumentException unless {@code x[]} and {@code y[]}
+     *         are of the same length
+     * @throws IllegalArgumentException if any coordinate is either NaN or infinite
+     * @throws IllegalArgumentException if either {@code x[]} or {@code y[]} is {@code null}
+     */
+    public static void polygon(double[] x, double[] y) {
+        validateNotNull(x, "x-coordinate array");
+        validateNotNull(y, "y-coordinate array");
+        for (int i = 0; i < x.length; i++) validate(x[i], "x[" + i + "]");
+        for (int i = 0; i < y.length; i++) validate(y[i], "y[" + i + "]");
+
+        int n1 = x.length;
+        int n2 = y.length;
+        if (n1 != n2) throw new IllegalArgumentException("arrays must be of the same length");
+        int n = n1;
+        if (n == 0) return;
+
+        GeneralPath path = new GeneralPath();
+        path.moveTo((float) scaleX(x[0]), (float) scaleY(y[0]));
+        for (int i = 0; i < n; i++)
+            path.lineTo((float) scaleX(x[i]), (float) scaleY(y[i]));
+        path.closePath();
+        offscreen.draw(path);
+        draw();
+    }
+
+    /**
+     * Draws a filled polygon with the vertices 
+     * (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>),
+     * (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), ...,
+     * (<em>x</em><sub><em>n</em>‚Äì1</sub>, <em>y</em><sub><em>n</em>‚Äì1</sub>).
+     *
+     * @param  x an array of all the <em>x</em>-coordinates of the polygon
+     * @param  y an array of all the <em>y</em>-coordinates of the polygon
+     * @throws IllegalArgumentException unless {@code x[]} and {@code y[]}
+     *         are of the same length
+     * @throws IllegalArgumentException if any coordinate is either NaN or infinite
+     * @throws IllegalArgumentException if either {@code x[]} or {@code y[]} is {@code null}
+     */
+    public static void filledPolygon(double[] x, double[] y) {
+        validateNotNull(x, "x-coordinate array");
+        validateNotNull(y, "y-coordinate array");
+        for (int i = 0; i < x.length; i++) validate(x[i], "x[" + i + "]");
+        for (int i = 0; i < y.length; i++) validate(y[i], "y[" + i + "]");
+
+        int n1 = x.length;
+        int n2 = y.length;
+        if (n1 != n2) throw new IllegalArgumentException("arrays must be of the same length");
+        int n = n1;
+        if (n == 0) return;
+
+        GeneralPath path = new GeneralPath();
+        path.moveTo((float) scaleX(x[0]), (float) scaleY(y[0]));
+        for (int i = 0; i < n; i++)
+            path.lineTo((float) scaleX(x[i]), (float) scaleY(y[i]));
+        path.closePath();
+        offscreen.fill(path);
+        draw();
+    }
+
+
+   /***************************************************************************
+    *  Drawing images.
+    ***************************************************************************/
+    // get an image from the given filename
+    private static Image getImage(String filename) {
+        if (filename == null) throw new IllegalArgumentException();
+
+        // to read from file
+        ImageIcon icon = new ImageIcon(filename);
+
+        // try to read from URL
+        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
+            try {
+                URL url = new URL(filename);
+                icon = new ImageIcon(url);
+            }
+            catch (MalformedURLException e) {
+                /* not a url */
+            }
+        }
+
+        // in case file is inside a .jar (classpath relative to StdDraw)
+        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
+            URL url = StdDraw.class.getResource(filename);
+            if (url != null)
+                icon = new ImageIcon(url);
+        }
+
+        // in case file is inside a .jar (classpath relative to root of jar)
+        if ((icon == null) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
+            URL url = StdDraw.class.getResource("/" + filename);
+            if (url == null) throw new IllegalArgumentException("image " + filename + " not found");
+            icon = new ImageIcon(url);
+        }
+
+        return icon.getImage();
+    }
+
+   /***************************************************************************
+    * [Summer 2016] Should we update to use ImageIO instead of ImageIcon()?
+    *               Seems to have some issues loading images on some systems
+    *               and slows things down on other systems.
+    *               especially if you don't call ImageIO.setUseCache(false)
+    *               One advantage is that it returns a BufferedImage.
+    ***************************************************************************/
+/*
+    private static BufferedImage getImage(String filename) {
+        if (filename == null) throw new IllegalArgumentException();
+
+        // from a file or URL
+        try {
+            URL url = new URL(filename);
+            BufferedImage image = ImageIO.read(url);
+            return image;
+        } 
+        catch (IOException e) {
+            // ignore
+        }
+
+        // in case file is inside a .jar (classpath relative to StdDraw)
+        try {
+            URL url = StdDraw.class.getResource(filename);
+            BufferedImage image = ImageIO.read(url);
+            return image;
+        } 
+        catch (IOException e) {
+            // ignore
+        }
+
+        // in case file is inside a .jar (classpath relative to root of jar)
+        try {
+            URL url = StdDraw.class.getResource("/" + filename);
+            BufferedImage image = ImageIO.read(url);
+            return image;
+        } 
+        catch (IOException e) {
+            // ignore
+        }
+        throw new IllegalArgumentException("image " + filename + " not found");
+    }
+*/
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>).
+     * The supported image formats are JPEG, PNG, and GIF.
+     * As an optimization, the picture is cached, so there is no performance
+     * penalty for redrawing the same image multiple times (e.g., in an animation).
+     * However, if you change the picture file after drawing it, subsequent
+     * calls will draw the original picture.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @throws IllegalArgumentException if the image filename is invalid
+     * @throws IllegalArgumentException if either {@code x} or {@code y} is either NaN or infinite
+     */
+    public static void picture(double x, double y, String filename) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(filename, "filename");
+
+        // BufferedImage image = getImage(filename);
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        // int ws = image.getWidth();    // can call only if image is a BufferedImage
+        // int hs = image.getHeight();
+        int ws = image.getWidth(null);
+        int hs = image.getHeight(null);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+
+        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0), (int) Math.round(ys - hs/2.0), null);
+        draw();
+    }
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>),
+     * rotated given number of degrees.
+     * The supported image formats are JPEG, PNG, and GIF.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @param  degrees is the number of degrees to rotate counterclockwise
+     * @throws IllegalArgumentException if the image filename is invalid
+     * @throws IllegalArgumentException if {@code x}, {@code y}, {@code degrees} is NaN or infinite
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public static void picture(double x, double y, String filename, double degrees) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(degrees, "degrees");
+        validateNotNull(filename, "filename");
+
+        // BufferedImage image = getImage(filename);
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        // int ws = image.getWidth();    // can call only if image is a BufferedImage
+        // int hs = image.getHeight();
+        int ws = image.getWidth(null);
+        int hs = image.getHeight(null);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+
+        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
+        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0), (int) Math.round(ys - hs/2.0), null);
+        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
+
+        draw();
+    }
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>),
+     * rescaled to the specified bounding box.
+     * The supported image formats are JPEG, PNG, and GIF.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @param  scaledWidth the width of the scaled image (in screen coordinates)
+     * @param  scaledHeight the height of the scaled image (in screen coordinates)
+     * @throws IllegalArgumentException if either {@code scaledWidth}
+     *         or {@code scaledHeight} is negative
+     * @throws IllegalArgumentException if the image filename is invalid
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public static void picture(double x, double y, String filename, double scaledWidth, double scaledHeight) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(scaledWidth, "scaled width");
+        validate(scaledHeight, "scaled height");
+        validateNotNull(filename, "filename");
+        validateNonnegative(scaledWidth, "scaled width");
+        validateNonnegative(scaledHeight, "scaled height");
+
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(scaledWidth);
+        double hs = factorY(scaledHeight);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+        else {
+            offscreen.drawImage(image, (int) Math.round(xs - ws/2.0),
+                                       (int) Math.round(ys - hs/2.0),
+                                       (int) Math.round(ws),
+                                       (int) Math.round(hs), null);
+        }
+        draw();
+    }
+
+
+    /**
+     * Draws the specified image centered at (<em>x</em>, <em>y</em>), rotated
+     * given number of degrees, and rescaled to the specified bounding box.
+     * The supported image formats are JPEG, PNG, and GIF.
+     *
+     * @param  x the center <em>x</em>-coordinate of the image
+     * @param  y the center <em>y</em>-coordinate of the image
+     * @param  filename the name of the image/picture, e.g., "ball.gif"
+     * @param  scaledWidth the width of the scaled image (in screen coordinates)
+     * @param  scaledHeight the height of the scaled image (in screen coordinates)
+     * @param  degrees is the number of degrees to rotate counterclockwise
+     * @throws IllegalArgumentException if either {@code scaledWidth}
+     *         or {@code scaledHeight} is negative
+     * @throws IllegalArgumentException if the image filename is invalid
+     */
+    public static void picture(double x, double y, String filename, double scaledWidth, double scaledHeight, double degrees) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(scaledWidth, "scaled width");
+        validate(scaledHeight, "scaled height");
+        validate(degrees, "degrees");
+        validateNotNull(filename, "filename");
+        validateNonnegative(scaledWidth, "scaled width");
+        validateNonnegative(scaledHeight, "scaled height");
+
+        Image image = getImage(filename);
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        double ws = factorX(scaledWidth);
+        double hs = factorY(scaledHeight);
+        if (ws < 0 || hs < 0) throw new IllegalArgumentException("image " + filename + " is corrupt");
+        if (ws <= 1 && hs <= 1) pixel(x, y);
+
+        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
+        offscreen.drawImage(image, (int) Math.round(xs - ws/2.0),
+                                   (int) Math.round(ys - hs/2.0),
+                                   (int) Math.round(ws),
+                                   (int) Math.round(hs), null);
+        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
+
+        draw();
+    }
+
+   /***************************************************************************
+    *  Drawing text.
+    ***************************************************************************/
+
+    /**
+     * Writes the given text string in the current font, centered at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the center <em>x</em>-coordinate of the text
+     * @param  y the center <em>y</em>-coordinate of the text
+     * @param  text the text to write
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    public static void text(double x, double y, String text) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(text, "text");
+
+        offscreen.setFont(font);
+        FontMetrics metrics = offscreen.getFontMetrics();
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int ws = metrics.stringWidth(text);
+        int hs = metrics.getDescent();
+        offscreen.drawString(text, (float) (xs - ws/2.0), (float) (ys + hs));
+        draw();
+    }
+
+    /**
+     * Writes the given text string in the current font, centered at (<em>x</em>, <em>y</em>) and
+     * rotated by the specified number of degrees.
+     * @param  x the center <em>x</em>-coordinate of the text
+     * @param  y the center <em>y</em>-coordinate of the text
+     * @param  text the text to write
+     * @param  degrees is the number of degrees to rotate counterclockwise
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x}, {@code y}, or {@code degrees} is either NaN or infinite
+     */
+    public static void text(double x, double y, String text, double degrees) {
+        validate(x, "x");
+        validate(y, "y");
+        validate(degrees, "degrees");
+        validateNotNull(text, "text");
+
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
+        text(x, y, text);
+        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
+    }
+
+
+    /**
+     * Writes the given text string in the current font, left-aligned at (<em>x</em>, <em>y</em>).
+     * @param  x the <em>x</em>-coordinate of the text
+     * @param  y the <em>y</em>-coordinate of the text
+     * @param  text the text
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    public static void textLeft(double x, double y, String text) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(text, "text");
+
+        offscreen.setFont(font);
+        FontMetrics metrics = offscreen.getFontMetrics();
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int hs = metrics.getDescent();
+        offscreen.drawString(text, (float) xs, (float) (ys + hs));
+        draw();
+    }
+
+    /**
+     * Writes the given text string in the current font, right-aligned at (<em>x</em>, <em>y</em>).
+     *
+     * @param  x the <em>x</em>-coordinate of the text
+     * @param  y the <em>y</em>-coordinate of the text
+     * @param  text the text to write
+     * @throws IllegalArgumentException if {@code text} is {@code null}
+     * @throws IllegalArgumentException if {@code x} or {@code y} is either NaN or infinite
+     */
+    public static void textRight(double x, double y, String text) {
+        validate(x, "x");
+        validate(y, "y");
+        validateNotNull(text, "text");
+
+        offscreen.setFont(font);
+        FontMetrics metrics = offscreen.getFontMetrics();
+        double xs = scaleX(x);
+        double ys = scaleY(y);
+        int ws = metrics.stringWidth(text);
+        int hs = metrics.getDescent();
+        offscreen.drawString(text, (float) (xs - ws), (float) (ys + hs));
+        draw();
+    }
+
+
+    /**
+     * Copies the offscreen buffer to the onscreen buffer, pauses for t milliseconds
+     * and enables double buffering.
+     * @param t number of milliseconds
+     * @deprecated replaced by {@link #enableDoubleBuffering()}, {@link #show()}, and {@link #pause(int t)}
+     */
+    @Deprecated
+    public static void show(int t) {
+        validateNonnegative(t, "t");
+        show();
+        pause(t);
+        enableDoubleBuffering();
+    }
+
+    /**
+     * Pauses for t milliseconds. This method is intended to support computer animations.
+     * @param t number of milliseconds
+     */
+    public static void pause(int t) {
+        validateNonnegative(t, "t");
+        try {
+            Thread.sleep(t);
+        }
+        catch (InterruptedException e) {
+            System.out.println("Error sleeping");
+        }
+    }
+
+    /**
+     * Copies offscreen buffer to onscreen buffer. There is no reason to call
+     * this method unless double buffering is enabled.
+     */
+    public static void show() {
+        onscreen.drawImage(offscreenImage, 0, 0, null);
+        frame.repaint();
+    }
+
+    // draw onscreen if defer is false
+    private static void draw() {
+        if (!defer) show();
+    }
+
+    /**
+     * Enables double buffering. All subsequent calls to 
+     * drawing methods such as {@code line()}, {@code circle()},
+     * and {@code square()} will be deferred until the next call
+     * to show(). Useful for animations.
+     */
+    public static void enableDoubleBuffering() {
+        defer = true;
+    }
+
+    /**
+     * Disables double buffering. All subsequent calls to 
+     * drawing methods such as {@code line()}, {@code circle()},
+     * and {@code square()} will be displayed on screen when called.
+     * This is the default.
+     */
+    public static void disableDoubleBuffering() {
+        defer = false;
+    }
+
+
+   /***************************************************************************
+    *  Save drawing to a file.
+    ***************************************************************************/
+
+    /**
+     * Saves the drawing to using the specified filename.
+     * The supported image formats are JPEG and PNG;
+     * the filename suffix must be {@code .jpg} or {@code .png}.
+     *
+     * @param  filename the name of the file with one of the required suffixes
+     * @throws IllegalArgumentException if {@code filename} is {@code null}
+     */
+    public static void save(String filename) {
+        validateNotNull(filename, "filename");
+        File file = new File(filename);
+        String suffix = filename.substring(filename.lastIndexOf('.') + 1);
+
+        // png files
+        if ("png".equalsIgnoreCase(suffix)) {
+            try {
+                ImageIO.write(onscreenImage, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // need to change from ARGB to RGB for JPEG
+        // reference: http://archives.java.sun.com/cgi-bin/wa?A2=ind0404&L=java2d-interest&D=0&P=2727
+        else if ("jpg".equalsIgnoreCase(suffix)) {
+            WritableRaster raster = onscreenImage.getRaster();
+            WritableRaster newRaster;
+            newRaster = raster.createWritableChild(0, 0, width, height, 0, 0, new int[] {0, 1, 2});
+            DirectColorModel cm = (DirectColorModel) onscreenImage.getColorModel();
+            DirectColorModel newCM = new DirectColorModel(cm.getPixelSize(),
+                                                          cm.getRedMask(),
+                                                          cm.getGreenMask(),
+                                                          cm.getBlueMask());
+            BufferedImage rgbBuffer = new BufferedImage(newCM, newRaster, false,  null);
+            try {
+                ImageIO.write(rgbBuffer, suffix, file);
+            }
+            catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        else {
+            System.out.println("Invalid image file type: " + suffix);
+        }
+    }
+
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void actionPerformed(ActionEvent e) {
+        FileDialog chooser = new FileDialog(StdDraw.frame, "Use a .png or .jpg extension", FileDialog.SAVE);
+        chooser.setVisible(true);
+        String filename = chooser.getFile();
+        if (filename != null) {
+            StdDraw.save(chooser.getDirectory() + File.separator + chooser.getFile());
+        }
+    }
+
+
+   /***************************************************************************
+    *  Mouse interactions.
+    ***************************************************************************/
+
+    /**
+     * Returns true if the mouse is being pressed.
+     *
+     * @return {@code true} if the mouse is being pressed; {@code false} otherwise
+     */
+    public static boolean isMousePressed() {
+        synchronized (mouseLock) {
+            return isMousePressed;
+        }
+    }
+
+    /**
+     * Returns true if the mouse is being pressed.
+     *
+     * @return {@code true} if the mouse is being pressed; {@code false} otherwise
+     * @deprecated replaced by {@link #isMousePressed()}
+     */
+    @Deprecated
+    public static boolean mousePressed() {
+        synchronized (mouseLock) {
+            return isMousePressed;
+        }
+    }
+
+    /**
+     * Returns the <em>x</em>-coordinate of the mouse.
+     *
+     * @return the <em>x</em>-coordinate of the mouse
+     */
+    public static double mouseX() {
+        synchronized (mouseLock) {
+            return mouseX;
+        }
+    }
+
+    /**
+     * Returns the <em>y</em>-coordinate of the mouse.
+     *
+     * @return <em>y</em>-coordinate of the mouse
+     */
+    public static double mouseY() {
+        synchronized (mouseLock) {
+            return mouseY;
+        }
+    }
+
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseClicked(MouseEvent e) {
+        // this body is intentionally left empty
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseEntered(MouseEvent e) {
+        // this body is intentionally left empty
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseExited(MouseEvent e) {
+        // this body is intentionally left empty
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mousePressed(MouseEvent e) {
+        synchronized (mouseLock) {
+            mouseX = StdDraw.userX(e.getX());
+            mouseY = StdDraw.userY(e.getY());
+            isMousePressed = true;
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseReleased(MouseEvent e) {
+        synchronized (mouseLock) {
+            isMousePressed = false;
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseDragged(MouseEvent e)  {
+        synchronized (mouseLock) {
+            mouseX = StdDraw.userX(e.getX());
+            mouseY = StdDraw.userY(e.getY());
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void mouseMoved(MouseEvent e) {
+        synchronized (mouseLock) {
+            mouseX = StdDraw.userX(e.getX());
+            mouseY = StdDraw.userY(e.getY());
+        }
+    }
+
+
+   /***************************************************************************
+    *  Keyboard interactions.
+    ***************************************************************************/
+
+    /**
+     * Returns true if the user has typed a key (that has not yet been processed).
+     *
+     * @return {@code true} if the user has typed a key (that has not yet been processed
+     *         by {@link #nextKeyTyped()}; {@code false} otherwise
+     */
+    public static boolean hasNextKeyTyped() {
+        synchronized (keyLock) {
+            return !keysTyped.isEmpty();
+        }
+    }
+
+    /**
+     * Returns the next key that was typed by the user (that your program has not already processed).
+     * This method should be preceded by a call to {@link #hasNextKeyTyped()} to ensure
+     * that there is a next key to process.
+     * This method returns a Unicode character corresponding to the key
+     * typed (such as {@code 'a'} or {@code 'A'}).
+     * It cannot identify action keys (such as F1 and arrow keys)
+     * or modifier keys (such as control).
+     *
+     * @return the next key typed by the user (that your program has not already processed).
+     * @throws NoSuchElementException if there is no remaining key
+     */
+    public static char nextKeyTyped() {
+        synchronized (keyLock) {
+            if (keysTyped.isEmpty()) {
+                throw new NoSuchElementException("your program has already processed all keystrokes");
+            }
+            return keysTyped.remove(keysTyped.size() - 1);
+            // return keysTyped.removeLast();
+        }
+    }
+
+    /**
+     * Returns true if the given key is being pressed.
+     * <p>
+     * This method takes the keycode (corresponding to a physical key)
+    *  as an argument. It can handle action keys
+     * (such as F1 and arrow keys) and modifier keys (such as shift and control).
+     * See {@link KeyEvent} for a description of key codes.
+     *
+     * @param  keycode the key to check if it is being pressed
+     * @return {@code true} if {@code keycode} is currently being pressed;
+     *         {@code false} otherwise
+     */
+    public static boolean isKeyPressed(int keycode) {
+        synchronized (keyLock) {
+            return keysDown.contains(keycode);
+        }
+    }
+
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void keyTyped(KeyEvent e) {
+        synchronized (keyLock) {
+            keysTyped.addFirst(e.getKeyChar());
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void keyPressed(KeyEvent e) {
+        synchronized (keyLock) {
+            keysDown.add(e.getKeyCode());
+        }
+    }
+
+    /**
+     * This method cannot be called directly.
+     */
+    @Override
+    public void keyReleased(KeyEvent e) {
+        synchronized (keyLock) {
+            keysDown.remove(e.getKeyCode());
+        }
+    }
+
+
+   /***************************************************************************
+    *  For improved resolution on Mac Retina displays.
+    ***************************************************************************/
+
+    private static class RetinaImageIcon extends ImageIcon {
+    
+        public RetinaImageIcon(Image image) {
+            super(image);
+        }
+
+        public int getIconWidth() {
+            return super.getIconWidth() / 2;
+        }
+
+        /**
+         * Gets the height of the icon.
+         *
+         * @return the height in pixels of this icon
+         */
+        public int getIconHeight() {
+            return super.getIconHeight() / 2;
+        }
+
+        public synchronized void paintIcon(Component c, Graphics g, int x, int y) {
+            Graphics2D g2 = (Graphics2D) g.create();
+            g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
+            g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
+            g2.scale(0.5, 0.5);
+            super.paintIcon(c, g2, x * 2, y * 2);
+            g2.dispose();
+        }
+    }
+
+
+    /**
+     * Test client.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        StdDraw.square(0.2, 0.8, 0.1);
+        StdDraw.filledSquare(0.8, 0.8, 0.2);
+        StdDraw.circle(0.8, 0.2, 0.2);
+
+        StdDraw.setPenColor(StdDraw.BOOK_RED);
+        StdDraw.setPenRadius(0.02);
+        StdDraw.arc(0.8, 0.2, 0.1, 200, 45);
+
+        // draw a blue diamond
+        StdDraw.setPenRadius();
+        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
+        double[] x = { 0.1, 0.2, 0.3, 0.2 };
+        double[] y = { 0.2, 0.3, 0.2, 0.1 };
+        StdDraw.filledPolygon(x, y);
+
+        // text
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.text(0.2, 0.5, "black text");
+        StdDraw.setPenColor(StdDraw.WHITE);
+        StdDraw.text(0.8, 0.8, "white text");
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdIn.java b/src/main/java/edu/princeton/cs/algs4/StdIn.java
new file mode 100644
index 0000000..2b75f4b
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdIn.java
@@ -0,0 +1,696 @@
+/******************************************************************************
+ *  Compilation:  javac StdIn.java
+ *  Execution:    java StdIn   (interactive test of basic functionality)
+ *  Dependencies: none
+ *
+ *  Reads in data of various types from standard input.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.ArrayList;
+import java.util.InputMismatchException;
+import java.util.Locale;
+import java.util.NoSuchElementException;
+import java.util.Scanner;
+import java.util.regex.Pattern;
+
+/**
+ *  The {@code StdIn} class provides static methods for reading strings
+ *  and numbers from standard input.
+ *  These functions fall into one of four categories:
+ *  <ul>
+ *  <li>those for reading individual tokens from standard input, one at a time,
+ *      and converting each to a number, string, or boolean
+ *  <li>those for reading characters from standard input, one at a time
+ *  <li>those for reading lines from standard input, one at a time
+ *  <li>those for reading a sequence of values of the same type from standard input,
+ *      and returning the values in an array
+ *  </ul>
+ *  <p>
+ *  Generally, it is best not to mix functions from the different
+ *  categories in the same program.
+ *  <p>
+ *  <b>Getting started.</b>
+ *  To use this class, you must have {@code StdIn.class} in your
+ *  Java classpath. If you used our autoinstaller, you should be all set.
+ *  Otherwise, either download
+ *  <a href = "https://introcs.cs.princeton.edu/java/code/stdlib.jar">stdlib.jar</a>
+ *  and add to your Java classpath or download
+ *  <a href = "https://introcs.cs.princeton.edu/java/stdlib/StdIn.java">StdIn.java</a>
+ *  and put a copy in your working directory.
+ *  <p>
+ *  <b>Reading tokens from standard input and converting to numbers and strings.</b>
+ *  You can use the following methods to read numbers, strings, and booleans
+ *  from standard input one at a time:
+ *  <ul>
+ *  <li> {@link #isEmpty()}
+ *  <li> {@link #readInt()}
+ *  <li> {@link #readDouble()}
+ *  <li> {@link #readString()}
+ *  <li> {@link #readShort()}
+ *  <li> {@link #readLong()}
+ *  <li> {@link #readFloat()}
+ *  <li> {@link #readByte()}
+ *  <li> {@link #readBoolean()}
+ *  </ul>
+ *  <p>
+ *  The first method returns true if standard input has no more tokens.
+ *  Each other method skips over any input that is whitespace. Then, it reads
+ *  the next token and attempts to convert it into a value of the specified
+ *  type. If it succeeds, it returns that value; otherwise, it
+ *  throws an {@link InputMismatchException}.
+ *  <p>
+ *  <em>Whitespace</em> includes spaces, tabs, and newlines; the full definition
+ *  is inherited from {@link Character#isWhitespace(char)}.
+ *  A <em>token</em> is a maximal sequence of non-whitespace characters.
+ *  The precise rules for describing which tokens can be converted to
+ *  integers and floating-point numbers are inherited from
+ *  <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#number-syntax">Scanner</a>,
+ *  using the locale {@link Locale#US}; the rules
+ *  for floating-point numbers are slightly different
+ *  from those in {@link Double#valueOf(String)},
+ *  but unlikely to be of concern to most programmers.
+ *  <p>
+ *  As an example, the following code fragment reads integers from standard input,
+ *  one at a time, and prints them one per line.
+ *  <pre>
+ *  while (!StdIn.isEmpty()) {
+ *      double value = StdIn.readDouble();
+ *      StdOut.println(value);
+ *  }
+ *  </pre>
+ *  <p>
+ *  <b>Reading characters from standard input.</b>
+ *  You can use the following two methods to read characters from standard input one at a time:
+ *  <ul>
+ *  <li> {@link #hasNextChar()}
+ *  <li> {@link #readChar()}
+ *  </ul>
+ *  <p>
+ *  The first method returns true if standard input has more input (including whitespace).
+ *  The second method reads and returns the next character of input on standard 
+ *  input (possibly a whitespace character).
+ *  <p>
+ *  As an example, the following code fragment reads characters from standard input,
+ *  one character at a time, and prints it to standard output.
+ *  <pre>
+ *  while (StdIn.hasNextChar()) {
+ *      char c = StdIn.readChar();
+ *      StdOut.print(c);
+ *  }
+ *  </pre>
+ *  <p>
+ *  <b>Reading lines from standard input.</b>
+ *  You can use the following two methods to read lines from standard input:
+ *  <ul>
+ *  <li> {@link #hasNextLine()}
+ *  <li> {@link #readLine()}
+ *  </ul>
+ *  <p>
+ *  The first method returns true if standard input has more input (including whitespace).
+ *  The second method reads and returns the remaining portion of 
+ *  the next line of input on standard input (possibly whitespace),
+ *  discarding the trailing line separator.
+ *  <p>
+ *  A <em>line separator</em> is defined to be one of the following strings:
+ *  {@code \n} (Linux), {@code \r} (old Macintosh),
+ *  {@code \r\n} (Windows),
+ *  {@code \}{@code u2028}, {@code \}{@code u2029}, or {@code \}{@code u0085}.
+ *  <p>
+ *  As an example, the following code fragment reads text from standard input,
+ *  one line at a time, and prints it to standard output.
+ *  <pre>
+ *  while (StdIn.hasNextLine()) {
+ *      String line = StdIn.readLine();
+ *      StdOut.println(line);
+ *  }
+ *  </pre>
+ *  <p>
+ *  <b>Reading a sequence of values of the same type from standard input.</b>
+ *  You can use the following methods to read a sequence numbers, strings,
+ *  or booleans (all of the same type) from standard input:
+ *  <ul>
+ *  <li> {@link #readAllDoubles()}
+ *  <li> {@link #readAllInts()}
+ *  <li> {@link #readAllLongs()}
+ *  <li> {@link #readAllStrings()}
+ *  <li> {@link #readAllLines()}
+ *  <li> {@link #readAll()}
+ *  </ul>
+ *  <p>
+ *  The first three methods read of all of remaining token on standard input
+ *  and converts the tokens to values of
+ *  the specified type, as in the corresponding
+ *  {@code readDouble}, {@code readInt}, and {@code readString()} methods.
+ *  The {@code readAllLines()} method reads all remaining lines on standard
+ *  input and returns them as an array of strings.
+ *  The {@code readAll()} method reads all remaining input on standard
+ *  input and returns it as a string.
+ *  <p>
+ *  As an example, the following code fragment reads all of the remaining
+ *  tokens from standard input and returns them as an array of strings.
+ *  <pre>
+ *  String[] words = StdIn.readAllStrings();
+ *  </pre>
+ *  <p>
+ *  <b>Differences with Scanner.</b>
+ *  {@code StdIn} and {@link Scanner} are both designed to parse 
+ *  tokens and convert them to primitive types and strings.
+ *  The main differences are summarized below:
+ *  <ul>
+ *  <li> {@code StdIn} is a set of static methods and reads 
+ *       reads input from only standard input. It is suitable for use before
+ *       a programmer knows about objects.
+ *       See {@link In} for an object-oriented version that handles
+ *       input from files, URLs,
+ *       and sockets.
+ *  <li> {@code StdIn} uses whitespace as the delimiter pattern
+ *       that separates tokens.
+ *       {@link Scanner} supports arbitrary delimiter patterns.
+ *  <li> {@code StdIn} coerces the character-set encoding to UTF-8,
+ *       which is the most widely used character encoding for Unicode.
+ *  <li> {@code StdIn} coerces the locale to {@link Locale#US},
+ *       for consistency with {@link StdOut}, {@link Double#parseDouble(String)},
+ *       and floating-point literals.
+ *  <li> {@code StdIn} has convenient methods for reading a single
+ *       character; reading in sequences of integers, doubles, or strings;
+ *       and reading in all of the remaining input.
+ *  </ul>
+ *  <p>
+ *  Historical note: {@code StdIn} preceded {@code Scanner}; when
+ *  {@code Scanner} was introduced, this class was re-implemented to use {@code Scanner}.
+ *  <p>
+ *  <b>Using standard input.</b>
+ *  Standard input is a fundamental operating system abstraction on Mac OS X,
+ *  Windows, and Linux.
+ *  The methods in {@code StdIn} are <em>blocking</em>, which means that they
+ *  will wait until you enter input on standard input.
+ *  If your program has a loop that repeats until standard input is empty,
+ *  you must signal that the input is finished.
+ *  To do so, depending on your operating system and IDE, 
+ *  use either {@code <Ctrl-d>} or {@code <Ctrl-z>}, on its own line.
+ *  If you are redirecting standard input from a file, you will not need
+ *  to do anything to signal that the input is finished.
+ *  <p>
+ *  <b>Known bugs.</b>
+ *  Java's UTF-8 encoding does not recognize the optional 
+ *  <a href = "http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058">byte-order mask</a>.
+ *  If the input begins with the optional byte-order mask, {@code StdIn}
+ *  will have an extra character {@code \}{@code uFEFF} at the beginning.
+ *  <p>
+ *  <b>Reference.</b> 
+ *  For additional documentation,
+ *  see <a href="https://introcs.cs.princeton.edu/15inout">Section 1.5</a> of   
+ *  <em>Computer Science: An Interdisciplinary Approach</em>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ *  @author David Pritchard
+ */
+public final class StdIn {
+
+    /*** begin: section (1 of 2) of code duplicated from In to StdIn. */
+    
+    // assume Unicode UTF-8 encoding
+    private static final String CHARSET_NAME = "UTF-8";
+
+    // assume language = English, country = US for consistency with System.out.
+    private static final Locale LOCALE = Locale.US;
+
+    // the default token separator; we maintain the invariant that this value
+    // is held by the scanner's delimiter between calls
+    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");
+
+    // makes whitespace significant
+    private static final Pattern EMPTY_PATTERN = Pattern.compile("");
+
+    // used to read the entire input
+    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");
+
+    /*** end: section (1 of 2) of code duplicated from In to StdIn. */
+
+    private static Scanner scanner;
+ 
+    // it doesn't make sense to instantiate this class
+    private StdIn() { }
+
+    //// begin: section (2 of 2) of code duplicated from In to StdIn,
+    //// with all methods changed from "public" to "public static"
+
+   /**
+     * Returns true if standard input is empty (except possibly for whitespace).
+     * Use this method to know whether the next call to {@link #readString()}, 
+     * {@link #readDouble()}, etc will succeed.
+     *
+     * @return {@code true} if standard input is empty (except possibly
+     *         for whitespace); {@code false} otherwise
+     */
+    public static boolean isEmpty() {
+        return !scanner.hasNext();
+    }
+
+   /**
+     * Returns true if standard input has a next line.
+     * Use this method to know whether the
+     * next call to {@link #readLine()} will succeed.
+     * This method is functionally equivalent to {@link #hasNextChar()}.
+     *
+     * @return {@code true} if standard input has more input (including whitespace);
+     *         {@code false} otherwise
+     */
+    public static boolean hasNextLine() {
+        return scanner.hasNextLine();
+    }
+
+    /**
+     * Returns true if standard input has more input (including whitespace).
+     * Use this method to know whether the next call to {@link #readChar()} will succeed.
+     * This method is functionally equivalent to {@link #hasNextLine()}.
+     *
+     * @return {@code true} if standard input has more input (including whitespace);
+     *         {@code false} otherwise
+     */
+    public static boolean hasNextChar() {
+        scanner.useDelimiter(EMPTY_PATTERN);
+        boolean result = scanner.hasNext();
+        scanner.useDelimiter(WHITESPACE_PATTERN);
+        return result;
+    }
+
+
+   /**
+     * Reads and returns the next line, excluding the line separator if present.
+     *
+     * @return the next line, excluding the line separator if present;
+     *         {@code null} if no such line
+     */
+    public static String readLine() {
+        String line;
+        try {
+            line = scanner.nextLine();
+        }
+        catch (NoSuchElementException e) {
+            line = null;
+        }
+        return line;
+    }
+
+    /**
+     * Reads and returns the next character.
+     *
+     * @return the next {@code char}
+     * @throws NoSuchElementException if standard input is empty
+     */
+    public static char readChar() {
+        try {
+            scanner.useDelimiter(EMPTY_PATTERN);
+            String ch = scanner.next();
+            assert ch.length() == 1 : "Internal (Std)In.readChar() error!"
+                + " Please contact the authors.";
+            scanner.useDelimiter(WHITESPACE_PATTERN);
+            return ch.charAt(0);
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'char' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+    }  
+
+
+   /**
+     * Reads and returns the remainder of the input, as a string.
+     *
+     * @return the remainder of the input, as a string
+     * @throws NoSuchElementException if standard input is empty
+     */
+    public static String readAll() {
+        if (!scanner.hasNextLine())
+            return "";
+
+        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
+        // not that important to reset delimeter, since now scanner is empty
+        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
+        return result;
+    }
+
+
+   /**
+     * Reads the next token from standard input and returns it as a {@code String}.
+     *
+     * @return the next {@code String}
+     * @throws NoSuchElementException if standard input is empty
+     */
+    public static String readString() {
+        try {
+            return scanner.next();
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'String' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from standard input, parses it as an integer, and returns the integer.
+     *
+     * @return the next integer on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
+     */
+    public static int readInt() {
+        try {
+            return scanner.nextInt();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read an 'int' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attemps to read an 'int' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+
+    }
+
+   /**
+     * Reads the next token from standard input, parses it as a double, and returns the double.
+     *
+     * @return the next double on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
+     */
+    public static double readDouble() {
+        try {
+            return scanner.nextDouble();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'double' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'double' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from standard input, parses it as a float, and returns the float.
+     *
+     * @return the next float on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
+     */
+    public static float readFloat() {
+        try {
+            return scanner.nextFloat();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'float' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'float' value from standard input, "
+                                           + "but there no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.
+     *
+     * @return the next long integer on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
+     */
+    public static long readLong() {
+        try {
+            return scanner.nextLong();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'long' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'long' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.
+     *
+     * @return the next short integer on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
+     */
+    public static short readShort() {
+        try {
+            return scanner.nextShort();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'short' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'short' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+   /**
+     * Reads the next token from standard input, parses it as a byte, and returns the byte.
+     *
+     * @return the next byte on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
+     */
+    public static byte readByte() {
+        try {
+            return scanner.nextByte();
+        }
+        catch (InputMismatchException e) {
+            String token = scanner.next();
+            throw new InputMismatchException("attempts to read a 'byte' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'byte' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+    }
+
+    /**
+     * Reads the next token from standard input, parses it as a boolean,
+     * and returns the boolean.
+     *
+     * @return the next boolean on standard input
+     * @throws NoSuchElementException if standard input is empty
+     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:
+     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,
+     *    ignoring case
+     */
+    public static boolean readBoolean() {
+        try {
+            String token = readString();
+            if ("true".equalsIgnoreCase(token))  return true;
+            if ("false".equalsIgnoreCase(token)) return false;
+            if ("1".equals(token))               return true;
+            if ("0".equals(token))               return false;
+            throw new InputMismatchException("attempts to read a 'boolean' value from standard input, "
+                                           + "but the next token is \"" + token + "\"");
+        }
+        catch (NoSuchElementException e) {
+            throw new NoSuchElementException("attempts to read a 'boolean' value from standard input, "
+                                           + "but no more tokens are available");
+        }
+
+    }
+
+    /**
+     * Reads all remaining tokens from standard input and returns them as an array of strings.
+     *
+     * @return all remaining tokens on standard input, as an array of strings
+     */
+    public static String[] readAllStrings() {
+        // we could use readAll.trim().split(), but that's not consistent
+        // because trim() uses characters 0x00..0x20 as whitespace
+        String[] tokens = WHITESPACE_PATTERN.split(readAll());
+        if (tokens.length == 0 || tokens[0].length() > 0)
+            return tokens;
+
+        // don't include first token if it is leading whitespace
+        String[] decapitokens = new String[tokens.length-1];
+        for (int i = 0; i < tokens.length - 1; i++)
+            decapitokens[i] = tokens[i+1];
+        return decapitokens;
+    }
+
+    /**
+     * Reads all remaining lines from standard input and returns them as an array of strings.
+     * @return all remaining lines on standard input, as an array of strings
+     */
+    public static String[] readAllLines() {
+        ArrayList<String> lines = new ArrayList<String>();
+        while (hasNextLine()) {
+            lines.add(readLine());
+        }
+        return lines.toArray(new String[lines.size()]);
+    }
+
+    /**
+     * Reads all remaining tokens from standard input, parses them as integers, and returns
+     * them as an array of integers.
+     * @return all remaining integers on standard input, as an array
+     * @throws InputMismatchException if any token cannot be parsed as an {@code int}
+     */
+    public static int[] readAllInts() {
+        String[] fields = readAllStrings();
+        int[] vals = new int[fields.length];
+        for (int i = 0; i < fields.length; i++)
+            vals[i] = Integer.parseInt(fields[i]);
+        return vals;
+    }
+
+    /**
+     * Reads all remaining tokens from standard input, parses them as longs, and returns
+     * them as an array of longs.
+     * @return all remaining longs on standard input, as an array
+     * @throws InputMismatchException if any token cannot be parsed as a {@code long}
+     */
+    public static long[] readAllLongs() {
+        String[] fields = readAllStrings();
+        long[] vals = new long[fields.length];
+        for (int i = 0; i < fields.length; i++)
+            vals[i] = Long.parseLong(fields[i]);
+        return vals;
+    }
+
+    /**
+     * Reads all remaining tokens from standard input, parses them as doubles, and returns
+     * them as an array of doubles.
+     * @return all remaining doubles on standard input, as an array
+     * @throws InputMismatchException if any token cannot be parsed as a {@code double}
+     */
+    public static double[] readAllDoubles() {
+        String[] fields = readAllStrings();
+        double[] vals = new double[fields.length];
+        for (int i = 0; i < fields.length; i++)
+            vals[i] = Double.parseDouble(fields[i]);
+        return vals;
+    }
+    
+    //// end: section (2 of 2) of code duplicated from In to StdIn
+    
+    
+    // do this once when StdIn is initialized
+    static {
+        resync();
+    }
+
+    /**
+     * If StdIn changes, use this to reinitialize the scanner.
+     */
+    private static void resync() {
+        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));
+    }
+    
+    private static void setScanner(Scanner scanner) {
+        StdIn.scanner = scanner;
+        StdIn.scanner.useLocale(LOCALE);
+    }
+
+   /**
+     * Reads all remaining tokens, parses them as integers, and returns
+     * them as an array of integers.
+     * @return all remaining integers, as an array
+     * @throws InputMismatchException if any token cannot be parsed as an {@code int}
+     * @deprecated Replaced by {@link #readAllInts()}.
+     */
+    @Deprecated
+    public static int[] readInts() {
+        return readAllInts();
+    }
+
+   /**
+     * Reads all remaining tokens, parses them as doubles, and returns
+     * them as an array of doubles.
+     * @return all remaining doubles, as an array
+     * @throws InputMismatchException if any token cannot be parsed as a {@code double}
+     * @deprecated Replaced by {@link #readAllDoubles()}.
+     */
+    @Deprecated
+    public static double[] readDoubles() {
+        return readAllDoubles();
+    }
+
+   /**
+     * Reads all remaining tokens and returns them as an array of strings.
+     * @return all remaining tokens, as an array of strings
+     * @deprecated Replaced by {@link #readAllStrings()}.
+     */
+    @Deprecated
+    public static String[] readStrings() {
+        return readAllStrings();
+    }
+
+
+    /**
+     * Interactive test of basic functionality.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        StdOut.print("Type a string: ");
+        String s = StdIn.readString();
+        StdOut.println("Your string was: " + s);
+        StdOut.println();
+
+        StdOut.print("Type an int: ");
+        int a = StdIn.readInt();
+        StdOut.println("Your int was: " + a);
+        StdOut.println();
+
+        StdOut.print("Type a boolean: ");
+        boolean b = StdIn.readBoolean();
+        StdOut.println("Your boolean was: " + b);
+        StdOut.println();
+
+        StdOut.print("Type a double: ");
+        double c = StdIn.readDouble();
+        StdOut.println("Your double was: " + c);
+        StdOut.println();
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdInTest.java b/src/main/java/edu/princeton/cs/algs4/StdInTest.java
new file mode 100644
index 0000000..f2b803a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdInTest.java
@@ -0,0 +1,340 @@
+/**
+ * Test client for StdIn and In. 
+ **/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Scanner;
+import java.lang.reflect.Array;
+import java.lang.reflect.Method;
+import java.io.ByteArrayInputStream;
+
+public class StdInTest {
+    private static boolean testStdIn;
+    private static Method resyncMethod;
+    private static int testCount = 0;
+
+    
+    // make a printable/readable version of an object
+    public static Object escape(Object original) {
+        if (original instanceof Character) {
+            char u = (char) ((Character) original);
+            int idx = "\b\t\n\f\r\"\'\\".indexOf(u);
+            if (idx >= 0)
+                return "\\"+"btnfr\"\'\\".charAt(idx);
+            if (u < 32) 
+                return "\\"+Integer.toOctalString(u);
+            if (u > 126) 
+                return "\\u" + String.format("%04X", (int) u);
+            return original;
+        }
+        else if (original instanceof String) {
+            StringBuilder result = new StringBuilder();
+            for (char c : ((String) original).toCharArray())
+                result.append(escape(c));
+            return "\"" + result.toString() + "\"";
+        }
+        else if (original.getClass().isArray()) {
+            StringBuilder result = new StringBuilder("[");
+            int len = Array.getLength(original);
+            for (int i = 0; i < len; i++)
+                result.append(" ").append(escape(Array.get(original, i)));
+            return result.append("]").toString();
+        }
+        return original;
+    }
+    
+    public static boolean canResync() {
+        try {
+            resyncMethod = StdIn.class.getMethod("resync");
+        }
+        catch (NoSuchMethodException e) {
+            return false;
+        }
+        return true;
+    }
+    
+    /**
+     * In the two methods below, each Object[] of "steps" is a length-2
+     * array: the first is a String holding a method name, the second
+     * is the expected return value when that method is called in sequence.
+     */
+    public static void test(String input, Object[][] steps) {
+        test(input, steps, false); // create Scanner from String
+        if (testStdIn)
+            test(input, steps, true);  // uses stdIn/System.setIn
+        testCount++;
+    }
+    
+    public static void test(String input, Object[][] steps, boolean useStdIn) {
+        In in = null;
+        if (useStdIn) {
+            try {
+                System.setIn(new ByteArrayInputStream(input.getBytes("UTF-8")));
+            }
+            catch (java.io.UnsupportedEncodingException e) {
+                throw new RuntimeException(e.toString());
+            }
+
+            // in order for this to work, you need to change resync to public
+            
+            try { //call StdIn.resync();
+                resyncMethod.invoke(null);
+            }
+            catch (IllegalAccessException e) {
+                throw new RuntimeException(e.toString());
+            }
+            catch (java.lang.reflect.InvocationTargetException e) {
+                throw new RuntimeException(e.toString());                   
+            }
+        }
+        else 
+            in = new In(new Scanner(input));
+
+        int count = 0;
+        for (Object[] step : steps) {
+            String cmd = (String) step[0];
+            Object expected = step[1];
+            Object result;
+            
+            String preamble = "Failed input %s\nStep %d (%s)\n";
+
+            try {
+                Method method;
+                // nice and easy since these methods take no arguments
+                if (useStdIn)
+                    method = StdIn.class.getMethod(cmd);
+                else
+                    method = in.getClass().getMethod(cmd);
+                result = method.invoke(in); // fine to be null for static
+            }
+            catch (NoSuchMethodException e) {
+                java.io.StringWriter errors = new java.io.StringWriter();
+                e.printStackTrace(new java.io.PrintWriter(errors));
+                throw new RuntimeException(String.format(preamble, 
+                                                         input, count, cmd) +
+                                           errors.toString());
+            }
+            catch (IllegalAccessException e) {
+                java.io.StringWriter errors = new java.io.StringWriter();
+                e.printStackTrace(new java.io.PrintWriter(errors));
+                throw new RuntimeException(String.format(preamble, 
+                                                         input, count, cmd) +
+                                           errors.toString());
+            }
+            catch (java.lang.reflect.InvocationTargetException e) {
+                java.io.StringWriter errors = new java.io.StringWriter();
+                e.printStackTrace(new java.io.PrintWriter(errors));
+                e.getCause().printStackTrace(new java.io.PrintWriter(errors));
+                throw new RuntimeException(String.format(preamble, 
+                                                         input, count, cmd) +
+                                           errors.toString());
+            }
+                        
+            if (expected.getClass().isArray()) {
+                if (!(result.getClass().isArray())) {
+                    StdOut.printf(preamble + "Expected array, got %s\n",
+                                  input, count, cmd, result);
+                    continue;
+                }
+                Object r = result, e = expected; // to shorten lines below
+                int rl = Array.getLength(r);
+                int el = Array.getLength(e);
+                if (el != rl)
+                    StdOut.printf(preamble + "Expected %d, got %d items:\n%s\n",
+                                  escape(input), count, cmd, el, rl, escape(r));
+                else {
+                    for (int i = 0; i < rl; i++) {
+                        if (!(Array.get(r, i).equals(Array.get(e, i)))) 
+                        StdOut.printf(preamble + "\nExpected [%d]=%s, got %s\n",
+                                      escape(input), count, cmd, i, 
+                                      escape(Array.get(e, i)), 
+                                      escape(Array.get(r, i)));
+                    }
+                }
+            }
+            else if (!result.equals(expected)) {
+                StdOut.printf(preamble + "Expected %s, got %s\n",
+                              escape(input), count, cmd, escape(expected), 
+                              escape(result));
+            }
+            count++;
+        }
+    }
+    
+    public static void main(String[] args) {
+        testStdIn = canResync();
+        
+        if (testStdIn) 
+            StdOut.println("Note: any errors appear duplicated since tests run 2x.");
+        else 
+            StdOut.println("Note: StdIn.resync is private, only In will be tested.");
+
+        test("this is a test", 
+             new Object[][] {
+            {"isEmpty", false}, {"hasNextChar", true}, {"hasNextLine", true},
+            {"readAllStrings", new String[] {"this", "is", "a", "test"}},
+            {"isEmpty", true}, {"hasNextChar", false}, {"hasNextLine", false}
+        });
+        test("\n\n\n", 
+             new Object[][] {
+            {"isEmpty", true}, {"hasNextChar", true}, {"hasNextLine", true},
+            {"readAll", "\n\n\n"}
+        });
+        test("", 
+             new Object[][] {
+            {"isEmpty", true}, {"hasNextChar", false}, {"hasNextLine", false}
+        });
+        test("\t\t  \t\t", 
+             new Object[][] {
+            {"isEmpty", true}, {"hasNextChar", true}, {"hasNextLine", true},
+            {"readAll", "\t\t  \t\t"}
+        });
+        test("readLine consumes newline\nyeah!", 
+             new Object[][] {
+            {"readLine", "readLine consumes newline"}, {"readChar", 'y'}
+        });
+        test("readString doesn't consume spaces", 
+             new Object[][] {
+            {"readString", "readString"}, {"readChar", ' '}
+        });
+        test("\n\nblank lines test",
+             new Object[][] {
+            {"readLine", ""}, {"readLine", ""}, {"hasNextLine", true},
+            {"readLine", "blank lines test"}, {"hasNextLine", false}
+        });
+        test("   \n  \t \n  correct  \n\t\n\t .trim replacement \n\t",
+             new Object[][] {
+            {"readAllStrings", new String[]{"correct", ".trim", "replacement"}},
+            {"hasNextChar", false}
+        });
+        StringBuilder sb = new StringBuilder();
+        Object[][] expected = new Object[2000][2];
+        for (int i=0; i < 1000; i++) {
+            sb.append((char) i);
+            sb.append((char) (i + 8000)); // include weird non-breaking spaces
+            expected[2*i][0] = "readChar";
+            expected[2*i+1][0] = "readChar";
+            expected[2*i][1] = (char)i;
+            expected[2*i+1][1] = (char)(i+8000);
+        }
+        test(sb.toString(), expected);
+        test(" this \n and \that \n ",
+             new Object[][] {
+            {"readString", "this"}, {"readString", "and"}, {"readChar", ' '},
+            {"readString", "hat"}, {"readChar", ' '}, {"isEmpty", true},
+            {"hasNextLine", true}, {"readLine", ""}, {"readLine", " "}
+        });
+        test(" 1 2 3 \n\t 4 5 ",
+             new Object[][] {
+            {"readAllInts", new int[] {1, 2, 3, 4, 5}}
+        });
+        test(" 0 1 False true falsE True ",
+             new Object[][] {
+            {"readBoolean", false}, {"readBoolean", true}, 
+            {"readBoolean", false}, {"readBoolean", true}, 
+            {"readBoolean", false}, {"readBoolean", true}
+        });
+        test(" \240\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008"
+                 + "\u2009\u200A\u205F\u3000",
+             new Object[][] {
+            {"readString", "\240"},   // non-breaking space - not java whitespace
+            {"readString", "\u2007"}, // similarly
+            {"hasNextChar", true}, // there is some stuff left over
+            {"isEmpty", true},        // but it is all whitespace
+            {"readChar", '\u2008'}    // such as this one
+        });
+        
+        // line sep, par sep, NEL, unit sep, vtab --- first 3 are newlines
+        // NB: \205 is treated as a line separator, but not whitespace!
+        test("a\u2028b\u2029c\37d\13e\205f", 
+             new Object[][] {
+            {"readAllStrings", new String[]{"a", "b", "c", "d", "e\205f"}}
+        });
+        test("a\u2028b\u2029c\37d\13e\205f", 
+             new Object[][] {
+            {"readLine", "a"},
+            {"readLine", "b"},
+            {"readLine", "c\37d\13e"},
+            {"readLine", "f"}
+        });
+        test("\u2028\u2029", // line separator, par separator
+             new Object[][] {
+            {"readLine", ""}, {"hasNextLine", true}, {"hasNextChar", true},
+            {"readLine", ""}, {"hasNextLine", false}, {"hasNextChar", false}
+        });
+        test("\n\n", 
+             new Object[][] {
+            {"readLine", ""}, {"hasNextLine", true}, {"hasNextChar", true},
+            {"readLine", ""}, {"hasNextLine", false}, {"hasNextChar", false}
+        });
+        test("\r\n\r\n", 
+             new Object[][] {
+            {"readLine", ""}, {"hasNextLine", true}, {"hasNextChar", true},
+            {"readLine", ""}, {"hasNextLine", false}, {"hasNextChar", false}
+        });
+        test("\n\r", 
+             new Object[][] {
+            {"readLine", ""}, {"hasNextLine", true}, {"hasNextChar", true},
+            {"readLine", ""}, {"hasNextLine", false}, {"hasNextChar", false}
+        });
+        test("\r\n", 
+             new Object[][] {
+            {"readLine", ""}, {"hasNextChar", false}, {"hasNextLine", false}
+        });
+        test("3E4 \t -0.5 \n \t +4", 
+             new Object[][] {
+            {"readAllDoubles", new double[] {30000, -0.5, 4}}
+        });
+        test(" whitespace ", 
+             new Object[][] {
+            {"readString", "whitespace"}, {"readChar", ' '},
+            {"hasNextLine", false}
+        });
+        test(" whitespace \n", 
+             new Object[][] {
+            {"readString", "whitespace"}, {"readChar", ' '},
+            {"readLine", ""}, {"hasNextLine", false}
+        });
+        test(" whitespace \n ", 
+             new Object[][] {
+            {"readString", "whitespace"}, {"readChar", ' '},
+            {"readLine", ""}, {"hasNextLine", true},
+            {"readLine", " "}, {"hasNextLine", false}
+        });
+        test(" 34 -12983   3.25\n\t foo!",
+             new Object[][] {
+            {"readByte", (byte) 34}, 
+            {"readShort", (short) -12983},
+            {"readDouble", 3.25},
+            {"readAll", "\n\t foo!"}
+        });
+        test("30000000000  3.5 3e4, foo   \t\t ya",
+             new Object[][] {
+            {"readLong", 30000000000L},
+            {"readFloat", (float) 3.5},
+            {"readAllStrings", new String[] {"3e4,", "foo", "ya"}}
+        });
+        // testing consistency of whitespace and read(All)String(s)
+        test(" \u0001 foo \u0001 foo \u0001 foo",
+             new Object[][] {
+            {"readAllStrings", new String[] {
+                "\u0001", "foo", "\u0001", "foo", "\u0001", "foo"}}
+        });
+        test(" \u2005 foo \u2005 foo \u2005 foo",
+             new Object[][] {
+            {"readAllStrings", new String[] {"foo", "foo", "foo"}}
+        });
+        test(" \u0001 foo \u0001 foo \u0001 foo",
+             new Object[][] {
+            {"readString", "\u0001"}, {"readString", "foo"},
+            {"readString", "\u0001"}, {"readString", "foo"},
+            {"readString", "\u0001"}, {"readString", "foo"}
+        });
+        test(" \u2005 foo \u2005 foo \u2005 foo",
+             new Object[][] {
+            {"readString", "foo"}, {"readString", "foo"}, {"readString", "foo"}
+        });
+        StdOut.printf("Ran %d tests.\n", testCount);
+    }
+}
diff --git a/src/main/java/edu/princeton/cs/algs4/StdOut.java b/src/main/java/edu/princeton/cs/algs4/StdOut.java
new file mode 100644
index 0000000..2fafbd6
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdOut.java
@@ -0,0 +1,339 @@
+/******************************************************************************
+ *  Compilation:  javac StdOut.java
+ *  Execution:    java StdOut
+ *  Dependencies: none
+ *
+ *  Writes data of various types to standard output.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.UnsupportedEncodingException;
+import java.util.Locale;
+
+/**
+ *  This class provides methods for printing strings and numbers to standard output.
+ *  <p>
+ *  <b>Getting started.</b>
+ *  To use this class, you must have {@code StdOut.class} in your
+ *  Java classpath. If you used our autoinstaller, you should be all set.
+ *  Otherwise, either download
+ *  <a href = "https://introcs.cs.princeton.edu/java/code/stdlib.jar">stdlib.jar</a>
+ *  and add to your Java classpath or download
+ *  <a href = "https://introcs.cs.princeton.edu/java/stdlib/StdOut.java">StdOut.java</a>
+ *  and put a copy in your working directory.
+ *  <p>
+ *  Here is an example program that uses {@code StdOut}:
+ *  <pre>
+ *   public class TestStdOut {
+ *       public static void main(String[] args) {
+ *           int a = 17;
+ *           int b = 23;
+ *           int sum = a + b;
+ *           StdOut.println("Hello, World");
+ *           StdOut.printf("%d + %d = %d\n", a, b, sum);
+ *       }
+ *   }
+ *  </pre>
+ *  <p>
+ *  <b>Differences with System.out.</b>
+ *  The behavior of {@code StdOut} is similar to that of {@link System#out},
+ *  but there are a few technical differences:
+ *  <ul>
+ *  <li> {@code StdOut} coerces the character-set encoding to UTF-8,
+ *       which is a standard character encoding for Unicode.
+ *  <li> {@code StdOut} coerces the locale to {@link Locale#US},
+ *       for consistency with {@link StdIn}, {@link Double#parseDouble(String)},
+ *       and floating-point literals.
+ *  <li> {@code StdOut} <em>flushes</em> standard output after each call to
+ *       {@code print()} so that text will appear immediately in the terminal.
+ *  </ul>
+ *  <p>
+ *  <b>Reference.</b>
+ *  For additional documentation,
+ *  see <a href="https://introcs.cs.princeton.edu/15inout">Section 1.5</a> of
+ *  <em>Computer Science: An Interdisciplinary Approach</em>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class StdOut {
+
+    // force Unicode UTF-8 encoding; otherwise it's system dependent
+    private static final String CHARSET_NAME = "UTF-8";
+
+    // assume language = English, country = US for consistency with StdIn
+    private static final Locale LOCALE = Locale.US;
+
+    // send output here
+    private static PrintWriter out;
+
+    // this is called before invoking any methods
+    static {
+        try {
+            out = new PrintWriter(new OutputStreamWriter(System.out, CHARSET_NAME), true);
+        }
+        catch (UnsupportedEncodingException e) {
+            System.out.println(e);
+        }
+    }
+
+    // don't instantiate
+    private StdOut() { }
+
+   /**
+     * Terminates the current line by printing the line-separator string.
+     */
+    public static void println() {
+        out.println();
+    }
+
+   /**
+     * Prints an object to this output stream and then terminates the line.
+     *
+     * @param x the object to print
+     */
+    public static void println(Object x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a boolean to standard output and then terminates the line.
+     *
+     * @param x the boolean to print
+     */
+    public static void println(boolean x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a character to standard output and then terminates the line.
+     *
+     * @param x the character to print
+     */
+    public static void println(char x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a double to standard output and then terminates the line.
+     *
+     * @param x the double to print
+     */
+    public static void println(double x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints an integer to standard output and then terminates the line.
+     *
+     * @param x the integer to print
+     */
+    public static void println(float x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints an integer to standard output and then terminates the line.
+     *
+     * @param x the integer to print
+     */
+    public static void println(int x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a long to standard output and then terminates the line.
+     *
+     * @param x the long to print
+     */
+    public static void println(long x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a short integer to standard output and then terminates the line.
+     *
+     * @param x the short to print
+     */
+    public static void println(short x) {
+        out.println(x);
+    }
+
+   /**
+     * Prints a byte to standard output and then terminates the line.
+     * <p>
+     * To write binary data, see {@link BinaryStdOut}.
+     *
+     * @param x the byte to print
+     */
+    public static void println(byte x) {
+        out.println(x);
+    }
+
+   /**
+     * Flushes standard output.
+     */
+    public static void print() {
+        out.flush();
+    }
+
+   /**
+     * Prints an object to standard output and flushes standard output.
+     *
+     * @param x the object to print
+     */
+    public static void print(Object x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a boolean to standard output and flushes standard output.
+     *
+     * @param x the boolean to print
+     */
+    public static void print(boolean x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a character to standard output and flushes standard output.
+     *
+     * @param x the character to print
+     */
+    public static void print(char x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a double to standard output and flushes standard output.
+     *
+     * @param x the double to print
+     */
+    public static void print(double x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a float to standard output and flushes standard output.
+     *
+     * @param x the float to print
+     */
+    public static void print(float x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints an integer to standard output and flushes standard output.
+     *
+     * @param x the integer to print
+     */
+    public static void print(int x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a long integer to standard output and flushes standard output.
+     *
+     * @param x the long integer to print
+     */
+    public static void print(long x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a short integer to standard output and flushes standard output.
+     *
+     * @param x the short integer to print
+     */
+    public static void print(short x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a byte to standard output and flushes standard output.
+     *
+     * @param x the byte to print
+     */
+    public static void print(byte x) {
+        out.print(x);
+        out.flush();
+    }
+
+   /**
+     * Prints a formatted string to standard output, using the specified format
+     * string and arguments, and then flushes standard output.
+     *
+     *
+     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>
+     * @param args   the arguments accompanying the format string
+     */
+    public static void printf(String format, Object... args) {
+        out.printf(LOCALE, format, args);
+        out.flush();
+    }
+
+   /**
+     * Prints a formatted string to standard output, using the locale and
+     * the specified format string and arguments; then flushes standard output.
+     *
+     * @param locale the locale
+     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>
+     * @param args   the arguments accompanying the format string
+     */
+    public static void printf(Locale locale, String format, Object... args) {
+        out.printf(locale, format, args);
+        out.flush();
+    }
+
+   /**
+     * Unit tests some of the methods in {@code StdOut}.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // write to stdout
+        StdOut.println("Test");
+        StdOut.println(17);
+        StdOut.println(true);
+        StdOut.printf("%.6f\n", 1.0/7.0);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdRandom.java b/src/main/java/edu/princeton/cs/algs4/StdRandom.java
new file mode 100644
index 0000000..6e7e239
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdRandom.java
@@ -0,0 +1,674 @@
+/******************************************************************************
+ *  Compilation:  javac StdRandom.java
+ *  Execution:    java StdRandom
+ *  Dependencies: StdOut.java
+ *
+ *  A library of static methods to generate pseudo-random numbers from
+ *  different distributions (bernoulli, uniform, gaussian, discrete,
+ *  and exponential). Also includes a method for shuffling an array.
+ *
+ *
+ *  %  java StdRandom 5
+ *  seed = 1316600602069
+ *  59 16.81826  true 8.83954  0 
+ *  32 91.32098  true 9.11026  0 
+ *  35 10.11874  true 8.95396  3 
+ *  92 32.88401  true 8.87089  0 
+ *  72 92.55791  true 9.46241  0 
+ *
+ *  % java StdRandom 5
+ *  seed = 1316600616575
+ *  96 60.17070  true 8.72821  0 
+ *  79 32.01607  true 8.58159  0 
+ *  81 59.49065  true 9.10423  1 
+ *  96 51.65818  true 9.02102  0 
+ *  99 17.55771  true 8.99762  0 
+ *
+ *  % java StdRandom 5 1316600616575
+ *  seed = 1316600616575
+ *  96 60.17070  true 8.72821  0 
+ *  79 32.01607  true 8.58159  0 
+ *  81 59.49065  true 9.10423  1 
+ *  96 51.65818  true 9.02102  0 
+ *  99 17.55771  true 8.99762  0 
+ *
+ *
+ *  Remark
+ *  ------
+ *    - Relies on randomness of nextDouble() method in java.util.Random
+ *      to generate pseudo-random numbers in [0, 1).
+ *
+ *    - This library allows you to set and get the pseudo-random number seed.
+ *
+ *    - See http://www.honeylocust.com/RngPack/ for an industrial
+ *      strength random number generator in Java.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Random;
+
+/**
+ *  The {@code StdRandom} class provides static methods for generating
+ *  random number from various discrete and continuous distributions, 
+ *  including uniform, Bernoulli, geometric, Gaussian, exponential, Pareto,
+ *  Poisson, and Cauchy. It also provides method for shuffling an
+ *  array or subarray and generating random permutations.
+ *  <p>
+ *  By convention, all intervals are half open. For example,
+ *  <code>uniform(-1.0, 1.0)</code> returns a random number between
+ *  <code>-1.0</code> (inclusive) and <code>1.0</code> (exclusive).
+ *  Similarly, <code>shuffle(a, lo, hi)</code> shuffles the <code>hi - lo</code>
+ *  elements in the array <code>a[]</code>, starting at index <code>lo</code>
+ *  (inclusive) and ending at index <code>hi</code> (exclusive).
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://introcs.cs.princeton.edu/22library">Section 2.2</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class StdRandom {
+
+    private static Random random;    // pseudo-random number generator
+    private static long seed;        // pseudo-random number generator seed
+
+    // static initializer
+    static {
+        // this is how the seed was set in Java 1.4
+        seed = System.currentTimeMillis();
+        random = new Random(seed);
+    }
+
+    // don't instantiate
+    private StdRandom() { }
+
+    /**
+     * Sets the seed of the pseudo-random number generator.
+     * This method enables you to produce the same sequence of "random"
+     * number for each execution of the program.
+     * Ordinarily, you should call this method at most once per program.
+     *
+     * @param s the seed
+     */
+    public static void setSeed(long s) {
+        seed   = s;
+        random = new Random(seed);
+    }
+
+    /**
+     * Returns the seed of the pseudo-random number generator.
+     *
+     * @return the seed
+     */
+    public static long getSeed() {
+        return seed;
+    }
+
+    /**
+     * Returns a random real number uniformly in [0, 1).
+     *
+     * @return a random real number uniformly in [0, 1)
+     */
+    public static double uniform() {
+        return random.nextDouble();
+    }
+
+    /**
+     * Returns a random integer uniformly in [0, n).
+     * 
+     * @param n number of possible integers
+     * @return a random integer uniformly between 0 (inclusive) and {@code n} (exclusive)
+     * @throws IllegalArgumentException if {@code n <= 0}
+     */
+    public static int uniform(int n) {
+        if (n <= 0) throw new IllegalArgumentException("argument must be positive: " + n);
+        return random.nextInt(n);
+    }
+
+
+    /**
+     * Returns a random long integer uniformly in [0, n).
+     * 
+     * @param n number of possible {@code long} integers
+     * @return a random long integer uniformly between 0 (inclusive) and {@code n} (exclusive)
+     * @throws IllegalArgumentException if {@code n <= 0}
+     */
+    public static long uniform(long n) {
+        if (n <= 0L) throw new IllegalArgumentException("argument must be positive: " + n);
+
+        // https://docs.oracle.com/javase/8/docs/api/java/util/Random.html#longs-long-long-long-
+        long r = random.nextLong();
+        long m = n - 1;
+
+        // power of two
+        if ((n & m) == 0L) {
+            return r & m;
+        }
+
+        // reject over-represented candidates
+        long u = r >>> 1;
+        while (u + m - (r = u % n) < 0L) {
+            u = random.nextLong() >>> 1;
+        }
+        return r;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    //  STATIC METHODS BELOW RELY ON JAVA.UTIL.RANDOM ONLY INDIRECTLY VIA
+    //  THE STATIC METHODS ABOVE.
+    ///////////////////////////////////////////////////////////////////////////
+
+    /**
+     * Returns a random real number uniformly in [0, 1).
+     * 
+     * @return     a random real number uniformly in [0, 1)
+     * @deprecated Replaced by {@link #uniform()}.
+     */
+    @Deprecated
+    public static double random() {
+        return uniform();
+    }
+
+    /**
+     * Returns a random integer uniformly in [a, b).
+     * 
+     * @param  a the left endpoint
+     * @param  b the right endpoint
+     * @return a random integer uniformly in [a, b)
+     * @throws IllegalArgumentException if {@code b <= a}
+     * @throws IllegalArgumentException if {@code b - a >= Integer.MAX_VALUE}
+     */
+    public static int uniform(int a, int b) {
+        if ((b <= a) || ((long) b - a >= Integer.MAX_VALUE)) {
+            throw new IllegalArgumentException("invalid range: [" + a + ", " + b + ")");
+        }
+        return a + uniform(b - a);
+    }
+
+    /**
+     * Returns a random real number uniformly in [a, b).
+     * 
+     * @param  a the left endpoint
+     * @param  b the right endpoint
+     * @return a random real number uniformly in [a, b)
+     * @throws IllegalArgumentException unless {@code a < b}
+     */
+    public static double uniform(double a, double b) {
+        if (!(a < b)) {
+            throw new IllegalArgumentException("invalid range: [" + a + ", " + b + ")");
+        }
+        return a + uniform() * (b-a);
+    }
+
+    /**
+     * Returns a random boolean from a Bernoulli distribution with success
+     * probability <em>p</em>.
+     *
+     * @param  p the probability of returning {@code true}
+     * @return {@code true} with probability {@code p} and
+     *         {@code false} with probability {@code 1 - p}
+     * @throws IllegalArgumentException unless {@code 0} &le; {@code p} &le; {@code 1.0}
+     */
+    public static boolean bernoulli(double p) {
+        if (!(p >= 0.0 && p <= 1.0))
+            throw new IllegalArgumentException("probability p must be between 0.0 and 1.0: " + p);
+        return uniform() < p;
+    }
+
+    /**
+     * Returns a random boolean from a Bernoulli distribution with success
+     * probability 1/2.
+     * 
+     * @return {@code true} with probability 1/2 and
+     *         {@code false} with probability 1/2
+     */
+    public static boolean bernoulli() {
+        return bernoulli(0.5);
+    }
+
+    /**
+     * Returns a random real number from a standard Gaussian distribution.
+     * 
+     * @return a random real number from a standard Gaussian distribution
+     *         (mean 0 and standard deviation 1).
+     */
+    public static double gaussian() {
+        // use the polar form of the Box-Muller transform
+        double r, x, y;
+        do {
+            x = uniform(-1.0, 1.0);
+            y = uniform(-1.0, 1.0);
+            r = x*x + y*y;
+        } while (r >= 1 || r == 0);
+        return x * Math.sqrt(-2 * Math.log(r) / r);
+
+        // Remark:  y * Math.sqrt(-2 * Math.log(r) / r)
+        // is an independent random gaussian
+    }
+
+    /**
+     * Returns a random real number from a Gaussian distribution with mean &mu;
+     * and standard deviation &sigma;.
+     * 
+     * @param  mu the mean
+     * @param  sigma the standard deviation
+     * @return a real number distributed according to the Gaussian distribution
+     *         with mean {@code mu} and standard deviation {@code sigma}
+     */
+    public static double gaussian(double mu, double sigma) {
+        return mu + sigma * gaussian();
+    }
+
+    /**
+     * Returns a random integer from a geometric distribution with success
+     * probability <em>p</em>.
+     * The integer represents the number of independent trials
+     * before the first success.
+     * 
+     * @param  p the parameter of the geometric distribution
+     * @return a random integer from a geometric distribution with success
+     *         probability {@code p}; or {@code Integer.MAX_VALUE} if
+     *         {@code p} is (nearly) equal to {@code 1.0}.
+     * @throws IllegalArgumentException unless {@code p >= 0.0} and {@code p <= 1.0}
+     */
+    public static int geometric(double p) {
+        if (!(p >= 0)) {
+            throw new IllegalArgumentException("probability p must be greater than 0: " + p);
+        }
+        if (!(p <= 1.0)) {
+            throw new IllegalArgumentException("probability p must not be larger than 1: " + p);
+        }
+        // using algorithm given by Knuth
+        return (int) Math.ceil(Math.log(uniform()) / Math.log(1.0 - p));
+    }
+
+    /**
+     * Returns a random integer from a Poisson distribution with mean &lambda;.
+     *
+     * @param  lambda the mean of the Poisson distribution
+     * @return a random integer from a Poisson distribution with mean {@code lambda}
+     * @throws IllegalArgumentException unless {@code lambda > 0.0} and not infinite
+     */
+    public static int poisson(double lambda) {
+        if (!(lambda > 0.0))
+            throw new IllegalArgumentException("lambda must be positive: " + lambda);
+        if (Double.isInfinite(lambda))
+            throw new IllegalArgumentException("lambda must not be infinite: " + lambda);
+        // using algorithm given by Knuth
+        // see http://en.wikipedia.org/wiki/Poisson_distribution
+        int k = 0;
+        double p = 1.0;
+        double expLambda = Math.exp(-lambda);
+        do {
+            k++;
+            p *= uniform();
+        } while (p >= expLambda);
+        return k-1;
+    }
+
+    /**
+     * Returns a random real number from the standard Pareto distribution.
+     *
+     * @return a random real number from the standard Pareto distribution
+     */
+    public static double pareto() {
+        return pareto(1.0);
+    }
+
+    /**
+     * Returns a random real number from a Pareto distribution with
+     * shape parameter &alpha;.
+     *
+     * @param  alpha shape parameter
+     * @return a random real number from a Pareto distribution with shape
+     *         parameter {@code alpha}
+     * @throws IllegalArgumentException unless {@code alpha > 0.0}
+     */
+    public static double pareto(double alpha) {
+        if (!(alpha > 0.0))
+            throw new IllegalArgumentException("alpha must be positive: " + alpha);
+        return Math.pow(1 - uniform(), -1.0/alpha) - 1.0;
+    }
+
+    /**
+     * Returns a random real number from the Cauchy distribution.
+     *
+     * @return a random real number from the Cauchy distribution.
+     */
+    public static double cauchy() {
+        return Math.tan(Math.PI * (uniform() - 0.5));
+    }
+
+    /**
+     * Returns a random integer from the specified discrete distribution.
+     *
+     * @param  probabilities the probability of occurrence of each integer
+     * @return a random integer from a discrete distribution:
+     *         {@code i} with probability {@code probabilities[i]}
+     * @throws IllegalArgumentException if {@code probabilities} is {@code null}
+     * @throws IllegalArgumentException if sum of array entries is not (very nearly) equal to {@code 1.0}
+     * @throws IllegalArgumentException unless {@code probabilities[i] >= 0.0} for each index {@code i}
+     */
+    public static int discrete(double[] probabilities) {
+        if (probabilities == null) throw new IllegalArgumentException("argument array must not be null");
+        double EPSILON = 1.0E-14;
+        double sum = 0.0;
+        for (int i = 0; i < probabilities.length; i++) {
+            if (!(probabilities[i] >= 0.0))
+                throw new IllegalArgumentException("array entry " + i + " must be non-negative: " + probabilities[i]);
+            sum += probabilities[i];
+        }
+        if (sum > 1.0 + EPSILON || sum < 1.0 - EPSILON)
+            throw new IllegalArgumentException("sum of array entries does not approximately equal 1.0: " + sum);
+
+        // the for loop may not return a value when both r is (nearly) 1.0 and when the
+        // cumulative sum is less than 1.0 (as a result of floating-point roundoff error)
+        while (true) {
+            double r = uniform();
+            sum = 0.0;
+            for (int i = 0; i < probabilities.length; i++) {
+                sum = sum + probabilities[i];
+                if (sum > r) return i;
+            }
+        }
+    }
+
+    /**
+     * Returns a random integer from the specified discrete distribution.
+     *
+     * @param  frequencies the frequency of occurrence of each integer
+     * @return a random integer from a discrete distribution:
+     *         {@code i} with probability proportional to {@code frequencies[i]}
+     * @throws IllegalArgumentException if {@code frequencies} is {@code null}
+     * @throws IllegalArgumentException if all array entries are {@code 0}
+     * @throws IllegalArgumentException if {@code frequencies[i]} is negative for any index {@code i}
+     * @throws IllegalArgumentException if sum of frequencies exceeds {@code Integer.MAX_VALUE} (2<sup>31</sup> - 1)
+     */
+    public static int discrete(int[] frequencies) {
+        if (frequencies == null) throw new IllegalArgumentException("argument array must not be null");
+        long sum = 0;
+        for (int i = 0; i < frequencies.length; i++) {
+            if (frequencies[i] < 0)
+                throw new IllegalArgumentException("array entry " + i + " must be non-negative: " + frequencies[i]);
+            sum += frequencies[i];
+        }
+        if (sum == 0)
+            throw new IllegalArgumentException("at least one array entry must be positive");
+        if (sum >= Integer.MAX_VALUE)
+            throw new IllegalArgumentException("sum of frequencies overflows an int");
+
+        // pick index i with probabilitity proportional to frequency
+        double r = uniform((int) sum);
+        sum = 0;
+        for (int i = 0; i < frequencies.length; i++) {
+            sum += frequencies[i];
+            if (sum > r) return i;
+        }
+
+        // can't reach here
+        assert false;
+        return -1;
+    }
+
+    /**
+     * Returns a random real number from an exponential distribution
+     * with rate &lambda;.
+     * 
+     * @param  lambda the rate of the exponential distribution
+     * @return a random real number from an exponential distribution with
+     *         rate {@code lambda}
+     * @throws IllegalArgumentException unless {@code lambda > 0.0}
+     */
+    public static double exp(double lambda) {
+        if (!(lambda > 0.0))
+            throw new IllegalArgumentException("lambda must be positive: " + lambda);
+        return -Math.log(1 - uniform()) / lambda;
+    }
+
+    /**
+     * Rearranges the elements of the specified array in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     */
+    public static void shuffle(Object[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            int r = i + uniform(n-i);     // between i and n-1
+            Object temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Rearranges the elements of the specified array in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     */
+    public static void shuffle(double[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            int r = i + uniform(n-i);     // between i and n-1
+            double temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Rearranges the elements of the specified array in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     */
+    public static void shuffle(int[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            int r = i + uniform(n-i);     // between i and n-1
+            int temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Rearranges the elements of the specified array in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     */
+    public static void shuffle(char[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            int r = i + uniform(n-i);     // between i and n-1
+            char temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Rearranges the elements of the specified subarray in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @param  lo the left endpoint (inclusive)
+     * @param  hi the right endpoint (exclusive)
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     * 
+     */
+    public static void shuffle(Object[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        for (int i = lo; i < hi; i++) {
+            int r = i + uniform(hi-i);     // between i and hi-1
+            Object temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Rearranges the elements of the specified subarray in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @param  lo the left endpoint (inclusive)
+     * @param  hi the right endpoint (exclusive)
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static void shuffle(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        for (int i = lo; i < hi; i++) {
+            int r = i + uniform(hi-i);     // between i and hi-1
+            double temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Rearranges the elements of the specified subarray in uniformly random order.
+     *
+     * @param  a the array to shuffle
+     * @param  lo the left endpoint (inclusive)
+     * @param  hi the right endpoint (exclusive)
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static void shuffle(int[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        for (int i = lo; i < hi; i++) {
+            int r = i + uniform(hi-i);     // between i and hi-1
+            int temp = a[i];
+            a[i] = a[r];
+            a[r] = temp;
+        }
+    }
+
+    /**
+     * Returns a uniformly random permutation of <em>n</em> elements.
+     *
+     * @param  n number of elements
+     * @throws IllegalArgumentException if {@code n} is negative
+     * @return an array of length {@code n} that is a uniformly random permutation
+     *         of {@code 0}, {@code 1}, ..., {@code n-1}
+     */
+    public static int[] permutation(int n) {
+        if (n < 0) throw new IllegalArgumentException("n must be non-negative: " + n);
+        int[] perm = new int[n];
+        for (int i = 0; i < n; i++)
+            perm[i] = i;
+        shuffle(perm);
+        return perm;
+    }
+
+    /**
+     * Returns a uniformly random permutation of <em>k</em> of <em>n</em> elements.
+     *
+     * @param  n number of elements
+     * @param  k number of elements to select
+     * @throws IllegalArgumentException if {@code n} is negative
+     * @throws IllegalArgumentException unless {@code 0 <= k <= n}
+     * @return an array of length {@code k} that is a uniformly random permutation
+     *         of {@code k} of the elements from {@code 0}, {@code 1}, ..., {@code n-1}
+     */
+    public static int[] permutation(int n, int k) {
+        if (n < 0) throw new IllegalArgumentException("n must be non-negative: " + n);
+        if (k < 0 || k > n) throw new IllegalArgumentException("k must be between 0 and n: " + k);
+        int[] perm = new int[k];
+        for (int i = 0; i < k; i++) {
+            int r = uniform(i+1);    // between 0 and i
+            perm[i] = perm[r];
+            perm[r] = i;
+        }
+        for (int i = k; i < n; i++) {
+            int r = uniform(i+1);    // between 0 and i
+            if (r < k) perm[r] = i;
+        }
+        return perm;
+    }
+
+    // throw an IllegalArgumentException if x is null
+    // (x can be of type Object[], double[], int[], ...)
+    private static void validateNotNull(Object x) {
+        if (x == null) {
+            throw new IllegalArgumentException("argument must not be null");
+        }
+    }
+
+    // throw an exception unless 0 <= lo <= hi <= length
+    private static void validateSubarrayIndices(int lo, int hi, int length) {
+        if (lo < 0 || hi > length || lo > hi) {
+            throw new IllegalArgumentException("subarray indices out of bounds: [" + lo + ", " + hi + ")");
+        }
+    }
+
+    /**
+     * Unit tests the methods in this class.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = Integer.parseInt(args[0]);
+        if (args.length == 2) StdRandom.setSeed(Long.parseLong(args[1]));
+        double[] probabilities = { 0.5, 0.3, 0.1, 0.1 };
+        int[] frequencies = { 5, 3, 1, 1 };
+        String[] a = "A B C D E F G".split(" ");
+
+        StdOut.println("seed = " + StdRandom.getSeed());
+        for (int i = 0; i < n; i++) {
+            StdOut.printf("%2d ",   uniform(100));
+            StdOut.printf("%8.5f ", uniform(10.0, 99.0));
+            StdOut.printf("%5b ",   bernoulli(0.5));
+            StdOut.printf("%7.5f ", gaussian(9.0, 0.2));
+            StdOut.printf("%1d ",   discrete(probabilities));
+            StdOut.printf("%1d ",   discrete(frequencies));
+            StdOut.printf("%11d ",  uniform(100000000000L));
+            StdRandom.shuffle(a);
+            for (String s : a)
+                StdOut.print(s);
+            StdOut.println();
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StdStats.java b/src/main/java/edu/princeton/cs/algs4/StdStats.java
new file mode 100644
index 0000000..ca87402
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StdStats.java
@@ -0,0 +1,559 @@
+/******************************************************************************
+ *  Compilation:  javac StdStats.java
+ *  Execution:    java StdStats < input.txt
+ *  Dependencies: StdOut.java
+ *
+ *  Library of statistical functions.
+ *
+ *  The test client reads an array of real numbers from standard
+ *  input, and computes the minimum, mean, maximum, and
+ *  standard deviation.
+ *
+ *  The functions all throw a java.lang.IllegalArgumentException
+ *  if the array passed in as an argument is null.
+ *
+ *  The floating-point functions all return NaN if any input is NaN.
+ *
+ *  Unlike Math.min() and Math.max(), the min() and max() functions
+ *  do not differentiate between -0.0 and 0.0.
+ *
+ *  % more tiny.txt
+ *  5
+ *  3.0 1.0 2.0 5.0 4.0
+ *
+ *  % java StdStats < tiny.txt
+ *         min   1.000
+ *        mean   3.000
+ *         max   5.000
+ *     std dev   1.581
+ *
+ *  Should these funtions use varargs instead of array arguments?
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code StdStats} class provides static methods for computing
+ *  statistics such as min, max, mean, sample standard deviation, and
+ *  sample variance.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://introcs.cs.princeton.edu/22library">Section 2.2</a> of
+ *  <i>Computer Science: An Interdisciplinary Approach</i>
+ *  by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public final class StdStats {
+
+    private StdStats() { }
+
+    /**
+     * Returns the maximum value in the specified array.
+     *
+     * @param  a the array
+     * @return the maximum value in the array {@code a[]};
+     *         {@code Double.NEGATIVE_INFINITY} if no such value
+     */
+    public static double max(double[] a) {
+        validateNotNull(a);
+
+        double max = Double.NEGATIVE_INFINITY;
+        for (int i = 0; i < a.length; i++) {
+            if (Double.isNaN(a[i])) return Double.NaN;
+            if (a[i] > max) max = a[i];
+        }
+        return max;
+    }
+
+    /**
+     * Returns the maximum value in the specified subarray.
+     *
+     * @param  a the array
+     * @param  lo the left endpoint of the subarray (inclusive)
+     * @param  hi the right endpoint of the subarray (exclusive)
+     * @return the maximum value in the subarray {@code a[lo..hi)};
+     *         {@code Double.NEGATIVE_INFINITY} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null}
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double max(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        double max = Double.NEGATIVE_INFINITY;
+        for (int i = lo; i < hi; i++) {
+            if (Double.isNaN(a[i])) return Double.NaN;
+            if (a[i] > max) max = a[i];
+        }
+        return max;
+    }
+
+    /**
+     * Returns the maximum value in the specified array.
+     *
+     * @param  a the array
+     * @return the maximum value in the array {@code a[]};
+     *         {@code Integer.MIN_VALUE} if no such value
+     */
+    public static int max(int[] a) {
+        validateNotNull(a);
+
+        int max = Integer.MIN_VALUE;
+        for (int i = 0; i < a.length; i++) {
+            if (a[i] > max) max = a[i];
+        }
+        return max;
+    }
+
+    /**
+     * Returns the minimum value in the specified array.
+     *
+     * @param  a the array
+     * @return the minimum value in the array {@code a[]};
+     *         {@code Double.POSITIVE_INFINITY} if no such value
+     */
+    public static double min(double[] a) {
+        validateNotNull(a);
+
+        double min = Double.POSITIVE_INFINITY;
+        for (int i = 0; i < a.length; i++) {
+            if (Double.isNaN(a[i])) return Double.NaN;
+            if (a[i] < min) min = a[i];
+        }
+        return min;
+    }
+
+    /**
+     * Returns the minimum value in the specified subarray.
+     *
+     * @param  a the array
+     * @param  lo the left endpoint of the subarray (inclusive)
+     * @param  hi the right endpoint of the subarray (exclusive)
+     * @return the maximum value in the subarray {@code a[lo..hi)};
+     *         {@code Double.POSITIVE_INFINITY} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double min(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        double min = Double.POSITIVE_INFINITY;
+        for (int i = lo; i < hi; i++) {
+            if (Double.isNaN(a[i])) return Double.NaN;
+            if (a[i] < min) min = a[i];
+        }
+        return min;
+    }
+
+    /**
+     * Returns the minimum value in the specified array.
+     *
+     * @param  a the array
+     * @return the minimum value in the array {@code a[]};
+     *         {@code Integer.MAX_VALUE} if no such value
+     */
+    public static int min(int[] a) {
+        validateNotNull(a);
+
+        int min = Integer.MAX_VALUE;
+        for (int i = 0; i < a.length; i++) {
+            if (a[i] < min) min = a[i];
+        }
+        return min;
+    }
+
+    /**
+     * Returns the average value in the specified array.
+     *
+     * @param  a the array
+     * @return the average value in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double mean(double[] a) {
+        validateNotNull(a);
+
+        if (a.length == 0) return Double.NaN;
+        double sum = sum(a);
+        return sum / a.length;
+    }
+
+    /**
+     * Returns the average value in the specified subarray.
+     *
+     * @param a the array
+     * @param lo the left endpoint of the subarray (inclusive)
+     * @param hi the right endpoint of the subarray (exclusive)
+     * @return the average value in the subarray {@code a[lo..hi)};
+     *         {@code Double.NaN} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double mean(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        int length = hi - lo;
+        if (length == 0) return Double.NaN;
+
+        double sum = sum(a, lo, hi);
+        return sum / length;
+    }
+
+    /**
+     * Returns the average value in the specified array.
+     *
+     * @param  a the array
+     * @return the average value in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double mean(int[] a) {
+        validateNotNull(a);
+
+        if (a.length == 0) return Double.NaN;
+        int sum = sum(a);
+        return 1.0 * sum / a.length;
+    }
+
+    /**
+     * Returns the sample variance in the specified array.
+     *
+     * @param  a the array
+     * @return the sample variance in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double var(double[] a) {
+        validateNotNull(a);
+
+        if (a.length == 0) return Double.NaN;
+        double avg = mean(a);
+        double sum = 0.0;
+        for (int i = 0; i < a.length; i++) {
+            sum += (a[i] - avg) * (a[i] - avg);
+        }
+        return sum / (a.length - 1);
+    }
+
+    /**
+     * Returns the sample variance in the specified subarray.
+     *
+     * @param  a the array
+     * @param lo the left endpoint of the subarray (inclusive)
+     * @param hi the right endpoint of the subarray (exclusive)
+     * @return the sample variance in the subarray {@code a[lo..hi)};
+     *         {@code Double.NaN} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double var(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        int length = hi - lo;
+        if (length == 0) return Double.NaN;
+
+        double avg = mean(a, lo, hi);
+        double sum = 0.0;
+        for (int i = lo; i < hi; i++) {
+            sum += (a[i] - avg) * (a[i] - avg);
+        }
+        return sum / (length - 1);
+    }
+
+    /**
+     * Returns the sample variance in the specified array.
+     *
+     * @param  a the array
+     * @return the sample variance in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double var(int[] a) {
+        validateNotNull(a);
+        if (a.length == 0) return Double.NaN;
+        double avg = mean(a);
+        double sum = 0.0;
+        for (int i = 0; i < a.length; i++) {
+            sum += (a[i] - avg) * (a[i] - avg);
+        }
+        return sum / (a.length - 1);
+    }
+
+    /**
+     * Returns the population variance in the specified array.
+     *
+     * @param  a the array
+     * @return the population variance in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double varp(double[] a) {
+        validateNotNull(a);
+        if (a.length == 0) return Double.NaN;
+        double avg = mean(a);
+        double sum = 0.0;
+        for (int i = 0; i < a.length; i++) {
+            sum += (a[i] - avg) * (a[i] - avg);
+        }
+        return sum / a.length;
+    }
+
+    /**
+     * Returns the population variance in the specified subarray.
+     *
+     * @param  a the array
+     * @param lo the left endpoint of the subarray (inclusive)
+     * @param hi the right endpoint of the subarray (exclusive)
+     * @return the population variance in the subarray {@code a[lo..hi)};
+     *         {@code Double.NaN} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double varp(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        int length = hi - lo;
+        if (length == 0) return Double.NaN;
+
+        double avg = mean(a, lo, hi);
+        double sum = 0.0;
+        for (int i = lo; i < hi; i++) {
+            sum += (a[i] - avg) * (a[i] - avg);
+        }
+        return sum / length;
+    }
+
+    /**
+     * Returns the sample standard deviation in the specified array.
+     *
+     * @param  a the array
+     * @return the sample standard deviation in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double stddev(double[] a) {
+        validateNotNull(a);
+        return Math.sqrt(var(a));
+    }
+
+    /**
+     * Returns the sample standard deviation in the specified array.
+     *
+     * @param  a the array
+     * @return the sample standard deviation in the array {@code a[]};
+     *         {@code Double.NaN} if no such value
+     */
+    public static double stddev(int[] a) {
+        validateNotNull(a);
+        return Math.sqrt(var(a));
+    }
+
+    /**
+     * Returns the sample standard deviation in the specified subarray.
+     *
+     * @param  a the array
+     * @param lo the left endpoint of the subarray (inclusive)
+     * @param hi the right endpoint of the subarray (exclusive)
+     * @return the sample standard deviation in the subarray {@code a[lo..hi)};
+     *         {@code Double.NaN} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double stddev(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        return Math.sqrt(var(a, lo, hi));
+    }
+
+
+    /**
+     * Returns the population standard deviation in the specified array.
+     *
+     * @param  a the array
+     * @return the population standard deviation in the array;
+     *         {@code Double.NaN} if no such value
+     */
+    public static double stddevp(double[] a) {
+        validateNotNull(a);
+        return Math.sqrt(varp(a));
+    }
+
+    /**
+     * Returns the population standard deviation in the specified subarray.
+     *
+     * @param  a the array
+     * @param lo the left endpoint of the subarray (inclusive)
+     * @param hi the right endpoint of the subarray (exclusive)
+     * @return the population standard deviation in the subarray {@code a[lo..hi)};
+     *         {@code Double.NaN} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    public static double stddevp(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        return Math.sqrt(varp(a, lo, hi));
+    }
+
+    /**
+     * Returns the sum of all values in the specified array.
+     *
+     * @param  a the array
+     * @return the sum of all values in the array {@code a[]};
+     *         {@code 0.0} if no such value
+     */
+    private static double sum(double[] a) {
+        validateNotNull(a);
+        double sum = 0.0;
+        for (int i = 0; i < a.length; i++) {
+            sum += a[i];
+        }
+        return sum;
+    }
+
+    /**
+     * Returns the sum of all values in the specified subarray.
+     *
+     * @param  a the array
+     * @param lo the left endpoint of the subarray (inclusive)
+     * @param hi the right endpoint of the subarray (exclusive)
+     * @return the sum of all values in the subarray {@code a[lo..hi)};
+     *         {@code 0.0} if no such value
+     * @throws IllegalArgumentException if {@code a} is {@code null} 
+     * @throws IllegalArgumentException unless {@code (0 <= lo) && (lo < hi) && (hi <= a.length)}
+     */
+    private static double sum(double[] a, int lo, int hi) {
+        validateNotNull(a);
+        validateSubarrayIndices(lo, hi, a.length);
+
+        double sum = 0.0;
+        for (int i = lo; i < hi; i++) {
+            sum += a[i];
+        }
+        return sum;
+    }
+
+    /**
+     * Returns the sum of all values in the specified array.
+     *
+     * @param  a the array
+     * @return the sum of all values in the array {@code a[]};
+     *         {@code 0.0} if no such value
+     */
+    private static int sum(int[] a) {
+        validateNotNull(a);
+        int sum = 0;
+        for (int i = 0; i < a.length; i++) {
+            sum += a[i];
+        }
+        return sum;
+    }
+
+   /**
+     * Plots the points (0, <em>a</em><sub>0</sub>), (1, <em>a</em><sub>1</sub>), ...,
+     * (<em>n</em>-1, <em>a</em><sub><em>n</em>-1</sub>) to standard draw.
+     *
+     * @param a the array of values
+     */
+    public static void plotPoints(double[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        StdDraw.setXscale(-1, n);
+        StdDraw.setPenRadius(1.0 / (3.0 * n));
+        for (int i = 0; i < n; i++) {
+            StdDraw.point(i, a[i]);
+        }
+    }
+
+   /**
+     * Plots the line segments connecting 
+     * (<em>i</em>, <em>a</em><sub><em>i</em></sub>) to
+     * (<em>i</em>+1, <em>a</em><sub><em>i</em>+1</sub>) for 
+     * each <em>i</em> to standard draw.
+     *
+     * @param a the array of values
+     */
+    public static void plotLines(double[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        StdDraw.setXscale(-1, n);
+        StdDraw.setPenRadius();
+        for (int i = 1; i < n; i++) {
+            StdDraw.line(i-1, a[i-1], i, a[i]);
+        }
+    }
+
+   /**
+     * Plots bars from (0, <em>a</em><sub><em>i</em></sub>) to
+     * (<em>a</em><sub><em>i</em></sub>) for each <em>i</em>
+     * to standard draw.
+     *
+     * @param a the array of values
+     */
+    public static void plotBars(double[] a) {
+        validateNotNull(a);
+        int n = a.length;
+        StdDraw.setXscale(-1, n);
+        for (int i = 0; i < n; i++) {
+            StdDraw.filledRectangle(i, a[i]/2, 0.25, a[i]/2);
+        }
+    }
+
+    // throw an IllegalArgumentException if x is null
+    // (x is either of type double[] or int[])
+    private static void validateNotNull(Object x) {
+        if (x == null)
+            throw new IllegalArgumentException("argument is null");
+    }
+
+    // throw an exception unless 0 <= lo <= hi <= length
+    private static void validateSubarrayIndices(int lo, int hi, int length) {
+        if (lo < 0 || hi > length || lo > hi)
+            throw new IllegalArgumentException("subarray indices out of bounds: [" + lo + ", " + hi + ")");
+    }
+
+
+   /**
+     * Unit tests {@code StdStats}.
+     * Convert command-line arguments to array of doubles and call various methods.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        double[] a = StdArrayIO.readDouble1D();
+        StdOut.printf("       min %10.3f\n", min(a));
+        StdOut.printf("      mean %10.3f\n", mean(a));
+        StdOut.printf("       max %10.3f\n", max(a));
+        StdOut.printf("    stddev %10.3f\n", stddev(a));
+        StdOut.printf("       var %10.3f\n", var(a));
+        StdOut.printf("   stddevp %10.3f\n", stddevp(a));
+        StdOut.printf("      varp %10.3f\n", varp(a));
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Stopwatch.java b/src/main/java/edu/princeton/cs/algs4/Stopwatch.java
new file mode 100644
index 0000000..f165daf
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Stopwatch.java
@@ -0,0 +1,110 @@
+/******************************************************************************
+ *  Compilation:  javac Stopwatch.java
+ *  Execution:    java Stopwatch n
+ *  Dependencies: none
+ *
+ *  A utility class to measure the running time (wall clock) of a program.
+ *
+ *  % java8 Stopwatch 100000000
+ *  6.666667e+11  0.5820 seconds
+ *  6.666667e+11  8.4530 seconds
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Stopwatch} data type is for measuring
+ *  the time that elapses between the start and end of a
+ *  programming task (wall-clock time).
+ *
+ *  See {@link StopwatchCPU} for a version that measures CPU time.
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/14analysis">Section 1.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+
+public class Stopwatch { 
+
+    private final long start;
+
+    /**
+     * Initializes a new stopwatch.
+     */
+    public Stopwatch() {
+        start = System.currentTimeMillis();
+    } 
+
+
+    /**
+     * Returns the elapsed CPU time (in seconds) since the stopwatch was created.
+     *
+     * @return elapsed CPU time (in seconds) since the stopwatch was created
+     */
+    public double elapsedTime() {
+        long now = System.currentTimeMillis();
+        return (now - start) / 1000.0;
+    }
+
+    
+    /**
+     * Unit tests the {@code Stopwatch} data type.
+     * Takes a command-line argument {@code n} and computes the 
+     * sum of the square roots of the first {@code n} positive integers,
+     * first using {@code Math.sqrt()}, then using {@code Math.pow()}.
+     * It prints to standard output the sum and the amount of time to
+     * compute the sum. Note that the discrete sum can be approximated by
+     * an integral - the sum should be approximately 2/3 * (n^(3/2) - 1).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = Integer.parseInt(args[0]);
+
+        // sum of square roots of integers from 1 to n using Math.sqrt(x).
+        Stopwatch timer1 = new Stopwatch();
+        double sum1 = 0.0;
+        for (int i = 1; i <= n; i++) {
+            sum1 += Math.sqrt(i);
+        }
+        double time1 = timer1.elapsedTime();
+        StdOut.printf("%e (%.2f seconds)\n", sum1, time1);
+
+        // sum of square roots of integers from 1 to n using Math.pow(x, 0.5).
+        Stopwatch timer2 = new Stopwatch();
+        double sum2 = 0.0;
+        for (int i = 1; i <= n; i++) {
+            sum2 += Math.pow(i, 0.5);
+        }
+        double time2 = timer2.elapsedTime();
+        StdOut.printf("%e (%.2f seconds)\n", sum2, time2);
+    }
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/StopwatchCPU.java b/src/main/java/edu/princeton/cs/algs4/StopwatchCPU.java
new file mode 100644
index 0000000..e506e4d
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/StopwatchCPU.java
@@ -0,0 +1,112 @@
+/******************************************************************************
+ *  Compilation:  javac StopwatchCPU.java
+ *  Execution:    java StopwtachCPU n
+ *  Dependencies: none
+ *
+ *  A version of Stopwatch.java that measures CPU time on a single
+ *  core or processor (instead of wall clock time).
+ *
+ *  % java8 StopwatchCPU 100000000
+ *  6.666667e+11 (1.05 seconds)
+ *  6.666667e+11 (7.50 seconds)
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.lang.management.ThreadMXBean;
+import java.lang.management.ManagementFactory;
+
+/**
+ *  The {@code StopwatchCPU} data type is for measuring
+ *  the CPU time used during a programming task.
+ *
+ *  See {@link Stopwatch} for a version that measures wall-clock time
+ *  (the real time that elapses).
+ *
+ *  @author Josh Hug
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class StopwatchCPU {
+    private static final double NANOSECONDS_PER_SECOND = 1000000000;
+
+    private final ThreadMXBean threadTimer;
+    private final long start;
+            
+    /**
+     * Initializes a new stopwatch.
+     */
+    public StopwatchCPU() {  
+        threadTimer = ManagementFactory.getThreadMXBean();
+        start = threadTimer.getCurrentThreadCpuTime();
+    }   
+        
+    /**
+     * Returns the elapsed CPU time (in seconds) since the stopwatch was created.
+     *
+     * @return elapsed CPU time (in seconds) since the stopwatch was created
+     */
+    public double elapsedTime() {
+        long now = threadTimer.getCurrentThreadCpuTime();
+        return (now - start) / NANOSECONDS_PER_SECOND;
+    }
+
+    /**
+     * Unit tests the {@code StopwatchCPU} data type.
+     * Takes a command-line argument {@code n} and computes the 
+     * sum of the square roots of the first {@code n} positive integers,
+     * first using {@code Math.sqrt()}, then using {@code Math.pow()}.
+     * It prints to standard output the sum and the amount of time to
+     * compute the sum. Note that the discrete sum can be approximated by
+     * an integral - the sum should be approximately 2/3 * (n^(3/2) - 1).
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = Integer.parseInt(args[0]);
+
+        // sum of square roots of integers from 1 to n using Math.sqrt(x).
+        StopwatchCPU timer1 = new StopwatchCPU();
+        double sum1 = 0.0;
+        for (int i = 1; i <= n; i++) {
+            sum1 += Math.sqrt(i);
+        }
+        double time1 = timer1.elapsedTime();
+        StdOut.printf("%e (%.2f seconds)\n", sum1, time1);
+
+        // sum of square roots of integers from 1 to n using Math.pow(x, 0.5).
+        StopwatchCPU timer2 = new StopwatchCPU();
+        double sum2 = 0.0;
+        for (int i = 1; i <= n; i++) {
+            sum2 += Math.pow(i, 0.5);
+        }
+        double time2 = timer2.elapsedTime();
+        StdOut.printf("%e (%.2f seconds)\n", sum2, time2);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SuffixArray.java b/src/main/java/edu/princeton/cs/algs4/SuffixArray.java
new file mode 100644
index 0000000..d55789c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SuffixArray.java
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *  Compilation:  javac SuffixArray.java
+ *  Execution:    java SuffixArray < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/63suffix/abra.txt
+ *
+ *  A data type that computes the suffix array of a string.
+ *
+ *   % java SuffixArray < abra.txt
+ *    i ind lcp rnk  select
+ *   ---------------------------
+ *    0  11   -   0  "!"
+ *    1  10   0   1  "A!"
+ *    2   7   1   2  "ABRA!"
+ *    3   0   4   3  "ABRACADABRA!"
+ *    4   3   1   4  "ACADABRA!"
+ *    5   5   1   5  "ADABRA!"
+ *    6   8   0   6  "BRA!"
+ *    7   1   3   7  "BRACADABRA!"
+ *    8   4   0   8  "CADABRA!"
+ *    9   6   0   9  "DABRA!"
+ *   10   9   0  10  "RA!"
+ *   11   2   2  11  "RACADABRA!"
+ *
+ *  See SuffixArrayX.java for an optimized version that uses 3-way
+ *  radix quicksort and does not use the nested class Suffix.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ *  The {@code SuffixArray} class represents a suffix array of a string of
+ *  length <em>n</em>.
+ *  It supports the <em>selecting</em> the <em>i</em>th smallest suffix,
+ *  getting the <em>index</em> of the <em>i</em>th smallest suffix,
+ *  computing the length of the <em>longest common prefix</em> between the
+ *  <em>i</em>th smallest suffix and the <em>i</em>-1st smallest suffix,
+ *  and determining the <em>rank</em> of a query string (which is the number
+ *  of suffixes strictly less than the query string).
+ *  <p>
+ *  This implementation uses a nested class {@code Suffix} to represent
+ *  a suffix of a string (using constant time and space) and
+ *  {@code Arrays.sort()} to sort the array of suffixes.
+ *  The <em>index</em> and <em>length</em> operations takes constant time 
+ *  in the worst case. The <em>lcp</em> operation takes time proportional to the
+ *  length of the longest common prefix.
+ *  The <em>select</em> operation takes time proportional
+ *  to the length of the suffix and should be used primarily for debugging.
+ *  <p>
+ *  For alternate implementations of the same API, see
+ *  {@link SuffixArrayX}, which is faster in practice (uses 3-way radix quicksort)
+ *  and uses less memory (does not create {@code Suffix} objects)
+ *  and <a href = "https://algs4.cs.princeton.edu/63suffix/SuffixArrayJava6.java.html">SuffixArrayJava6.java</a>,
+ *  which relies on the constant-time substring extraction method that existed
+ *  in Java 6.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/63suffix">Section 6.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class SuffixArray {
+    private Suffix[] suffixes;
+
+    /**
+     * Initializes a suffix array for the given {@code text} string.
+     * @param text the input string
+     */
+    public SuffixArray(String text) {
+        int n = text.length();
+        this.suffixes = new Suffix[n];
+        for (int i = 0; i < n; i++)
+            suffixes[i] = new Suffix(text, i);
+        Arrays.sort(suffixes);
+    }
+
+    private static class Suffix implements Comparable<Suffix> {
+        private final String text;
+        private final int index;
+
+        private Suffix(String text, int index) {
+            this.text = text;
+            this.index = index;
+        }
+        private int length() {
+            return text.length() - index;
+        }
+        private char charAt(int i) {
+            return text.charAt(index + i);
+        }
+
+        public int compareTo(Suffix that) {
+            if (this == that) return 0;  // optimization
+            int n = Math.min(this.length(), that.length());
+            for (int i = 0; i < n; i++) {
+                if (this.charAt(i) < that.charAt(i)) return -1;
+                if (this.charAt(i) > that.charAt(i)) return +1;
+            }
+            return this.length() - that.length();
+        }
+
+        public String toString() {
+            return text.substring(index);
+        }
+    }
+
+    /**
+     * Returns the length of the input string.
+     * @return the length of the input string
+     */
+    public int length() {
+        return suffixes.length;
+    }
+
+
+    /**
+     * Returns the index into the original string of the <em>i</em>th smallest suffix.
+     * That is, {@code text.substring(sa.index(i))} is the <em>i</em>th smallest suffix.
+     * @param i an integer between 0 and <em>n</em>-1
+     * @return the index into the original string of the <em>i</em>th smallest suffix
+     * @throws java.lang.IllegalArgumentException unless {@code 0 <= i < n}
+     */
+    public int index(int i) {
+        if (i < 0 || i >= suffixes.length) throw new IllegalArgumentException();
+        return suffixes[i].index;
+    }
+
+
+    /**
+     * Returns the length of the longest common prefix of the <em>i</em>th
+     * smallest suffix and the <em>i</em>-1st smallest suffix.
+     * @param i an integer between 1 and <em>n</em>-1
+     * @return the length of the longest common prefix of the <em>i</em>th
+     * smallest suffix and the <em>i</em>-1st smallest suffix.
+     * @throws java.lang.IllegalArgumentException unless {@code 1 <= i < n}
+     */
+    public int lcp(int i) {
+        if (i < 1 || i >= suffixes.length) throw new IllegalArgumentException();
+        return lcpSuffix(suffixes[i], suffixes[i-1]);
+    }
+
+    // longest common prefix of s and t
+    private static int lcpSuffix(Suffix s, Suffix t) {
+        int n = Math.min(s.length(), t.length());
+        for (int i = 0; i < n; i++) {
+            if (s.charAt(i) != t.charAt(i)) return i;
+        }
+        return n;
+    }
+
+    /**
+     * Returns the <em>i</em>th smallest suffix as a string.
+     * @param i the index
+     * @return the <em>i</em> smallest suffix as a string
+     * @throws java.lang.IllegalArgumentException unless {@code 0 <= i < n}
+     */
+    public String select(int i) {
+        if (i < 0 || i >= suffixes.length) throw new IllegalArgumentException();
+        return suffixes[i].toString();
+    }
+
+    /**
+     * Returns the number of suffixes strictly less than the {@code query} string.
+     * We note that {@code rank(select(i))} equals {@code i} for each {@code i}
+     * between 0 and <em>n</em>-1.
+     * @param query the query string
+     * @return the number of suffixes strictly less than {@code query}
+     */
+    public int rank(String query) {
+        int lo = 0, hi = suffixes.length - 1;
+        while (lo <= hi) {
+            int mid = lo + (hi - lo) / 2;
+            int cmp = compare(query, suffixes[mid]);
+            if (cmp < 0) hi = mid - 1;
+            else if (cmp > 0) lo = mid + 1;
+            else return mid;
+        }
+        return lo;
+    }
+
+    // compare query string to suffix
+    private static int compare(String query, Suffix suffix) {
+        int n = Math.min(query.length(), suffix.length());
+        for (int i = 0; i < n; i++) {
+            if (query.charAt(i) < suffix.charAt(i)) return -1;
+            if (query.charAt(i) > suffix.charAt(i)) return +1;
+        }
+        return query.length() - suffix.length();
+    }
+
+    /**
+     * Unit tests the {@code SuffixArray} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String s = StdIn.readAll().replaceAll("\\s+", " ").trim();
+        SuffixArray suffix = new SuffixArray(s);
+
+        // StdOut.println("rank(" + args[0] + ") = " + suffix.rank(args[0]));
+
+        StdOut.println("  i ind lcp rnk select");
+        StdOut.println("---------------------------");
+
+        for (int i = 0; i < s.length(); i++) {
+            int index = suffix.index(i);
+            String ith = "\"" + s.substring(index, Math.min(index + 50, s.length())) + "\"";
+            assert s.substring(index).equals(suffix.select(i));
+            int rank = suffix.rank(s.substring(index));
+            if (i == 0) {
+                StdOut.printf("%3d %3d %3s %3d %s\n", i, index, "-", rank, ith);
+            }
+            else {
+                int lcp = suffix.lcp(i);
+                StdOut.printf("%3d %3d %3d %3d %s\n", i, index, lcp, rank, ith);
+            }
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SuffixArrayX.java b/src/main/java/edu/princeton/cs/algs4/SuffixArrayX.java
new file mode 100644
index 0000000..a89d61a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SuffixArrayX.java
@@ -0,0 +1,295 @@
+/******************************************************************************
+ *  Compilation:  javac SuffixArrayX.java
+ *  Execution:    java SuffixArrayX < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/63suffix/abra.txt
+ *  
+ *  A data type that computes the suffix array of a string using 3-way
+ *  radix quicksort.
+ *
+ *  % java SuffixArrayX < abra.txt 
+ *    i ind lcp rnk  select
+ *  ---------------------------
+ *    0  11   -   0  !
+ *    1  10   0   1  A!
+ *    2   7   1   2  ABRA!
+ *    3   0   4   3  ABRACADABRA!
+ *    4   3   1   4  ACADABRA!
+ *    5   5   1   5  ADABRA!
+ *    6   8   0   6  BRA!
+ *    7   1   3   7  BRACADABRA!
+ *    8   4   0   8  CADABRA!
+ *    9   6   0   9  DABRA!
+ *   10   9   0  10  RA!
+ *   11   2   2  11  RACADABRA!
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code SuffixArrayX} class represents a suffix array of a string of
+ *  length <em>n</em>.
+ *  It supports the <em>selecting</em> the <em>i</em>th smallest suffix,
+ *  getting the <em>index</em> of the <em>i</em>th smallest suffix,
+ *  computing the length of the <em>longest common prefix</em> between the
+ *  <em>i</em>th smallest suffix and the <em>i</em>-1st smallest suffix,
+ *  and determining the <em>rank</em> of a query string (which is the number
+ *  of suffixes strictly less than the query string).
+ *  <p>
+ *  This implementation uses 3-way radix quicksort to sort the array of suffixes.
+ *  For a simpler (but less efficient) implementations of the same API, see
+ *  {@link SuffixArray}.
+ *  The <em>index</em> and <em>length</em> operations takes constant time
+ *  in the worst case. The <em>lcp</em> operation takes time proportional to the
+ *  length of the longest common prefix.
+ *  The <em>select</em> operation takes time proportional
+ *  to the length of the suffix and should be used primarily for debugging.
+ *  <p>
+ *  This implementation uses '\0' as a sentinel and assumes that the charater
+ *  '\0' does not appear in the text.
+ *  <p>
+ *  In practice, this algorithm runs very fast. However, in the worst-case
+ *  it can be very poor (e.g., a string consisting of N copies of the same
+ *  character. We do not shuffle the array of suffixes before sorting because
+ *  shuffling is relatively expensive and a pathologial input for which 
+ *  the suffixes start out in a bad order (e.g., sorted) is likely to be
+ *  a bad input for this algorithm with or without the shuffle.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/63suffix">Section 6.3</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class SuffixArrayX {
+    private static final int CUTOFF =  5;   // cutoff to insertion sort (any value between 0 and 12)
+
+    private final char[] text;
+    private final int[] index;   // index[i] = j means text.substring(j) is ith largest suffix
+    private final int n;         // number of characters in text
+
+    /**
+     * Initializes a suffix array for the given {@code text} string.
+     * @param text the input string
+     */
+    public SuffixArrayX(String text) {
+        n = text.length();
+        text = text + '\0';
+        this.text = text.toCharArray();
+        this.index = new int[n];
+        for (int i = 0; i < n; i++)
+            index[i] = i;
+
+        sort(0, n-1, 0);
+    }
+
+    // 3-way string quicksort lo..hi starting at dth character
+    private void sort(int lo, int hi, int d) { 
+
+        // cutoff to insertion sort for small subarrays
+        if (hi <= lo + CUTOFF) {
+            insertion(lo, hi, d);
+            return;
+        }
+
+        int lt = lo, gt = hi;
+        char v = text[index[lo] + d];
+        int i = lo + 1;
+        while (i <= gt) {
+            char t = text[index[i] + d];
+            if      (t < v) exch(lt++, i++);
+            else if (t > v) exch(i, gt--);
+            else            i++;
+        }
+
+        // a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]. 
+        sort(lo, lt-1, d);
+        if (v > 0) sort(lt, gt, d+1);
+        sort(gt+1, hi, d);
+    }
+
+    // sort from a[lo] to a[hi], starting at the dth character
+    private void insertion(int lo, int hi, int d) {
+        for (int i = lo; i <= hi; i++)
+            for (int j = i; j > lo && less(index[j], index[j-1], d); j--)
+                exch(j, j-1);
+    }
+
+    // is text[i+d..n) < text[j+d..n) ?
+    private boolean less(int i, int j, int d) {
+        if (i == j) return false;
+        i = i + d;
+        j = j + d;
+        while (i < n && j < n) {
+            if (text[i] < text[j]) return true;
+            if (text[i] > text[j]) return false;
+            i++;
+            j++;
+        }
+        return i > j;
+    }
+
+    // exchange index[i] and index[j]
+    private void exch(int i, int j) {
+        int swap = index[i];
+        index[i] = index[j];
+        index[j] = swap;
+    }
+
+    /**
+     * Returns the length of the input string.
+     * @return the length of the input string
+     */
+    public int length() {
+        return n;
+    }
+
+
+    /**
+     * Returns the index into the original string of the <em>i</em>th smallest suffix.
+     * That is, {@code text.substring(sa.index(i))} is the <em>i</em> smallest suffix.
+     * @param i an integer between 0 and <em>n</em>-1
+     * @return the index into the original string of the <em>i</em>th smallest suffix
+     * @throws java.lang.IllegalArgumentException unless {@code 0 <=i < n}
+     */
+    public int index(int i) {
+        if (i < 0 || i >= n) throw new IllegalArgumentException();
+        return index[i];
+    }
+
+    /**
+     * Returns the length of the longest common prefix of the <em>i</em>th
+     * smallest suffix and the <em>i</em>-1st smallest suffix.
+     * @param i an integer between 1 and <em>n</em>-1
+     * @return the length of the longest common prefix of the <em>i</em>th
+     * smallest suffix and the <em>i</em>-1st smallest suffix.
+     * @throws java.lang.IllegalArgumentException unless {@code 1 <= i < n}
+     */
+    public int lcp(int i) {
+        if (i < 1 || i >= n) throw new IllegalArgumentException();
+        return lcp(index[i], index[i-1]);
+    }
+
+    // longest common prefix of text[i..n) and text[j..n)
+    private int lcp(int i, int j) {
+        int length = 0;
+        while (i < n && j < n) {
+            if (text[i] != text[j]) return length;
+            i++;
+            j++;
+            length++;
+        }
+        return length;
+    }
+
+    /**
+     * Returns the <em>i</em>th smallest suffix as a string.
+     * @param i the index
+     * @return the <em>i</em> smallest suffix as a string
+     * @throws java.lang.IllegalArgumentException unless {@code 0 <= i < n}
+     */
+    public String select(int i) {
+        if (i < 0 || i >= n) throw new IllegalArgumentException();
+        return new String(text, index[i], n - index[i]);
+    }
+
+    /**
+     * Returns the number of suffixes strictly less than the {@code query} string.
+     * We note that {@code rank(select(i))} equals {@code i} for each {@code i}
+     * between 0 and <em>n</em>-1. 
+     * @param query the query string
+     * @return the number of suffixes strictly less than {@code query}
+     */
+    public int rank(String query) {
+        int lo = 0, hi = n - 1;
+        while (lo <= hi) {
+            int mid = lo + (hi - lo) / 2;
+            int cmp = compare(query, index[mid]);
+            if      (cmp < 0) hi = mid - 1;
+            else if (cmp > 0) lo = mid + 1;
+            else return mid;
+        }
+        return lo;
+    } 
+
+    // is query < text[i..n) ?
+    private int compare(String query, int i) {
+        int m = query.length();
+        int j = 0;
+        while (i < n && j < m) {
+            if (query.charAt(j) != text[i]) return query.charAt(j) - text[i];
+            i++;
+            j++;
+
+        }
+        if (i < n) return -1;
+        if (j < m) return +1;
+        return 0;
+    }
+
+
+    /**
+     * Unit tests the {@code SuffixArrayx} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String s = StdIn.readAll().replaceAll("\n", " ").trim();
+        SuffixArrayX suffix1 = new SuffixArrayX(s);
+        SuffixArray suffix2 = new SuffixArray(s);
+        boolean check = true;
+        for (int i = 0; check && i < s.length(); i++) {
+            if (suffix1.index(i) != suffix2.index(i)) {
+                StdOut.println("suffix1(" + i + ") = " + suffix1.index(i));
+                StdOut.println("suffix2(" + i + ") = " + suffix2.index(i));
+                String ith = "\"" + s.substring(suffix1.index(i), Math.min(suffix1.index(i) + 50, s.length())) + "\"";
+                String jth = "\"" + s.substring(suffix2.index(i), Math.min(suffix2.index(i) + 50, s.length())) + "\"";
+                StdOut.println(ith);
+                StdOut.println(jth);
+                check = false;
+            }
+        }
+
+        StdOut.println("  i ind lcp rnk  select");
+        StdOut.println("---------------------------");
+
+        for (int i = 0; i < s.length(); i++) {
+            int index = suffix2.index(i);
+            String ith = "\"" + s.substring(index, Math.min(index + 50, s.length())) + "\"";
+            int rank = suffix2.rank(s.substring(index));
+            assert s.substring(index).equals(suffix2.select(i));
+            if (i == 0) {
+                StdOut.printf("%3d %3d %3s %3d  %s\n", i, index, "-", rank, ith);
+            }
+            else {
+                // int lcp  = suffix.lcp(suffix2.index(i), suffix2.index(i-1));
+                int lcp  = suffix2.lcp(i);
+                StdOut.printf("%3d %3d %3d %3d  %s\n", i, index, lcp, rank, ith);
+            }
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SymbolDigraph.java b/src/main/java/edu/princeton/cs/algs4/SymbolDigraph.java
new file mode 100644
index 0000000..66359ea
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SymbolDigraph.java
@@ -0,0 +1,213 @@
+/******************************************************************************
+ *  Compilation:  javac SymbolDigraph.java
+ *  Execution:    java SymbolDigraph
+ *  Dependencies: ST.java Digraph.java In.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/routes.txt
+ *  
+ *  %  java SymbolDigraph routes.txt " "
+ *  JFK
+ *     MCO
+ *     ATL
+ *     ORD
+ *  ATL
+ *     HOU
+ *     MCO
+ *  LAX
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code SymbolDigraph} class represents a digraph, where the
+ *  vertex names are arbitrary strings.
+ *  By providing mappings between string vertex names and integers,
+ *  it serves as a wrapper around the
+ *  {@link Digraph} data type, which assumes the vertex names are integers
+ *  between 0 and <em>V</em> - 1.
+ *  It also supports initializing a symbol digraph from a file.
+ *  <p>
+ *  This implementation uses an {@link ST} to map from strings to integers,
+ *  an array to map from integers to strings, and a {@link Digraph} to store
+ *  the underlying graph.
+ *  The <em>indexOf</em> and <em>contains</em> operations take time 
+ *  proportional to log <em>V</em>, where <em>V</em> is the number of vertices.
+ *  The <em>nameOf</em> operation takes constant time.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class SymbolDigraph {
+    private ST<String, Integer> st;  // string -> index
+    private String[] keys;           // index  -> string
+    private Digraph graph;           // the underlying digraph
+
+    /**  
+     * Initializes a digraph from a file using the specified delimiter.
+     * Each line in the file contains
+     * the name of a vertex, followed by a list of the names
+     * of the vertices adjacent to that vertex, separated by the delimiter.
+     * @param filename the name of the file
+     * @param delimiter the delimiter between fields
+     */
+    public SymbolDigraph(String filename, String delimiter) {
+        st = new ST<String, Integer>();
+
+        // First pass builds the index by reading strings to associate
+        // distinct strings with an index
+        In in = new In(filename);
+        while (in.hasNextLine()) {
+            String[] a = in.readLine().split(delimiter);
+            for (int i = 0; i < a.length; i++) {
+                if (!st.contains(a[i]))
+                    st.put(a[i], st.size());
+            }
+        }
+
+        // inverted index to get string keys in an array
+        keys = new String[st.size()];
+        for (String name : st.keys()) {
+            keys[st.get(name)] = name;
+        }
+
+        // second pass builds the digraph by connecting first vertex on each
+        // line to all others
+        graph = new Digraph(st.size());
+        in = new In(filename);
+        while (in.hasNextLine()) {
+            String[] a = in.readLine().split(delimiter);
+            int v = st.get(a[0]);
+            for (int i = 1; i < a.length; i++) {
+                int w = st.get(a[i]);
+                graph.addEdge(v, w);
+            }
+        }
+    }
+
+    /**
+     * Does the digraph contain the vertex named {@code s}?
+     * @param s the name of a vertex
+     * @return {@code true} if {@code s} is the name of a vertex, and {@code false} otherwise
+     */
+    public boolean contains(String s) {
+        return st.contains(s);
+    }
+
+    /**
+     * Returns the integer associated with the vertex named {@code s}.
+     * @param s the name of a vertex
+     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
+     * @deprecated Replaced by {@link #indexOf(String)}.
+     */
+    @Deprecated
+    public int index(String s) {
+        return st.get(s);
+    }
+
+    /**
+     * Returns the integer associated with the vertex named {@code s}.
+     * @param s the name of a vertex
+     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
+     */
+    public int indexOf(String s) {
+        return st.get(s);
+    }
+
+    /**
+     * Returns the name of the vertex associated with the integer {@code v}.
+     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
+     * @return the name of the vertex associated with the integer {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @deprecated Replaced by {@link #nameOf(int)}.
+     */
+    @Deprecated
+    public String name(int v) {
+        validateVertex(v);
+        return keys[v];
+    }
+
+    /**
+     * Returns the name of the vertex associated with the integer {@code v}.
+     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
+     * @return the name of the vertex associated with the integer {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public String nameOf(int v) {
+        validateVertex(v);
+        return keys[v];
+    }
+
+    /**
+     * Returns the digraph assoicated with the symbol graph. It is the client's responsibility
+     * not to mutate the digraph.
+     *
+     * @return the digraph associated with the symbol digraph
+     * @deprecated Replaced by {@link #digraph()}.
+     */
+    @Deprecated
+    public Digraph G() {
+        return graph;
+    }
+
+    /**
+     * Returns the digraph assoicated with the symbol graph. It is the client's responsibility
+     * not to mutate the digraph.
+     *
+     * @return the digraph associated with the symbol digraph
+     */
+    public Digraph digraph() {
+        return graph;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = graph.V();
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code SymbolDigraph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String filename  = args[0];
+        String delimiter = args[1];
+        SymbolDigraph sg = new SymbolDigraph(filename, delimiter);
+        Digraph graph = sg.digraph();
+        while (!StdIn.isEmpty()) {
+            String t = StdIn.readLine();
+            for (int v : graph.adj(sg.index(t))) {
+                StdOut.println("   " + sg.name(v));
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/SymbolGraph.java b/src/main/java/edu/princeton/cs/algs4/SymbolGraph.java
new file mode 100644
index 0000000..ee985d9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/SymbolGraph.java
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *  Compilation:  javac SymbolGraph.java
+ *  Execution:    java SymbolGraph filename.txt delimiter
+ *  Dependencies: ST.java Graph.java In.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/41graph/routes.txt
+ *                https://algs4.cs.princeton.edu/41graph/movies.txt
+ *                https://algs4.cs.princeton.edu/41graph/moviestiny.txt
+ *                https://algs4.cs.princeton.edu/41graph/moviesG.txt
+ *                https://algs4.cs.princeton.edu/41graph/moviestopGrossing.txt
+ *  
+ *  %  java SymbolGraph routes.txt " "
+ *  JFK
+ *     MCO
+ *     ATL
+ *     ORD
+ *  LAX
+ *     PHX
+ *     LAS
+ *
+ *  % java SymbolGraph movies.txt "/"
+ *  Tin Men (1987)
+ *     Hershey, Barbara
+ *     Geppi, Cindy
+ *     Jones, Kathy (II)
+ *     Herr, Marcia
+ *     ...
+ *     Blumenfeld, Alan
+ *     DeBoy, David
+ *  Bacon, Kevin
+ *     Woodsman, The (2004)
+ *     Wild Things (1998)
+ *     Where the Truth Lies (2005)
+ *     Tremors (1990)
+ *     ...
+ *     Apollo 13 (1995)
+ *     Animal House (1978)
+ *
+ * 
+ *  Assumes that input file is encoded using UTF-8.
+ *  % iconv -f ISO-8859-1 -t UTF-8 movies-iso8859.txt > movies.txt
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code SymbolGraph} class represents an undirected graph, where the
+ *  vertex names are arbitrary strings.
+ *  By providing mappings between string vertex names and integers,
+ *  it serves as a wrapper around the
+ *  {@link Graph} data type, which assumes the vertex names are integers
+ *  between 0 and <em>V</em> - 1.
+ *  It also supports initializing a symbol graph from a file.
+ *  <p>
+ *  This implementation uses an {@link ST} to map from strings to integers,
+ *  an array to map from integers to strings, and a {@link Graph} to store
+ *  the underlying graph.
+ *  The <em>indexOf</em> and <em>contains</em> operations take time 
+ *  proportional to log <em>V</em>, where <em>V</em> is the number of vertices.
+ *  The <em>nameOf</em> operation takes constant time.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class SymbolGraph {
+    private ST<String, Integer> st;  // string -> index
+    private String[] keys;           // index  -> string
+    private Graph graph;             // the underlying graph
+
+    /**  
+     * Initializes a graph from a file using the specified delimiter.
+     * Each line in the file contains
+     * the name of a vertex, followed by a list of the names
+     * of the vertices adjacent to that vertex, separated by the delimiter.
+     * @param filename the name of the file
+     * @param delimiter the delimiter between fields
+     */
+    public SymbolGraph(String filename, String delimiter) {
+        st = new ST<String, Integer>();
+
+        // First pass builds the index by reading strings to associate
+        // distinct strings with an index
+        In in = new In(filename);
+        // while (in.hasNextLine()) {
+        while (!in.isEmpty()) {
+            String[] a = in.readLine().split(delimiter);
+            for (int i = 0; i < a.length; i++) {
+                if (!st.contains(a[i]))
+                    st.put(a[i], st.size());
+            }
+        }
+
+        // inverted index to get string keys in an array
+        keys = new String[st.size()];
+        for (String name : st.keys()) {
+            keys[st.get(name)] = name;
+        }
+
+        // second pass builds the graph by connecting first vertex on each
+        // line to all others
+        graph = new Graph(st.size());
+        in = new In(filename);
+        while (in.hasNextLine()) {
+            String[] a = in.readLine().split(delimiter);
+            int v = st.get(a[0]);
+            for (int i = 1; i < a.length; i++) {
+                int w = st.get(a[i]);
+                graph.addEdge(v, w);
+            }
+        }
+    }
+
+    /**
+     * Does the graph contain the vertex named {@code s}?
+     * @param s the name of a vertex
+     * @return {@code true} if {@code s} is the name of a vertex, and {@code false} otherwise
+     */
+    public boolean contains(String s) {
+        return st.contains(s);
+    }
+
+    /**
+     * Returns the integer associated with the vertex named {@code s}.
+     * @param s the name of a vertex
+     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
+     * @deprecated Replaced by {@link #indexOf(String)}.
+     */
+    @Deprecated
+    public int index(String s) {
+        return st.get(s);
+    }
+
+
+    /**
+     * Returns the integer associated with the vertex named {@code s}.
+     * @param s the name of a vertex
+     * @return the integer (between 0 and <em>V</em> - 1) associated with the vertex named {@code s}
+     */
+    public int indexOf(String s) {
+        return st.get(s);
+    }
+
+    /**
+     * Returns the name of the vertex associated with the integer {@code v}.
+     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
+     * @return the name of the vertex associated with the integer {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @deprecated Replaced by {@link #nameOf(int)}.
+     */
+    @Deprecated
+    public String name(int v) {
+        validateVertex(v);
+        return keys[v];
+    }
+
+    /**
+     * Returns the name of the vertex associated with the integer {@code v}.
+     * @param  v the integer corresponding to a vertex (between 0 and <em>V</em> - 1) 
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @return the name of the vertex associated with the integer {@code v}
+     */
+    public String nameOf(int v) {
+        validateVertex(v);
+        return keys[v];
+    }
+
+    /**
+     * Returns the graph assoicated with the symbol graph. It is the client's responsibility
+     * not to mutate the graph.
+     * @return the graph associated with the symbol graph
+     * @deprecated Replaced by {@link #graph()}.
+     */
+    @Deprecated
+    public Graph G() {
+        return graph;
+    }
+
+    /**
+     * Returns the graph assoicated with the symbol graph. It is the client's responsibility
+     * not to mutate the graph.
+     * @return the graph associated with the symbol graph
+     */
+    public Graph graph() {
+        return graph;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = graph.V();
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+
+    /**
+     * Unit tests the {@code SymbolGraph} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String filename  = args[0];
+        String delimiter = args[1];
+        SymbolGraph sg = new SymbolGraph(filename, delimiter);
+        Graph graph = sg.graph();
+        while (StdIn.hasNextLine()) {
+            String source = StdIn.readLine();
+            if (sg.contains(source)) {
+                int s = sg.index(source);
+                for (int v : graph.adj(s)) {
+                    StdOut.println("   " + sg.name(v));
+                }
+            }
+            else {
+                StdOut.println("input not contain '" + source + "'");
+            }
+        }
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TST.java b/src/main/java/edu/princeton/cs/algs4/TST.java
new file mode 100644
index 0000000..fbcdb77
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TST.java
@@ -0,0 +1,322 @@
+/******************************************************************************
+ *  Compilation:  javac TST.java
+ *  Execution:    java TST < words.txt
+ *  Dependencies: StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/52trie/shellsST.txt
+ *
+ *  Symbol table with string keys, implemented using a ternary search
+ *  trie (TST).
+ *
+ *
+ *  % java TST < shellsST.txt
+ *  keys(""):
+ *  by 4
+ *  sea 6
+ *  sells 1
+ *  she 0
+ *  shells 3
+ *  shore 7
+ *  the 5
+ *
+ *  longestPrefixOf("shellsort"):
+ *  shells
+ *
+ *  keysWithPrefix("shor"):
+ *  shore
+ *
+ *  keysThatMatch(".he.l."):
+ *  shells
+ *
+ *  % java TST
+ *  theory the now is the time for all good men
+ *
+ *  Remarks
+ *  --------
+ *    - can't use a key that is the empty string ""
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TST} class represents an symbol table of key-value
+ *  pairs, with string keys and generic values.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides character-based methods for finding the string
+ *  in the symbol table that is the <em>longest prefix</em> of a given prefix,
+ *  finding all strings in the symbol table that <em>start with</em> a given prefix,
+ *  and finding all strings in the symbol table that <em>match</em> a given pattern.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  This implementation uses a ternary search trie.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/52trie">Section 5.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class TST<Value> {
+    private int n;              // size
+    private Node<Value> root;   // root of TST
+
+    private static class Node<Value> {
+        private char c;                        // character
+        private Node<Value> left, mid, right;  // left, middle, and right subtries
+        private Value val;                     // value associated with string
+    }
+
+    /**
+     * Initializes an empty string symbol table.
+     */
+    public TST() {
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Does this symbol table contain the given key?
+     * @param key the key
+     * @return {@code true} if this symbol table contains {@code key} and
+     *     {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(String key) {
+        if (key == null) {
+            throw new IllegalArgumentException("argument to contains() is null");
+        }
+        return get(key) != null;
+    }
+
+    /**
+     * Returns the value associated with the given key.
+     * @param key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *     and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(String key) {
+        if (key == null) {
+            throw new IllegalArgumentException("calls get() with null argument");
+        }
+        if (key.length() == 0) throw new IllegalArgumentException("key must have length >= 1");
+        Node<Value> x = get(root, key, 0);
+        if (x == null) return null;
+        return x.val;
+    }
+
+    // return subtrie corresponding to given key
+    private Node<Value> get(Node<Value> x, String key, int d) {
+        if (x == null) return null;
+        if (key.length() == 0) throw new IllegalArgumentException("key must have length >= 1");
+        char c = key.charAt(d);
+        if      (c < x.c)              return get(x.left,  key, d);
+        else if (c > x.c)              return get(x.right, key, d);
+        else if (d < key.length() - 1) return get(x.mid,   key, d+1);
+        else                           return x;
+    }
+
+    /**
+     * Inserts the key-value pair into the symbol table, overwriting the old value
+     * with the new value if the key is already in the symbol table.
+     * If the value is {@code null}, this effectively deletes the key from the symbol table.
+     * @param key the key
+     * @param val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(String key, Value val) {
+        if (key == null) {
+            throw new IllegalArgumentException("calls put() with null key");
+        }
+        if (!contains(key)) n++;
+        else if(val == null) n--;       // delete existing key
+        root = put(root, key, val, 0);
+    }
+
+    private Node<Value> put(Node<Value> x, String key, Value val, int d) {
+        char c = key.charAt(d);
+        if (x == null) {
+            x = new Node<Value>();
+            x.c = c;
+        }
+        if      (c < x.c)               x.left  = put(x.left,  key, val, d);
+        else if (c > x.c)               x.right = put(x.right, key, val, d);
+        else if (d < key.length() - 1)  x.mid   = put(x.mid,   key, val, d+1);
+        else                            x.val   = val;
+        return x;
+    }
+
+    /**
+     * Returns the string in the symbol table that is the longest prefix of {@code query},
+     * or {@code null}, if no such string.
+     * @param query the query string
+     * @return the string in the symbol table that is the longest prefix of {@code query},
+     *     or {@code null} if no such string
+     * @throws IllegalArgumentException if {@code query} is {@code null}
+     */
+    public String longestPrefixOf(String query) {
+        if (query == null) {
+            throw new IllegalArgumentException("calls longestPrefixOf() with null argument");
+        }
+        if (query.length() == 0) return null;
+        int length = 0;
+        Node<Value> x = root;
+        int i = 0;
+        while (x != null && i < query.length()) {
+            char c = query.charAt(i);
+            if      (c < x.c) x = x.left;
+            else if (c > x.c) x = x.right;
+            else {
+                i++;
+                if (x.val != null) length = i;
+                x = x.mid;
+            }
+        }
+        return query.substring(0, length);
+    }
+
+    /**
+     * Returns all keys in the symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     * @return all keys in the symbol table as an {@code Iterable}
+     */
+    public Iterable<String> keys() {
+        Queue<String> queue = new Queue<String>();
+        collect(root, new StringBuilder(), queue);
+        return queue;
+    }
+
+    /**
+     * Returns all of the keys in the set that start with {@code prefix}.
+     * @param prefix the prefix
+     * @return all of the keys in the set that start with {@code prefix},
+     *     as an iterable
+     * @throws IllegalArgumentException if {@code prefix} is {@code null}
+     */
+    public Iterable<String> keysWithPrefix(String prefix) {
+        if (prefix == null) {
+            throw new IllegalArgumentException("calls keysWithPrefix() with null argument");
+        }
+        Queue<String> queue = new Queue<String>();
+        Node<Value> x = get(root, prefix, 0);
+        if (x == null) return queue;
+        if (x.val != null) queue.enqueue(prefix);
+        collect(x.mid, new StringBuilder(prefix), queue);
+        return queue;
+    }
+
+    // all keys in subtrie rooted at x with given prefix
+    private void collect(Node<Value> x, StringBuilder prefix, Queue<String> queue) {
+        if (x == null) return;
+        collect(x.left,  prefix, queue);
+        if (x.val != null) queue.enqueue(prefix.toString() + x.c);
+        collect(x.mid,   prefix.append(x.c), queue);
+        prefix.deleteCharAt(prefix.length() - 1);
+        collect(x.right, prefix, queue);
+    }
+
+
+    /**
+     * Returns all of the keys in the symbol table that match {@code pattern},
+     * where the character '.' is interpreted as a wildcard character.
+     * @param pattern the pattern
+     * @return all of the keys in the symbol table that match {@code pattern},
+     *     as an iterable, where . is treated as a wildcard character.
+     */
+    public Iterable<String> keysThatMatch(String pattern) {
+        Queue<String> queue = new Queue<String>();
+        collect(root, new StringBuilder(), 0, pattern, queue);
+        return queue;
+    }
+ 
+    private void collect(Node<Value> x, StringBuilder prefix, int i, String pattern, Queue<String> queue) {
+        if (x == null) return;
+        char c = pattern.charAt(i);
+        if (c == '.' || c < x.c) collect(x.left, prefix, i, pattern, queue);
+        if (c == '.' || c == x.c) {
+            if (i == pattern.length() - 1 && x.val != null) queue.enqueue(prefix.toString() + x.c);
+            if (i < pattern.length() - 1) {
+                collect(x.mid, prefix.append(x.c), i+1, pattern, queue);
+                prefix.deleteCharAt(prefix.length() - 1);
+            }
+        }
+        if (c == '.' || c > x.c) collect(x.right, prefix, i, pattern, queue);
+    }
+
+
+    /**
+     * Unit tests the {@code TST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // build symbol table from standard input
+        TST<Integer> st = new TST<Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+
+        // print results
+        if (st.size() < 100) {
+            StdOut.println("keys(\"\"):");
+            for (String key : st.keys()) {
+                StdOut.println(key + " " + st.get(key));
+            }
+            StdOut.println();
+        }
+
+        StdOut.println("longestPrefixOf(\"shellsort\"):");
+        StdOut.println(st.longestPrefixOf("shellsort"));
+        StdOut.println();
+
+        StdOut.println("longestPrefixOf(\"shell\"):");
+        StdOut.println(st.longestPrefixOf("shell"));
+        StdOut.println();
+
+        StdOut.println("keysWithPrefix(\"shor\"):");
+        for (String s : st.keysWithPrefix("shor"))
+            StdOut.println(s);
+        StdOut.println();
+
+        StdOut.println("keysThatMatch(\".he.l.\"):");
+        for (String s : st.keysThatMatch(".he.l."))
+            StdOut.println(s);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TarjanSCC.java b/src/main/java/edu/princeton/cs/algs4/TarjanSCC.java
new file mode 100644
index 0000000..93f3003
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TarjanSCC.java
@@ -0,0 +1,216 @@
+/******************************************************************************
+ *  Compilation:  javac TarjanSCC.java
+ *  Execution:    Java TarjanSCC V E
+ *  Dependencies: Digraph.java Stack.java TransitiveClosure.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/mediumDG.txt
+ *                https://algs4.cs.princeton.edu/42digraph/largeDG.txt
+ *
+ *  Compute the strongly-connected components of a digraph using 
+ *  Tarjan's algorithm.
+ *
+ *  Runs in O(E + V) time.
+ *
+ *  % java TarjanSCC tinyDG.txt
+ *  5 components
+ *  1 
+ *  0 2 3 4 5
+ *  9 10 11 12
+ *  6 8
+ *  7 
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TarjanSCC} class represents a data type for 
+ *  determining the strong components in a digraph.
+ *  The <em>id</em> operation determines in which strong component
+ *  a given vertex lies; the <em>areStronglyConnected</em> operation
+ *  determines whether two vertices are in the same strong component;
+ *  and the <em>count</em> operation determines the number of strong
+ *  components.
+ *  <p>
+ *  The <em>component identifier</em> of a component is one of the
+ *  vertices in the strong component: two vertices have the same component
+ *  identifier if and only if they are in the same strong component.
+ *  <p>
+ *  This implementation uses Tarjan's algorithm.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time,
+ *  where <em>V</em> is the number of vertices and <em>E</em> is the
+ *  number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  For alternative implementations of the same API, see
+ *  {@link KosarajuSharirSCC} and {@link GabowSCC}.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class TarjanSCC {
+
+    private boolean[] marked;        // marked[v] = has v been visited?
+    private int[] id;                // id[v] = id of strong component containing v
+    private int[] low;               // low[v] = low number of v
+    private int pre;                 // preorder number counter
+    private int count;               // number of strongly-connected components
+    private Stack<Integer> stack;
+
+
+    /**
+     * Computes the strong components of the digraph {@code G}.
+     * @param G the digraph
+     */
+    public TarjanSCC(Digraph G) {
+        marked = new boolean[G.V()];
+        stack = new Stack<Integer>();
+        id = new int[G.V()]; 
+        low = new int[G.V()];
+        for (int v = 0; v < G.V(); v++) {
+            if (!marked[v]) dfs(G, v);
+        }
+
+        // check that id[] gives strong components
+        assert check(G);
+    }
+
+    private void dfs(Digraph G, int v) { 
+        marked[v] = true;
+        low[v] = pre++;
+        int min = low[v];
+        stack.push(v);
+        for (int w : G.adj(v)) {
+            if (!marked[w]) dfs(G, w);
+            if (low[w] < min) min = low[w];
+        }
+        if (min < low[v]) {
+            low[v] = min;
+            return;
+        }
+        int w;
+        do {
+            w = stack.pop();
+            id[w] = count;
+            low[w] = G.V();
+        } while (w != v);
+        count++;
+    }
+
+
+    /**
+     * Returns the number of strong components.
+     * @return the number of strong components
+     */
+    public int count() {
+        return count;
+    }
+
+
+    /**
+     * Are vertices {@code v} and {@code w} in the same strong component?
+     * @param  v one vertex
+     * @param  w the other vertex
+     * @return {@code true} if vertices {@code v} and {@code w} are in the same
+     *         strong component, and {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @throws IllegalArgumentException unless {@code 0 <= w < V}
+     */
+    public boolean stronglyConnected(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        return id[v] == id[w];
+    }
+
+    /**
+     * Returns the component id of the strong component containing vertex {@code v}.
+     * @param  v the vertex
+     * @return the component id of the strong component containing vertex {@code v}
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int id(int v) {
+        validateVertex(v);
+        return id[v];
+    }
+
+    // does the id[] array contain the strongly connected components?
+    private boolean check(Digraph G) {
+        TransitiveClosure tc = new TransitiveClosure(G);
+        for (int v = 0; v < G.V(); v++) {
+            for (int w = 0; w < G.V(); w++) {
+                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = marked.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code TarjanSCC} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+        TarjanSCC scc = new TarjanSCC(G);
+
+        // number of connected components
+        int m = scc.count();
+        StdOut.println(m + " components");
+
+        // compute list of vertices in each strong component
+        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[m];
+        for (int i = 0; i < m; i++) {
+            components[i] = new Queue<Integer>();
+        }
+        for (int v = 0; v < G.V(); v++) {
+            components[scc.id(v)].enqueue(v);
+        }
+
+        // print results
+        for (int i = 0; i < m; i++) {
+            for (int v : components[i]) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TestIntroCS.java b/src/main/java/edu/princeton/cs/algs4/TestIntroCS.java
new file mode 100644
index 0000000..3606f06
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TestIntroCS.java
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *  Compilation:  javac-introcs TestIntroCS.java
+ *  Execution:    java-introcs TestIntroCS n
+ *  
+ *  Play chaos game to produce Barnsley's fern.
+ *  This program is intended to test that stdlib.jar is properly installed.
+ *
+ *  % java-introcs TestIntroCS 10000
+ * 
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+public class TestIntroCS {
+
+    public static void main(String[] args) {
+        int n = 10000;  // number of points to draw (default 10000)
+        if (args.length == 1) {
+            n = Integer.parseInt(args[0]);
+        }
+        StdDraw.setScale(-0.1, 1.1);              // leave a 10% border
+        StdDraw.clear(StdDraw.BOOK_LIGHT_BLUE);   // background color
+        StdDraw.setPenColor(0, 114, 0);           // a shade of green
+
+        // starting point
+        double x = 0.5;
+        double y = 0.0;
+
+        // repeated choose one of four update rules at random
+        for (int i = 0; i < n; i++) {
+            double tempx, tempy;
+            double r = StdRandom.uniform(0.0, 1.0);
+
+            // stem
+            if (r <= 0.01)  {
+                tempx = 0.50;
+                tempy = 0.16 * y;
+            }
+
+            // largest left-hand leaflet
+            else if (r <= 0.08) {
+                tempx =  0.20 * x - 0.26 * y + 0.400;
+                tempy =  0.23 * x + 0.22 * y - 0.045;
+            }
+
+            // largest right-hand leaflet
+            else if (r <= 0.15) {
+                tempx = -0.15 * x + 0.28 * y + 0.575;
+                tempy =  0.26 * x + 0.24 * y - 0.086;
+            }
+
+            // successively smaller leaflets
+            else {
+                tempx =  0.85 * x + 0.04 * y + 0.075;
+                tempy = -0.04 * x + 0.85 * y + 0.180;
+            }
+
+            // update (x, y) and draw point
+            x = tempx;
+            y = tempy;
+            StdDraw.point(x, y);
+        }
+    }   
+}
diff --git a/src/main/java/edu/princeton/cs/algs4/ThreeSum.java b/src/main/java/edu/princeton/cs/algs4/ThreeSum.java
new file mode 100644
index 0000000..3f202b2
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ThreeSum.java
@@ -0,0 +1,131 @@
+/******************************************************************************
+ *  Compilation:  javac ThreeSum.java
+ *  Execution:    java ThreeSum input.txt
+ *  Dependencies: In.java StdOut.java Stopwatch.java
+ *  Data files:   https://algs4.cs.princeton.edu/14analysis/1Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/2Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/4Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/8Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/16Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/32Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/1Mints.txt
+ *
+ *  A program with cubic running time. Reads n integers
+ *  and counts the number of triples that sum to exactly 0
+ *  (ignoring integer overflow).
+ *
+ *  % java ThreeSum 1Kints.txt 
+ *  70
+ *
+ *  % java ThreeSum 2Kints.txt 
+ *  528
+ *
+ *  % java ThreeSum 4Kints.txt 
+ *  4039
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code ThreeSum} class provides static methods for counting
+ *  and printing the number of triples in an array of integers that sum to 0
+ *  (ignoring integer overflow).
+ *  <p>
+ *  This implementation uses a triply nested loop and takes proportional to n^3,
+ *  where n is the number of integers.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/14analysis">Section 1.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class ThreeSum {
+
+    // Do not instantiate.
+    private ThreeSum() { }
+
+    /**
+     * Prints to standard output the (i, j, k) with {@code i < j < k}
+     * such that {@code a[i] + a[j] + a[k] == 0}.
+     *
+     * @param a the array of integers
+     */
+    public static void printAll(int[] a) {
+        int n = a.length;
+        for (int i = 0; i < n; i++) {
+            for (int j = i+1; j < n; j++) {
+                for (int k = j+1; k < n; k++) {
+                    if (a[i] + a[j] + a[k] == 0) {
+                        StdOut.println(a[i] + " " + a[j] + " " + a[k]);
+                    }
+                }
+            }
+        }
+    } 
+
+    /**
+     * Returns the number of triples (i, j, k) with {@code i < j < k}
+     * such that {@code a[i] + a[j] + a[k] == 0}.
+     *
+     * @param  a the array of integers
+     * @return the number of triples (i, j, k) with {@code i < j < k}
+     *         such that {@code a[i] + a[j] + a[k] == 0}
+     */
+    public static int count(int[] a) {
+        int n = a.length;
+        int count = 0;
+        for (int i = 0; i < n; i++) {
+            for (int j = i+1; j < n; j++) {
+                for (int k = j+1; k < n; k++) {
+                    if (a[i] + a[j] + a[k] == 0) {
+                        count++;
+                    }
+                }
+            }
+        }
+        return count;
+    } 
+
+    /**
+     * Reads in a sequence of integers from a file, specified as a command-line argument;
+     * counts the number of triples sum to exactly zero; prints out the time to perform
+     * the computation.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args)  { 
+        In in = new In(args[0]);
+        int[] a = in.readAllInts();
+
+        Stopwatch timer = new Stopwatch();
+        int count = count(a);
+        StdOut.println("elapsed time = " + timer.elapsedTime());
+        StdOut.println(count);
+    } 
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/ThreeSumFast.java b/src/main/java/edu/princeton/cs/algs4/ThreeSumFast.java
new file mode 100644
index 0000000..ed2b10f
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/ThreeSumFast.java
@@ -0,0 +1,150 @@
+/******************************************************************************
+ *  Compilation:  javac ThreeSumFast.java
+ *  Execution:    java ThreeSumFast input.txt
+ *  Dependencies: StdOut.java In.java Stopwatch.java
+ *  Data files:   https://algs4.cs.princeton.edu/14analysis/1Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/2Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/4Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/8Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/16Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/32Kints.txt
+ *                https://algs4.cs.princeton.edu/14analysis/1Mints.txt
+ *
+ *  A program with n^2 log n running time. Reads n integers
+ *  and counts the number of triples that sum to exactly 0.
+ *
+ *  Limitations
+ *  -----------
+ *     - we ignore integer overflow
+ *     - doesn't handle case when input has duplicates
+ *
+ *
+ *  % java ThreeSumFast 1Kints.txt
+ *  70
+ *  
+ *  % java ThreeSumFast 2Kints.txt
+ *  528
+ *                
+ *  % java ThreeSumFast 4Kints.txt
+ *  4039
+ * 
+ *  % java ThreeSumFast 8Kints.txt
+ *  32074
+ *
+ *  % java ThreeSumFast 16Kints.txt
+ *  255181
+ *
+ *  % java ThreeSumFast 32Kints.txt
+ *  2052358
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+
+/**
+ *  The {@code ThreeSumFast} class provides static methods for counting
+ *  and printing the number of triples in an array of distinct integers that
+ *  sum to 0 (ignoring integer overflow).
+ *  <p>
+ *  This implementation uses sorting and binary search and takes time 
+ *  proportional to n^2 log n, where n is the number of integers.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/14analysis">Section 1.4</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class ThreeSumFast {
+
+    // Do not instantiate.
+    private ThreeSumFast() { }
+
+    // returns true if the sorted array a[] contains any duplicated integers
+    private static boolean containsDuplicates(int[] a) {
+        for (int i = 1; i < a.length; i++)
+            if (a[i] == a[i-1]) return true;
+        return false;
+    }
+
+    /**
+     * Prints to standard output the (i, j, k) with {@code i < j < k}
+     * such that {@code a[i] + a[j] + a[k] == 0}.
+     *
+     * @param a the array of integers
+     * @throws IllegalArgumentException if the array contains duplicate integers
+     */
+    public static void printAll(int[] a) {
+        int n = a.length;
+        Arrays.sort(a);
+        if (containsDuplicates(a)) throw new IllegalArgumentException("array contains duplicate integers");
+        for (int i = 0; i < n; i++) {
+            for (int j = i+1; j < n; j++) {
+                int k = Arrays.binarySearch(a, -(a[i] + a[j]));
+                if (k > j) StdOut.println(a[i] + " " + a[j] + " " + a[k]);
+            }
+        }
+    } 
+
+    /**
+     * Returns the number of triples (i, j, k) with {@code i < j < k}
+     * such that {@code a[i] + a[j] + a[k] == 0}.
+     *
+     * @param a the array of integers
+     * @return the number of triples (i, j, k) with {@code i < j < k}
+     * such that {@code a[i] + a[j] + a[k] == 0}
+     */
+    public static int count(int[] a) {
+        int n = a.length;
+        Arrays.sort(a);
+        if (containsDuplicates(a)) throw new IllegalArgumentException("array contains duplicate integers");
+        int count = 0;
+        for (int i = 0; i < n; i++) {
+            for (int j = i+1; j < n; j++) {
+                int k = Arrays.binarySearch(a, -(a[i] + a[j]));
+                if (k > j) count++;
+            }
+        }
+        return count;
+    } 
+
+    /**
+     * Reads in a sequence of distinct integers from a file, specified as a command-line argument;
+     * counts the number of triples sum to exactly zero; prints out the time to perform
+     * the computation.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args)  { 
+        In in = new In(args[0]);
+        int[] a = in.readAllInts();
+        int count = count(a);
+        StdOut.println(count);
+    } 
+} 
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TopM.java b/src/main/java/edu/princeton/cs/algs4/TopM.java
new file mode 100644
index 0000000..b6119b5
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TopM.java
@@ -0,0 +1,94 @@
+/******************************************************************************
+ *  Compilation:  javac TopM.java
+ *  Execution:    java TopM m < input.txt
+ *  Dependencies: MinPQ.java Transaction.java StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/24pq/tinyBatch.txt
+ * 
+ *  Given an integer m from the command line and an input stream where
+ *  each line contains a String and a long value, this MinPQ client
+ *  prints the m lines whose numbers are the highest.
+ * 
+ *  % java TopM 5 < tinyBatch.txt 
+ *  Thompson    2/27/2000  4747.08
+ *  vonNeumann  2/12/1994  4732.35
+ *  vonNeumann  1/11/1999  4409.74
+ *  Hoare       8/18/1992  4381.21
+ *  vonNeumann  3/26/2002  4121.85
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TopM} class provides a client that reads a sequence of
+ *  transactions from standard input and prints the <em>m</em> largest ones
+ *  to standard output. This implementation uses a {@link MinPQ} of size
+ *  at most <em>m</em> + 1 to identify the <em>M</em> largest transactions
+ *  and a {@link Stack} to output them in the proper order.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/24pq">Section 2.4</a>
+ *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class TopM {   
+
+    // This class should not be instantiated.
+    private TopM() { }
+
+    /**
+     *  Reads a sequence of transactions from standard input; takes a
+     *  command-line integer m; prints to standard output the m largest
+     *  transactions in descending order.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int m = Integer.parseInt(args[0]); 
+        MinPQ<Transaction> pq = new MinPQ<Transaction>(m+1);
+
+        while (StdIn.hasNextLine()) {
+            // Create an entry from the next line and put on the PQ. 
+            String line = StdIn.readLine();
+            Transaction transaction = new Transaction(line);
+            pq.insert(transaction); 
+
+            // remove minimum if m+1 entries on the PQ
+            if (pq.size() > m) 
+                pq.delMin();
+        }   // top m entries are on the PQ
+
+        // print entries on PQ in reverse order
+        Stack<Transaction> stack = new Stack<Transaction>();
+        for (Transaction transaction : pq)
+            stack.push(transaction);
+        for (Transaction transaction : stack)
+            StdOut.println(transaction);
+    } 
+} 
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Topological.java b/src/main/java/edu/princeton/cs/algs4/Topological.java
new file mode 100644
index 0000000..94a3abd
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Topological.java
@@ -0,0 +1,185 @@
+/******************************************************************************
+ *  Compilation:  javac Topological.java
+ *  Execution:    java  Topological filename.txt delimiter
+ *  Dependencies: Digraph.java DepthFirstOrder.java DirectedCycle.java
+ *                EdgeWeightedDigraph.java EdgeWeightedDirectedCycle.java
+ *                SymbolDigraph.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/jobs.txt
+ *
+ *  Compute topological ordering of a DAG or edge-weighted DAG.
+ *  Runs in O(E + V) time.
+ *
+ *  % java Topological jobs.txt "/"
+ *  Calculus
+ *  Linear Algebra
+ *  Introduction to CS
+ *  Advanced Programming
+ *  Algorithms
+ *  Theoretical CS
+ *  Artificial Intelligence
+ *  Robotics
+ *  Machine Learning
+ *  Neural Networks
+ *  Databases
+ *  Scientific Computing
+ *  Computational Biology
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Topological} class represents a data type for 
+ *  determining a topological order of a <em>directed acyclic graph</em> (DAG).
+ *  A digraph has a topological order if and only if it is a DAG.
+ *  The <em>hasOrder</em> operation determines whether the digraph has
+ *  a topological order, and if so, the <em>order</em> operation
+ *  returns one.
+ *  <p>
+ *  This implementation uses depth-first search.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the
+ *  worst case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  See {@link DirectedCycle}, {@link DirectedCycleX}, and
+ *  {@link EdgeWeightedDirectedCycle} for computing a directed cycle
+ *  if the digraph is not a DAG.
+ *  See {@link TopologicalX} for a nonrecursive queue-based algorithm
+ *  for computing a topological order of a DAG.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Topological {
+    private Iterable<Integer> order;  // topological order
+    private int[] rank;               // rank[v] = rank of vertex v in order
+
+    /**
+     * Determines whether the digraph {@code G} has a topological order and, if so,
+     * finds such a topological order.
+     * @param G the digraph
+     */
+    public Topological(Digraph G) {
+        DirectedCycle finder = new DirectedCycle(G);
+        if (!finder.hasCycle()) {
+            DepthFirstOrder dfs = new DepthFirstOrder(G);
+            order = dfs.reversePost();
+            rank = new int[G.V()];
+            int i = 0;
+            for (int v : order)
+                rank[v] = i++;
+        }
+    }
+
+    /**
+     * Determines whether the edge-weighted digraph {@code G} has a topological
+     * order and, if so, finds such an order.
+     * @param G the edge-weighted digraph
+     */
+    public Topological(EdgeWeightedDigraph G) {
+        EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(G);
+        if (!finder.hasCycle()) {
+            DepthFirstOrder dfs = new DepthFirstOrder(G);
+            order = dfs.reversePost();
+        }
+    }
+
+    /**
+     * Returns a topological order if the digraph has a topologial order,
+     * and {@code null} otherwise.
+     * @return a topological order of the vertices (as an interable) if the
+     *    digraph has a topological order (or equivalently, if the digraph is a DAG),
+     *    and {@code null} otherwise
+     */
+    public Iterable<Integer> order() {
+        return order;
+    }
+
+    /**
+     * Does the digraph have a topological order?
+     * @return {@code true} if the digraph has a topological order (or equivalently,
+     *    if the digraph is a DAG), and {@code false} otherwise
+     */
+    public boolean hasOrder() {
+        return order != null;
+    }
+
+    /**
+     * Does the digraph have a topological order?
+     * @return {@code true} if the digraph has a topological order (or equivalently,
+     *    if the digraph is a DAG), and {@code false} otherwise
+     * @deprecated Replaced by {@link #hasOrder()}.
+     */
+    @Deprecated
+    public boolean isDAG() {
+        return hasOrder();
+    }
+
+    /**
+     * The the rank of vertex {@code v} in the topological order;
+     * -1 if the digraph is not a DAG
+     *
+     * @param v the vertex
+     * @return the position of vertex {@code v} in a topological order
+     *    of the digraph; -1 if the digraph is not a DAG
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int rank(int v) {
+        validateVertex(v);
+        if (hasOrder()) return rank[v];
+        else            return -1;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = rank.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code Topological} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        String filename  = args[0];
+        String delimiter = args[1];
+        SymbolDigraph sg = new SymbolDigraph(filename, delimiter);
+        Topological topological = new Topological(sg.digraph());
+        for (int v : topological.order()) {
+            StdOut.println(sg.nameOf(v));
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TopologicalX.java b/src/main/java/edu/princeton/cs/algs4/TopologicalX.java
new file mode 100644
index 0000000..d7d009a
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TopologicalX.java
@@ -0,0 +1,343 @@
+/******************************************************************************
+ *  Compilation:  javac TopologicalX.java
+ *  Execution:    java TopologicalX V E F
+ *  Dependencies: Queue.java Digraph.java
+ *
+ *  Compute topological ordering of a DAG using queue-based algorithm.
+ *  Runs in O(E + V) time.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TopologicalX} class represents a data type for 
+ *  determining a topological order of a <em>directed acyclic graph</em> (DAG).
+ *  A digraph has a topological order if and only if it is a DAG.
+ *  The <em>hasOrder</em> operation determines whether the digraph has
+ *  a topological order, and if so, the <em>order</em> operation
+ *  returns one.
+ *  <p>
+ *  This implementation uses a nonrecursive, queue-based algorithm.
+ *  The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the worst
+ *  case, where <em>V</em> is the number of vertices and <em>E</em>
+ *  is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em>) extra space (not including the digraph).
+ *  <p>
+ *  See {@link DirectedCycle}, {@link DirectedCycleX}, and
+ *  {@link EdgeWeightedDirectedCycle} to compute a
+ *  directed cycle if the digraph is not a DAG.
+ *  See {@link Topological} for a recursive version that uses depth-first search.
+ *  <p>
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class TopologicalX {
+    private Queue<Integer> order;     // vertices in topological order
+    private int[] ranks;              // ranks[v] = order where vertex v appers in order
+
+    /**
+     * Determines whether the digraph {@code G} has a topological order and, if so,
+     * finds such a topological order.
+     * @param G the digraph
+     */
+    public TopologicalX(Digraph G) {
+
+        // indegrees of remaining vertices
+        int[] indegree = new int[G.V()];
+        for (int v = 0; v < G.V(); v++) {
+            indegree[v] = G.indegree(v);
+        }
+
+        // initialize 
+        ranks = new int[G.V()]; 
+        order = new Queue<Integer>();
+        int count = 0;
+
+        // initialize queue to contain all vertices with indegree = 0
+        Queue<Integer> queue = new Queue<Integer>();
+        for (int v = 0; v < G.V(); v++)
+            if (indegree[v] == 0) queue.enqueue(v);
+
+        while (!queue.isEmpty()) {
+            int v = queue.dequeue();
+            order.enqueue(v);
+            ranks[v] = count++;
+            for (int w : G.adj(v)) {
+                indegree[w]--;
+                if (indegree[w] == 0) queue.enqueue(w);
+            }
+        }
+
+        // there is a directed cycle in subgraph of vertices with indegree >= 1.
+        if (count != G.V()) {
+            order = null;
+        }
+
+        assert check(G);
+    }
+
+    /**
+     * Determines whether the edge-weighted digraph {@code G} has a
+     * topological order and, if so, finds such a topological order.
+     * @param G the digraph
+     */
+    public TopologicalX(EdgeWeightedDigraph G) {
+
+        // indegrees of remaining vertices
+        int[] indegree = new int[G.V()];
+        for (int v = 0; v < G.V(); v++) {
+            indegree[v] = G.indegree(v);
+        }
+
+        // initialize 
+        ranks = new int[G.V()]; 
+        order = new Queue<Integer>();
+        int count = 0;
+
+        // initialize queue to contain all vertices with indegree = 0
+        Queue<Integer> queue = new Queue<Integer>();
+        for (int v = 0; v < G.V(); v++)
+            if (indegree[v] == 0) queue.enqueue(v);
+
+        while (!queue.isEmpty()) {
+            int v = queue.dequeue();
+            order.enqueue(v);
+            ranks[v] = count++;
+            for (DirectedEdge e : G.adj(v)) {
+                int w = e.to();
+                indegree[w]--;
+                if (indegree[w] == 0) queue.enqueue(w);
+            }
+        }
+
+        // there is a directed cycle in subgraph of vertices with indegree >= 1.
+        if (count != G.V()) {
+            order = null;
+        }
+
+        assert check(G);
+    }
+
+    /**
+     * Returns a topological order if the digraph has a topologial order,
+     * and {@code null} otherwise.
+     * @return a topological order of the vertices (as an interable) if the
+     *    digraph has a topological order (or equivalently, if the digraph is a DAG),
+     *    and {@code null} otherwise
+     */
+    public Iterable<Integer> order() {
+        return order;
+    }
+
+    /**
+     * Does the digraph have a topological order?
+     * @return {@code true} if the digraph has a topological order (or equivalently,
+     *    if the digraph is a DAG), and {@code false} otherwise
+     */
+    public boolean hasOrder() {
+        return order != null;
+    }
+
+    /**
+     * The the rank of vertex {@code v} in the topological order;
+     * -1 if the digraph is not a DAG
+     *
+     * @param v vertex
+     * @return the position of vertex {@code v} in a topological order
+     *    of the digraph; -1 if the digraph is not a DAG
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     */
+    public int rank(int v) {
+        validateVertex(v);
+        if (hasOrder()) return ranks[v];
+        else            return -1;
+    }
+
+    // certify that digraph is acyclic
+    private boolean check(Digraph G) {
+
+        // digraph is acyclic
+        if (hasOrder()) {
+            // check that ranks are a permutation of 0 to V-1
+            boolean[] found = new boolean[G.V()];
+            for (int i = 0; i < G.V(); i++) {
+                found[rank(i)] = true;
+            }
+            for (int i = 0; i < G.V(); i++) {
+                if (!found[i]) {
+                    System.err.println("No vertex with rank " + i);
+                    return false;
+                }
+            }
+
+            // check that ranks provide a valid topological order
+            for (int v = 0; v < G.V(); v++) {
+                for (int w : G.adj(v)) {
+                    if (rank(v) > rank(w)) {
+                        System.err.printf("%d-%d: rank(%d) = %d, rank(%d) = %d\n",
+                                          v, w, v, rank(v), w, rank(w));
+                        return false;
+                    }
+                }
+            }
+
+            // check that order() is consistent with rank()
+            int r = 0;
+            for (int v : order()) {
+                if (rank(v) != r) {
+                    System.err.println("order() and rank() inconsistent");
+                    return false;
+                }
+                r++;
+            }
+        }
+
+
+        return true;
+    }
+
+    // certify that digraph is acyclic
+    private boolean check(EdgeWeightedDigraph G) {
+
+        // digraph is acyclic
+        if (hasOrder()) {
+            // check that ranks are a permutation of 0 to V-1
+            boolean[] found = new boolean[G.V()];
+            for (int i = 0; i < G.V(); i++) {
+                found[rank(i)] = true;
+            }
+            for (int i = 0; i < G.V(); i++) {
+                if (!found[i]) {
+                    System.err.println("No vertex with rank " + i);
+                    return false;
+                }
+            }
+
+            // check that ranks provide a valid topological order
+            for (int v = 0; v < G.V(); v++) {
+                for (DirectedEdge e : G.adj(v)) {
+                    int w = e.to();
+                    if (rank(v) > rank(w)) {
+                        System.err.printf("%d-%d: rank(%d) = %d, rank(%d) = %d\n",
+                                          v, w, v, rank(v), w, rank(w));
+                        return false;
+                    }
+                }
+            }
+
+            // check that order() is consistent with rank()
+            int r = 0;
+            for (int v : order()) {
+                if (rank(v) != r) {
+                    System.err.println("order() and rank() inconsistent");
+                    return false;
+                }
+                r++;
+            }
+        }
+
+
+        return true;
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = ranks.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code TopologicalX} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // create random DAG with V vertices and E edges; then add F random edges
+        int V = Integer.parseInt(args[0]);
+        int E = Integer.parseInt(args[1]);
+        int F = Integer.parseInt(args[2]);
+
+        Digraph G1 = DigraphGenerator.dag(V, E);
+
+        // corresponding edge-weighted digraph
+        EdgeWeightedDigraph G2 = new EdgeWeightedDigraph(V);
+        for (int v = 0; v < G1.V(); v++)
+            for (int w : G1.adj(v))
+                G2.addEdge(new DirectedEdge(v, w, 0.0));
+
+        // add F extra edges
+        for (int i = 0; i < F; i++) {
+            int v = StdRandom.uniform(V);
+            int w = StdRandom.uniform(V);
+            G1.addEdge(v, w);
+            G2.addEdge(new DirectedEdge(v, w, 0.0));
+        }
+
+        StdOut.println(G1);
+        StdOut.println();
+        StdOut.println(G2);
+
+        // find a directed cycle
+        TopologicalX topological1 = new TopologicalX(G1);
+        if (!topological1.hasOrder()) {
+            StdOut.println("Not a DAG");
+        }
+
+        // or give topologial sort
+        else {
+            StdOut.print("Topological order: ");
+            for (int v : topological1.order()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+
+        // find a directed cycle
+        TopologicalX topological2 = new TopologicalX(G2);
+        if (!topological2.hasOrder()) {
+            StdOut.println("Not a DAG");
+        }
+
+        // or give topologial sort
+        else {
+            StdOut.print("Topological order: ");
+            for (int v : topological2.order()) {
+                StdOut.print(v + " ");
+            }
+            StdOut.println();
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/Transaction.java b/src/main/java/edu/princeton/cs/algs4/Transaction.java
new file mode 100644
index 0000000..26288ca
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Transaction.java
@@ -0,0 +1,244 @@
+/******************************************************************************
+ *  Compilation:  javac Transaction.java
+ *  Execution:    java Transaction
+ *  Dependencies: StdOut.java
+ *  
+ *  Data type for commercial transactions.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Arrays;
+import java.util.Comparator;
+
+/**
+ *  The {@code Transaction} class is an immutable data type to encapsulate a
+ *  commercial transaction with a customer name, date, and amount.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Transaction implements Comparable<Transaction> {
+    private final String  who;      // customer
+    private final Date    when;     // date
+    private final double  amount;   // amount
+
+
+    /**
+     * Initializes a new transaction from the given arguments.
+     *
+     * @param  who the person involved in this transaction
+     * @param  when the date of this transaction
+     * @param  amount the amount of this transaction
+     * @throws IllegalArgumentException if {@code amount} 
+     *         is {@code Double.NaN}, {@code Double.POSITIVE_INFINITY},
+     *         or {@code Double.NEGATIVE_INFINITY}
+     */
+    public Transaction(String who, Date when, double amount) {
+        if (Double.isNaN(amount) || Double.isInfinite(amount))
+            throw new IllegalArgumentException("Amount cannot be NaN or infinite");
+        this.who    = who;
+        this.when   = when;
+        this.amount = amount;
+    }
+
+    /**
+     * Initializes a new transaction by parsing a string of the form NAME DATE AMOUNT.
+     *
+     * @param  transaction the string to parse
+     * @throws IllegalArgumentException if {@code amount} 
+     *         is {@code Double.NaN}, {@code Double.POSITIVE_INFINITY},
+     *         or {@code Double.NEGATIVE_INFINITY}
+     */
+    public Transaction(String transaction) {
+        String[] a = transaction.split("\\s+");
+        who    = a[0];
+        when   = new Date(a[1]);
+        amount = Double.parseDouble(a[2]);
+        if (Double.isNaN(amount) || Double.isInfinite(amount))
+            throw new IllegalArgumentException("Amount cannot be NaN or infinite");
+    }
+
+    /**
+     * Returns the name of the customer involved in this transaction.
+     *
+     * @return the name of the customer involved in this transaction
+     */
+    public String who() {
+        return who;
+    }
+ 
+    /**
+     * Returns the date of this transaction.
+     *
+     * @return the date of this transaction
+     */
+    public Date when() {
+        return when;
+    }
+ 
+    /**
+     * Returns the amount of this transaction.
+     *
+     * @return the amount of this transaction
+     */
+    public double amount() {
+        return amount;
+    }
+
+    /**
+     * Returns a string representation of this transaction.
+     *
+     * @return a string representation of this transaction
+     */
+    @Override
+    public String toString() {
+        return String.format("%-10s %10s %8.2f", who, when, amount);
+    }
+
+    /**
+     * Compares two transactions by amount.
+     *
+     * @param  that the other transaction
+     * @return { a negative integer, zero, a positive integer}, depending
+     *         on whether the amount of this transaction is { less than,
+     *         equal to, or greater than } the amount of that transaction
+     */
+    public int compareTo(Transaction that) {
+        return Double.compare(this.amount, that.amount);
+    }    
+
+    /**
+     * Compares this transaction to the specified object.
+     *
+     * @param  other the other transaction
+     * @return true if this transaction is equal to {@code other}; false otherwise
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (other == this) return true;
+        if (other == null) return false;
+        if (other.getClass() != this.getClass()) return false;
+        Transaction that = (Transaction) other;
+        return (this.amount == that.amount) && (this.who.equals(that.who))
+                                            && (this.when.equals(that.when));
+    }
+
+
+    /**
+     * Returns a hash code for this transaction.
+     *
+     * @return a hash code for this transaction
+     */
+    public int hashCode() {
+        int hash = 1;
+        hash = 31*hash + who.hashCode();
+        hash = 31*hash + when.hashCode();
+        hash = 31*hash + ((Double) amount).hashCode();
+        return hash;
+        // return Objects.hash(who, when, amount);
+    }
+
+    /**
+     * Compares two transactions by customer name.
+     */
+    public static class WhoOrder implements Comparator<Transaction> {
+
+        @Override
+        public int compare(Transaction v, Transaction w) {
+            return v.who.compareTo(w.who);
+        }
+    }
+
+    /**
+     * Compares two transactions by date.
+     */
+    public static class WhenOrder implements Comparator<Transaction> {
+
+        @Override
+        public int compare(Transaction v, Transaction w) {
+            return v.when.compareTo(w.when);
+        }
+    }
+
+    /**
+     * Compares two transactions by amount.
+     */
+    public static class HowMuchOrder implements Comparator<Transaction> {
+
+        @Override
+        public int compare(Transaction v, Transaction w) {
+            return Double.compare(v.amount, w.amount);
+        }
+    }
+
+
+    /**
+     * Unit tests the {@code Transaction} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        Transaction[] a = new Transaction[4];
+        a[0] = new Transaction("Turing   6/17/1990  644.08");
+        a[1] = new Transaction("Tarjan   3/26/2002 4121.85");
+        a[2] = new Transaction("Knuth    6/14/1999  288.34");
+        a[3] = new Transaction("Dijkstra 8/22/2007 2678.40");
+
+        StdOut.println("Unsorted");
+        for (int i = 0; i < a.length; i++)
+            StdOut.println(a[i]);
+        StdOut.println();
+        
+        StdOut.println("Sort by date");
+        Arrays.sort(a, new Transaction.WhenOrder());
+        for (int i = 0; i < a.length; i++)
+            StdOut.println(a[i]);
+        StdOut.println();
+
+        StdOut.println("Sort by customer");
+        Arrays.sort(a, new Transaction.WhoOrder());
+        for (int i = 0; i < a.length; i++)
+            StdOut.println(a[i]);
+        StdOut.println();
+
+        StdOut.println("Sort by amount");
+        Arrays.sort(a, new Transaction.HowMuchOrder());
+        for (int i = 0; i < a.length; i++)
+            StdOut.println(a[i]);
+        StdOut.println();
+    }
+
+}
+
+
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TransitiveClosure.java b/src/main/java/edu/princeton/cs/algs4/TransitiveClosure.java
new file mode 100644
index 0000000..dc788a9
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TransitiveClosure.java
@@ -0,0 +1,146 @@
+/******************************************************************************
+ *  Compilation:  javac TransitiveClosure.java
+ *  Execution:    java TransitiveClosure filename.txt
+ *  Dependencies: Digraph.java DepthFirstDirectedPaths.java In.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/42digraph/tinyDG.txt
+ *
+ *  Compute transitive closure of a digraph and support
+ *  reachability queries.
+ *
+ *  Preprocessing time: O(V(E + V)) time.
+ *  Query time: O(1).
+ *  Space: O(V^2).
+ *
+ *  % java TransitiveClosure tinyDG.txt
+ *         0  1  2  3  4  5  6  7  8  9 10 11 12
+ *  --------------------------------------------
+ *    0:   T  T  T  T  T  T                     
+ *    1:      T                                 
+ *    2:   T  T  T  T  T  T                     
+ *    3:   T  T  T  T  T  T                     
+ *    4:   T  T  T  T  T  T                     
+ *    5:   T  T  T  T  T  T                     
+ *    6:   T  T  T  T  T  T  T        T  T  T  T
+ *    7:   T  T  T  T  T  T  T  T  T  T  T  T  T
+ *    8:   T  T  T  T  T  T  T  T  T  T  T  T  T
+ *    9:   T  T  T  T  T  T           T  T  T  T
+ *   10:   T  T  T  T  T  T           T  T  T  T
+ *   11:   T  T  T  T  T  T           T  T  T  T
+ *   12:   T  T  T  T  T  T           T  T  T  T
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TransitiveClosure} class represents a data type for 
+ *  computing the transitive closure of a digraph.
+ *  <p>
+ *  This implementation runs depth-first search from each vertex.
+ *  The constructor takes &Theta;(<em>V</em>(<em>V</em> + <em>E</em>))
+ *  in the worst case, where <em>V</em> is the number of vertices and
+ *  <em>E</em> is the number of edges.
+ *  Each instance method takes &Theta;(1) time.
+ *  It uses &Theta;(<em>V</em><sup>2</sup>) extra space (not including the digraph).
+ *  <p>
+ *  For large digraphs, you may want to consider a more sophisticated algorithm.
+ *  <a href = "http://www.cs.hut.fi/~enu/thesis.html">Nuutila</a> proposes two
+ *  algorithm for the problem (based on strong components and an interval representation)
+ *  that runs in &Theta;(<em>E</em> + <em>V</em>) time on typical digraphs.
+ *
+ *  For additional documentation,
+ *  see <a href="https://algs4.cs.princeton.edu/42digraph">Section 4.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class TransitiveClosure {
+    private DirectedDFS[] tc;  // tc[v] = reachable from v
+
+    /**
+     * Computes the transitive closure of the digraph {@code G}.
+     * @param G the digraph
+     */
+    public TransitiveClosure(Digraph G) {
+        tc = new DirectedDFS[G.V()];
+        for (int v = 0; v < G.V(); v++)
+            tc[v] = new DirectedDFS(G, v);
+    }
+
+    /**
+     * Is there a directed path from vertex {@code v} to vertex {@code w} in the digraph?
+     * @param  v the source vertex
+     * @param  w the target vertex
+     * @return {@code true} if there is a directed path from {@code v} to {@code w},
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless {@code 0 <= v < V}
+     * @throws IllegalArgumentException unless {@code 0 <= w < V}
+     */
+    public boolean reachable(int v, int w) {
+        validateVertex(v);
+        validateVertex(w);
+        return tc[v].marked(w);
+    }
+
+    // throw an IllegalArgumentException unless {@code 0 <= v < V}
+    private void validateVertex(int v) {
+        int V = tc.length;
+        if (v < 0 || v >= V)
+            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
+    }
+
+    /**
+     * Unit tests the {@code TransitiveClosure} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        In in = new In(args[0]);
+        Digraph G = new Digraph(in);
+
+        TransitiveClosure tc = new TransitiveClosure(G);
+
+        // print header
+        StdOut.print("     ");
+        for (int v = 0; v < G.V(); v++)
+            StdOut.printf("%3d", v);
+        StdOut.println();
+        StdOut.println("--------------------------------------------");
+
+        // print transitive closure
+        for (int v = 0; v < G.V(); v++) {
+            StdOut.printf("%3d: ", v);
+            for (int w = 0; w < G.V(); w++) {
+                if (tc.reachable(v, w)) StdOut.printf("  T");
+                else                    StdOut.printf("   ");
+            }
+            StdOut.println();
+        }
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TrieSET.java b/src/main/java/edu/princeton/cs/algs4/TrieSET.java
new file mode 100644
index 0000000..89d5e93
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TrieSET.java
@@ -0,0 +1,310 @@
+/******************************************************************************
+ *  Compilation:  javac TrieSET.java
+ *  Execution:    java TrieSET < words.txt
+ *  Dependencies: StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/52trie/shellsST.txt
+ *
+ *  An set for extended ASCII strings, implemented  using a 256-way trie.
+ *
+ *  Sample client reads in a list of words from standard input and
+ *  prints out each word, removing any duplicates.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+import java.util.Iterator;
+
+/**
+ *  The {@code TrieSET} class represents an ordered set of strings over
+ *  the extended ASCII alphabet.
+ *  It supports the usual <em>add</em>, <em>contains</em>, and <em>delete</em>
+ *  methods. It also provides character-based methods for finding the string
+ *  in the set that is the <em>longest prefix</em> of a given prefix,
+ *  finding all strings in the set that <em>start with</em> a given prefix,
+ *  and finding all strings in the set that <em>match</em> a given pattern.
+ *  <p>
+ *  This implementation uses a 256-way trie.
+ *  The <em>add</em>, <em>contains</em>, <em>delete</em>, and
+ *  <em>longest prefix</em> methods take time proportional to the length
+ *  of the key (in the worst case). Construction takes constant time.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/52trie">Section 5.2</a> of
+ *  <i>Algorithms in Java, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class TrieSET implements Iterable<String> {
+    private static final int R = 256;        // extended ASCII
+
+    private Node root;      // root of trie
+    private int n;          // number of keys in trie
+
+    // R-way trie node
+    private static class Node {
+        private Node[] next = new Node[R];
+        private boolean isString;
+    }
+
+    /**
+     * Initializes an empty set of strings.
+     */
+    public TrieSET() {
+    }
+
+    /**
+     * Does the set contain the given key?
+     * @param key the key
+     * @return {@code true} if the set contains {@code key} and
+     *     {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(String key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        Node x = get(root, key, 0);
+        if (x == null) return false;
+        return x.isString;
+    }
+
+    private Node get(Node x, String key, int d) {
+        if (x == null) return null;
+        if (d == key.length()) return x;
+        char c = key.charAt(d);
+        return get(x.next[c], key, d+1);
+    }
+
+    /**
+     * Adds the key to the set if it is not already present.
+     * @param key the key to add
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void add(String key) {
+        if (key == null) throw new IllegalArgumentException("argument to add() is null");
+        root = add(root, key, 0);
+    }
+
+    private Node add(Node x, String key, int d) {
+        if (x == null) x = new Node();
+        if (d == key.length()) {
+            if (!x.isString) n++;
+            x.isString = true;
+        }
+        else {
+            char c = key.charAt(d);
+            x.next[c] = add(x.next[c], key, d+1);
+        }
+        return x;
+    }
+
+    /**
+     * Returns the number of strings in the set.
+     * @return the number of strings in the set
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Is the set empty?
+     * @return {@code true} if the set is empty, and {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns all of the keys in the set, as an iterator.
+     * To iterate over all of the keys in a set named {@code set}, use the
+     * foreach notation: {@code for (Key key : set)}.
+     * @return an iterator to all of the keys in the set
+     */
+    public Iterator<String> iterator() {
+        return keysWithPrefix("").iterator();
+    }
+
+    /**
+     * Returns all of the keys in the set that start with {@code prefix}.
+     * @param prefix the prefix
+     * @return all of the keys in the set that start with {@code prefix},
+     *     as an iterable
+     */
+    public Iterable<String> keysWithPrefix(String prefix) {
+        Queue<String> results = new Queue<String>();
+        Node x = get(root, prefix, 0);
+        collect(x, new StringBuilder(prefix), results);
+        return results;
+    }
+
+    private void collect(Node x, StringBuilder prefix, Queue<String> results) {
+        if (x == null) return;
+        if (x.isString) results.enqueue(prefix.toString());
+        for (char c = 0; c < R; c++) {
+            prefix.append(c);
+            collect(x.next[c], prefix, results);
+            prefix.deleteCharAt(prefix.length() - 1);
+        }
+    }
+
+    /**
+     * Returns all of the keys in the set that match {@code pattern},
+     * where the character '.' is interpreted as a wildcard character.
+     * @param pattern the pattern
+     * @return all of the keys in the set that match {@code pattern},
+     *     as an iterable, where . is treated as a wildcard character.
+     */  
+    public Iterable<String> keysThatMatch(String pattern) {
+        Queue<String> results = new Queue<String>();
+        StringBuilder prefix = new StringBuilder();
+        collect(root, prefix, pattern, results);
+        return results;
+    }
+        
+    private void collect(Node x, StringBuilder prefix, String pattern, Queue<String> results) {
+        if (x == null) return;
+        int d = prefix.length();
+        if (d == pattern.length() && x.isString)
+            results.enqueue(prefix.toString());
+        if (d == pattern.length())
+            return;
+        char c = pattern.charAt(d);
+        if (c == '.') {
+            for (char ch = 0; ch < R; ch++) {
+                prefix.append(ch);
+                collect(x.next[ch], prefix, pattern, results);
+                prefix.deleteCharAt(prefix.length() - 1);
+            }
+        }
+        else {
+            prefix.append(c);
+            collect(x.next[c], prefix, pattern, results);
+            prefix.deleteCharAt(prefix.length() - 1);
+        }
+    }
+
+    /**
+     * Returns the string in the set that is the longest prefix of {@code query},
+     * or {@code null}, if no such string.
+     * @param query the query string
+     * @return the string in the set that is the longest prefix of {@code query},
+     *     or {@code null} if no such string
+     * @throws IllegalArgumentException if {@code query} is {@code null}
+     */
+    public String longestPrefixOf(String query) {
+        if (query == null) throw new IllegalArgumentException("argument to longestPrefixOf() is null");
+        int length = longestPrefixOf(root, query, 0, -1);
+        if (length == -1) return null;
+        return query.substring(0, length);
+    }
+
+    // returns the length of the longest string key in the subtrie
+    // rooted at x that is a prefix of the query string,
+    // assuming the first d character match and we have already
+    // found a prefix match of length length
+    private int longestPrefixOf(Node x, String query, int d, int length) {
+        if (x == null) return length;
+        if (x.isString) length = d;
+        if (d == query.length()) return length;
+        char c = query.charAt(d);
+        return longestPrefixOf(x.next[c], query, d+1, length);
+    }
+
+    /**
+     * Removes the key from the set if the key is present.
+     * @param key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(String key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
+        root = delete(root, key, 0);
+    }
+
+    private Node delete(Node x, String key, int d) {
+        if (x == null) return null;
+        if (d == key.length()) {
+            if (x.isString) n--;
+            x.isString = false;
+        }
+        else {
+            char c = key.charAt(d);
+            x.next[c] = delete(x.next[c], key, d+1);
+        }
+
+        // remove subtrie rooted at x if it is completely empty
+        if (x.isString) return x;
+        for (int c = 0; c < R; c++)
+            if (x.next[c] != null)
+                return x;
+        return null;
+    }
+
+
+    /**
+     * Unit tests the {@code TrieSET} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        TrieSET set = new TrieSET();
+        while (!StdIn.isEmpty()) {
+            String key = StdIn.readString();
+            set.add(key);
+        }
+
+        // print results
+        if (set.size() < 100) {
+            StdOut.println("keys(\"\"):");
+            for (String key : set) {
+                StdOut.println(key);
+            }
+            StdOut.println();
+        }
+
+        StdOut.println("longestPrefixOf(\"shellsort\"):");
+        StdOut.println(set.longestPrefixOf("shellsort"));
+        StdOut.println();
+
+        StdOut.println("longestPrefixOf(\"xshellsort\"):");
+        StdOut.println(set.longestPrefixOf("xshellsort"));
+        StdOut.println();
+
+        StdOut.println("keysWithPrefix(\"shor\"):");
+        for (String s : set.keysWithPrefix("shor"))
+            StdOut.println(s);
+        StdOut.println();
+
+        StdOut.println("keysWithPrefix(\"shortening\"):");
+        for (String s : set.keysWithPrefix("shortening"))
+            StdOut.println(s);
+        StdOut.println();
+
+        StdOut.println("keysThatMatch(\".he.l.\"):");
+        for (String s : set.keysThatMatch(".he.l."))
+            StdOut.println(s);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TrieST.java b/src/main/java/edu/princeton/cs/algs4/TrieST.java
new file mode 100644
index 0000000..29a1747
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TrieST.java
@@ -0,0 +1,333 @@
+/******************************************************************************
+ *  Compilation:  javac TrieST.java
+ *  Execution:    java TrieST < words.txt
+ *  Dependencies: StdIn.java
+ *  Data files:   https://algs4.cs.princeton.edu/52trie/shellsST.txt
+ *
+ *  A string symbol table for extended ASCII strings, implemented
+ *  using a 256-way trie.
+ *
+ *  % java TrieST < shellsST.txt 
+ *  by 4
+ *  sea 6
+ *  sells 1
+ *  she 0
+ *  shells 3
+ *  shore 7
+ *  the 5
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TrieST} class represents an symbol table of key-value
+ *  pairs, with string keys and generic values.
+ *  It supports the usual <em>put</em>, <em>get</em>, <em>contains</em>,
+ *  <em>delete</em>, <em>size</em>, and <em>is-empty</em> methods.
+ *  It also provides character-based methods for finding the string
+ *  in the symbol table that is the <em>longest prefix</em> of a given prefix,
+ *  finding all strings in the symbol table that <em>start with</em> a given prefix,
+ *  and finding all strings in the symbol table that <em>match</em> a given pattern.
+ *  A symbol table implements the <em>associative array</em> abstraction:
+ *  when associating a value with a key that is already in the symbol table,
+ *  the convention is to replace the old value with the new value.
+ *  Unlike {@link java.util.Map}, this class uses the convention that
+ *  values cannot be {@code null}‚Äîsetting the
+ *  value associated with a key to {@code null} is equivalent to deleting the key
+ *  from the symbol table.
+ *  <p>
+ *  This implementation uses a 256-way trie.
+ *  The <em>put</em>, <em>contains</em>, <em>delete</em>, and
+ *  <em>longest prefix</em> operations take time proportional to the length
+ *  of the key (in the worst case). Construction takes constant time.
+ *  The <em>size</em>, and <em>is-empty</em> operations take constant time.
+ *  Construction takes constant time.
+ *  <p>
+ *  For additional documentation, see <a href="https://algs4.cs.princeton.edu/52trie">Section 5.2</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ */
+public class TrieST<Value> {
+    private static final int R = 256;        // extended ASCII
+
+
+    private Node root;      // root of trie
+    private int n;          // number of keys in trie
+
+    // R-way trie node
+    private static class Node {
+        private Object val;
+        private Node[] next = new Node[R];
+    }
+
+   /**
+     * Initializes an empty string symbol table.
+     */
+    public TrieST() {
+    }
+
+
+    /**
+     * Returns the value associated with the given key.
+     * @param key the key
+     * @return the value associated with the given key if the key is in the symbol table
+     *     and {@code null} if the key is not in the symbol table
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public Value get(String key) {
+        if (key == null) throw new IllegalArgumentException("argument to get() is null");
+        Node x = get(root, key, 0);
+        if (x == null) return null;
+        return (Value) x.val;
+    }
+
+    /**
+     * Does this symbol table contain the given key?
+     * @param key the key
+     * @return {@code true} if this symbol table contains {@code key} and
+     *     {@code false} otherwise
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public boolean contains(String key) {
+        if (key == null) throw new IllegalArgumentException("argument to contains() is null");
+        return get(key) != null;
+    }
+
+    private Node get(Node x, String key, int d) {
+        if (x == null) return null;
+        if (d == key.length()) return x;
+        char c = key.charAt(d);
+        return get(x.next[c], key, d+1);
+    }
+
+    /**
+     * Inserts the key-value pair into the symbol table, overwriting the old value
+     * with the new value if the key is already in the symbol table.
+     * If the value is {@code null}, this effectively deletes the key from the symbol table.
+     * @param key the key
+     * @param val the value
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void put(String key, Value val) {
+        if (key == null) throw new IllegalArgumentException("first argument to put() is null");
+        if (val == null) delete(key);
+        else root = put(root, key, val, 0);
+    }
+
+    private Node put(Node x, String key, Value val, int d) {
+        if (x == null) x = new Node();
+        if (d == key.length()) {
+            if (x.val == null) n++;
+            x.val = val;
+            return x;
+        }
+        char c = key.charAt(d);
+        x.next[c] = put(x.next[c], key, val, d+1);
+        return x;
+    }
+
+    /**
+     * Returns the number of key-value pairs in this symbol table.
+     * @return the number of key-value pairs in this symbol table
+     */
+    public int size() {
+        return n;
+    }
+
+    /**
+     * Is this symbol table empty?
+     * @return {@code true} if this symbol table is empty and {@code false} otherwise
+     */
+    public boolean isEmpty() {
+        return size() == 0;
+    }
+
+    /**
+     * Returns all keys in the symbol table as an {@code Iterable}.
+     * To iterate over all of the keys in the symbol table named {@code st},
+     * use the foreach notation: {@code for (Key key : st.keys())}.
+     * @return all keys in the symbol table as an {@code Iterable}
+     */
+    public Iterable<String> keys() {
+        return keysWithPrefix("");
+    }
+
+    /**
+     * Returns all of the keys in the set that start with {@code prefix}.
+     * @param prefix the prefix
+     * @return all of the keys in the set that start with {@code prefix},
+     *     as an iterable
+     */
+    public Iterable<String> keysWithPrefix(String prefix) {
+        Queue<String> results = new Queue<String>();
+        Node x = get(root, prefix, 0);
+        collect(x, new StringBuilder(prefix), results);
+        return results;
+    }
+
+    private void collect(Node x, StringBuilder prefix, Queue<String> results) {
+        if (x == null) return;
+        if (x.val != null) results.enqueue(prefix.toString());
+        for (char c = 0; c < R; c++) {
+            prefix.append(c);
+            collect(x.next[c], prefix, results);
+            prefix.deleteCharAt(prefix.length() - 1);
+        }
+    }
+
+    /**
+     * Returns all of the keys in the symbol table that match {@code pattern},
+     * where the character '.' is interpreted as a wildcard character.
+     * @param pattern the pattern
+     * @return all of the keys in the symbol table that match {@code pattern},
+     *     as an iterable, where . is treated as a wildcard character.
+     */
+    public Iterable<String> keysThatMatch(String pattern) {
+        Queue<String> results = new Queue<String>();
+        collect(root, new StringBuilder(), pattern, results);
+        return results;
+    }
+
+    private void collect(Node x, StringBuilder prefix, String pattern, Queue<String> results) {
+        if (x == null) return;
+        int d = prefix.length();
+        if (d == pattern.length() && x.val != null)
+            results.enqueue(prefix.toString());
+        if (d == pattern.length())
+            return;
+        char c = pattern.charAt(d);
+        if (c == '.') {
+            for (char ch = 0; ch < R; ch++) {
+                prefix.append(ch);
+                collect(x.next[ch], prefix, pattern, results);
+                prefix.deleteCharAt(prefix.length() - 1);
+            }
+        }
+        else {
+            prefix.append(c);
+            collect(x.next[c], prefix, pattern, results);
+            prefix.deleteCharAt(prefix.length() - 1);
+        }
+    }
+
+    /**
+     * Returns the string in the symbol table that is the longest prefix of {@code query},
+     * or {@code null}, if no such string.
+     * @param query the query string
+     * @return the string in the symbol table that is the longest prefix of {@code query},
+     *     or {@code null} if no such string
+     * @throws IllegalArgumentException if {@code query} is {@code null}
+     */
+    public String longestPrefixOf(String query) {
+        if (query == null) throw new IllegalArgumentException("argument to longestPrefixOf() is null");
+        int length = longestPrefixOf(root, query, 0, -1);
+        if (length == -1) return null;
+        else return query.substring(0, length);
+    }
+
+    // returns the length of the longest string key in the subtrie
+    // rooted at x that is a prefix of the query string,
+    // assuming the first d character match and we have already
+    // found a prefix match of given length (-1 if no such match)
+    private int longestPrefixOf(Node x, String query, int d, int length) {
+        if (x == null) return length;
+        if (x.val != null) length = d;
+        if (d == query.length()) return length;
+        char c = query.charAt(d);
+        return longestPrefixOf(x.next[c], query, d+1, length);
+    }
+
+    /**
+     * Removes the key from the set if the key is present.
+     * @param key the key
+     * @throws IllegalArgumentException if {@code key} is {@code null}
+     */
+    public void delete(String key) {
+        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
+        root = delete(root, key, 0);
+    }
+
+    private Node delete(Node x, String key, int d) {
+        if (x == null) return null;
+        if (d == key.length()) {
+            if (x.val != null) n--;
+            x.val = null;
+        }
+        else {
+            char c = key.charAt(d);
+            x.next[c] = delete(x.next[c], key, d+1);
+        }
+
+        // remove subtrie rooted at x if it is completely empty
+        if (x.val != null) return x;
+        for (int c = 0; c < R; c++)
+            if (x.next[c] != null)
+                return x;
+        return null;
+    }
+
+    /**
+     * Unit tests the {@code TrieST} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+
+        // build symbol table from standard input
+        TrieST<Integer> st = new TrieST<Integer>();
+        for (int i = 0; !StdIn.isEmpty(); i++) {
+            String key = StdIn.readString();
+            st.put(key, i);
+        }
+
+        // print results
+        if (st.size() < 100) {
+            StdOut.println("keys(\"\"):");
+            for (String key : st.keys()) {
+                StdOut.println(key + " " + st.get(key));
+            }
+            StdOut.println();
+        }
+
+        StdOut.println("longestPrefixOf(\"shellsort\"):");
+        StdOut.println(st.longestPrefixOf("shellsort"));
+        StdOut.println();
+
+        StdOut.println("longestPrefixOf(\"quicksort\"):");
+        StdOut.println(st.longestPrefixOf("quicksort"));
+        StdOut.println();
+
+        StdOut.println("keysWithPrefix(\"shor\"):");
+        for (String s : st.keysWithPrefix("shor"))
+            StdOut.println(s);
+        StdOut.println();
+
+        StdOut.println("keysThatMatch(\".he.l.\"):");
+        for (String s : st.keysThatMatch(".he.l."))
+            StdOut.println(s);
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/TwoPersonZeroSumGame.java b/src/main/java/edu/princeton/cs/algs4/TwoPersonZeroSumGame.java
new file mode 100644
index 0000000..a40ccbb
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/TwoPersonZeroSumGame.java
@@ -0,0 +1,377 @@
+/******************************************************************************
+ *  Compilation:  javac TwoPersonZeroSumGame.java
+ *  Execution:    java TwoPersonZeroSumGame m n
+ *  Dependencies: LinearProgramming.java StdOut.java
+ *
+ *  Solve an m-by-n two-person zero-sum game by reducing it to
+ *  linear programming. Assuming A is a strictly positive payoff
+ *  matrix, the optimal row and column player strategies are x* an y*,
+ *  scaled to be probability distributions.
+ *
+ *  (P)  max  y^T 1         (D)  min   1^T x
+ *       s.t  A^T y <= 1         s.t   A x >= 1
+ *                y >= 0                 x >= 0
+ *
+ *  Row player is x, column player is y.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code TwoPersonZeroSumGame} class represents a data type for
+ *  computing optimal row and column strategies to two-person zero-sum games.
+ *  <p>
+ *  This implementation solves an <em>m</em>-by-<em>n</em> two-person
+ *  zero-sum game by reducing it to a linear programming problem.
+ *  Assuming the payoff matrix <em>A</em> is strictly positive, the
+ *  optimal row and column player strategies x* and y* are obtained
+ *  by solving the following primal and dual pair of linear programs,
+ *  scaling the results to be probability distributions.
+ *  <blockquote><pre>
+ *  (P)  max  y^T 1           (D)  min   1^T x
+ *       s.t  A^T y &le; 1         s.t   A x &ge; 1
+ *                y &le; 0                 x &ge; 0
+ *  </pre></blockquote>
+ *  <p>
+ *  If the payoff matrix <em>A</em> has any negative entries, we add
+ *  the same constant to every entry so that every entry is positive.
+ *  This increases the value of the game by that constant, but does not
+ *  change solutions to the two-person zero-sum game.
+ *  <p>
+ *  This implementation is not suitable for large inputs, as it calls
+ *  a bare-bones linear programming solver that is neither fast nor
+ *  robust with respect to floating-point roundoff error.
+ *  <p>
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/65reductions">Section 6.5</a>
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class TwoPersonZeroSumGame {
+    private static final double EPSILON = 1E-8;
+
+    private final int m;            // number of rows
+    private final int n;            // number of columns
+    private LinearProgramming lp;   // linear program solver
+    private double constant;        // constant added to each entry in payoff matrix
+                                    // (0 if all entries are strictly positive)
+ 
+    /**
+     * Determines an optimal solution to the two-sum zero-sum game
+     * with the specified payoff matrix.
+     *
+     * @param  payoff the <em>m</em>-by-<em>n</em> payoff matrix
+     */ 
+    public TwoPersonZeroSumGame(double[][] payoff) {
+        m = payoff.length;
+        n = payoff[0].length;
+
+        double[] c = new double[n];
+        double[] b = new double[m];
+        double[][] A = new double[m][n];
+        for (int i = 0; i < m; i++)
+            b[i] = 1.0;
+        for (int j = 0; j < n; j++)
+            c[j] = 1.0;
+
+        // find smallest entry
+        constant = Double.POSITIVE_INFINITY;
+        for (int i = 0; i < m; i++)
+            for (int j = 0; j < n; j++)
+                if (payoff[i][j] < constant)
+                    constant = payoff[i][j];
+
+        // add constant  to every entry to make strictly positive
+        if (constant <= 0) constant = -constant + 1;
+        else               constant = 0;
+        for (int i = 0; i < m; i++)
+            for (int j = 0; j < n; j++)
+                A[i][j] = payoff[i][j] + constant;
+
+        lp = new LinearProgramming(A, b, c);
+
+        assert certifySolution(payoff);
+    }
+
+
+    /**
+     * Returns the optimal value of this two-person zero-sum game.
+     *
+     * @return the optimal value of this two-person zero-sum game
+     *
+     */
+    public double value() {
+        return 1.0 / scale() - constant;
+    }
+
+
+    // sum of x[j]
+    private double scale() {
+        double[] x = lp.primal();
+        double sum = 0.0;
+        for (int j = 0; j < n; j++)
+            sum += x[j];
+        return sum;
+    }
+
+    /**
+     * Returns the optimal row strategy of this two-person zero-sum game.
+     *
+     * @return the optimal row strategy <em>x</em> of this two-person zero-sum game
+     */
+    public double[] row() {
+        double scale = scale();
+        double[] x = lp.primal();
+        for (int j = 0; j < n; j++)
+            x[j] /= scale;
+        return x;
+    }
+
+    /**
+     * Returns the optimal column strategy of this two-person zero-sum game.
+     *
+     * @return the optimal column strategy <em>y</em> of this two-person zero-sum game
+     */
+    public double[] column() {
+        double scale = scale();
+        double[] y = lp.dual();
+        for (int i = 0; i < m; i++)
+            y[i] /= scale;
+        return y;
+    }
+
+
+    /**************************************************************************
+     *
+     *  The code below is solely for testing correctness of the data type.
+     *
+     **************************************************************************/
+
+    // is the row vector x primal feasible?
+    private boolean isPrimalFeasible() {
+        double[] x = row();
+        double sum = 0.0;
+        for (int j = 0; j < n; j++) {
+            if (x[j] < 0) {
+                StdOut.println("row vector not a probability distribution");
+                StdOut.printf("    x[%d] = %f\n", j, x[j]);
+                return false;
+            }
+            sum += x[j];
+        }
+        if (Math.abs(sum - 1.0) > EPSILON) {
+            StdOut.println("row vector x[] is not a probability distribution");
+            StdOut.println("    sum = " + sum);
+            return false;
+        }
+        return true;
+    }
+
+    // is the column vector y dual feasible?
+    private boolean isDualFeasible() {
+        double[] y = column();
+        double sum = 0.0;
+        for (int i = 0; i < m; i++) {
+            if (y[i] < 0) {
+                StdOut.println("column vector y[] is not a probability distribution");
+                StdOut.printf("    y[%d] = %f\n", i, y[i]);
+                return false;
+            }
+            sum += y[i];
+        }
+        if (Math.abs(sum - 1.0) > EPSILON) {
+            StdOut.println("column vector not a probability distribution");
+            StdOut.println("    sum = " + sum);
+            return false;
+        }
+        return true;
+    }
+
+    // is the solution a Nash equilibrium?
+    private boolean isNashEquilibrium(double[][] payoff) {
+        double[] x = row();
+        double[] y = column();
+        double value = value();
+
+        // given row player's mixed strategy, find column player's best pure strategy
+        double opt1 = Double.NEGATIVE_INFINITY;
+        for (int i = 0; i < m; i++) {
+            double sum = 0.0;
+            for (int j = 0; j < n; j++) {
+                sum += payoff[i][j] * x[j];
+            }
+            if (sum > opt1) opt1 = sum;
+        }
+        if (Math.abs(opt1 - value) > EPSILON) {
+            StdOut.println("Optimal value = " + value);
+            StdOut.println("Optimal best response for column player = " + opt1);
+            return false;
+        }
+
+        // given column player's mixed strategy, find row player's best pure strategy
+        double opt2 = Double.POSITIVE_INFINITY;
+        for (int j = 0; j < n; j++) {
+            double sum = 0.0;
+            for (int i = 0; i < m; i++) {
+                sum += payoff[i][j] * y[i];
+            }
+            if (sum < opt2) opt2 = sum;
+        }
+        if (Math.abs(opt2 - value) > EPSILON) {
+            StdOut.println("Optimal value = " + value);
+            StdOut.println("Optimal best response for row player = " + opt2);
+            return false;
+        }
+
+
+        return true;
+    }
+
+    private boolean certifySolution(double[][] payoff) {
+        return isPrimalFeasible() && isDualFeasible() && isNashEquilibrium(payoff);
+    }
+
+
+    private static void test(String description, double[][] payoff) {
+        StdOut.println();
+        StdOut.println(description);
+        StdOut.println("------------------------------------");
+        int m = payoff.length;
+        int n = payoff[0].length;
+        TwoPersonZeroSumGame zerosum = new TwoPersonZeroSumGame(payoff);
+        double[] x = zerosum.row();
+        double[] y = zerosum.column();
+
+        StdOut.print("x[] = [");
+        for (int j = 0; j < n-1; j++)
+            StdOut.printf("%8.4f, ", x[j]);
+        StdOut.printf("%8.4f]\n", x[n-1]);
+
+        StdOut.print("y[] = [");
+        for (int i = 0; i < m-1; i++)
+            StdOut.printf("%8.4f, ", y[i]);
+        StdOut.printf("%8.4f]\n", y[m-1]);
+        StdOut.println("value =  " + zerosum.value());
+        
+    }
+
+    // row = { 4/7, 3/7 }, column = { 0, 4/7, 3/7 }, value = 20/7
+    // http://en.wikipedia.org/wiki/Zero-sum
+    private static void test1() {
+        double[][] payoff = {
+            { 30, -10,  20 },
+            { 10,  20, -20 }
+        };
+        test("wikipedia", payoff);
+    }
+
+    // skew-symmetric => value = 0
+    // Linear Programming by Chvatal, p. 230
+    private static void test2() {
+        double[][] payoff = {
+            {  0,  2, -3,  0 },
+            { -2,  0,  0,  3 },
+            {  3,  0,  0, -4 },
+            {  0, -3,  4,  0 }
+        };
+        test("Chvatal, p. 230", payoff);
+    }
+
+    // Linear Programming by Chvatal, p. 234
+    // row    = { 0, 56/99, 40/99, 0, 0, 2/99, 0, 1/99 }
+    // column = { 28/99, 30/99, 21/99, 20/99 }
+    // value  = 4/99
+    private static void test3() {
+        double[][] payoff = {
+            {  0,  2, -3,  0 },
+            { -2,  0,  0,  3 },
+            {  3,  0,  0, -4 },
+            {  0, -3,  4,  0 },
+            {  0,  0, -3,  3 },
+            { -2,  2,  0,  0 },
+            {  3, -3,  0,  0 },
+            {  0,  0,  4, -4 }
+        };
+        test("Chvatal, p. 234", payoff);
+    }
+
+    // Linear Programming by Chvatal, p. 236
+    // row    = { 0, 2/5, 7/15, 0, 2/15, 0, 0, 0 }
+    // column = { 2/3, 0, 0, 1/3 }
+    // value  = -1/3
+    private static void test4() {
+        double[][] payoff = {
+            {  0,  2, -1, -1 },
+            {  0,  1, -2, -1 },
+            { -1, -1,  1,  1 },
+            { -1,  0,  0,  1 },
+            {  1, -2,  0, -3 },
+            {  1, -1, -1, -3 },
+            {  0, -3,  2, -1 },
+            {  0, -2,  1, -1 },
+        };
+        test("Chvatal p. 236", payoff);
+    }
+
+    // rock, paper, scissors
+    // row    = { 1/3, 1/3, 1/3 }
+    // column = { 1/3, 1/3, 1/3 }
+    private static void test5() {
+        double[][] payoff = {
+            {  0, -1,  1 },
+            {  1,  0, -1 },
+            { -1,  1,  0 }
+        };
+        test("rock, paper, scisssors", payoff);
+    }
+
+
+    /**
+     * Unit tests the {@code ZeroSumGameToLP} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        test1();
+        test2();
+        test3();
+        test4();
+        test5();
+
+        int m = Integer.parseInt(args[0]);
+        int n = Integer.parseInt(args[1]);
+        double[][] payoff = new double[m][n];
+        for (int i = 0; i < m; i++)
+            for (int j = 0; j < n; j++)
+                payoff[i][j] = StdRandom.uniform(-0.5, 0.5);
+        test("random " + m + "-by-" + n, payoff);
+    }
+
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/UF.java b/src/main/java/edu/princeton/cs/algs4/UF.java
new file mode 100644
index 0000000..fa289d7
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/UF.java
@@ -0,0 +1,227 @@
+/******************************************************************************
+ *  Compilation:  javac UF.java
+ *  Execution:    java UF < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/15uf/tinyUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/mediumUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/largeUF.txt
+ *
+ *  Weighted quick-union by rank with path compression by halving.
+ *
+ *  % java UF < tinyUF.txt
+ *  4 3
+ *  3 8
+ *  6 5
+ *  9 4
+ *  2 1
+ *  5 0
+ *  7 2
+ *  6 1
+ *  2 components
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+/**
+ *  The {@code UF} class represents a <em>union‚Äìfind data type</em>
+ *  (also known as the <em>disjoint-sets data type</em>).
+ *  It supports the classic <em>union</em> and <em>find</em> operations,
+ *  along with a <em>count</em> operation that returns the total number
+ *  of sets.
+ *  <p>
+ *  The union‚Äìfind data type models a collection of sets containing
+ *  <em>n</em> elements, with each element in exactly one set.
+ *  The elements are named 0 through <em>n</em>‚Äì1.
+ *  Initially, there are <em>n</em> sets, with each element in its
+ *  own set. The <em>canonical element</em> of a set
+ *  (also known as the <em>root</em>, <em>identifier</em>,
+ *  <em>leader</em>, or <em>set representative</em>)
+ *  is one distinguished element in the set. Here is a summary of
+ *  the operations:
+ *  <ul>
+ *  <li><em>find</em>(<em>p</em>) returns the canonical element
+ *      of the set containing <em>p</em>. The <em>find</em> operation
+ *      returns the same value for two elements if and only if
+ *      they are in the same set.
+ *  <li><em>union</em>(<em>p</em>, <em>q</em>) merges the set
+ *      containing element <em>p</em> with the set containing
+ *      element <em>q</em>. That is, if <em>p</em> and <em>q</em>
+ *      are in different sets, replace these two sets
+ *      with a new set that is the union of the two.
+ *  <li><em>count</em>() returns the number of sets.
+ *  </ul>
+ *  <p>
+ *  The canonical element of a set can change only when the set
+ *  itself changes during a call to <em>union</em>&mdash;it cannot
+ *  change during a call to either <em>find</em> or <em>count</em>.
+ *  <p>
+ *  This implementation uses <em>weighted quick union by rank</em>
+ *  with <em>path compression by halving</em>.
+ *  The constructor takes &Theta;(<em>n</em>) time, where
+ *  <em>n</em> is the number of elements.
+ *  The <em>union</em> and <em>find</em> operations take
+ *  &Theta;(log <em>n</em>) time in the worst case.
+ *  The <em>count</em> operation takes &Theta;(1) time.
+ *  Moreover, starting from an empty data structure with <em>n</em> sites,
+ *  any intermixed sequence of <em>m</em> <em>union</em> and <em>find</em>
+ *  operations takes <em>O</em>(<em>m</em> &alpha;(<em>n</em>)) time,
+ *  where &alpha;(<em>n</em>) is the inverse of
+ *  <a href = "https://en.wikipedia.org/wiki/Ackermann_function#Inverse">Ackermann's function</a>.
+ *  <p>
+ *  For alternative implementations of the same API, see
+ *  {@link QuickUnionUF}, {@link QuickFindUF}, and {@link WeightedQuickUnionUF}.
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/15uf">Section 1.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+
+public class UF {
+
+    private int[] parent;  // parent[i] = parent of i
+    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
+    private int count;     // number of components
+
+    /**
+     * Initializes an empty union-find data structure with
+     * {@code n} elements {@code 0} through {@code n-1}.
+     * Initially, each elements is in its own set.
+     *
+     * @param  n the number of elements
+     * @throws IllegalArgumentException if {@code n < 0}
+     */
+    public UF(int n) {
+        if (n < 0) throw new IllegalArgumentException();
+        count = n;
+        parent = new int[n];
+        rank = new byte[n];
+        for (int i = 0; i < n; i++) {
+            parent[i] = i;
+            rank[i] = 0;
+        }
+    }
+
+    /**
+     * Returns the canonical element of the set containing element {@code p}.
+     *
+     * @param  p an element
+     * @return the canonical element of the set containing {@code p}
+     * @throws IllegalArgumentException unless {@code 0 <= p < n}
+     */
+    public int find(int p) {
+        validate(p);
+        while (p != parent[p]) {
+            parent[p] = parent[parent[p]];    // path compression by halving
+            p = parent[p];
+        }
+        return p;
+    }
+
+    /**
+     * Returns the number of sets.
+     *
+     * @return the number of sets (between {@code 1} and {@code n})
+     */
+    public int count() {
+        return count;
+    }
+  
+    /**
+     * Returns true if the two elements are in the same set.
+     *
+     * @param  p one element
+     * @param  q the other element
+     * @return {@code true} if {@code p} and {@code q} are in the same set;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     * @deprecated Replace with two calls to {@link #find(int)}.
+     */
+    @Deprecated
+    public boolean connected(int p, int q) {
+        return find(p) == find(q);
+    }
+  
+    /**
+     * Merges the set containing element {@code p} with the 
+     * the set containing element {@code q}.
+     *
+     * @param  p one element
+     * @param  q the other element
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     */
+    public void union(int p, int q) {
+        int rootP = find(p);
+        int rootQ = find(q);
+        if (rootP == rootQ) return;
+
+        // make root of smaller rank point to root of larger rank
+        if      (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;
+        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;
+        else {
+            parent[rootQ] = rootP;
+            rank[rootP]++;
+        }
+        count--;
+    }
+
+    // validate that p is a valid index
+    private void validate(int p) {
+        int n = parent.length;
+        if (p < 0 || p >= n) {
+            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));  
+        }
+    }
+
+    /**
+     * Reads an integer {@code n} and a sequence of pairs of integers
+     * (between {@code 0} and {@code n-1}) from standard input, where each integer
+     * in the pair represents some element;
+     * if the elements are in different sets, merge the two sets
+     * and print the pair to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        UF uf = new UF(n);
+        while (!StdIn.isEmpty()) {
+            int p = StdIn.readInt();
+            int q = StdIn.readInt();
+            if (uf.find(p) == uf.find(q)) continue;
+            uf.union(p, q);
+            StdOut.println(p + " " + q);
+        }
+        StdOut.println(uf.count() + " components");
+    }
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/UnicodeTest.java b/src/main/java/edu/princeton/cs/algs4/UnicodeTest.java
new file mode 100644
index 0000000..005b22c
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/UnicodeTest.java
@@ -0,0 +1,107 @@
+/******************************************************************************
+ *  Compilation:  javac-introcs  UnicodeTest.java
+ *  Execution:    java-introcs  UnicodeTest
+ *  Dependencies: StdOut.java
+ *
+ *  This programs prints out all of the Unicode characters in the basic
+ *  multilingual plane (U+0000 to U+FFFF) in a table. It skips the
+ *  following types of characters:
+ *    -  undefined
+ *    -  control characters
+ *    -  modifier symbols
+ *    -  non-spacing marks
+ *    -  Unicode formatting commands
+ *    -  reserved for surrogate pairs
+ *    -  reserved for private use
+ *
+ *
+ *  % java-introcs UnicodeTest
+ *  U+0020      !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /  
+ *  U+0030   0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?  
+ *  U+0040   @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  
+ *  U+0050   P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]     _  
+ *  U+0060      a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  
+ *  U+0070   p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~     
+ *  U+00A0   ¬†  ¬°  ¬¢  ¬£  ¬§  ¬•  ¬¶  ¬ß     ¬©  ¬™  ¬´  ¬¨     ¬Æ     
+ *  U+00B0   ¬∞  ¬±  ¬≤  ¬≥     ¬µ  ¬∂  ¬∑     ¬π  ¬∫  ¬ª  ¬º  ¬Ω  ¬æ  ¬ø  
+ *  U+00C0   √Ä  √Å  √Ç  √É  √Ñ  √Ö  √Ü  √á  √à  √â  √ä  √ã  √å  √ç  √é  √è  
+ *  U+00D0   √ê  √ë  √í  √ì  √î  √ï  √ñ  √ó  √ò  √ô  √ö  √õ  √ú  √ù  √û  √ü  
+ *  U+00E0   √†  √°  √¢  √£  √§  √•  √¶  √ß  √®  √©  √™  √´  √¨  √≠  √Æ  √Ø  
+ *  U+00F0   √∞  √±  √≤  √≥  √¥  √µ  √∂  √∑  √∏  √π  √∫  √ª  √º  √Ω  √æ  √ø 
+ *  U+0100   ƒÄ  ƒÅ  ƒÇ  ƒÉ  ƒÑ  ƒÖ  ƒÜ  ƒá  ƒà  ƒâ  ƒä  ƒã  ƒå  ƒç  ƒé  ƒè
+ *  ...
+ *
+ *  Depending on your system setup and font, not all of the Unicode
+ *  characters may display properly.
+ *
+ *  Quirks: when printing certain Hebrew or Arabic characters, the
+ *  table may print right-to-left instead of left-to-right.
+ *
+ *  For a description of Unicode terminology, see:
+ *  http://docs.oracle.com/javase/tutorial/i18n/text/terminology.html
+ *
+ *  For the Character API, see:
+ *  http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html
+ *
+ *  To see what each Unicode character should look like, see:
+ *  http://www.fileformat.info/info/unicode/index.htm
+ *  http://www.fileformat.info/info/unicode/char/05D0/index.htm
+ *
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+
+public class UnicodeTest {
+    // number of Unicode characters to display per line
+    private static final int CHARS_PER_LINE = 16;
+
+    // number of Unicode characters to display (basic multilingual plane)
+    private static final int MAX_CHAR = 65536;
+
+    // do not instantiate
+    private UnicodeTest() { }
+
+    // Returns a string representation of the given codePoint, or a single
+    // space if the codePoint should not be suppressed when printing.
+    private static String toString(int codePoint) {
+        if (!Character.isDefined(codePoint))             return " ";
+        if (Character.isISOControl(codePoint))           return " ";
+        if (Character.isWhitespace(codePoint))           return " ";
+     // if (Character.isSurrogate(codePoint)             return " ";   // Java 1.7+ only
+        if (Character.isLowSurrogate((char) codePoint))  return " ";   // Java 1.5+
+        if (Character.isHighSurrogate((char) codePoint)) return " ";   // Java 1.5+
+
+        switch(Character.getType(codePoint)) {
+            case Character.MODIFIER_SYMBOL:              return " ";
+            case Character.CONTROL:                      return " ";
+            case Character.MODIFIER_LETTER:              return " ";
+            case Character.NON_SPACING_MARK:             return " ";
+            case Character.FORMAT:                       return " ";
+            case Character.PRIVATE_USE:                  return " ";
+            default: return new String(Character.toChars(codePoint));
+        }
+    }
+
+   /**
+     * Prints Unicode characters to standard output.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        for (int line = 0; line < 2*Character.MAX_VALUE / CHARS_PER_LINE; line++) {
+            StringBuilder buffer = new StringBuilder();
+            for (int i = 0; i < CHARS_PER_LINE; i++) {
+                int codePoint = CHARS_PER_LINE*line + i;
+                buffer.append(toString(codePoint) + "  ");
+            }
+            String output = buffer.toString();
+            if (!output.trim().equals("")) {
+                // U+202D is the Unicode override to force left-to-right direction
+                // but doesn't seem to work with Unix more
+                StdOut.printf("U+%04X   %s\n", 16*line, output);
+            }
+        }
+    }
+}
diff --git a/src/main/java/edu/princeton/cs/algs4/Vector.java b/src/main/java/edu/princeton/cs/algs4/Vector.java
new file mode 100644
index 0000000..2bcd874
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/Vector.java
@@ -0,0 +1,275 @@
+/******************************************************************************
+ *  Compilation:  javac Vector.java
+ *  Execution:    java Vector
+ *  Dependencies: StdOut.java
+ *
+ *  Implementation of a vector of real numbers.
+ *
+ *  This class is implemented to be immutable: once the client program
+ *  initialize a Vector, it cannot change any of its fields
+ *  (d or data[i]) either directly or indirectly. Immutability is a
+ *  very desirable feature of a data type.
+ *
+ *  % java Vector
+ *     x     = [ 1.0 2.0 3.0 4.0 ]
+ *     y     = [ 5.0 2.0 4.0 1.0 ]
+ *     z     = [ 6.0 4.0 7.0 5.0 ]
+ *   10z     = [ 60.0 40.0 70.0 50.0 ]
+ *    |x|    = 5.477225575051661
+ *   <x, y>  = 25.0
+ * 
+ *
+ *  Note that Vector is also the name of an unrelated Java library class
+ *  in the package java.util.
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code Vector} class represents a <em>d</em>-dimensional Euclidean vector.
+ *  Vectors are immutable: their values cannot be changed after they are created.
+ *  It includes methods for addition, subtraction,
+ *  dot product, scalar product, unit vector, Euclidean norm, and the Euclidean
+ *  distance between two vectors.
+ *  <p>
+ *  For additional documentation, 
+ *  see <a href="https://algs4.cs.princeton.edu/12oop">Section 1.2</a> of 
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. 
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class Vector { 
+
+    private int d;               // dimension of the vector
+    private double[] data;       // array of vector's components
+
+
+    /**
+     * Initializes a d-dimensional zero vector.
+     *
+     * @param d the dimension of the vector
+     */
+    public Vector(int d) {
+        this.d = d;
+        data = new double[d];
+    }
+
+    /**
+     * Initializes a vector from either an array or a vararg list.
+     * The vararg syntax supports a constructor that takes a variable number of
+     * arugments such as Vector x = new Vector(1.0, 2.0, 3.0, 4.0).
+     *
+     * @param a  the array or vararg list
+     */
+    public Vector(double... a) {
+        d = a.length;
+
+        // defensive copy so that client can't alter our copy of data[]
+        data = new double[d];
+        for (int i = 0; i < d; i++)
+            data[i] = a[i];
+    }
+
+    /**
+     * Returns the length of this vector.
+     *
+     * @return the dimension of this vector
+     * @deprecated Replaced by {@link #dimension()}.
+     */
+    @Deprecated
+    public int length() {
+        return d;
+    }
+
+    /**
+     * Returns the dimension of this vector.
+     *
+     * @return the dimension of this vector
+     */
+    public int dimension() {
+        return d;
+    }
+
+    /**
+     * Returns the dot product of this vector with the specified vector.
+     *
+     * @param  that the other vector
+     * @return the dot product of this vector and that vector
+     * @throws IllegalArgumentException if the dimensions of the two vectors are not equal
+     */
+    public double dot(Vector that) {
+        if (this.d != that.d) throw new IllegalArgumentException("Dimensions don't agree");
+        double sum = 0.0;
+        for (int i = 0; i < d; i++)
+            sum = sum + (this.data[i] * that.data[i]);
+        return sum;
+    }
+
+    /**
+     * Returns the magnitude of this vector.
+     * This is also known as the L2 norm or the Euclidean norm.
+     *
+     * @return the magnitude of this vector
+     */
+    public double magnitude() {
+        return Math.sqrt(this.dot(this));
+    }
+
+    /**
+     * Returns the Euclidean distance between this vector and the specified vector.
+     *
+     * @param  that the other vector 
+     * @return the Euclidean distance between this vector and that vector
+     * @throws IllegalArgumentException if the dimensions of the two vectors are not equal
+     */
+    public double distanceTo(Vector that) {
+        if (this.d != that.d) throw new IllegalArgumentException("Dimensions don't agree");
+        return this.minus(that).magnitude();
+    }
+
+    /**
+     * Returns the sum of this vector and the specified vector.
+     *
+     * @param  that the vector to add to this vector
+     * @return the vector whose value is {@code (this + that)}
+     * @throws IllegalArgumentException if the dimensions of the two vectors are not equal
+     */
+    public Vector plus(Vector that) {
+        if (this.d != that.d) throw new IllegalArgumentException("Dimensions don't agree");
+        Vector c = new Vector(d);
+        for (int i = 0; i < d; i++)
+            c.data[i] = this.data[i] + that.data[i];
+        return c;
+    }
+
+    /**
+     * Returns the difference between this vector and the specified vector.
+     *
+     * @param  that the vector to subtract from this vector
+     * @return the vector whose value is {@code (this - that)}
+     * @throws IllegalArgumentException if the dimensions of the two vectors are not equal
+     */
+    public Vector minus(Vector that) {
+        if (this.d != that.d) throw new IllegalArgumentException("Dimensions don't agree");
+        Vector c = new Vector(d);
+        for (int i = 0; i < d; i++)
+            c.data[i] = this.data[i] - that.data[i];
+        return c;
+    }
+
+    /**
+     * Returns the ith cartesian coordinate.
+     *
+     * @param  i the coordinate index
+     * @return the ith cartesian coordinate
+     */
+    public double cartesian(int i) {
+        return data[i];
+    }
+
+    /**
+     * Returns the scalar-vector product of this vector and the specified scalar
+     *
+     * @param  alpha the scalar
+     * @return the vector whose value is {@code (alpha * this)}
+     * @deprecated Replaced by {@link #scale(double)}.
+     */
+    @Deprecated
+    public Vector times(double alpha) {
+        Vector c = new Vector(d);
+        for (int i = 0; i < d; i++)
+            c.data[i] = alpha * data[i];
+        return c;
+    }
+
+    /**
+     * Returns the scalar-vector product of this vector and the specified scalar
+     *
+     * @param  alpha the scalar
+     * @return the vector whose value is {@code (alpha * this)}
+     */
+    public Vector scale(double alpha) {
+        Vector c = new Vector(d);
+        for (int i = 0; i < d; i++)
+            c.data[i] = alpha * data[i];
+        return c;
+    }
+
+    /**
+     * Returns a unit vector in the direction of this vector.
+     *
+     * @return a unit vector in the direction of this vector
+     * @throws ArithmeticException if this vector is the zero vector
+     */
+    public Vector direction() {
+        if (this.magnitude() == 0.0) throw new ArithmeticException("Zero-vector has no direction");
+        return this.times(1.0 / this.magnitude());
+    }
+
+
+    /**
+     * Returns a string representation of this vector.
+     *
+     * @return a string representation of this vector, which consists of the 
+     *         the vector entries, separates by single spaces
+     */
+    public String toString() {
+        StringBuilder s = new StringBuilder();
+        for (int i = 0; i < d; i++)
+            s.append(data[i] + " ");
+        return s.toString();
+    }
+
+    /**
+     * Unit tests the {@code Vector} data type.
+     *
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        double[] xdata = { 1.0, 2.0, 3.0, 4.0 };
+        double[] ydata = { 5.0, 2.0, 4.0, 1.0 };
+        Vector x = new Vector(xdata);
+        Vector y = new Vector(ydata);
+
+        StdOut.println("   x       = " + x);
+        StdOut.println("   y       = " + y);
+
+        Vector z = x.plus(y);
+        StdOut.println("   z       = " + z);
+
+        z = z.times(10.0);
+        StdOut.println(" 10z       = " + z);
+
+        StdOut.println("  |x|      = " + x.magnitude());
+        StdOut.println(" <x, y>    = " + x.dot(y));
+        StdOut.println("dist(x, y) = " + x.distanceTo(y));
+        StdOut.println("dir(x)     = " + x.direction());
+
+    }
+}
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/WeightedQuickUnionUF.java b/src/main/java/edu/princeton/cs/algs4/WeightedQuickUnionUF.java
new file mode 100644
index 0000000..8db89be
--- /dev/null
+++ b/src/main/java/edu/princeton/cs/algs4/WeightedQuickUnionUF.java
@@ -0,0 +1,209 @@
+/******************************************************************************
+ *  Compilation:  javac WeightedQuickUnionUF.java
+ *  Execution:  java WeightedQuickUnionUF < input.txt
+ *  Dependencies: StdIn.java StdOut.java
+ *  Data files:   https://algs4.cs.princeton.edu/15uf/tinyUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/mediumUF.txt
+ *                https://algs4.cs.princeton.edu/15uf/largeUF.txt
+ *
+ *  Weighted quick-union (without path compression).
+ *
+ ******************************************************************************/
+
+package edu.princeton.cs.algs4;
+
+/**
+ *  The {@code WeightedQuickUnionUF} class represents a <em>union‚Äìfind data type</em>
+ *  (also known as the <em>disjoint-sets data type</em>).
+ *  It supports the classic <em>union</em> and <em>find</em> operations,
+ *  along with a <em>count</em> operation that returns the total number
+ *  of sets.
+ *  <p>
+ *  The union‚Äìfind data type models a collection of sets containing
+ *  <em>n</em> elements, with each element in exactly one set.
+ *  The elements are named 0 through <em>n</em>‚Äì1.
+ *  Initially, there are <em>n</em> sets, with each element in its
+ *  own set. The <em>canonical element</em> of a set
+ *  (also known as the <em>root</em>, <em>identifier</em>,
+ *  <em>leader</em>, or <em>set representative</em>)
+ *  is one distinguished element in the set. Here is a summary of
+ *  the operations:
+ *  <ul>
+ *  <li><em>find</em>(<em>p</em>) returns the canonical element
+ *      of the set containing <em>p</em>. The <em>find</em> operation
+ *      returns the same value for two elements if and only if
+ *      they are in the same set.
+ *  <li><em>union</em>(<em>p</em>, <em>q</em>) merges the set
+ *      containing element <em>p</em> with the set containing
+ *      element <em>q</em>. That is, if <em>p</em> and <em>q</em>
+ *      are in different sets, replace these two sets
+ *      with a new set that is the union of the two.
+ *  <li><em>count</em>() returns the number of sets.
+ *  </ul>
+ *  <p>
+ *  The canonical element of a set can change only when the set
+ *  itself changes during a call to <em>union</em>&mdash;it cannot
+ *  change during a call to either <em>find</em> or <em>count</em>.
+ *  <p>
+ *  This implementation uses <em>weighted quick union by size</em>
+ *  (without path compression).
+ *  The constructor takes &Theta;(<em>n</em>), where <em>n</em>
+ *  is the number of elements.
+ *  The <em>union</em> and <em>find</em>
+ *  operations  take &Theta;(log <em>n</em>) time in the worst
+ *  case. The <em>count</em> operation takes &Theta;(1) time.
+ *  <p>
+ *  For alternative implementations of the same API, see
+ *  {@link UF}, {@link QuickFindUF}, and {@link QuickUnionUF}.
+ *  For additional documentation, see
+ *  <a href="https://algs4.cs.princeton.edu/15uf">Section 1.5</a> of
+ *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
+ *
+ *  @author Robert Sedgewick
+ *  @author Kevin Wayne
+ */
+public class WeightedQuickUnionUF {
+    private int[] parent;   // parent[i] = parent of i
+    private int[] size;     // size[i] = number of elements in subtree rooted at i
+    private int count;      // number of components
+
+    /**
+     * Initializes an empty union-find data structure with
+     * {@code n} elements {@code 0} through {@code n-1}. 
+     * Initially, each elements is in its own set.
+     *
+     * @param  n the number of elements
+     * @throws IllegalArgumentException if {@code n < 0}
+     */
+    public WeightedQuickUnionUF(int n) {
+        count = n;
+        parent = new int[n];
+        size = new int[n];
+        for (int i = 0; i < n; i++) {
+            parent[i] = i;
+            size[i] = 1;
+        }
+    }
+
+    /**
+     * Returns the number of sets.
+     *
+     * @return the number of sets (between {@code 1} and {@code n})
+     */
+    public int count() {
+        return count;
+    }
+  
+    /**
+     * Returns the canonical element of the set containing element {@code p}.
+     *
+     * @param  p an element
+     * @return the canonical element of the set containing {@code p}
+     * @throws IllegalArgumentException unless {@code 0 <= p < n}
+     */
+    public int find(int p) {
+        validate(p);
+        while (p != parent[p])
+            p = parent[p];
+        return p;
+    }
+
+    /**
+     * Returns true if the two elements are in the same set.
+     * 
+     * @param  p one element
+     * @param  q the other element
+     * @return {@code true} if {@code p} and {@code q} are in the same set;
+     *         {@code false} otherwise
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     * @deprecated Replace with two calls to {@link #find(int)}.
+     */
+    @Deprecated
+    public boolean connected(int p, int q) {
+        return find(p) == find(q);
+    }
+
+    // validate that p is a valid index
+    private void validate(int p) {
+        int n = parent.length;
+        if (p < 0 || p >= n) {
+            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n-1));  
+        }
+    }
+
+    /**
+     * Merges the set containing element {@code p} with the 
+     * the set containing element {@code q}.
+     *
+     * @param  p one element
+     * @param  q the other element
+     * @throws IllegalArgumentException unless
+     *         both {@code 0 <= p < n} and {@code 0 <= q < n}
+     */
+    public void union(int p, int q) {
+        int rootP = find(p);
+        int rootQ = find(q);
+        if (rootP == rootQ) return;
+
+        // make smaller root point to larger one
+        if (size[rootP] < size[rootQ]) {
+            parent[rootP] = rootQ;
+            size[rootQ] += size[rootP];
+        }
+        else {
+            parent[rootQ] = rootP;
+            size[rootP] += size[rootQ];
+        }
+        count--;
+    }
+
+
+    /**
+     * Reads an integer {@code n} and a sequence of pairs of integers
+     * (between {@code 0} and {@code n-1}) from standard input, where each integer
+     * in the pair represents some element;
+     * if the elements are in different sets, merge the two sets
+     * and print the pair to standard output.
+     * 
+     * @param args the command-line arguments
+     */
+    public static void main(String[] args) {
+        int n = StdIn.readInt();
+        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n);
+        while (!StdIn.isEmpty()) {
+            int p = StdIn.readInt();
+            int q = StdIn.readInt();
+            if (uf.find(p) == uf.find(q)) continue;
+            uf.union(p, q);
+            StdOut.println(p + " " + q);
+        }
+        StdOut.println(uf.count() + " components");
+    }
+
+}
+
+
+/******************************************************************************
+ *  Copyright 2002-2020, Robert Sedgewick and Kevin Wayne.
+ *
+ *  This file is part of algs4.jar, which accompanies the textbook
+ *
+ *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
+ *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
+ *      http://algs4.cs.princeton.edu
+ *
+ *
+ *  algs4.jar is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  algs4.jar is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
+ ******************************************************************************/
diff --git a/src/main/java/edu/princeton/cs/algs4/mandrill.jpg b/src/main/java/edu/princeton/cs/algs4/mandrill.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..ec58db89223725a7e9351d9b38e0d5ad38664dad
GIT binary patch
literal 66925
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
Rc<|$?fBs93yshkC|JfY}r&0g_

literal 0
HcmV?d00001

diff --git a/src/main/java/net/jhorstmann/base64/Base64Charset.java b/src/main/java/net/jhorstmann/base64/Base64Charset.java
new file mode 100644
index 0000000..6418d75
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64Charset.java
@@ -0,0 +1,28 @@
+package net.jhorstmann.base64;
+
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+
+class Base64Charset extends Charset {
+    public static final String CHARSET_NAME = "BASE64";
+
+    protected Base64Charset() {
+        super(CHARSET_NAME, new String[0]);
+    }
+
+    @Override
+    public boolean contains(Charset cs) {
+        return cs instanceof Base64Charset;
+    }
+
+    @Override
+    public CharsetDecoder newDecoder() {
+        return new Base64CharsetDecoder(this);
+    }
+
+    @Override
+    public CharsetEncoder newEncoder() {
+        return new Base64CharsetEncoder(this);
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64CharsetDecoder.java b/src/main/java/net/jhorstmann/base64/Base64CharsetDecoder.java
new file mode 100644
index 0000000..58daa53
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64CharsetDecoder.java
@@ -0,0 +1,57 @@
+package net.jhorstmann.base64;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CoderMalfunctionError;
+import java.nio.charset.CoderResult;
+
+class Base64CharsetDecoder extends CharsetDecoder {
+
+    private final Base64StreamEncoder coder;
+
+    protected Base64CharsetDecoder(Charset cs) {
+        super(cs, 4.0f / 3.0f, 4.0f);
+        this.coder = new Base64StreamEncoder();
+    }
+
+    @Override
+    protected void implReset() {
+        this.coder.reset();
+    }
+
+    @Override
+    protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out) {
+        try {
+            while (in.hasRemaining()) {
+                if (out.remaining() < 3) {
+                    return CoderResult.OVERFLOW;
+                }
+                coder.encode(in.get() & 0xFF, out);
+            }
+            return CoderResult.UNDERFLOW;
+        } catch (IncompleteStreamException ex) {
+            return CoderResult.malformedForLength(1);
+        } catch (InvalidCharacterException ex) {
+            return CoderResult.unmappableForLength(1);
+        } catch (IOException ex) {
+            throw new CoderMalfunctionError(ex);
+        }
+    }
+
+    @Override
+    protected CoderResult implFlush(CharBuffer out) {
+        try {
+            coder.encodeFinal(out);
+            return CoderResult.UNDERFLOW;
+        } catch (IncompleteStreamException ex) {
+            return CoderResult.malformedForLength(1);
+        } catch (InvalidCharacterException ex) {
+            return CoderResult.unmappableForLength(1);
+        } catch (IOException ex) {
+            throw new CoderMalfunctionError(ex);
+        }
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64CharsetEncoder.java b/src/main/java/net/jhorstmann/base64/Base64CharsetEncoder.java
new file mode 100644
index 0000000..cc5858b
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64CharsetEncoder.java
@@ -0,0 +1,38 @@
+package net.jhorstmann.base64;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderMalfunctionError;
+import java.nio.charset.CoderResult;
+
+class Base64CharsetEncoder extends CharsetEncoder {
+
+    private Base64NIODecoder coder;
+
+    protected Base64CharsetEncoder(Base64Charset cs) {
+        super(cs, 3.0f / 4.0f, 3);
+        this.coder = new Base64NIODecoder();
+    }
+
+    @Override
+    protected void implReset() {
+        this.coder.reset();
+    }
+
+    @Override
+    protected CoderResult encodeLoop(CharBuffer in, ByteBuffer out) {
+        try {
+            while (in.hasRemaining()) {
+                if (out.remaining() < 3) {
+                    return CoderResult.OVERFLOW;
+                }
+                coder.decode(in.get(), out);
+            }
+            return CoderResult.UNDERFLOW;
+        } catch (IOException ex) {
+            throw new CoderMalfunctionError(ex);
+        }
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64CharsetProvider.java b/src/main/java/net/jhorstmann/base64/Base64CharsetProvider.java
new file mode 100644
index 0000000..93af3ed
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64CharsetProvider.java
@@ -0,0 +1,25 @@
+package net.jhorstmann.base64;
+
+import java.nio.charset.Charset;
+import java.nio.charset.spi.CharsetProvider;
+import java.util.Collections;
+import java.util.Iterator;
+
+public class Base64CharsetProvider extends CharsetProvider {
+    private Charset charset = new Base64Charset();
+
+    @Override
+    public Iterator<Charset> charsets() {
+        return Collections.singleton(charset).iterator();
+    }
+
+    @Override
+    public Charset charsetForName(String charsetName) {
+        if (Base64Charset.CHARSET_NAME.equalsIgnoreCase(charsetName)) {
+            return charset;
+        }
+        else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64Exception.java b/src/main/java/net/jhorstmann/base64/Base64Exception.java
new file mode 100644
index 0000000..3ea030b
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64Exception.java
@@ -0,0 +1,30 @@
+package net.jhorstmann.base64;
+
+import java.io.IOException;
+
+public abstract class Base64Exception extends IOException {
+
+    static String characterName(int ch) {
+        if (ch == -1) {
+            return "EOF";
+        } else if (ch == '\r') {
+            return "\\r";
+        } else if (ch == '\n') {
+            return "\\n";
+        } else if (ch == '\t') {
+            return "\\t";
+        } else if (ch == '\f') {
+            return "\\f";
+        } else if (ch >= ' ' && ch <= '~') {
+            return new StringBuilder(3).append("\'").append((char)ch).append("\'").toString();
+        } else if (ch <= 255) {
+            return String.format("\\x%02x", ch);
+        } else {
+            return String.format("\\u%04x", ch);
+        }
+    }
+
+    public Base64Exception(String msg) {
+        super(msg);
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64InputStream.java b/src/main/java/net/jhorstmann/base64/Base64InputStream.java
new file mode 100644
index 0000000..e529520
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64InputStream.java
@@ -0,0 +1,92 @@
+package net.jhorstmann.base64;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+public class Base64InputStream extends InputStream {
+
+    static class OutputStreamBuffer extends ByteArrayOutputStream {
+
+        private int pos;
+
+        int remaining() {
+            return count - pos;
+        }
+
+        boolean hasRemaining() {
+            return pos < count;
+        }
+
+        void clear() {
+            pos = 0;
+        }
+
+        int read() {
+            if (hasRemaining()) {
+                int res = buf[pos++] & 0xFF;
+                if (pos == count) {
+                    pos = 0;
+                    count = 0;
+                }
+                return res;
+            }
+            else {
+                return -1;
+            }
+        }
+
+        int read(byte[] b, int off, int len) {
+            if (hasRemaining()) {
+                int max = Math.min(b.length, remaining());
+                System.arraycopy(buf, pos, b, 0, max);
+                pos += max;
+                return max;
+            } else {
+                return -1;
+            }
+        }
+    }
+    private Base64StreamDecoder decoder;
+    private Reader reader;
+    private OutputStreamBuffer buffer;
+
+    public Base64InputStream(Base64StreamDecoder decoder, Reader reader) throws IOException {
+        this.decoder = decoder;
+        this.reader = reader;
+        this.buffer = new OutputStreamBuffer();
+    }
+
+    public Base64InputStream(InputStream in) throws IOException {
+        this(new InputStreamReader(in, "US-ASCII"));
+    }
+
+    public Base64InputStream(Reader reader) throws IOException {
+        this(new Base64StreamDecoder(), reader);
+    }
+
+    @Override
+    public int read() throws IOException {
+        while (!decoder.isEOF() && !buffer.hasRemaining()) {
+            int ch = reader.read();
+            decoder.decode(ch, buffer);
+        }
+        return buffer.read();
+    }
+
+    @Override
+    public int read(byte[] b) throws IOException {
+        return read(b, 0, b.length);
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        while (!decoder.isEOF() && buffer.remaining() < len - off) {
+            int ch = reader.read();
+            decoder.decode(ch, buffer);
+        }
+        return buffer.read(b, off, len);
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64NIODecoder.java b/src/main/java/net/jhorstmann/base64/Base64NIODecoder.java
new file mode 100644
index 0000000..151355f
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64NIODecoder.java
@@ -0,0 +1,261 @@
+package net.jhorstmann.base64;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
+
+public class Base64NIODecoder {
+    private static final byte[] codes = new byte[256];
+
+    static {
+        for (int i = 0; i < 256; i++) {
+            codes[i] = -1;
+        }
+        for (int i = 'A'; i <= 'Z'; i++) {
+            codes[i] = (byte)(i - 'A');
+        }
+        for (int i = 'a'; i <= 'z'; i++) {
+            codes[i] = (byte)(26 + i - 'a');
+        }
+        for (int i = '0'; i <= '9'; i++) {
+            codes[i] = (byte)(52 + i - '0');
+        }
+        codes['+'] = 62;
+        codes['/'] = 63;
+    }
+    private static final int STATE_EOF = -1;
+    private static final int STATE_START = 0;
+    private static final int STATE_SECOND = 1;
+    private static final int STATE_THIRD = 2;
+    private static final int STATE_PADDING = 3;
+    private static final int STATE_FOURTH = 4;
+    private int state = 0;
+    private int buf = 0;
+
+    void reset() {
+        this.state = 0;
+        this.buf = 0;
+    }
+
+    private static boolean isSpace(int ch) {
+        return ch == '\r' || ch == '\n' || ch == '\t' || ch == '\f' || ch == ' ';
+    }
+
+    private static int decodeChar(int ch) throws IOException {
+        if (ch < 0 || ch >= codes.length) {
+            throw new InvalidCharacterException(ch);
+        } else {
+            int val = codes[ch];
+            if (val >= 0) {
+                return val;
+            } else {
+                throw new InvalidCharacterException(ch);
+            }
+        }
+    }
+
+    final void decode(final int ch, final ByteBuffer out) throws IOException {
+        switch (this.state) {
+            case STATE_EOF:
+                break;
+            case STATE_START:
+                if (ch == -1) {
+                    this.state = STATE_EOF;
+                } else if (ch == '=') {
+                    throw new InvalidCharacterException(ch);
+                } else if (!isSpace(ch)) {
+                    this.buf = decodeChar(ch);
+                    this.state = STATE_SECOND;
+                }
+                break;
+            case STATE_SECOND:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    throw new InvalidCharacterException(ch);
+                } else {
+                    int val = decodeChar(ch);
+                    this.buf = (this.buf << 6) | val;
+                    this.state = STATE_THIRD;
+                }
+                break;
+            case STATE_THIRD:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    this.state = STATE_PADDING;
+                } else {
+                    int val = decodeChar(ch);
+                    this.buf = (this.buf << 6) | val;
+                    this.state = STATE_FOURTH;
+                }
+                break;
+            case STATE_PADDING:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    out.put((byte)((this.buf >> 4) & 0xFF));
+                    this.state = STATE_START;
+                } else {
+                    throw new InvalidCharacterException(ch);
+                }
+                break;
+            case STATE_FOURTH:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    int tmp = this.buf;
+                    out.put((byte)((tmp >> 10) & 0xFF));
+                    out.put((byte)((tmp >> 2) & 0xFF));
+                    this.state = STATE_START;
+                } else {
+                    int val = decodeChar(ch);
+                    int tmp = (this.buf << 6) | val;
+                    out.put((byte)((tmp >> 16) & 0xFF));
+                    out.put((byte)((tmp >> 8) & 0xFF));
+                    out.put((byte)(tmp & 0xFF));
+                    this.state = STATE_START;
+                }
+                break;
+            default:
+                throw new IllegalStateException("Invalid State " + this.state);
+        }
+    }
+
+    public boolean isComplete() {
+        return this.state == STATE_START || this.state == STATE_EOF;
+    }
+
+    public void checkComplete() throws IOException {
+        if (!isComplete()) {
+            throw new IncompleteStreamException("Incomplete Base64 Stream");
+        }
+    }
+
+    public void decode(byte[] in, int offset, int len, ByteBuffer out) throws IOException {
+        int idx = offset;
+        while (idx < offset + len && this.state != STATE_EOF) {
+            decode(in[idx] & 0xFF, out);
+            idx++;
+        }
+    }
+
+    public void decode(char[] in, int offset, int len, ByteBuffer out) throws IOException {
+        int idx = offset;
+        while (this.state != STATE_EOF && idx < offset + len) {
+            int ch = in[idx];
+            decode(ch, out);
+            idx++;
+        }
+    }
+
+    void decodeImpl(CharBuffer in, ByteBuffer out) throws IOException {
+        int ch;
+        while (in.hasRemaining() && this.state != STATE_EOF) {
+            ch = in.get();
+            decode(ch, out);
+        }
+    }
+
+    public void decode(CharBuffer in, ByteBuffer out) throws IOException {
+        if (in.hasArray()) {
+            int offset = in.arrayOffset();
+            int length = in.limit()-offset;
+            decode(in.array(), offset, length, out);
+        }
+        else {
+            decodeImpl(in, out);
+        }
+    }
+
+    void decodeImpl(ByteBuffer in, ByteBuffer out) throws IOException {
+        int ch;
+        while (in.hasRemaining() && this.state != STATE_EOF) {
+            ch = in.get();
+            decode(ch, out);
+        }
+    }
+
+    public void decode(ByteBuffer in, ByteBuffer out) throws IOException {
+        if (in.hasArray()) {
+            int offset = in.arrayOffset();
+            int length = in.limit()-offset;
+            decode(in.array(), offset, length, out);
+        }
+        else {
+            decodeImpl(in, out);
+        }
+    }
+
+    public void decode(FileChannel in, ByteBuffer byteBuffer, ByteBuffer out) throws IOException {
+        byteBuffer.rewind();
+        while (-1 != in.read(byteBuffer) && this.state != STATE_EOF) {
+            byteBuffer.flip();
+            decode(byteBuffer, out);
+        }
+    }
+
+    public void decode(File inFile, File outFile, int bufferSize, boolean directIn, boolean directOut) throws IOException {
+        FileChannel in = new FileInputStream(inFile).getChannel();
+        try {
+            FileChannel out = new FileOutputStream(outFile).getChannel();
+            try {
+                ByteBuffer inBuffer  = directIn  ? ByteBuffer.allocateDirect(bufferSize) : ByteBuffer.allocate(bufferSize);
+                ByteBuffer outBuffer = directOut ? ByteBuffer.allocateDirect(bufferSize) : ByteBuffer.allocate(bufferSize);
+                while (-1 != in.read(inBuffer) && this.state != -1) {
+                    inBuffer.flip();
+                    //System.out.println(inBuffer.position() + " " + inBuffer.limit() + " " + outBuffer.position() + " " + outBuffer.limit());
+                    decodeImpl(inBuffer, outBuffer);
+                    inBuffer.clear();
+
+                    outBuffer.flip();
+                    //System.out.println(outBuffer.position() + " " + outBuffer.limit());
+                    out.write(outBuffer);
+                    outBuffer.clear();
+                    //System.out.println(outBuffer.position() + " " + outBuffer.limit());
+                }
+            }
+            finally {
+                out.close();
+            }
+        }
+        finally {
+            in.close();
+        }
+    }
+
+    public void decodeMapped(File inFile, File outFile, int bufferSize, boolean directOut) throws IOException {
+        FileChannel in = new FileInputStream(inFile).getChannel();
+        try {
+            FileChannel out = new FileOutputStream(outFile).getChannel();
+            try {
+                int size = (int)in.size();
+                MappedByteBuffer inBuffer = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
+                ByteBuffer outBuffer = directOut ? ByteBuffer.allocateDirect(bufferSize) : ByteBuffer.allocate(bufferSize);
+                int limit = bufferSize;
+                while (inBuffer.position() < size) {
+                    //System.out.println(inBuffer.position() + " " + inBuffer.limit() + " " + outBuffer.position() + " " + outBuffer.limit());
+                    inBuffer.limit(Math.min(limit, size));
+                    decodeImpl(inBuffer, outBuffer);
+                    outBuffer.flip();
+                    out.write(outBuffer);
+                    outBuffer.clear();
+                    limit += bufferSize;
+                }
+            }
+            finally {
+                out.close();
+            }
+        }
+        finally {
+            in.close();
+        }
+
+    }
+
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64OutputStream.java b/src/main/java/net/jhorstmann/base64/Base64OutputStream.java
new file mode 100644
index 0000000..ad696da
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64OutputStream.java
@@ -0,0 +1,38 @@
+package net.jhorstmann.base64;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class Base64OutputStream extends OutputStream {
+
+    private Base64StreamEncoder encoder;
+    private Appendable out;
+
+    public Base64OutputStream(Base64StreamEncoder encoder, Appendable out) {
+        this.encoder = encoder;
+        this.out = out;
+    }
+
+    public Base64OutputStream(Appendable out) {
+        this(new Base64StreamEncoder(), out);
+    }
+
+    public Base64OutputStream(OutputStream out) {
+        this(new Base64StreamEncoder(), new ByteAppendable(out));
+    }
+
+    @Override
+    public void write(byte[] b) throws IOException {
+        encoder.encode(b, out);
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        encoder.encode(b, off, len, out);
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        encoder.encode(b, out);
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64StreamDecoder.java b/src/main/java/net/jhorstmann/base64/Base64StreamDecoder.java
new file mode 100644
index 0000000..459f341
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64StreamDecoder.java
@@ -0,0 +1,261 @@
+package net.jhorstmann.base64;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Reader;
+
+public class Base64StreamDecoder {
+
+    private static final byte[] codes = new byte[256];
+
+    static {
+        for (int i = 0; i < 256; i++) {
+            codes[i] = -1;
+        }
+        for (int i = 'A'; i <= 'Z'; i++) {
+            codes[i] = (byte)(i - 'A');
+        }
+        for (int i = 'a'; i <= 'z'; i++) {
+            codes[i] = (byte)(26 + i - 'a');
+        }
+        for (int i = '0'; i <= '9'; i++) {
+            codes[i] = (byte)(52 + i - '0');
+        }
+        codes['+'] = 62;
+        codes['/'] = 63;
+    }
+    private static final int STATE_EOF = -1;
+    private static final int STATE_START = 0;
+    private static final int STATE_SECOND = 1;
+    private static final int STATE_THIRD = 2;
+    private static final int STATE_PADDING = 3;
+    private static final int STATE_FOURTH = 4;
+    private int state = 0;
+    private int buf = 0;
+
+    void reset() {
+        this.state = 0;
+        this.buf = 0;
+    }
+
+    private static boolean isSpace(int ch) {
+        return ch == '\r' || ch == '\n' || ch == '\t' || ch == '\f' || ch == ' ';
+    }
+
+    private static int decodeChar(int ch) throws IOException {
+        if (ch < 0 || ch >= codes.length) {
+            throw new InvalidCharacterException(ch);
+        } else {
+            int val = codes[ch];
+            if (val >= 0) {
+                return val;
+            } else {
+                throw new InvalidCharacterException(ch);
+            }
+        }
+    }
+
+    final void decode(final int ch, final OutputStream out) throws IOException {
+        switch (this.state) {
+            case STATE_EOF:
+                break;
+            case STATE_START:
+                if (ch == -1) {
+                    this.state = STATE_EOF;
+                } else if (ch == '=') {
+                    throw new InvalidCharacterException(ch);
+                } else if (!isSpace(ch)) {
+                    this.buf = decodeChar(ch);
+                    this.state = STATE_SECOND;
+                }
+                break;
+            case STATE_SECOND:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    throw new InvalidCharacterException(ch);
+                } else {
+                    int val = decodeChar(ch);
+                    this.buf = (this.buf << 6) | val;
+                    this.state = STATE_THIRD;
+                }
+                break;
+            case STATE_THIRD:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    this.state = STATE_PADDING;
+                } else {
+                    int val = decodeChar(ch);
+                    this.buf = (this.buf << 6) | val;
+                    this.state = STATE_FOURTH;
+                }
+                break;
+            case STATE_PADDING:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    out.write((this.buf >> 4) & 0xFF);
+                    this.state = STATE_START;
+                } else {
+                    throw new InvalidCharacterException(ch);
+                }
+                break;
+            case STATE_FOURTH:
+                if (ch == -1) {
+                    throw new IncompleteStreamException(ch);
+                } else if (ch == '=') {
+                    int tmp = this.buf;
+                    out.write((tmp >> 10) & 0xFF);
+                    out.write((tmp >> 2) & 0xFF);
+                    this.state = STATE_START;
+                } else {
+                    int val = decodeChar(ch);
+                    int tmp = (this.buf << 6) | val;
+                    out.write((tmp >> 16) & 0xFF);
+                    out.write((tmp >> 8) & 0xFF);
+                    out.write((tmp) & 0xFF);
+                    this.state = STATE_START;
+                }
+                break;
+            default:
+                throw new IllegalStateException("Invalid State " + this.state);
+        }
+    }
+
+    public boolean isEOF() {
+        return this.state == STATE_EOF;
+    }
+
+    public boolean isComplete() {
+        return this.state == STATE_START || this.state == STATE_EOF;
+    }
+
+    public void checkComplete() throws IOException {
+        if (!isComplete()) {
+            throw new IncompleteStreamException("Incomplete Base64 Stream");
+        }
+    }
+
+    public void decode(char[] in, int offset, int len, OutputStream out) throws IOException {
+        int idx = offset;
+        while (this.state != STATE_EOF && idx < offset + len) {
+            int ch = in[idx];
+            decode(ch, out);
+            idx++;
+        }
+    }
+
+    public void decode(char[] in, OutputStream out) throws IOException {
+        decode(in, 0, in.length, out);
+        checkComplete();
+    }
+
+    public byte[] decode(char[] in, int offset, int len) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        decode(in, offset, len, out);
+        return out.toByteArray();
+    }
+
+    public byte[] decode(char[] in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        decode(in, out);
+        checkComplete();
+        return out.toByteArray();
+    }
+
+    public void decode(byte[] in, int offset, int len, OutputStream out) throws IOException {
+        int idx = offset;
+        while (idx < offset + len && this.state != STATE_EOF) {
+            decode(in[idx] & 0xFF, out);
+            idx++;
+        }
+    }
+
+    public void decode(byte[] in, OutputStream out) throws IOException {
+        decode(in, 0, in.length, out);
+        checkComplete();
+    }
+
+    public byte[] decode(byte[] bytes) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        decode(bytes, 0, bytes.length, out);
+        checkComplete();
+        return out.toByteArray();
+    }
+
+    public void decode(InputStream in, OutputStream out) throws IOException {
+        int ch;
+        while ((ch = in.read()) != -1 && this.state != STATE_EOF) {
+            decode(ch, out);
+        }
+        checkComplete();
+    }
+
+    public void decode(InputStream in, OutputStream out, int bufferSize) throws IOException {
+        byte[] buffer = new byte[bufferSize];
+        int len;
+        while ((len = in.read(buffer)) != -1) {
+            decode(buffer, 0, len, out);
+        }
+        checkComplete();
+    }
+
+    public void decode(Reader in, OutputStream out) throws IOException {
+        int ch;
+        while ((ch = in.read()) != -1 && this.state != STATE_EOF) {
+            decode(ch, out);
+        }
+        checkComplete();
+    }
+
+    public void decode(Reader in, OutputStream out, int bufferSize) throws IOException {
+        char[] buffer = new char[bufferSize];
+        int len;
+        while ((len = in.read(buffer)) != -1) {
+            decode(buffer, 0, len, out);
+        }
+        checkComplete();
+    }
+
+    public void decode(CharSequence str, OutputStream out) throws IOException {
+        int len = str.length();
+        int idx = 0;
+        while (idx < len && this.state != STATE_EOF) {
+            decode(str.charAt(idx), out);
+            idx++;
+        }
+        checkComplete();
+    }
+
+    public byte[] decode(CharSequence str) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        decode(str, out);
+        return out.toByteArray();
+    }
+
+    public void decode(File inFile, File outFile) throws IOException {
+        decode(inFile, outFile, 32 * 1024);
+    }
+
+    public void decode(File inFile, File outFile, int bufferSize) throws IOException {
+        InputStream in = new BufferedInputStream(new FileInputStream(inFile), bufferSize);
+        try {
+            OutputStream out = new BufferedOutputStream(new FileOutputStream(outFile), bufferSize);
+            try {
+                decode(in, out, bufferSize);
+            } finally {
+                out.close();
+            }
+        } finally {
+            in.close();
+        }
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/Base64StreamEncoder.java b/src/main/java/net/jhorstmann/base64/Base64StreamEncoder.java
new file mode 100644
index 0000000..245b4e1
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/Base64StreamEncoder.java
@@ -0,0 +1,191 @@
+package net.jhorstmann.base64;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+public class Base64StreamEncoder {
+    private static final char[] alphabet =
+            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();
+    private static final int DEFAULT_LINE_WIDTH = 76;
+    private static final char DEFAULT_LINE_SEPARATOR = '\n';
+
+    private static final int STATE_EOF   = -1;
+    private static final int STATE_START = 0;
+
+    private int state;
+    private int buffer;
+    private int lineIdx;
+    private int lineWidth = DEFAULT_LINE_WIDTH;
+    private char lineSeparator = DEFAULT_LINE_SEPARATOR;
+
+    void reset() {
+        this.state = 0;
+        this.buffer = 0;
+        this.lineIdx = 0;
+    }
+
+    final void encode(final int ch, final Appendable out) throws IOException {
+        //System.out.println(this.state + " " + ch + " " + this.buffer);
+        switch (this.state) {
+            case STATE_EOF:
+                break;
+            case STATE_START:
+                if (ch == -1) {
+                    this.state = STATE_EOF;
+                }
+                else {
+                    if (this.lineIdx >= this.lineWidth) {
+                        out.append(this.lineSeparator);
+                        this.lineIdx = 0;
+                    }
+                    out.append(alphabet[(ch >>> 2)]);
+                    this.lineIdx++;
+                    this.buffer = (ch & 3) << 4;
+                    this.state = 1;
+                }
+                break;
+            case 1:
+                if (ch == -1) {
+                    out.append(alphabet[this.buffer]);
+                    out.append('=');
+                    out.append('=');
+                    this.lineIdx += 3;
+                    this.state = STATE_EOF;
+                }
+                else {
+                    out.append(alphabet[this.buffer | (ch >>> 4)]);
+                    this.lineIdx++;
+                    this.buffer = (ch & 15) << 2;
+                    this.state = 2;
+                }
+                break;
+            case 2:
+                if (ch == -1) {
+                    out.append(alphabet[this.buffer]);
+                    out.append('=');
+                    this.lineIdx += 2;
+                    this.state = STATE_EOF;
+                }
+                else {
+                    out.append(alphabet[this.buffer | (ch >>> 6)]);
+                    out.append(alphabet[ch & 63]);
+                    this.lineIdx += 2;
+                    this.state = STATE_START;
+                }
+                break;
+            default:
+                throw new IllegalStateException("Invalid State " + this.state);
+
+        }
+    }
+
+    private int expectedLength(int length) {
+        int tmp = (length+3)*4/3; // round up
+        return tmp + tmp/lineWidth + 2; // add newlines and padding
+    }
+
+    public boolean isComplete() {
+        return this.state == STATE_START || this.state == STATE_EOF;
+    }
+
+    public void encodeFinal(Appendable out) throws IOException {
+        if (this.state != STATE_EOF) {
+            encode(-1, out);
+        }
+    }
+
+    public void encode(InputStream in, Appendable out) throws IOException {
+        int ch;
+        while ((ch = in.read()) != -1 && this.state != STATE_EOF) {
+            encode(ch, out);
+        }
+        encodeFinal(out);
+    }
+
+    public void encode(InputStream in, Appendable out, int bufferSize) throws IOException {
+        byte[] tmp = new byte[bufferSize];
+        int len;
+        while (-1 != (len = in.read(tmp)) && this.state != STATE_EOF) {
+            encode(tmp, 0, len, out);
+        }
+        encodeFinal(out);
+    }
+
+    public void encode(CharSequence str, int offset, int length, Appendable out) throws IOException {
+        int idx = offset;
+        while (this.state != STATE_EOF && idx < offset + length) {
+            int ch = str.charAt(idx);
+            encode(ch, out);
+            idx++;
+        }
+    }
+
+    public void encode(CharSequence str, Appendable out) throws IOException {
+        encode(str, 0, str.length(), out);
+        encodeFinal(out);
+    }
+
+    public String encode(String str) throws IOException {
+        FixedSizeStringBuilder out = new FixedSizeStringBuilder(expectedLength(str.length()));
+        encode(str, out);
+        return out.toString();
+    }
+
+    public String encode(byte[] in) throws IOException {
+        FixedSizeStringBuilder out = new FixedSizeStringBuilder(expectedLength(in.length));
+        encode(in, out);
+        return out.toString();
+    }
+
+    public void encode(byte[] in, Appendable out) throws IOException {
+        encode(in, 0, in.length, out);
+        encodeFinal(out);
+    }
+
+    public void encode(byte[] in, int offset, int length, Appendable out) throws IOException {
+        int idx = offset;
+        while (this.state != STATE_EOF && idx < offset + length) {
+            encode(in[idx] & 0xFF, out);
+            idx++;
+        }
+    }
+
+    void encodeByteBuffer(ByteBuffer in, Appendable out) throws IOException {
+        while (this.state != STATE_EOF && in.hasRemaining()) {
+            encode(in.get() & 0xFF, out);
+        }
+    }
+
+    public void encode(ByteBuffer in, Appendable out) throws IOException {
+        if (in.hasArray()) {
+            int offset = in.arrayOffset();
+            int length = in.limit()-offset;
+            encode(in.array(), offset, length, out);
+        }
+        else {
+            encodeByteBuffer(in, out);
+        }
+    }
+
+    public void encode(File inFile, File outFile) throws IOException {
+        int inBufferSize = 24*1024;
+        int outBufferSize = inBufferSize/6*8;
+        InputStream in = new BufferedInputStream(new FileInputStream(inFile), inBufferSize);
+        try {
+            BufferedByteAppendable out = new BufferedByteAppendable(new FileOutputStream(outFile), outBufferSize);
+            try {
+                encode(in, out, inBufferSize);
+            } finally {
+                out.close();
+            }
+        } finally {
+            in.close();
+        }
+        
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/BufferedByteAppendable.java b/src/main/java/net/jhorstmann/base64/BufferedByteAppendable.java
new file mode 100644
index 0000000..ff3e2ed
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/BufferedByteAppendable.java
@@ -0,0 +1,61 @@
+package net.jhorstmann.base64;
+
+import java.io.Closeable;
+import java.io.Flushable;
+import java.io.IOException;
+import java.io.OutputStream;
+
+public class BufferedByteAppendable implements Appendable, Closeable, Flushable {
+    private OutputStream out;
+    private byte[] buffer;
+    private int index;
+
+    BufferedByteAppendable(OutputStream out, int bufferSize) {
+        this.out = out;
+        this.buffer = new byte[bufferSize];
+        this.index = 0;
+    }
+
+    private void flushImpl() throws IOException {
+        out.write(buffer, 0, index);
+        index = 0;
+    }
+
+    private void appendImpl(char c) throws IOException {
+        if (c > 255) {
+            throw new IllegalArgumentException("Invalid character " + (int)c);
+        }
+        buffer[index++] = (byte) c;
+        if (index >= buffer.length) {
+            flushImpl();
+        }
+    }
+
+    public Appendable append(CharSequence csq) throws IOException {
+        for (int i=0, len=csq.length(); i<len; i++) {
+            appendImpl(csq.charAt(i));
+        }
+        return this;
+    }
+
+    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+        for (int i=start; i<end; i++) {
+            appendImpl(csq.charAt(i));
+        }
+        return this;
+    }
+
+    public Appendable append(char c) throws IOException {
+        appendImpl(c);
+        return this;
+    }
+
+    public void flush() throws IOException {
+        flushImpl();
+    }
+
+    public void close() throws IOException {
+        flushImpl();
+        out.close();
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/ByteAppendable.java b/src/main/java/net/jhorstmann/base64/ByteAppendable.java
new file mode 100644
index 0000000..8ecd570
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/ByteAppendable.java
@@ -0,0 +1,44 @@
+package net.jhorstmann.base64;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.OutputStream;
+
+final class ByteAppendable implements Appendable, Closeable {
+
+    private OutputStream out;
+
+    ByteAppendable(OutputStream out) {
+        this.out = out;
+    }
+
+    private void appendImpl(char c) throws IOException {
+        if (c > 255) {
+            throw new IllegalArgumentException("Invalid character " + (int)c);
+        }
+        out.write(c);
+    }
+
+    public Appendable append(CharSequence csq) throws IOException {
+        for (int i=0, len=csq.length(); i<len; i++) {
+            appendImpl(csq.charAt(i));
+        }
+        return this;
+    }
+
+    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+        for (int i=start; i<end; i++) {
+            appendImpl(csq.charAt(i));
+        }
+        return this;
+    }
+
+    public Appendable append(char c) throws IOException {
+        appendImpl(c);
+        return this;
+    }
+
+    public void close() throws IOException {
+        out.close();
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/FixedSizeStringBuilder.java b/src/main/java/net/jhorstmann/base64/FixedSizeStringBuilder.java
new file mode 100644
index 0000000..dfb154d
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/FixedSizeStringBuilder.java
@@ -0,0 +1,44 @@
+package net.jhorstmann.base64;
+
+import java.io.IOException;
+
+final class FixedSizeStringBuilder implements Appendable {
+
+    private char[] array;
+    private int index;
+
+    FixedSizeStringBuilder(int length) {
+        array = new char[length];
+    }
+
+    private void appendImpl(char c) {
+        if (index >= array.length) {
+            throw new IllegalStateException("Capacity (" + array.length + ") exceeded");
+        }
+        array[index++] = c;
+    }
+
+    public Appendable append(CharSequence csq) throws IOException {
+        for (int i=0, len=csq.length(); i<len; i++) {
+            appendImpl(csq.charAt(i));
+        }
+        return this;
+    }
+
+    public Appendable append(CharSequence csq, int start, int end) throws IOException {
+        for (int i=start; i<end; i++) {
+            appendImpl(csq.charAt(i));
+        }
+        return this;
+    }
+
+    public Appendable append(char c) throws IOException {
+        appendImpl(c);
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return new String(array, 0, index);
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/IncompleteStreamException.java b/src/main/java/net/jhorstmann/base64/IncompleteStreamException.java
new file mode 100644
index 0000000..31c95dc
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/IncompleteStreamException.java
@@ -0,0 +1,12 @@
+package net.jhorstmann.base64;
+
+public class IncompleteStreamException extends Base64Exception {
+
+    public IncompleteStreamException(String msg) {
+        super(msg);
+    }
+
+    public IncompleteStreamException(int ch) {
+        super("Incomplete Base64 Stream: " + characterName(ch));
+    }
+}
diff --git a/src/main/java/net/jhorstmann/base64/InvalidCharacterException.java b/src/main/java/net/jhorstmann/base64/InvalidCharacterException.java
new file mode 100644
index 0000000..c08e2f8
--- /dev/null
+++ b/src/main/java/net/jhorstmann/base64/InvalidCharacterException.java
@@ -0,0 +1,12 @@
+package net.jhorstmann.base64;
+
+public class InvalidCharacterException extends Base64Exception {
+
+    public InvalidCharacterException(String msg) {
+        super(msg);
+    }
+
+    public InvalidCharacterException(int ch) {
+        super("Invalid Character: " + characterName(ch));
+    }
+}
diff --git a/src/main/java/se/nowise/codecs/base64/Base64Application.java b/src/main/java/se/nowise/codecs/base64/Base64Application.java
new file mode 100644
index 0000000..c83ff0a
--- /dev/null
+++ b/src/main/java/se/nowise/codecs/base64/Base64Application.java
@@ -0,0 +1,211 @@
+/*
+ * Web service library for the Batchelor batch job queue.
+ * Copyright (C) 2009 by Anders L√∂vgren and the Computing Department at BMC,
+ * Uppsala University.
+ * 
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ * Send questions, suggestions, bugs or comments to: 
+ * Anders L√∂vgren (andlov@nowise.se)
+ * 
+ * For more info: https://github.com/nowisesys/base64code/
+ */
+
+/*
+ * Base64Application.java
+ *
+ * Created: May 3, 2009, 11:07:14 PM
+ * Author:  Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+package se.nowise.codecs.base64;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+/**
+ * Sample main class that utilize the Base64Encode/Base64Decode classes to
+ * provide an Base 64 encoding/decoding application.
+ *
+ * @author Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+public class Base64Application {
+
+    enum OptionArg {
+
+        NONE, INPUT, OUTPUT, STRING
+    }
+
+    class OptionException extends Exception {
+
+        OptionException(String msg) {
+            super(msg);
+        }
+    }
+
+    class Options {
+
+        private String input;
+        private String output;
+        private String string;
+        private OptionArg optarg = OptionArg.NONE;
+        private boolean decode;
+        private boolean encode;
+        private String[] args;
+
+        Options(String[] args) {
+            this.args = args;
+        }
+
+        public boolean decode() {
+            return decode;
+        }
+
+        public InputStream getInputStream() throws FileNotFoundException {
+            if (input != null) {
+                return new FileInputStream(input);
+            } else {
+                return new ByteArrayInputStream(string.getBytes());
+            }
+        }
+
+        public OutputStream getOutputStream() throws FileNotFoundException {
+            if (output != null) {
+                return new FileOutputStream(output);
+            } else {
+                return System.out;
+            }
+        }
+
+        public boolean parseOptions() throws OptionException {
+            for (String arg : args) {
+                if (arg.compareTo("-h") == 0 ||
+                    arg.compareTo("--help") == 0) {
+                    return false;
+                } else if (arg.compareTo("-d") == 0 ||
+                    arg.compareTo("--decode") == 0) {
+                    decode = true;
+                } else if (arg.compareTo("-e") == 0 ||
+                    arg.compareTo("--encode") == 0) {
+                    encode = true;
+                } else if (arg.compareTo("-i") == 0) {
+                    optarg = OptionArg.INPUT;
+                } else if (arg.compareTo("-o") == 0) {
+                    optarg = OptionArg.OUTPUT;
+                } else if (arg.compareTo("-s") == 0) {
+                    optarg = OptionArg.STRING;
+                } else if (optarg != OptionArg.NONE) {
+                    switch (optarg) {
+                        case INPUT:
+                            input = arg;
+                            break;
+                        case OUTPUT:
+                            output = arg;
+                            break;
+                        case STRING:
+                            string = arg;
+                            break;
+                    }
+                    optarg = OptionArg.NONE;
+                } else {
+                    throw new OptionException("Unknown option '" + arg);
+                }
+            }
+            return true;
+        }
+
+        public void checkOptions() throws OptionException {
+            if (!decode && !encode) {
+                throw new OptionException("Neither decode (-d) nor encode (-e) mode selected");
+            }
+            if (decode && encode) {
+                throw new OptionException("Both encode (-e) and decode (-d) mode can't be active at same time");
+            }
+            if (input != null && string != null) {
+                throw new OptionException("Both input file (-i) and string (-s) can't be used at same time");
+            }
+            if (input == null && string == null) {
+                throw new OptionException("Neither input file (-i) or string (-s) specified");
+            }
+        }
+
+        public void showUsage() {
+            System.out.println("Base64Application - Encode/decode Base64 strings");
+            System.out.println("Usage: Base64Application [-d|-e] [-i file|-s string] [-o file]");
+            System.out.println("Options:");
+            System.out.println("  -d,--decode: Decode input");
+            System.out.println("  -e,--encode: Encode input");
+            System.out.println("  -i file:     Read input from file");
+            System.out.println("  -o file:     Write output to file");
+            System.out.println("  -s string:   Encode/decode string");
+            System.out.println("  -h,--help:   Show this help");
+            System.out.println("Copyright (C) 2009 Anders L√∂vgren");
+        }
+    }
+
+    Base64Application(String[] args) {
+        Options options = new Options(args);
+        try {
+            if (!options.parseOptions()) {
+                options.showUsage();
+                System.exit(0);
+            }
+            options.checkOptions();
+        } catch (OptionException e) {
+            System.err.print(e);
+        }
+
+        try {
+            InputStream input = options.getInputStream();
+            OutputStream output = options.getOutputStream();
+
+            if (options.decode()) {
+                Base64Decoder decoder = new Base64Decoder();
+                try {
+                    byte[] result = decoder.decode(input);
+                    while (result != null) {
+                        output.write(result);
+                        result = decoder.decode(input);
+                    }
+                } catch (IOException e) {
+                    System.err.print(e);
+                }
+            } else {
+                Base64Encoder encoder = new Base64Encoder();
+                try {
+                    byte[] result = encoder.encode(input);
+                    while (result != null) {
+                        output.write(result);
+                        result = encoder.encode(input);
+                    }
+                } catch (IOException e) {
+                    System.err.print(e);
+                }
+            }
+        } catch (FileNotFoundException e) {
+            System.err.print(e);
+        }
+    }
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) {
+        Base64Application app = new Base64Application(args);
+    }
+}
diff --git a/src/main/java/se/nowise/codecs/base64/Base64Decoder.java b/src/main/java/se/nowise/codecs/base64/Base64Decoder.java
new file mode 100644
index 0000000..e12f569
--- /dev/null
+++ b/src/main/java/se/nowise/codecs/base64/Base64Decoder.java
@@ -0,0 +1,281 @@
+/*
+ * Web service library for the Batchelor batch job queue.
+ * Copyright (C) 2009 by Anders L√∂vgren and the Computing Department at BMC,
+ * Uppsala University.
+ * 
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ * Send questions, suggestions, bugs or comments to: 
+ * Anders L√∂vgren (andlov@nowise.se)
+ * 
+ * For more info: https://github.com/nowisesys/base64code/
+ */
+
+/*
+ * Base64Decoder.java
+ *
+ * Created: Apr 27, 2009, 11:52:27 PM
+ * Author:  Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+package se.nowise.codecs.base64;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * <p>This class provides Base64 decoding of data. Basically, it has two modes 
+ * of operations:</p>
+ *
+ * <ol><li>Decoding of input streams.</li>
+ *     <li>Decoding of strings and byte/char arrays.</li>
+ * </ol>
+ *
+ * <p>Decoding an input stream is an iterative process where decode() gets called in
+ * a loop until null is returned (EOF). Strings and byte/char arrays are normally
+ * decoded by a single step by calling decode(), but chunked mode can be emulated
+ * for i.e. byte arrays by creating a ByteArrayInputStream object and using it
+ * as stream argument to decode().</p>
+ *
+ * <p>The default number of bytes to decode is BUFFER_SIZE, but can be changed
+ * dynamic before or in between calls to decode().</p>
+ *
+ * <p>This implementation is based on information from <a href="http://en.wikipedia.org/wiki/Base64">http://en.wikipedia.org/wiki/Base64</a>
+ * and RFC 2045 (section 6.8). It has been verified against other Base64
+ * implementations like the base64(1) command from the GNU coreutils package.</p>
+ * 
+ * @author Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+public class Base64Decoder {
+
+    private byte[] result;   // Output buffer.
+    private byte[] buffer;   // Input buffer.
+    private final static int[] VALID = {0, 1, 1, 2, 4};  // Valid bytes map.
+    private final static byte[] LOOKUP;                  // Lookup table.
+    private final static int[] MASK = {0xff0000, 0x00ff00, 0x0000ff};
+    /**
+     * Default buffer size.
+     */
+    public final static int BUFFER_SIZE = 512;
+    private int bufferSize;
+
+
+    static {
+        //
+        // Initilize the ASCII to Base64 index lookup table:
+        //
+        LOOKUP = new byte[255];
+        for (int i = 0; i < 26; ++i) {
+            LOOKUP[i + 65] = (byte) (i);        // 'A' - 'Z'
+        }
+        for (int i = 0; i < 26; ++i) {
+            LOOKUP[i + 97] = (byte) (i + 26);   // 'a' - 'z'
+        }
+        for (int i = 0; i < 10; ++i) {
+            LOOKUP[i + 48] = (byte) (i + 52);   // '0' - '9'
+        }
+        LOOKUP[43] = (byte) 62;                 // '+'
+        LOOKUP[47] = (byte) 63;                 // '/'
+    }
+
+    /**
+     * Creates a decoder object suitable for decoding strings and byte or
+     * char arrays.
+     */
+    public Base64Decoder() {
+        bufferSize = BUFFER_SIZE;
+    }
+
+    /**
+     * Creates a decoder object suitable for decoding InputStreams.
+     * @param size The number of bytes to decode per decode call.
+     */
+    public Base64Decoder(int size) {
+        bufferSize = size;
+    }
+
+    /**
+     * Set the number of bytes to decode. Calling this function has no effect
+     * unless the input source is a stream, for strings or char/byte arrays
+     * the size is instead determined from the input.
+     * @param size The number of bytes to encode.
+     */
+    public void setSize(int size) {
+        bufferSize = size;
+    }
+
+    /**
+     * Get the number of bytes that will be decoded by next call of decode().
+     * This function will also return the number of bytes decoded from last
+     * call of decode().
+     * @return Number of bytes to decode.
+     */
+    public int getSize() {
+        return bufferSize;
+    }
+
+    /**
+     * Get the number of bytes required to hold the result of decoding size
+     * number of bytes from the input source.
+     * @param size The number of bytes to decode.
+     * @return The number of bytes required for the result buffer.
+     */
+    private int getResultSize(int size) {
+        int aligned = (3 * (size / 4));
+        if (buffer[size - 2] == '=') {
+            --aligned;
+        }
+        if (buffer[size - 1] == '=') {
+            --aligned;
+        }
+        return aligned;
+    }
+
+    /**
+     * Creates the result buffer.
+     * @param size The number of bytes to decode.
+     */
+    private void prepare(int size) {
+        bufferSize = size;
+        int aligned = getResultSize(size);
+        if (result == null || aligned != result.length) {
+            result = new byte[aligned];
+        }
+    }
+
+    /**
+     * Decodes the whole string.
+     * @param string The string to encode.
+     * @return The encoded result.
+     */
+    public byte[] decode(String string) {
+        buffer = string.getBytes();
+        prepare(buffer.length);
+        return decode(true);
+    }
+
+    /**
+     * Decode the input stream using current input buffer. Call setSize() prior
+     * to calling this function to resize the input buffer. The number of bytes
+     * to decode is the same as returned by getSize(), that is BUFFER_SIZE by
+     * default.
+     * @param stream The input stream.
+     * @return The encoded result or null on EOF (end of file).
+     * @throws java.io.IOException
+     */
+    public byte[] decode(InputStream stream) throws IOException {
+        return decode(stream, bufferSize);
+    }
+
+    /**
+     * Decode the input stream in block of size number of bytes. The actual
+     * number of bytes decoded might be smaller if EOF is detected or larger
+     * if size is not an multiple of 4 (adjusted internal).
+     *
+     * @param stream The input stream.
+     * @param size The number of bytes to decode.
+     * @return The decoded result or null on EOF (end of file).
+     * @throws java.io.IOException
+     */
+    public byte[] decode(InputStream stream, int size) throws IOException {
+        //
+        // Make sure size is an multiple of 4.
+        //
+        while (size % 4 != 0) {
+            ++size;
+        }
+        if (buffer == null) {
+            buffer = new byte[size];
+        } else if (buffer.length != size) {
+            buffer = new byte[size];
+        }
+
+        int read;
+        while (size > 0) {
+            read = stream.read(buffer, buffer.length - size, size);
+            if (read == -1) {
+                break;
+            }
+            size -= read;
+        }
+        if (size == buffer.length) {
+            return null;  // Nothing read.
+        }
+        if (size > 0) {
+            bufferSize = buffer.length - size;
+            for (int i = buffer.length - size; i < buffer.length; ++i) {
+                buffer[i] = -1;
+            }
+        }
+        prepare(buffer.length - size);
+        return decode(false);
+    }
+
+    /**
+     * Decode the byte array.
+     * @param input The byte array to decode.
+     * @return The decoded result.
+     */
+    public byte[] decode(byte[] input) {
+        buffer = input;
+        prepare(buffer.length);
+        return decode(true);
+    }
+
+    /**
+     * Decode the char array.
+     * @param input The char array to decode.
+     * @return The decoded result.
+     */
+    public byte[] decode(char[] input) {
+        buffer = (new String(input)).getBytes();
+        prepare(buffer.length);
+        return decode(true);
+    }
+
+    /**
+     * Decodes the current buffer content.
+     * @param single Denotes whether the buffer is internal allocated or not (uses external buffer in single call mode).
+     * @return The decoded result.
+     */
+    private byte[] decode(boolean single) {
+        for (int i = 0; i < buffer.length / 4; ++i) {
+            int ch = 0, len = 0;
+            for (int j = 0; j < 4; ++j) {
+                int index = 4 * i + j;
+                int shift = 18 - j * 6;
+                if (buffer[index] != -1 && buffer[index] != '=') {
+                    ch |= LOOKUP[buffer[index]] << shift;
+                } else {
+                    break;
+                }
+                ++len;
+            }
+            int split = VALID[len];
+            for (int j = 0; j < 3; ++j) {
+                int index = 3 * i + j;
+                int shift = 16 - j * 8;
+                if (index >= result.length) {
+                    break;
+                }
+                if (j < split) {
+                    result[index] = (byte) ((ch & MASK[j]) >> shift);
+                }
+            }
+        }
+        if (single) {
+            buffer = null;
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/se/nowise/codecs/base64/Base64Encoder.java b/src/main/java/se/nowise/codecs/base64/Base64Encoder.java
new file mode 100644
index 0000000..98b788f
--- /dev/null
+++ b/src/main/java/se/nowise/codecs/base64/Base64Encoder.java
@@ -0,0 +1,261 @@
+/*
+ * Web service library for the Batchelor batch job queue.
+ * Copyright (C) 2009 by Anders L√∂vgren and the Computing Department at BMC,
+ * Uppsala University.
+ * 
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * 
+ * Send questions, suggestions, bugs or comments to: 
+ * Anders L√∂vgren (andlov@nowise.se)
+ * 
+ * For more info: https://github.com/nowisesys/base64code/
+ */
+
+/*
+ * Base64Encoder.java
+ *
+ * Created: Apr 27, 2009, 11:51:12 PM
+ * Author:  Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+package se.nowise.codecs.base64;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * <p>This class provides Base64 encoding of data. Basically, it has two modes
+ * of operations:</p>
+ *
+ * <ol><li>Encoding of input streams.</li>
+ *     <li>Encoding of strings and byte/char arrays.</li>
+ * </ol>
+ *
+ * <p>Encoding an input stream is an iterative process where encode() gets called in
+ * a loop until null is returned (EOF). Strings and byte/char arrays are normally
+ * encoded by a single call to encode(), but chunked mode can be emulated 
+ * i.e. for byte arrays by creating an ByteArrayInputStream object and calling
+ * encode(InputStream), using the byte array input stream.</p>
+ *
+ * <p>The default number of bytes to encode is BUFFER_SIZE, but can be changed
+ * dynamic before or in between calls to encode().</p>
+ * 
+ * <p>This implementation is based on information from <a href="http://en.wikipedia.org/wiki/Base64">http://en.wikipedia.org/wiki/Base64</a>
+ * and RFC 2045 (section 6.8). It has verified against other Base64 implementations
+ * like the base64(1) command from the GNU coreutils package.</p>
+ *
+ * @author Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+public final class Base64Encoder {
+
+    private byte[] result;   // Output buffer.
+    private byte[] buffer;   // Input buffer.
+    private final static int[] VALID = {0, 2, 3, 4, 4};  // Valid bytes map.
+    private final static byte[] LOOKUP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".getBytes();
+    private final static int[] MASK = {0xfc0000, 0x03f000, 0x000fc0, 0x00003f};
+    /**
+     * Default buffer size.
+     */
+    public final static int BUFFER_SIZE = 512;
+    private int bufferSize;
+
+    /**
+     * Creates a encoder object suitable for encoding strings and char or byte
+     * arrays.
+     */
+    public Base64Encoder() {
+        bufferSize = BUFFER_SIZE;
+    }
+
+    /**
+     * Creates a encoder object suitable for encoding InputStreams. The size
+     * argument is the number of bytes to encode from the input stream in each
+     * call to encode.
+     * @param size The number of bytes to encode.
+     */
+    public Base64Encoder(int size) {
+        bufferSize = size;
+    }
+
+    /**
+     * Set the number of bytes to encode. Calling this function has no effect
+     * unless the input source is a stream, for strings or char/byte arrays
+     * the size is instead determined from the input.
+     * @param size The number of bytes to encode.
+     */
+    public void setSize(int size) {
+        bufferSize = size;
+    }
+
+    /**
+     * Get the number of bytes that will be encoded by next call of encode().
+     * This function will also return the number of bytes encoded from last
+     * call of encode().
+     * @return Number of bytes to encode.
+     */
+    public int getSize() {
+        return bufferSize;
+    }
+
+    /**
+     * Get the number of bytes required to hold the result of encoding size
+     * number of bytes from the input source.
+     * @param size The number of bytes to encode.
+     * @return The aligned number of bytes.
+     */
+    private int getResultSize(int size) {
+        int aligned = (4 * (size / 3));
+        if (size % 3 != 0) {
+            aligned += 4;
+        }
+        return aligned;
+    }
+
+    /**
+     * Creates an suitable sized result buffer for encoding the size number
+     * of bytes.
+     * @param size The number of input bytes.
+     */
+    private void prepare(int size) {
+        bufferSize = size;
+        int aligned = getResultSize(size);
+        if (result == null || aligned != result.length) {
+            result = new byte[aligned];
+        }
+    }
+
+    /**
+     * Encodes the whole string.
+     * @param string The string to encode.
+     * @return The encoded result.
+     */
+    public byte[] encode(String string) {
+        buffer = string.getBytes();
+        prepare(buffer.length);
+        return encode(true);
+    }
+
+    /**
+     * Encode the input stream using current input buffer. Call setSize() prior
+     * to calling this function to resize the input buffer. The number of bytes
+     * to decode is the same as returned by getSize(), that is BUFFER_SIZE by
+     * default.
+     * @param stream The input stream.
+     * @return The encoded result or null on EOF (end of file).
+     * @throws java.io.IOException
+     */
+    public byte[] encode(InputStream stream) throws IOException {
+        return encode(stream, bufferSize);
+    }
+
+    /**
+     * Encode the input stream in block of size number of bytes. The actual
+     * number of bytes encoded might be smaller if EOF is detected or larger
+     * if size is not an multiple of 3 (adjusted internal).
+     *
+     * @param stream The input stream.
+     * @param size The number of bytes to encode.
+     * @return The encoded result or null on EOF (end of file).
+     * @throws java.io.IOException
+     */
+    public byte[] encode(InputStream stream, int size) throws IOException {
+        //
+        // Make sure size is an multiple of 3 to prevent trailing '=' unless
+        // EOF is detected on input stream. 
+        //
+        while(size % 3 != 0) {
+            ++size;
+        }
+        if (buffer == null) {
+            buffer = new byte[size];
+        } else if (buffer.length != size) {
+            buffer = new byte[size];
+        }
+
+        int read;
+        while (size > 0) {
+            read = stream.read(buffer, buffer.length - size, size);
+            if (read == -1) {
+                break;
+            }
+            size -= read;
+        }
+        if (size == buffer.length) {
+            return null;  // Nothing read.
+        }
+        if (size > 0) {
+            for (int i = buffer.length - size; i < buffer.length; ++i) {
+                buffer[i] = -1;
+            }
+        }
+        prepare(buffer.length - size);
+        return encode(false);
+    }
+
+    /**
+     * Encode the byte array.
+     * @param input The byte array to encode.
+     * @return The encoded result.
+     */
+    public byte[] encode(byte[] input) {
+        buffer = input;
+        prepare(buffer.length);
+        return encode(true);
+    }
+
+    /**
+     * Encode the char array.
+     * @param input The char array to encode.
+     * @return The encoded result.
+     */
+    public byte[] encode(char[] input) {
+        buffer = (new String(input)).getBytes();
+        prepare(buffer.length);
+        return encode(true);
+    }
+
+    /**
+     * Encodes the current buffer content.
+     * @param single Denotes whether the buffer is internal allocated or not (uses external buffer in single call mode).
+     * @return The encoded result.
+     */
+    private byte[] encode(boolean single) {
+        for (int i = 0; i < result.length / 4; ++i) {
+            int ch = 0, len = 0;
+            for (int j = 0; j < 3; ++j) {
+                int index = i * 3 + j;
+                int shift = 16 - 8 * j;
+                if (index < buffer.length && buffer[index] != -1) {
+                    ch |= buffer[i * 3 + j] << shift;
+                } else {
+                    break;
+                }
+                ++len;
+            }
+            int split = VALID[len];
+            for (int j = 0; j < 4; ++j) {
+                int index = i * 4 + j;
+                int shift = 18 - j * 6;
+                if (j < split) {
+                    result[index] = LOOKUP[(ch & MASK[j]) >> shift];
+                } else {
+                    result[index] = '=';
+                }
+            }
+        }
+        if (single) {
+            buffer = null;
+        }
+        return result;
+    }
+}
diff --git a/src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider b/src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider
new file mode 100644
index 0000000..a3aab85
--- /dev/null
+++ b/src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider
@@ -0,0 +1 @@
+net.jhorstmann.base64.Base64CharsetProvider
\ No newline at end of file
diff --git a/src/test/java/dk/xpreuss/xperimentering/basex/coders/EncodingTest.java b/src/test/java/dk/xpreuss/xperimentering/basex/coders/EncodingTest.java
new file mode 100644
index 0000000..7e84218
--- /dev/null
+++ b/src/test/java/dk/xpreuss/xperimentering/basex/coders/EncodingTest.java
@@ -0,0 +1,10 @@
+package dk.xpreuss.xperimentering.basex.coders;
+
+import org.junit.jupiter.api.Test;
+
+public class EncodingTest {
+	@Test
+	void testStringEncode() {
+
+	}
+}
diff --git a/src/test/java/net/jhorstmann/base64/Base64Encoder.java b/src/test/java/net/jhorstmann/base64/Base64Encoder.java
new file mode 100644
index 0000000..68f535e
--- /dev/null
+++ b/src/test/java/net/jhorstmann/base64/Base64Encoder.java
@@ -0,0 +1,73 @@
+package net.jhorstmann.base64;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+
+public class Base64Encoder {
+
+    static final char[] alphabet =
+            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();
+
+
+    private static final int readAndEncode(InputStream in, Writer out) throws IOException {
+        int ch1 = in.read();
+        if (ch1 == -1) {
+            return 0;
+        } else {
+            out.write(alphabet[(ch1 >> 2)]);
+            int ch2 = in.read();
+            if (ch2 == -1) {
+                out.write(alphabet[(ch1 & 3) << 4]);
+                out.write('=');
+                out.write('=');
+                return 1;
+            } else {
+                out.write(alphabet[((ch1 & 3) << 4) | (ch2 >> 4)]);
+
+                int ch3 = in.read();
+                if (ch3 == -1) {
+                    out.write(alphabet[((ch2 & 15) << 2)]);
+                    out.write('=');
+                    return 2;
+                } else {
+                    out.write(alphabet[((ch2 & 15) << 2) | (ch3 >> 6)]);
+                    out.write(alphabet[(ch3 & 63)]);
+                    return 3;
+                }
+            }
+        }
+    }
+
+    public static final void encode(InputStream in, Writer out) throws IOException {
+        encode(in, out, 76);
+    }
+
+    public static final void encode(InputStream in, Writer out, int lineLength) throws IOException {
+        for (int i = 0; readAndEncode(in, out) != 0; i += 4) {
+            if (i >= lineLength) {
+                i = 0;
+                out.write('\n');
+            }
+        }
+    }
+
+    public static final void encode(InputStream in, OutputStream out) throws IOException {
+        encode(in, new OutputStreamWriter(out, "US-ASCII"));
+    }
+
+    public static String encode(byte[] bytes) throws IOException {
+        ByteArrayInputStream in = new ByteArrayInputStream(bytes);
+        StringWriter out = new StringWriter();
+        encode(in, out);
+        return out.toString();
+    }
+
+    public static String encode(String str) throws IOException {
+        return encode(str.getBytes("US-ASCII"));
+    }
+}
diff --git a/src/test/java/net/jhorstmann/base64/Base64InputStreamTest.java b/src/test/java/net/jhorstmann/base64/Base64InputStreamTest.java
new file mode 100644
index 0000000..6087da5
--- /dev/null
+++ b/src/test/java/net/jhorstmann/base64/Base64InputStreamTest.java
@@ -0,0 +1,92 @@
+package net.jhorstmann.base64;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringReader;
+import java.util.Arrays;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class Base64InputStreamTest {
+
+    private static byte[] randomBytes(int length) {
+        byte[] data = new byte[length];
+        for (int i = 0; i < length; i++) {
+            data[i] = (byte)(Math.random() * 256 - 128);
+        }
+        return data;
+    }
+
+    private static int LENGTH = 12345678;
+    private static int BUFFER_SIZE = 256;
+
+    @Test
+    public void testSingleChar() throws IOException {
+        byte[] bytes = randomBytes(LENGTH);
+        String base64 = new Base64StreamEncoder().encode(bytes);
+        //System.out.println(base64);
+        //Assert.assertArrayEquals(bytes, new Base64StreamDecoder().decode(base64));
+        InputStream in = new Base64InputStream(new StringReader(base64));
+        int ch, pos = 0;
+        while ((ch = in.read()) != -1) {
+            Assertions.assertTrue(pos < bytes.length);
+            //System.out.println(pos + " " + bytes[pos] + " " + ch);
+            Assertions.assertEquals(bytes[pos], (byte)ch);
+            pos++;
+        }
+    }
+
+    @Test
+    public void testBlock() throws IOException {
+        byte[] bytes = randomBytes(LENGTH);
+        String base64 = new Base64StreamEncoder().encode(bytes);
+
+        InputStream in = new Base64InputStream(new StringReader(base64));
+        byte[] buf = new byte[BUFFER_SIZE];
+        int len, pos = 0;
+        while ((len = in.read(buf)) != -1) {
+            //System.out.println(pos + " " + len + " " + bytes[pos] + " " + buf[0]);
+
+            Assertions.assertTrue(pos < bytes.length);
+            Assertions.assertTrue(pos+len <= bytes.length);
+
+            byte[] expected = Arrays.copyOfRange(bytes, pos, pos+len);
+            byte[] actual   = Arrays.copyOfRange(buf, 0, len);
+            Assertions.assertArrayEquals(expected, actual);
+
+            pos += len;
+        }
+
+    }
+
+    @Test
+    public void testMixed() throws IOException {
+        byte[] bytes = randomBytes(LENGTH);
+        String base64 = new Base64StreamEncoder().encode(bytes);
+
+        InputStream in = new Base64InputStream(new StringReader(base64));
+        byte[] buf = new byte[BUFFER_SIZE];
+        int len, pos = 0;
+        while ((len = in.read(buf)) != -1) {
+            //System.out.println(pos + " " + len + " " + bytes[pos] + " " + buf[0]);
+
+            Assertions.assertTrue(pos < bytes.length);
+            Assertions.assertTrue(pos+len <= bytes.length);
+
+            byte[] expected = Arrays.copyOfRange(bytes, pos, pos+len);
+            byte[] actual   = Arrays.copyOfRange(buf, 0, len);
+            Assertions.assertArrayEquals(expected, actual);
+
+            pos += len;
+
+            int count = (int)(Math.random()*BUFFER_SIZE/32);
+            int ch;
+            while (count-- > 0 && pos < bytes.length && ((ch = in.read()) != -1)) {
+                Assertions.assertEquals(bytes[pos],(byte)ch);
+                pos++;
+            }
+        }
+
+    }
+
+}
diff --git a/src/test/java/net/jhorstmann/base64/Base64Test.java b/src/test/java/net/jhorstmann/base64/Base64Test.java
new file mode 100644
index 0000000..6b488b1
--- /dev/null
+++ b/src/test/java/net/jhorstmann/base64/Base64Test.java
@@ -0,0 +1,205 @@
+package net.jhorstmann.base64;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringReader;
+
+public class Base64Test {
+
+	private static void testEncode(String str, String expected) throws IOException {
+		//ByteArrayInputStream in = new ByteArrayInputStream(str.getBytes("US-ASCII"));
+		//StringWriter out = new StringWriter();
+		//Base64Encoder.encode(in, out);
+
+		Assertions.assertEquals(expected, Base64Encoder.encode(str));
+		Assertions.assertEquals(expected, new Base64StreamEncoder().encode(str));
+	}
+
+	private static void testDecodeReader(String str, String base64) throws IOException {
+		StringReader in = new StringReader(base64);
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+		new Base64StreamDecoder().decode(in, out);
+		String result = out.toString("US-ASCII");
+		Assertions.assertEquals(str, result);
+	}
+
+	private static void testDecodeInputStream(String str, String base64) throws IOException {
+		InputStream in = new ByteArrayInputStream(base64.getBytes("US-ASCII"));
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		new Base64StreamDecoder().decode(in, out);
+		String result = out.toString("US-ASCII");
+		Assertions.assertEquals(str, result);
+	}
+
+	private static void testDecode(String str) throws IOException {
+		String base64 = Base64Encoder.encode(str);
+
+		testDecodeReader(str, base64);
+		testDecodeInputStream(str, base64);
+		//System.out.println(base64);
+
+		Assertions.assertEquals(str, new String(new Base64StreamDecoder().decode(base64), "US-ASCII"));
+		Assertions.assertEquals(str, new String(new Base64StreamDecoder().decode(base64.getBytes("US-ASCII")), "US-ASCII"));
+		Assertions.assertEquals(str, new String(new Base64StreamDecoder().decode(base64.toCharArray()), "US-ASCII"));
+	}
+
+	@Test
+	public void testEncode1() throws IOException {
+		testEncode("0", "MA==");
+		testEncode("1", "MQ==");
+		testEncode("2", "Mg==");
+		testEncode("3", "Mw==");
+		testEncode("4", "NA==");
+		testEncode("5", "NQ==");
+		testEncode("a", "YQ==");
+		testEncode("b", "Yg==");
+		testEncode("A", "QQ==");
+		testEncode("B", "Qg==");
+	}
+
+	@Test
+	public void testEncode2() throws IOException {
+		testEncode("00", "MDA=");
+		testEncode("01", "MDE=");
+		testEncode("10", "MTA=");
+		testEncode("11", "MTE=");
+		testEncode("AA", "QUE=");
+		testEncode("BB", "QkI=");
+		testEncode("ZZ", "Wlo=");
+		testEncode("aa", "YWE=");
+		testEncode("bb", "YmI=");
+		testEncode("zz", "eno=");
+	}
+
+	@Test
+	public void testEncode3() throws IOException {
+		testEncode("000", "MDAw");
+		testEncode("111", "MTEx");
+		testEncode("999", "OTk5");
+		testEncode("AAA", "QUFB");
+		testEncode("ZZZ", "Wlpa");
+		testEncode("aaa", "YWFh");
+		testEncode("zzz", "enp6");
+	}
+
+	@Test
+	public void testEncode4() throws IOException {
+		testEncode("Hallo Welt", "SGFsbG8gV2VsdA==");
+		testEncode("Dies ist ein Test", "RGllcyBpc3QgZWluIFRlc3Q=");
+	}
+
+	@Test
+	public void testDecode1() throws IOException {
+		testDecode("0");
+		testDecode("1");
+		testDecode("9");
+		testDecode("a");
+		testDecode("b");
+		testDecode("z");
+		testDecode("A");
+		testDecode("B");
+		testDecode("Z");
+	}
+
+	@Test
+	public void testDecode2() throws IOException {
+		testDecode("00");
+		testDecode("01");
+		testDecode("11");
+		testDecode("99");
+		testDecode("aa");
+		testDecode("ab");
+		testDecode("bb");
+		testDecode("zz");
+		testDecode("AA");
+		testDecode("AB");
+		testDecode("BB");
+		testDecode("ZZ");
+	}
+
+	@Test
+	public void testDecode3() throws IOException {
+		testDecode("000");
+		testDecode("012");
+		testDecode("111");
+		testDecode("999");
+		testDecode("aaa");
+		testDecode("abc");
+		testDecode("bbb");
+		testDecode("zzz");
+		testDecode("AAA");
+		testDecode("ABC");
+		testDecode("BBB");
+		testDecode("ZZZ");
+	}
+
+	@Test
+	public void testDecode4() throws IOException {
+		testDecode("Hallo Welt");
+		testDecode("Dies ist ein Test");
+	}
+
+	@Test
+	public void testMultipart() throws IOException {
+		char[] tmp = "SGFs\nbG8g\nV2Vs\ndA==\n".toCharArray();
+
+		Base64StreamDecoder bd = new Base64StreamDecoder();
+		Assertions.assertEquals("Hallo Welt",
+				new String(bd.decode(tmp, 0, 10), "US-ASCII")
+						+ new String(bd.decode(tmp, 10, tmp.length - 10), "US-ASCII"));
+
+		bd = new Base64StreamDecoder();
+		Assertions.assertEquals("Hallo Welt",
+				new String(bd.decode(tmp, 0, 8), "US-ASCII")
+						+ new String(bd.decode(tmp, 8, tmp.length - 8), "US-ASCII"));
+
+		bd = new Base64StreamDecoder();
+		Assertions.assertEquals("Hallo Welt",
+				new String(bd.decode(tmp, 0, 3), "US-ASCII")
+						+ new String(bd.decode(tmp, 3, tmp.length - 3), "US-ASCII"));
+	}
+
+	@Test
+	public void testMultiLine() throws IOException {
+		Assertions.assertEquals("Hallo Welt", new String(new Base64StreamDecoder().decode("SGFs\nbG8g\nV2Vs\ndA==\n"), "US-ASCII"));
+		Assertions.assertEquals("Dies ist ein Test", new String(new Base64StreamDecoder().decode("RGllcyBp\nc3QgZWlu\nIFRlc3Q=\n"), "US-ASCII"));
+	}
+
+	@Test
+	public void testMultiLineIndent() throws IOException {
+		Assertions.assertEquals("Hallo Welt", new String(new Base64StreamDecoder().decode("    SGFs\n    bG8g\n    V2Vs\n    dA==\n"), "US-ASCII"));
+		Assertions.assertEquals("Dies ist ein Test", new String(new Base64StreamDecoder().decode("    RGllcyBp\n    c3QgZWlu\n    IFRlc3Q=\n"), "US-ASCII"));
+	}
+
+	@Test()
+	public void testInvalid() throws InvalidCharacterException, IOException {
+		Assertions.assertThrows(InvalidCharacterException.class, () -> {
+			new Base64StreamDecoder().decode("SGFs\nbG8g\nV2Vs\nacb$");
+		});
+	}
+
+	@Test
+	public void testIncomplete() throws IncompleteStreamException, IOException {
+		Assertions.assertThrows(IncompleteStreamException.class, () -> {
+			new Base64StreamDecoder().decode("SGFs\nbG8g\nV2Vs\ndA");
+		});
+	}
+
+	@Test
+	public void testCharacterName() {
+		Assertions.assertEquals("\\r", Base64Exception.characterName('\r'));
+		Assertions.assertEquals("\\n", Base64Exception.characterName('\n'));
+		Assertions.assertEquals("\\t", Base64Exception.characterName('\t'));
+		Assertions.assertEquals("\\f", Base64Exception.characterName('\f'));
+		Assertions.assertEquals("\\x01", Base64Exception.characterName(0x01));
+		Assertions.assertEquals("\\x02", Base64Exception.characterName(0x02));
+		Assertions.assertEquals("\\x16", Base64Exception.characterName(0x16));
+		Assertions.assertEquals("\\u1234", Base64Exception.characterName(0x1234));
+	}
+}
diff --git a/src/test/java/net/jhorstmann/base64/CharsetTest.java b/src/test/java/net/jhorstmann/base64/CharsetTest.java
new file mode 100644
index 0000000..7bd6d9b
--- /dev/null
+++ b/src/test/java/net/jhorstmann/base64/CharsetTest.java
@@ -0,0 +1,130 @@
+package net.jhorstmann.base64;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.util.Random;
+
+public class CharsetTest {
+    private final static String BASE64_CHARSET_ENCODING = "BASE64";
+
+    private static void assertEquals(byte[] expected, byte[] actual) {
+        Assertions.assertEquals(expected.length, actual.length);
+        for (int i = 0; i < expected.length; i++) {
+            //System.out.println(expected[i] + " " + actual[i]);
+            Assertions.assertEquals(expected[i], actual[i]);
+        }
+    }
+
+    @Test
+    public void testProvider() {
+        Charset cs = Charset.forName(BASE64_CHARSET_ENCODING);
+        Assertions.assertNotNull(cs);
+        Assertions.assertEquals(BASE64_CHARSET_ENCODING, cs.name());
+    }
+
+    @Test
+    public void testGetBytes() throws UnsupportedEncodingException {
+        assertEquals("JH".getBytes("US-ASCII"), "Skg=".getBytes(BASE64_CHARSET_ENCODING));
+        assertEquals("Hallo".getBytes("US-ASCII"), "SGFsbG8=".getBytes(BASE64_CHARSET_ENCODING));
+        assertEquals("Test 123".getBytes("US-ASCII"), "VGVzdCAxMjM=".getBytes(BASE64_CHARSET_ENCODING));
+    }
+
+    @Test
+    public void testNewString() throws UnsupportedEncodingException {
+        Assertions.assertEquals("Skg=", new String(new byte[]{'J', 'H'}, BASE64_CHARSET_ENCODING));
+        Assertions.assertEquals("SGFsbG8=", new String(new byte[]{'H', 'a', 'l', 'l', 'o'}, BASE64_CHARSET_ENCODING));
+        Assertions.assertEquals("VGVzdCAxMjM=", new String(new byte[]{'T', 'e', 's', 't', ' ', '1', '2', '3'}, BASE64_CHARSET_ENCODING));
+    }
+
+    private void test(String str) throws IOException {
+        byte[] data = str.getBytes("UTF-8");
+        test(data);
+    }
+
+    private void test(byte[] data) throws IOException {
+        String base64 = new Base64StreamEncoder().encode(data);
+        Assertions.assertEquals(base64, new String(data, BASE64_CHARSET_ENCODING));
+        assertEquals(data, base64.getBytes(BASE64_CHARSET_ENCODING));
+    }
+
+    @Test
+    public void test1() throws IOException {
+        test("a");
+        test("b");
+        test("c");
+        test("A");
+        test("B");
+        test("C");
+        test("0");
+        test("1");
+    }
+
+    @Test
+    public void test2() throws IOException {
+        test("ab");
+        test("bc");
+        test("cd");
+        test("AB");
+        test("BC");
+        test("CD");
+        test("01");
+        test("12");
+    }
+
+    @Test
+    public void test3() throws IOException {
+        test("abc");
+        test("bcd");
+        test("cde");
+        test("ABC");
+        test("BCD");
+        test("CDE");
+        test("012");
+        test("123");
+    }
+
+    @Test
+    public void test4() throws IOException {
+        test("abcd");
+        test("bcde");
+        test("cdef");
+        test("ABCD");
+        test("BCDE");
+        test("CDEF");
+        test("0123");
+        test("1245");
+    }
+
+    @Test
+    public void testHallo() throws IOException {
+        test("Hallo Welt");
+        test("Dies ist ein Test");
+    }
+
+    @Test
+    public void testRandomSmall() throws IOException {
+        Random random = new Random();
+        int step = 13;
+        int max = 1<<15;
+        for (int i=step; i<max; i+=step) {
+            byte[] data = new byte[i];
+            random.nextBytes(data);
+            test(data);
+        }
+    }
+
+    @Test
+    public void testRandomLarge() throws IOException {
+        Random random = new Random();
+        for (int i=8; i<25; i++) {
+            byte[] data = new byte[(1<<i) + random.nextInt(1<<(i-1))];
+            random.nextBytes(data);
+            test(data);
+        }
+    }
+
+}
diff --git a/src/test/java/net/jhorstmann/base64/Main.java b/src/test/java/net/jhorstmann/base64/Main.java
new file mode 100644
index 0000000..22ab896
--- /dev/null
+++ b/src/test/java/net/jhorstmann/base64/Main.java
@@ -0,0 +1,55 @@
+package net.jhorstmann.base64;
+
+import java.io.File;
+import java.io.IOException;
+
+public class Main {
+    
+    private static String seconds(long t1, long t2) {
+        return String.format("%.3fs", (t2-t1)/1000.0);
+    }
+    public static void main(String[] args) throws IOException {
+        long t1,t2;
+
+        t1 = System.currentTimeMillis();
+        new Base64StreamEncoder().encode(new File("/home/jh/Downloads/glassfish-v3-b65.zip"), new File("/tmp/test.base64"));
+        t2 = System.currentTimeMillis();
+        System.out.println("Encoded in " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64NIODecoder().decodeMapped(new File("/tmp/test.base64"), new File("/dev/null"), 32*1024, false);
+        t2 = System.currentTimeMillis();
+        System.out.println("NIODecoder(mapped, indirect) in " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64NIODecoder().decodeMapped(new File("/tmp/test.base64"), new File("/dev/null"), 32*1024, true);
+        t2 = System.currentTimeMillis();
+        System.out.println("NIODecoder(mapped, direct) in " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64StreamDecoder().decode(new File("/tmp/test.base64"), new File("/dev/null"));
+        t2 = System.currentTimeMillis();
+        System.out.println("StreamDecoder in " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64NIODecoder().decode(new File("/tmp/test.base64"), new File("/dev/null"), 32*1024, false, false);
+        t2 = System.currentTimeMillis();
+        System.out.println("NIODecoder in(indirect, indirect) " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64NIODecoder().decode(new File("/tmp/test.base64"), new File("/dev/null"), 32*1024, true, false);
+        t2 = System.currentTimeMillis();
+        System.out.println("NIODecoder(direct, indirect) in " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64NIODecoder().decode(new File("/tmp/test.base64"), new File("/dev/null"), 32*1024, false, true);
+        t2 = System.currentTimeMillis();
+        System.out.println("NIODecoder(indirect, direct) in " + seconds(t1, t2));
+
+        t1 = System.currentTimeMillis();
+        new Base64NIODecoder().decode(new File("/tmp/test.base64"), new File("/dev/null"), 32*1024, true, true);
+        t2 = System.currentTimeMillis();
+        System.out.println("NIODecoder(direct, direct) in " + seconds(t1, t2));
+    }
+
+}
diff --git a/src/test/java/se/nowise/codecs/base64/Base64DecoderTest.java b/src/test/java/se/nowise/codecs/base64/Base64DecoderTest.java
new file mode 100644
index 0000000..d5cef0a
--- /dev/null
+++ b/src/test/java/se/nowise/codecs/base64/Base64DecoderTest.java
@@ -0,0 +1,157 @@
+/*
+ * Web service library for the Batchelor batch job queue.
+ * Copyright (C) 2009 by Anders L√∂vgren and the Computing Department at BMC,
+ * Uppsala University.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Send questions, suggestions, bugs or comments to:
+ * Anders L√∂vgren (andlov@nowise.se)
+ *
+ * For more info: https://github.com/nowisesys/base64code/
+ */
+package se.nowise.codecs.base64;
+
+import java.io.ByteArrayInputStream;
+
+import org.junit.jupiter.api.*;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+/**
+ * @author Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+public class Base64DecoderTest {
+
+	Base64Decoder decoder;
+	final static String DECODED = "Hello, world!";
+	final static String ENCODED = "SGVsbG8sIHdvcmxkIQ==";
+
+	public Base64DecoderTest() {
+		decoder = new Base64Decoder();
+	}
+
+	@BeforeAll
+	public static void setUpClass() throws Exception {
+	}
+
+	@AfterAll
+	public static void tearDownClass() throws Exception {
+	}
+
+	@BeforeEach
+	public void setUp() {
+	}
+
+	@AfterEach
+	public void tearDown() {
+	}
+
+	/**
+	 * Test constructors.
+	 */
+	@Test
+	public void testEncode_Constructors() {
+		System.out.println("** Base64DecoderTest -> Contructors");
+		Base64Decoder obj = new Base64Decoder();
+		assertEquals(Base64Decoder.BUFFER_SIZE, obj.getSize());
+		obj = new Base64Decoder(3600);
+		assertEquals(3600, obj.getSize());
+	}
+
+	/**
+	 * Test of setSize method, of class Base64Decoder.
+	 */
+	@Test
+	public void testSetSize() {
+		System.out.println("** Base64DecoderTest -> setSize(int)");
+		decoder.setSize(3600);
+		assertEquals(3600, decoder.getSize());
+	}
+
+	/**
+	 * Test of getSize method, of class Base64Decoder.
+	 */
+	@Test
+	public void testGetSize() {
+		System.out.println("** Base64DecoderTest -> getSize()");
+		assertEquals(decoder.getSize(), Base64Decoder.BUFFER_SIZE);
+	}
+
+	/**
+	 * Test of decode method, of class Base64Decoder.
+	 */
+	@Test
+	public void testDecode_String() {
+		System.out.println("** Base64DecoderTest -> decode(String)");
+		byte[] bytes = decoder.decode(ENCODED);
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, DECODED);
+	}
+
+	/**
+	 * Test of decode method, of class Base64Decoder.
+	 *
+	 * @throws Exception
+	 */
+	@Test
+	public void testDecode_InputStream() throws Exception {
+		System.out.println("** Base64DecoderTest -> decode(InputStream)");
+		ByteArrayInputStream stream = new ByteArrayInputStream(ENCODED.getBytes());
+		byte[] bytes = decoder.decode(stream);
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, DECODED);
+	}
+
+	/**
+	 * Test of decode method, of class Base64Decoder.
+	 *
+	 * @throws Exception
+	 */
+	@Test
+	public void testDecode_InputStream_int() throws Exception {
+		System.out.println("** Base64DecoderTest -> decode(InputStream, int)");
+		ByteArrayInputStream stream = new ByteArrayInputStream(ENCODED.getBytes());
+		byte[] bytes = decoder.decode(stream, 512);
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, DECODED);
+	}
+
+	/**
+	 * Test of decode method, of class Base64Decoder.
+	 */
+	@Test
+	public void testDecode_byteArr() {
+		System.out.println("** Base64DecoderTest -> decode(byte[])");
+		byte[] bytes = decoder.decode(ENCODED.getBytes());
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, DECODED);
+	}
+
+	/**
+	 * Test of decode method, of class Base64Decoder.
+	 */
+	@Test
+	public void testDecode_charArr() {
+		System.out.println("** Base64DecoderTest -> decode(char[])");
+		byte[] bytes = decoder.decode(ENCODED.toCharArray());
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, DECODED);
+	}
+}
diff --git a/src/test/java/se/nowise/codecs/base64/Base64EncoderTest.java b/src/test/java/se/nowise/codecs/base64/Base64EncoderTest.java
new file mode 100644
index 0000000..af3c8fa
--- /dev/null
+++ b/src/test/java/se/nowise/codecs/base64/Base64EncoderTest.java
@@ -0,0 +1,159 @@
+/*
+ * Web service library for the Batchelor batch job queue.
+ * Copyright (C) 2009 by Anders L√∂vgren and the Computing Department at BMC,
+ * Uppsala University.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Send questions, suggestions, bugs or comments to:
+ * Anders L√∂vgren (andlov@nowise.se)
+ *
+ * For more info: https://github.com/nowisesys/base64code/
+ */
+
+package se.nowise.codecs.base64;
+
+import java.io.ByteArrayInputStream;
+
+import org.junit.jupiter.api.*;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+/**
+ * @author Anders L√∂vgren (Nowise Systems/BMC-IT, Uppsala University)
+ */
+public class Base64EncoderTest {
+
+	Base64Encoder encoder;
+	final static String DECODED = "Hello, world!";
+	final static String ENCODED = "SGVsbG8sIHdvcmxkIQ==";
+
+	public Base64EncoderTest() {
+		encoder = new Base64Encoder();
+	}
+
+	@BeforeAll
+	public static void setUpClass() throws Exception {
+	}
+
+	@AfterAll
+	public static void tearDownClass() throws Exception {
+	}
+
+	@BeforeEach
+	public void setUp() {
+	}
+
+	@AfterEach
+	public void tearDown() {
+	}
+
+	/**
+	 * Test constructors.
+	 */
+	@Test
+	public void testEncode_Constructors() {
+		System.out.println("** Base64EncoderTest -> Contructors");
+		Base64Encoder obj = new Base64Encoder();
+		assertEquals(Base64Encoder.BUFFER_SIZE, obj.getSize());
+		obj = new Base64Encoder(3600);
+		assertEquals(3600, obj.getSize());
+	}
+
+	/**
+	 * Test of setSize method, of class Base64Encoder.
+	 */
+	@Test
+	public void testEncode_SetSize() {
+		System.out.println("** Base64EncoderTest -> setSize(int)");
+		encoder.setSize(3600);
+		assertEquals(3600, encoder.getSize());
+	}
+
+	/**
+	 * Test of getSize method, of class Base64Encoder.
+	 */
+	@Test
+	public void testGetSize() {
+		System.out.println("** Base64EncoderTest -> getSize()");
+		assertEquals(encoder.getSize(), Base64Encoder.BUFFER_SIZE);
+	}
+
+	/**
+	 * Test of encode method, of class Base64Encoder.
+	 */
+	@Test
+	public void testEncode_String() {
+		System.out.println("** Base64EncoderTest -> encode(String)");
+		byte[] bytes = encoder.encode(DECODED);
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, ENCODED);
+	}
+
+	/**
+	 * Test of encode method, of class Base64Encoder.
+	 *
+	 * @throws Exception
+	 */
+	@Test
+	public void testEncode_InputStream() throws Exception {
+		System.out.println("** Base64EncoderTest -> encode(InputStream)");
+		ByteArrayInputStream stream = new ByteArrayInputStream(DECODED.getBytes());
+		byte[] bytes = encoder.encode(stream);
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, ENCODED);
+	}
+
+	/**
+	 * Test of decode method, of class Base64Encoder.
+	 *
+	 * @throws Exception
+	 */
+	@Test
+	public void testEncode_InputStream_int() throws Exception {
+		System.out.println("** Base64EncoderTest -> encode(InputStream, int)");
+		ByteArrayInputStream stream = new ByteArrayInputStream(DECODED.getBytes());
+		byte[] bytes = encoder.encode(stream, 512);
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, ENCODED);
+	}
+
+	/**
+	 * Test of encode method, of class Base64Encoder.
+	 */
+	@Test
+	public void testEncode_byteArr() {
+		System.out.println("** Base64EncoderTest -> encode(byte[])");
+		byte[] bytes = encoder.encode(DECODED.getBytes());
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, ENCODED);
+	}
+
+	/**
+	 * Test of encode method, of class Base64Encoder.
+	 */
+	@Test
+	public void testEncode_charArr() {
+		System.out.println("** Base64EncoderTest -> encode(char[])");
+		byte[] bytes = encoder.encode(DECODED.toCharArray());
+		String result = new String(bytes);
+		System.out.println("Result: '" + result + "'");
+		assertEquals(result, ENCODED);
+	}
+
+}
\ No newline at end of file
-- 
2.26.2.windows.1

